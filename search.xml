<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>字符编码</title>
    <url>/2020/03/08/sundry/character-encoding/</url>
    <content><![CDATA[<p>本文描述两种字符编码 <code>ascii</code> 和 <code>unicode</code>，并详解 <code>unicode</code> 编码的三种实现方式 <code>utf-8</code>、<code>utf-16</code> 和 <code>utf-32</code>。</p>
<a id="more"></a>

<h2 id="ascii"><a href="#ascii" class="headerlink" title="ascii"></a>ascii</h2><p>上世纪60年代，美国制定了一套字符编码 <strong>ascii</strong>，对英文字符和二进制位之间定义了一个映射关系。</p>
<p><img src="/2020/03/08/sundry/character-encoding/e850352ac65c103880a07b53bc119313b17e8941.png" alt="图一：字符编码"></p>
<p>在 <strong>ascii</strong> 中，一个英文字符使用一个字节的二进制位进行表述。</p>
<p><strong>ascii</strong> 仅对128个英文字符进行编码，因此一个字节的二进制位仅使用了 <code>00000000~01111111</code>。</p>
<h2 id="非ascii"><a href="#非ascii" class="headerlink" title="非ascii"></a>非ascii</h2><p>随着计算机的流行，其他国家也需要对其语言中的字符进行编码，通常做法是这样的——对 <strong>ascii</strong> 进行扩充，使用二进制位中的 <code>10000000~11111111</code> 表示其国家语言中的字符。</p>
<blockquote>
<p>中文编码比较特殊，这里不考虑。</p>
</blockquote>
<p>那么这样就会出现一个问题：二进制位中的 <code>10000000~11111111</code> 在不同国家的编码中表示不同的字符，如果以错误的字符编码打开一个文件，将会出现乱码？</p>
<p>为解决这个问题，需要制定一套字符编码，定义世界上所有字符与二进制位之间的映射关系，这种字符编码就是 <code>unicode</code>。</p>
<h2 id="unicode"><a href="#unicode" class="headerlink" title="unicode"></a>unicode</h2><p><strong>unicode</strong> 为世界上所有字符与二进制位之间定义了一个映射关系，形成一个巨大的字符集 。</p>
<p><strong>unicode</strong> 的编码空间为 <code>U+0000 ~  U+10FFFF</code>，共可容纳 1112064 个字符。</p>
<p><strong>unicode</strong> 定义了字符与二进制位之间的映射关系，但并没有规定如何存储这个二进制位。因此出现了众多 <strong>unicode</strong> 的实现方式，这里介绍三种——<code>utf-8</code> 、 <code>utf-16</code> 和 <code>utf-32</code>。</p>
<h3 id="utf-8"><a href="#utf-8" class="headerlink" title="utf-8"></a>utf-8</h3><p><strong>utf-8</strong> 是一种变长字符编码，即字符集中不同字符，可能具有不同的字节长度 (1/2/3/4 字节)。</p>
<p><strong>utf-8</strong> 的编码规则如下：</p>
<ul>
<li>对于单字节字符，字节第一位置为 <code>0</code>，其余 7 位为该字符的 <code>unicode</code> 编码。因此对于英文字母， <strong>utf-8</strong> 编码结果与 <strong>ascii</strong> 是相同的。</li>
<li>对于 <code>n</code>字节字符，第一个字节的前 <code>n</code> 位置为 <code>1</code>，<code>n + 1</code> 位置为 <code>0</code>，其余字节的前两位置为 <code>10</code>，其余二进制位为该字符的 <code>unicode</code> 编码。</li>
</ul>
<p><strong>unicode</strong> 与 <strong>utf-8</strong> 之间的对应关系：</p>
<table>
<thead>
<tr>
<th align="left">unicode编码</th>
<th align="left">utf-8编码</th>
</tr>
</thead>
<tbody><tr>
<td align="left">U+ 0000 ~ U+  007F</td>
<td align="left">0XXXXXXX</td>
</tr>
<tr>
<td align="left">U+ 0080 ~ U+  07FF</td>
<td align="left">110XXXXX 10XXXXXX</td>
</tr>
<tr>
<td align="left">U+ 0800 ~ U+  FFFF</td>
<td align="left">1110XXXX 10XXXXXX 10XXXXXX</td>
</tr>
<tr>
<td align="left">U+10000 ~ U+10FFFF</td>
<td align="left">11110XXX 10XXXXXX 10XXXXXX 10XXXXXX</td>
</tr>
</tbody></table>
<p>举一个例子：<code>严</code> 的 unicode编码 是 <code>U+4E25</code>，通过上面的对应关系，可以得知 <code>严</code> 的 utf-8 编码占三个字节，即格式为 <code>1110XXXX 10XXXXXX 10XXXXXX</code>。从最后一个二进制位开始，依次从后向前将 <code>U+4E25</code> 的二进制位填到<code>X</code>，多余的 <code>X</code> 填入 0，最终得到 <code>严</code> 的 utf-8 编码为 <code>11100100 10111000 10100101</code>。 </p>
<h3 id="utf-16"><a href="#utf-16" class="headerlink" title="utf-16"></a>utf-16</h3><p><strong>utf-16</strong> 是一种变长字符编码,即字符集中不同字符，可能具有不同的字节长度 (2/4 字节)。</p>
<p><strong>utf-16</strong> 的编码规则比较麻烦，具体如下：</p>
<ul>
<li><p><strong>utf-16</strong> 将 unicode 的编码空间划分为 16 个平面。第 <code>XX</code> 个平面的编码范围为 <code>0xXX0000 ~ 0xXXFFFF</code>。第一个平面称为 <em>基本多语言平面</em>  ( 2字节 ) ，其余平面称为 <em>辅助平面</em>  ( 4字节 )  。</p>
</li>
<li><p>unicode 标准规定区间 <code>U+D800 ~ U+DFFF</code> 不对应任何字符，因此  <strong>utf-16</strong> 使用这部分区间对辅助空间中的字符进行编码。</p>
</li>
<li><p>在 <em>基本多语言平面</em> 中，<code>U+D800 ~ U+DFFF</code> 区间不对应任何字符，因此无需编码；<code>U+0000 ~ U+D7FF</code> 和 <code>U+E000 ~ U+FFFF</code> 区间中的字符，其 <strong>utf-16</strong> 编码结果就是 unicode 编码。</p>
</li>
<li><p>在 <em>辅助平面</em>  中，<strong>utf-16</strong> 将 区间<code>U+10000 ~ U+10FFFF</code>中的字符编码为 <em>代理对</em> 。</p>
<p>具体编码方式如下：</p>
<ul>
<li>将 unicode 编码值减去 <code>0x10000</code> ，得到一个值 (值范围为 <code>0x00000 ~ 0xFFFFF</code> ) 。</li>
<li>取该值高 10 位 (值范围为 <code>0x00 ~ 0x3FF</code>)，加上 <code>0xD800</code> 得到 <em>前导代理</em>  (值范围为<code>0xD800 ~ 0xDBFF</code>)</li>
<li>取该值低 10 位 (值范围为 <code>0x00 ~ 0x3FF</code>)，加上 <code>0xDC00</code> 得到 <em>后尾代理</em>  (值范围为<code>0xDC00 ~ 0xDFFF</code>)</li>
<li>(前导代理，后尾代理) 即为 <strong>utf-16</strong> 编码结果。</li>
</ul>
</li>
</ul>
<p>举一个例子：𐐷 的 unicode编码为 <code>U+10437</code>。由于它在辅助平面，因此先减去 <code>0x10000</code> 得到 <code>0000 0000 0100 0011 0111</code> , 取高 10 位 和低 10 位 分别处理得到 <code>0xD800 + 0x0001 = 0xD801,0xDC00 + 0x0037 = 0xDC37</code>，最终 <strong>utf-16</strong> 编码结果就是 <code>0xD801 DC37</code>。</p>
<h3 id="utf-32"><a href="#utf-32" class="headerlink" title="utf-32"></a>utf-32</h3><p><strong>utf-32</strong> 是一种定长字符编码，即字符集中所有字符均编码为 4 字节。</p>
<p><strong>utf-32</strong> 的编码规则十分简单，具体如下：</p>
<ul>
<li>从低位到高位依次放置 unicode 编码，多余位置 <code>0</code> 即可。</li>
</ul>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>字符编码</tag>
      </tags>
  </entry>
  <entry>
    <title>git 学习(六)——工作流程</title>
    <url>/2020/12/22/git/gitstudy7/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>git 作为一种源码管理系统，不可避免地涉及到多人协作。为提升项目开发效率，若干种规范化的工作流程 (workflow) 被提出。</p>
<p>本文之中，我们介绍三种常见的工作流程：Git Flow、Github Flow、Gitlab Flow。</p>
<a id="more"></a>

<h2 id="Git-Flow"><a href="#Git-Flow" class="headerlink" title="Git Flow"></a>Git Flow</h2><img src="/2020/12/22/git/gitstudy7/5228524-c1f45f59fa064059.png" width="30%" alt="图一：Git Flow 工作流程">

<p>Git Flow 之中，master 分支和 develop 分支为两个长期分支；其余分支均为短期分支，相关功能开发完成后，其将被合并至长期分支。</p>
<ul>
<li><p>master 分支</p>
<p>用于存放对外发布的稳定版本。它只能通过合并其他分支而得到。</p>
</li>
<li><p>develop 分支</p>
<p>用于存放项目开发的最新版本。当向项目中添加新功能时，就会新建 feature 分支，随后在此分支中开发功能。功能开发及测试完成后，此分支就会被合并至 develop 分支。</p>
</li>
<li><p>feature 分支</p>
<p>用于开发某个功能点。</p>
</li>
<li><p>release 分支</p>
<p>当管理人员认为 develop 分支所代表的项目功能已经开发完成，此分支就会被合并至 release 分支。测试人员在此分支上进行最终测试，如果通过测试则合并至 master 分支。</p>
</li>
<li><p>hotfix 分支</p>
<p>当稳定版本发现 Bug，管理人员便会生成 hotfix 分支以紧急修复，随后将其合并至 master 分支和 develop 分支。</p>
</li>
</ul>
<p>Git Flow 具有如下优缺点：</p>
<ul>
<li><p>优点</p>
<p>分支清晰、可控。</p>
</li>
<li><p>缺点</p>
<p>分支众多，比较复杂。</p>
</li>
</ul>
<blockquote>
<p>对于 Git Flow 而言，长期分支 develop 用于开发，涉及频繁操作；长期分支 master 用于发布，不定期产生稳定版本。鉴于两者的使用频率不同，该种工作流程适用于“版本发布”类型的项目 (不定期上线新版本)。</p>
</blockquote>
<h2 id="Github-Flow"><a href="#Github-Flow" class="headerlink" title="Github Flow"></a>Github Flow</h2><p>鉴于 Git Flow 过于麻烦，Github Flow 被提出。它是一个简化版的 Git Flow，其中仅有一个长期分支—— master 分支。</p>
<p><img src="/2020/12/22/git/gitstudy7/bg2015122305.png" alt="图二：Github Flow 工作流程"></p>
<p>Github Flow 的使用流程如下：</p>
<ol>
<li>根据需求，从 master 拉取新分支。</li>
<li>新分支功能开发完成后，向 master 发起 <code>pull merge</code> 请求。</li>
<li>master 负责人测试新分支功能，如果没有问题，可合并其至 master。</li>
</ol>
<blockquote>
<p>对于 Github Flow 而言，长期分支 master 不仅用作开发，也用作发布，即 master 分支的开发与发布是同步的。鉴于此，该种工作流程适用于“持续发布”类型的项目。</p>
<p>可以看到，这种工作流程十分适用于开源项目，但是极大概率不适用于公司项目 (毕竟开发和发布之间往往存在间隔)。</p>
</blockquote>
<h2 id="Gitlab-Flow"><a href="#Gitlab-Flow" class="headerlink" title="Gitlab Flow"></a>Gitlab Flow</h2><p>Gitlab Flow 综合了 Git Flow 和 Github Flow 两者的优点，从而使得其可同时适用于“版本发布”类型和“持续发布”类型的项目开发。</p>
<p>Gitlab Flow 的最主要原则为 **上游优先 (upstream first)**，即 master 分支为所有其他分支的上游分支，当下游分支出现 Bug 时，其会开启分支进行修复，随后将此分支合并至 master 分支，master 分支再往出现 Bug 的分支合并其内容。</p>
<h3 id="持续发布"><a href="#持续发布" class="headerlink" title="持续发布"></a>持续发布</h3><p>对于“持续发布”类型的项目而言，Gitlab Flow 建议：除 master 分支外，建立其他环境分支。例如，master 分支用于开发环境、pre-production 分支用于预发环境，production 分支用于生产环境；且master 分支为 pre-production 分支的“上游分支”，pre-production 分支为 production 的“上游分支”。</p>
<img src="/2020/12/22/git/gitstudy7/bg2015122306.png" width="30%">

<h3 id="版本发布"><a href="#版本发布" class="headerlink" title="版本发布"></a>版本发布</h3><p>对于“版本发布”类型的项目而言，Gitlab Flow 建议：每发布一个稳定版本，就从 master 分支中拉取一个分支。</p>
<img src="/2020/12/22/git/gitstudy7/bg2015122307.png" width="30%">]]></content>
      <categories>
        <category>git学习</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>git 介绍(一)——git merge的合并策略</title>
    <url>/2020/12/21/git/gitstudy6/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>git merge</code> 的合并策略分为两种 —— fast-forward 和“三方合并”。fast-forward 合并策略的使用场景及具体操作已经介绍于 <a href="/2020/10/05/git/gitstudy3/" title="git 学习(三)——分支操作">git 学习(三)——分支操作</a>，本文主要介绍“三方合并”相关内容。</p>
<a id="more"></a>

<h2 id="三方合并"><a href="#三方合并" class="headerlink" title="三方合并"></a>三方合并</h2><p>如果当前分支不是待合并分支的前驱，此时便不会执行 fast-forward 合并策略，而是执行“三方合并”  (以当前分支所在快照、待合并分支所在快照、两分支最近公共祖先所在快照为依据，实施合并)。</p>
<img src="/2020/12/21/git/gitstudy6/image-20201004193646647.png" alt="图一：三方合并场景" width="40%" height="40%">

<p>在介绍“三方合并”之前，我们先行谈谈为什么不能使用“二方合并” (以当前分支所在快照、待合并分支所在快照为依据，实施合并)？</p>
<p>为回答这个问题，我们使用例子进行说明。</p>
<p>假定需要合并文件 <code>1bdd3be5</code> 和 <code>d6c1b0e2</code>，且其内容展示如下：</p>
<p><img src="/2020/12/21/git/gitstudy6/image-20201221202140807.png"></p>
<p>通过对比两个文件，我们发现第1,2,4,5行内容不同，便认为这些地方所示内容冲突。如果仅根据此冲突信息进行合并，那么将会得到：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; <span class="string">HEAD</span></span><br><span class="line"><span class="string">1</span></span><br><span class="line"><span class="string">=======</span></span><br><span class="line"><span class="string">5</span></span><br><span class="line"><span class="string">&gt;&gt;&gt;&gt;&gt;&gt;&gt; branch</span></span><br><span class="line"><span class="string">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span></span><br><span class="line">2</span><br><span class="line">=======</span><br><span class="line">4</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; branch</span><br><span class="line">3</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>仔细观察合并文件，可以发现：它仅提供了冲突信息，并没有任何合并功能的体现。由此我们可以得出结论：<em>仅提供当前分支所在快照、待合并分支所在快照信息，而不提供任何上下文信息，无法执行合并操作</em>。</p>
<p>在“三方合并”之中，它需要两分支最近公共祖先所在快照信息，从而据此提供上下文信息，并以此顺利实现合并操作。</p>
<p>假定需要合并文件 <code>1bdd3be5</code> 和 <code>d6c1b0e2</code>，并且两者祖先文件为 <code>ba8beb31</code>，三者内容展示如下：</p>
<p><img src="/2020/12/21/git/gitstudy6/image-20201221210120443.png"></p>
<p>基于祖先文件内容，我们可以得知当前文件对祖先文件进行了哪些修改 (使用 ‘*’ 加以标记)：</p>
<p><img src="/2020/12/21/git/gitstudy6/image-20201221210247460.png"></p>
<p>对于待合并文件而言，如果一者某部分内容已修改而另一者未曾修改，则合并后的内容为修改后的内容；如果两者均已修改，则需显示冲突信息，等待用户自己决定应当保留哪部分数据。根据此原则，合并后的文件内容如下：</p>
<p><img src="/2020/12/21/git/gitstudy6/image-20201221210547803.png"></p>
<blockquote>
<p>注意：最近公共祖先所在快照信息的不同，可能会引发不同的合并结果。</p>
</blockquote>
]]></content>
      <categories>
        <category>git学习</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>git 学习(五)——基本原理</title>
    <url>/2020/10/08/git/gitstudy5/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文简要介绍 <code>git</code> 版本控制系统的内部工作原理。</p>
<a id="more"></a>

<p>在介绍具体工作原理之前，需要声明如下几点：</p>
<ol>
<li>从本质来讲，Git 是一个 <strong>内容寻址 (content-addressable) 文件系统</strong>，其核心部分是一个简单的键值对数据库 (key-value data store)。当我们向 Git 中插入任意类型的数据时，它以键值对方式存储该数据，并返回一个唯一标识的键值，借助于该键值，我们可引用至该数据。</li>
<li>Git 提供两种指令 —— 上层指令和底层指令，上层指令允许我们以更友好地方式使用版本控制系统，底层指令帮助我们以更直观地方式理解版本控制系统。故而，此节之中会涉及若干底层指令。</li>
</ol>
<h2 id="Git-目录"><a href="#Git-目录" class="headerlink" title="Git 目录"></a>Git 目录</h2><p>当在一个空目录下执行 <code>git init</code> 命令时，Git 会创建一个 <code>.git</code> 目录，该目录几乎包含了 Git 存储和操纵所需的任何内容。<code>.git</code> 目录中各文件或文件夹的具体作用列举如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">config  ==&gt; 本地库配置相关内容。</span><br><span class="line">description  ==&gt; 仅供GitWeb程序使用，无需关心。</span><br><span class="line">HEAD  ==&gt; 指代HEAD指针，其内容指向项目的当前分支。(重点)</span><br><span class="line">index  ==&gt; 虽尚未创建，但是它保存暂存区信息。(重要)</span><br><span class="line">hooks/  ==&gt; 与客户端和服务端相关的钩子脚本集，基本无需关心。</span><br><span class="line">info/  ==&gt; 仅包含一个全局性排除文件exclude，与.gitignore类似。</span><br><span class="line">objects/  ==&gt; 存储所有数据内容。(重要)</span><br><span class="line">refs/  ==&gt; 存储分支、标签、远程仓库等所指向的提交记录。(重要)</span><br></pre></td></tr></table></figure>
<p>接下来，我们主要介绍标识为 “<strong>(重点)</strong>“ 的文件或文件夹，它们均为 Git 的核心内容。</p>
<h3 id="objects-目录"><a href="#objects-目录" class="headerlink" title="objects 目录"></a>objects 目录</h3><p><code>ojbects</code> 目录存储所有数据内容，具体包括 <code>git object</code>、<code>tree object</code>、<code>commit object</code>、<code>tag object</code>。正因其存储数据，Git 的键值对数据库本质在此体现地淋漓尽致。</p>
<p>我们首先依次介绍 <code>git object</code>、<code>tree object</code>、<code>commit object</code> 、<code>tag-object</code>。由于它们在目录 <code>objects</code> 中存储形式一致，所以我们仅在 <code>git object</code> 中展现各种操作完成后的目录情况。另外，由于数据存储仍涉及其他具体操作，故而我们在 <a href="#%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8">对象存储</a> 一节中详细描述存储过程，并在此节中介绍 <code>objects</code> 目录中两个子目录 <code>info</code> 和 <code>pack</code> 的作用。</p>
<h4 id="git-object"><a href="#git-object" class="headerlink" title="git object"></a>git object</h4><p><code>git object</code> 用于存储 Git 数据对象。底层命令 <code>git hash-object</code> 可将任意数据保存于 <code>objects</code> 目录，并返回与其相关的唯一标识。</p>
<p>我们首先说明 <code>objects</code> 目录情况：当前目录下存在两个空目录 —— <code>info</code> 和 <code>pack</code>。</p>
<p>控制台输入 <code>echo &#39;test content&#39; | git hash-object -w --stdin</code> (参数 <code>-w</code> 表示获取对应散列值并将其存入 Git 数据库)，它将手动创建一个数据对象并基于命令 <code>git hash-object</code>  将其存入 Git 数据库中，随后控制台输出如下内容，它为此数据对象的唯一标识，其本质是一个 <code>SHA-1</code> 散列值。</p>
<p><img src="/2020/10/08/git/gitstudy5/image-20201007230816329.png"></p>
<p>此时我们查看 <code>objects</code> 目录情况：当前目录下存在两个空目录 —— <code>info</code> 和 <code>pack</code>、一个子目录 <code>d6</code>，且子目录 <code>d6</code> 中存储二进制文件 <code>70460b4b4aece5915caf5c68d12f560a9fe3e4</code>。</p>
<p>根据 <code>objects</code> 目录情况，可以总结得到：<strong>Git 将待存储数据映射为一个 <code>SHA-1</code> 散列值，并以此散列值的前 2 个字符作为子目录，后 38 个字符作为文件名重新命名待存储数据</strong>。</p>
<p>为进行验证，我们可以使用底层命令 <code>git cat-file -p &lt;hash&gt;</code> (参数 <code>-p</code> 表示自动推断内容类型并大致显示其结果)查看指定键值所对应文件内容：</p>
<p><img src="/2020/10/08/git/gitstudy5/image-20201007231028751.png"></p>
<p>接下来，我们使用如下命令，向当前目录中添加一个文件并将其存入 Git 数据库、随后修改此文件，同时将其存入 Git 数据库：</p>
<p><img src="/2020/10/08/git/gitstudy5/image-20201008091800933.png"></p>
<p>此时查看 <code>objects</code> 目录，可以发现：两个版本的 <code>test.txt</code> 文件皆存在；查看 <code>git253</code> 目录，可以发现：存在 <code>test.txt</code> 文件，且其内容为 “version 2 –253”。</p>
<p>随后删除 <code>git253</code> 目录中 <code>test.txt</code> 文件，随后使用 <code>objects</code> 目录中 <code>test.txt</code> 文件进行恢复，可以看到恢复成功。</p>
<p><img src="/2020/10/08/git/gitstudy5/image-20201008092246858.png"></p>
<p>至此，我们已基本了解：文件如何存储于 Git 数据库，且其以何种方式存储于 Git 数据库。然而，我们需要注意两点：记住每个文件每个版本的 <code>SHA-1</code> 散列值并不现实、基于命令 <code>git hash-object</code> ，我们仅存储其内容，而没有存储其对应文件名。</p>
<blockquote>
<p><strong>基于 <code>git hash-object</code> 得到的数据对象，Git 中称为 <code>blob</code> 类型数据</strong>。使用命令 <code>git cat-file -t &lt;hash&gt;</code> ，我们可查看指定内容的具体类型。</p>
</blockquote>
<h4 id="tree-object"><a href="#tree-object" class="headerlink" title="tree object"></a>tree object</h4><p><code>git object</code> 解决了数据存储问题，<code>tree object</code> 则解决了数据对应文件名的存储问题。</p>
<p><code>tree object</code> 就是一棵树，其中存储若干树记录 <code>tree entry</code>。对于每条记录而言，其存储指向 <code>tree object</code> 或 <code>git object</code> 的 <code>SHA-1</code> 散列值以及相应内容的文件模式类型 (不同文件具有不同的模式类型，例如：100644 表示普通文件、100755 表示可执行文件、120000 表示符号链接、040000 表示目录)、文件类型 (Git 数据库中存储的实际类型，<code>git object</code> 对应 <code>blob</code>，<code>tree object</code> 对应 <code>tree</code>)、文件名。</p>
<p>命令 <code>git cat-file -p master^&#123;tree&#125;</code> 用于查看当前分支最新提交所对应的 <code>tree object</code>：</p>
<p><img src="/2020/10/08/git/gitstudy5/image-20201008103948260.png"></p>
<p>我们使用图例形象化表示此 <code>tree object</code>：</p>
<p><img src="/2020/10/08/git/gitstudy5/image-20201008105107988.png"></p>
<p>事实上，Git 会根据某时刻暂存区状态使用命令 <code>git write-tree</code> 自动创建一个 <code>tree object</code>，并返回相应的 <code>SHA-1</code> 散列值。</p>
<h4 id="commit-object"><a href="#commit-object" class="headerlink" title="commit object"></a>commit object</h4><p>就本质而言，<code>tree object</code> 便是 <strong>项目快照</strong>。如果我们想使用项目快照，就需要完全记住各项目快照所对应的 <code>SHA-1</code> 散列值。而这并不现实，因此 Git 使用 <code>commit-object</code> 保存项目快照信息。</p>
<p><code>commit-object</code> 表示为一个提交记录，其中包含待提交的 <code>tree object</code>、父提交 <code>commit-object</code>、提交者姓名、提交者电子邮件、提交时间戳、提交说明。底层命令 <code>git commit-tree &lt;tree-object-hash&gt; -p &lt;parent-hash&gt; -m &lt;commit-message&gt;</code> 可用于手动创建一个提交记录，并返回相应的 <code>SHA-1</code> 散列值。</p>
<h4 id="tag-object"><a href="#tag-object" class="headerlink" title="tag object"></a>tag object</h4><p>相比上面三种对象而言，<code>tag object</code> 显得可有可无。由于附注标签需要存储多种信息，因此底层实现中使用 <code>tag object</code> 进行存储。<br>对于 <code>tag object</code> 而言，其中包含提交者姓名、提交者电子邮件、提交时间戳、提交说明、某 <code>commit object</code>的 <code>SHA-1</code> 散列值。</p>
<blockquote>
<p>对于 <code>tag object</code> 而言，其可以不提交某 <code>commit object</code> 的 <code>SHA-1</code> 散列值，转而提交其他信息，例如某 <code>git object</code> 的 <code>SHA-1</code> 散列值。</p>
</blockquote>
<h4 id="对象存储"><a href="#对象存储" class="headerlink" title="对象存储"></a>对象存储</h4><p>我们在此简要描述 Git 存储对象的具体过程：</p>
<ol>
<li><p>基于待存储数据内容，计算头部信息 header。header 共分为四大部分，具体如下：</p>
<ul>
<li><p>获取待存储数据类型 (<code>blob</code>、<code>tree</code> 或 <code>commit</code>)，并以此作为 header 的第一部分内容。</p>
</li>
<li><p>空格作为 header 的第二部分内容。</p>
</li>
<li><p>获取待存储数据长度，并以此作为 header 的第三部分内容。</p>
</li>
<li><p>空字节作为 header 的第四部分内容。</p>
</li>
</ul>
<p>举例而言，对于文本串 <code>what is up, doc?</code> 而言，其对应 header 为 <code>blob 16 \0</code>。</p>
</li>
<li><p> 将 header 与待存储数据内容拼接起来，计算其 <code>SHA-1</code> 散列值 (它将作为存储数据的唯一标识返回)。</p>
</li>
<li><p>使用 zlib 压缩待存储数据，并基于路径构建原则 “``SHA-1` 散列值的前 2 个字符作为子目录名称，后 38 个字符则作为子目录内待存储数据对应的文件名” ，将数据存储至其中。需要注意：<strong>如果子目录或指定文件不存在，则创建相应内容，随后写入数据。如果指定文件存在，则重写之</strong>。</p>
</li>
</ol>
<p>基于上面所得知识，可以知道：当使用命令 <code>git add</code> 添加工作区文件至暂存区时，Git 一定会将修改过的文件添加到 <code>objects</code> 目录中 (即使该文件曾经已经被添加至 <code>objects</code> 目录，但是由于内容不同，故而需要再次添加)。这样就会引申出一个问题：当频繁使用命令 <code>git add</code> 后，<code>objects</code> 目录将会存在同一文件的众多版本。这种情况将会使得 <code>objects</code> 目录所占空间迅速增大，那么 Git 是如何解决此问题的？</p>
<p>与其他集中式版本控制系统类似，Git 基于保存文件差异实现压缩空间。具体而言，最初 zlib 压缩所采用的格式为 <em>松散对象格式</em>。当目录中松散格式文件过多、向远程服务器推送项目、或者手动输入命令 <code>git gc</code> 时，Git 会根据文件名和文件大小将松散格式文件打包为若干基于二进制存储的 <strong>包文件</strong>。</p>
<p>包文件存在于 <code>objects/pack</code> 目录之下，每个包文件具体对应两个文件 —— <code>xxx.idx</code> 索引文件和 <code>xxx.pack</code> 存储对象打包文件，其中 <code>xxx.pack</code> 存储相关对象的打包结果，<code>xxx.idx</code> 存储各数据对象在打包文件中的偏移位置。</p>
<blockquote>
<p><code>objects/info</code> 目录存储一些附加信息，似乎不太重要。</p>
</blockquote>
<h3 id="refs-目录"><a href="#refs-目录" class="headerlink" title="refs 目录"></a>refs 目录</h3><p>当需要查看特定提交记录的具体内容时，我们可以直接使用相应的 <code>SHA-1</code> 散列值进行获取，但是这种方法比较繁琐。如果我们可以使用别名替代 <code>SHA-1</code> 散列值，则该操作将变得简单、易用。在 Git 中，它使用 <strong>引用 (ref)</strong> 达成此效果，其实质在于：在特定位置存放与引用名同名的文件，该文件中存放特定提交记录的 <code>SHA-1</code> 散列值。当使用引用时，Git 会自动将其替换为该引用所对应文件中的 <code>SHA-1</code> 散列值。</p>
<p>Git 中所有引用文件均位于 <code>refs</code> 目录，这些引用文件分别对应于分支 (其均位于 <code>.git/refs/heads</code>)、标签 (其均位于 <code>.git/refs/tags</code>)、远程跟踪分支 (其均位于 <code>.git/refs/remotes</code>)。</p>
<p><img src="/2020/10/08/git/gitstudy5/image-20201008171841959.png"></p>
<p>按照 Git 引用原理，我们可通过写入一个 <code>SHA-1</code> 散列值至文件，从而得到该散列值的引用，其具体命令为 <code>echo &lt;hash&gt; &gt; ./git/refs/heads/&lt;fileName&gt;</code>。</p>
<p>由于直接编辑文件比较危险，Git 提供命令 <code>git update-ref &lt;refName&gt; &lt;commit-id&gt;</code> 以更新指定文件内容，其中 <code>refName</code> 具体为 <code>refs/**</code>。举例：命令 <code>git update-ref refs/heads/master 1a410</code>。</p>
<h4 id="branch-ref"><a href="#branch-ref" class="headerlink" title="branch ref"></a>branch ref</h4><p>Git 引用原理已经知晓，我们在此说明分支引用的若干操作原理：</p>
<ul>
<li><p><code>git branch &lt;branchName&gt;</code></p>
<p>Git 首先基于 <code>HEAD</code> 指针获取当前分支的最新提交记录 ID，随后新建文件 <code>refs/heads/&lt;branchName&gt;</code>，并将此 ID 写入其中。</p>
</li>
<li><p><code>git checkout &lt;branchName&gt;</code></p>
<p>假定当前分支名为 <code>currBranName</code>，Git 会将 <code>ref: refs/heads/currBranName</code> 写入 <code>HEAD</code> 文件之中 (<code>HEAD</code> 文件含义下见)。</p>
</li>
</ul>
<h4 id="tag-ref"><a href="#tag-ref" class="headerlink" title="tag ref"></a>tag ref</h4><p>上面已经提及 <code>tag object</code> 和 Git 引用原理，那么 <code>tag ref</code> 应该就比较好理解了：</p>
<ol>
<li>如果为轻量标签，则其 <code>ref/tags/&lt;tagName&gt;</code> 内容为某 <code>commit object</code> 的 <code>SHA-1</code> 散列值。</li>
<li>如果为附注标签，则其 <code>ref/tags/&lt;tagName&gt;</code> 内容为某 <code>tag object</code> 的 <code>SHA-1</code> 散列值。</li>
</ol>
<h4 id="remote-ref"><a href="#remote-ref" class="headerlink" title="remote ref"></a>remote ref</h4><p><code>remote ref</code> 指代远程跟踪分支，其引用原理已经介绍，与本地分支的区别也已经介绍，所以就没什么可说的了。</p>
<h3 id="HEAD-文件"><a href="#HEAD-文件" class="headerlink" title="HEAD 文件"></a>HEAD 文件</h3><p>在之前文章中，我们提及 <code>HEAD</code> 指针指代当前项目具体位于哪一分支。HEAD 文件其实就是这个 <code>HEAD</code> 指针，其内容便指明当前项目具体位于哪一分支。为理解这些话，只要查看本地文件 <code>.git/HEAD</code> 即可：</p>
<p><img src="/2020/10/08/git/gitstudy5/image-20201008173453477.png"></p>
<p>我们可直接编辑该文件以修改 <code>HEAD</code> 指针指向，Git 同样提供命令 <code>git symbolic-ref HEAD [&lt;refname&gt;/&lt;commit-id&gt;]</code> 以修改 <code>HEAD</code> 指针指向。</p>
<p>根据上文，我们知道：命令 <code>git checkout</code> 同样具有修改 <code>HEAD</code> 指针的作用。如果使用命令 <code>git checkout &lt;commit-id&gt;</code>，<code>HEAD</code> 指针便不再指向具体分支，而是指向具体 <code>SHA-1</code> 散列值，此时 Git 将报警 “ You are in ‘detached HEAD’ state.”。</p>
<h3 id="index-文件"><a href="#index-文件" class="headerlink" title="index 文件"></a>index 文件</h3><p>该文件保存暂存区的文件信息。它是一个二进制文件，无法直接查看具体内容，因此我们在此仅说明其内容组成：</p>
<ol>
<li><p>header 部分</p>
<p>共计 12 字节。前四字节标识该文件是否为合法 index 文件；中间四字节标识 index 文件的版本类型；后四字节标识暂存区内所管理的文件数量。</p>
</li>
<li><p>条目部分</p>
<p>条目部分用于记录暂存区内的文件信息。每一个条目具体对应于一个文件，不同条目之间使用 8 个连续的 0 进行分隔。</p>
<p>针对一个条目而言，其包括如下内容：</p>
<ul>
<li>8 字节的文件创建时间、8 字节的文件修改时间</li>
<li>4 字节的文件存储设备号、4 字节的文件存储 inode 号</li>
<li>4 字节的文件权限描述</li>
<li>4 字节的 UID (User ID)、4 字节的 GID (Group ID)</li>
<li>4 字节的文件大小</li>
<li>20 字节的文件 SHA-1 哈希值 (用于指代对应文件在 .git/objects 目录中的位置)</li>
<li>2 字节的状态信息 (包括假定不变标识符、阶段标识、文件名长度等)</li>
<li>若干字节的文件路径信息</li>
</ul>
</li>
<li><p>目录索引</p>
<p>目录索引用于存放目录信息，以实现快速重建工作目录。</p>
</li>
<li><p>校验值</p>
<p>20 字节的 index 文件校验值。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>git学习</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>git 学习(四)——高级操作</title>
    <url>/2020/10/07/git/gitstudy4/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文介绍使用 <code>git</code> 版本控制系统过程中所涉的一部分高级操作命令。</p>
<a id="more"></a>

<h2 id="查看提交记录"><a href="#查看提交记录" class="headerlink" title="查看提交记录"></a>查看提交记录</h2><p>命令 <code>git log</code> 可以查看全部提交记录信息，而借助于命令 <code>git show</code> ，我们可以查看单个提交记录、区间提交记录的具体信息。</p>
<h3 id="单个提交记录"><a href="#单个提交记录" class="headerlink" title="单个提交记录"></a>单个提交记录</h3><p>对于提交记录而言，它们使用 <code>&lt;commit-id&gt;</code> 进行标识 (<code>&lt;commit-id&gt;</code> 实际为 <code>SHA-1</code> 散列值)，因此我们可使用命令 <code>git show &lt;conmmit-id&gt;</code> 查看指定提交记录的具体信息。由于 <code>&lt;commit-id&gt;</code> 往往很长且难于记忆，所以 Git 提供快捷方式：允许使用不少于 4 个字符的 <code>SHA-1</code> 散列值代替 <code>&lt;commit-id&gt;</code>，如果该散列值仅能对应到一个 <code>&lt;commit-id&gt;</code>，则查询成功，否则查询失败。针对图例，等价命令可以是：<code>git show f58af6ceb89e5e00</code>、<code>git show f58a</code>。</p>
<blockquote>
<p>借助于命令 <code>git log --abbrev-commit --oneline</code> ，Git 可为提交记录显示简短而唯一的 <code>SHA-1</code> 散列值，默认截取 <code>&lt;commit-id&gt;</code> 前 7 个字符。</p>
</blockquote>
<img src="/2020/10/07/git/gitstudy4/image-20201006172007992.png" style="zoom: 67%;">

<p>除上面这种查看方式外，Git 仍提供其他多种方式拥有查看特定分支的提交信息：</p>
<ul>
<li><p>如果特定提交记录为某分支的顶端提交，则可使用该分支名表示此提交记录，针对上图例中提交，我们可使用等价命令 <code>git show 250</code>。</p>
</li>
<li><p>使用工具工作之时，Git 会在<em>本机本地</em>的后台保存一个引用日志 (reflog)，它用于记录 <code>HEAD</code> 和各分支所指向的提交记录。命令 <code>git reflog</code> 可用于查看这些信息：</p>
<img src="/2020/10/07/git/gitstudy4/image-20201006194030938.png" style="zoom:67%;">

<p>那么 <code>HEAD</code> 和各分支对提交记录就存在一一对应关系，使用命令 <code>git show HEAD@&#123;2&#125;/250@&#123;2&#125;</code> 可用于查看 <code>HEAD</code> 或分支 <code>250</code> 所指向的倒数第 2 个提交记录。</p>
</li>
<li><p>借助于特殊字符 <code>^&lt;num&gt;</code>，我们可以查看特定提交记录的第 <code>&lt;num&gt;</code> 个父提交记录信息。例如：命令 <code>git show f58a^</code> 用于查看 <code>f58a</code> 所示提交记录的第 1 个父提交记录信息；命令 <code>git show f58a^2</code> 用于查看 <code>f58a</code> 所示提交记录的第 2 个父提交记录信息。</p>
<blockquote>
<p>第 <code>&lt;num&gt;</code> 个父提交记录仅对于分支合并所产生的提交记录有用。对于该记录而言，它的第 1 个父提交记录位于合并分支之上，第 2 个父提交记录位于被合并分支之上。</p>
</blockquote>
</li>
<li><p>借助于特殊字符 <code>~&lt;num&gt;</code>，我们可以查看特定提交记录的祖父级提交记录信息，例如：命令 <code>git show f58a~/f582~1</code> 与命令 <code>git show f58a^</code> 具有相同作用，均用于查看 <code>f58a</code> 所示提交记录的父提交记录信息；命令 <code>git show f58a~2</code> 用于查看 <code>f58a</code> 所示提交记录的父提交记录的父提交记录信息。</p>
<blockquote>
<p>默认均指代第 1 父提交记录。</p>
</blockquote>
</li>
</ul>
<h3 id="区间提交记录"><a href="#区间提交记录" class="headerlink" title="区间提交记录"></a>区间提交记录</h3><p>区间提交记录可用于解决问题 “某分支还有哪些提交记录尚未合并至特定分支？”。它共有三种语法：</p>
<ul>
<li><p>双点</p>
<p>命令 <code>git log &lt;branchA&gt;..&lt;branchB&gt;</code> 用于查看在分支 <code>&lt;branchB&gt;</code> 中且不在分支 <code>&lt;branchA&gt;</code> 中的提交记录。</p>
</li>
<li><p>多点</p>
<p>为弥补双点命令不能作用于多个分支，多点命令被提出。它使用 <code>&lt;branchA&gt;</code> 表示在分支 <code>&lt;branchA&gt;</code> 、使用 <code>^&lt;branchA&gt;/--not &lt;branchA&gt;</code> 表示不在分支 <code>&lt;branchA&gt;</code> ，从而提供多分支支持。</p>
<p>命令 <code>git log &lt;branchA&gt; &lt;branchB&gt; ^&lt;branchC&gt;</code> 或命令 <code>git log &lt;branchA&gt; &lt;branchB&gt; --not &lt;branchC&gt;</code> 用于查看在分支 <code>&lt;branchA&gt;</code> 或在分支 <code>&lt;branchB&gt;</code> 且不在分支 <code>&lt;branchC&gt;</code> 中的提交记录。</p>
</li>
<li><p>三点</p>
<p>命令 <code>git log &lt;branchA&gt;...&lt;branchB&gt; --left-right</code> 用于查看被两分支之一包含且不被两分支同时包含的提交记录。借助于参数 <code>--left-right</code>，输出结果将标识哪些提交记录仅出现于哪个分支。</p>
</li>
</ul>
<h2 id="交互式暂存"><a href="#交互式暂存" class="headerlink" title="交互式暂存"></a>交互式暂存</h2><p>交互式暂存 Git 命令可用于将项目文件的特定部分组合为一次提交。换言之，如果我们修改大量文件后，希望将这些改动拆分为若干提交而非一次提交，使用交互式暂存命令将会很容易做到这一点。</p>
<p>使用命令 <code>git add -i/--interactive</code> 后，我们将进入交互式终端模式。该模式界面比较特殊，它显示了已暂存文件区和未暂存文件区，同时下方列出可执行的命令。</p>
<img src="/2020/10/07/git/gitstudy4/image-20201006212352167.png" style="zoom:67%;">

<p>如果希望列出交互式暂存状态，可在 <code>What now&gt;</code> 提示符后键入 <code>1</code>、<code>s</code> 或 <code>status</code>。</p>
<img src="/2020/10/07/git/gitstudy4/image-20201006213644632.png" style="zoom:67%;">

<p>如果希望暂存文件，可在 <code>What now&gt;</code> 提示符后键入 <code>2</code>、<code>u</code> 或 <code>update</code>，随后选择文件对应数字以待暂存此文件 (数字前有 <code>*</code> 表示文件处于待暂存状态)，如果某次待暂存文件集为空，则表示暂存文件工作完成。</p>
<img src="/2020/10/07/git/gitstudy4/image-20201006213859406.png" style="zoom:67%;">

<p>如果希望取消暂存文件，可在 <code>What now&gt;</code> 提示符后键入 <code>3</code>、<code>r</code> 或 <code>revert</code>，随后操作与暂存文件过程类似。</p>
<p>如果希望添加未追踪未经，可在 <code>What now&gt;</code> 提示符后键入 <code>4</code>、<code>a</code> 或 <code>add untracked</code>。</p>
<p>如果希望暂存指定文件的特定部分，可在 <code>What now&gt;</code> 提示符后键入 <code>5</code>、<code>p</code> 或 <code>patch</code>，随后选择待部分暂存文件对应数字，接下来 Git 会根据修改部分一一询问是否暂存。</p>
<img src="/2020/10/07/git/gitstudy4/image-20201007094444009.png" style="zoom:67%;">

<p>如果希望查看已暂存文件 (指代真实位于暂存区的文件) 与暂存文件 (指代 <code>staged</code> 列表中文件)的区别，可在 <code>What now&gt;</code> 提示符后键入 <code>6</code>、<code>d</code> 或 <code>diff</code>，随后选择待查看文件对应数字即可。</p>
<img src="/2020/10/07/git/gitstudy4/image-20201006214945873.png" style="zoom:67%;">

<h2 id="贮藏与清理"><a href="#贮藏与清理" class="headerlink" title="贮藏与清理"></a>贮藏与清理</h2><p>当对某分支的若干文件进行部分改动、且想要切换到另一个分支完成其他事宜时，按照 Git 使用规程，我们必须提交此次修改，然后才能完成分支切换，否则报如下错误。如果不想单独为此创建一次提交，我们可使用命令 <code>git stash</code> 加以解决。</p>
<img src="/2020/10/07/git/gitstudy4/image-20201007094041514.png" width="50%" height="50%">

<p>命令 <code>git stash</code> 或命令 <code>git stash push</code> 用于将工作目录中未完成的修改 (包括已暂存和未暂存的已追踪文件) 保存至 Git 栈中，同时你可在任何分支中应用这些修改。</p>
<img src="/2020/10/07/git/gitstudy4/image-20201007095753746.png" style="zoom:67%;">

<p>命令 <code>git stash list</code> 用于查看所有保存至 Git 栈中的修改列表。</p>
<img src="/2020/10/07/git/gitstudy4/image-20201007100155277.png" style="zoom:67%;">

<p>命令 <code>git stash apply [--index] [stash@&#123;&lt;num&gt;&#125;]</code> 用于将修改 <code>stash@&#123;&lt;num&gt;&#125;</code> 应用于当前分支。如果不使用参数 <code>--index</code>，则将所有改动恢复至工作区；如果使用参数 <code>--index</code> ，则将暂存区改动恢复至暂存区、工作区改动恢复至工作区。如果不添加参数 <code>stash@&#123;&lt;num&gt;&#125;</code> ，默认应用栈顶修改。，需要注意的是：如果当前分支相应内容已经修改，可能会发生合并冲突。</p>
<img src="/2020/10/07/git/gitstudy4/image-20201007102210289.png" width="50%" height="50%">

<p>命令 <code>git stash drop [stash@&#123;&lt;num&gt;&#125;]</code> 用于从 Git 栈中删除指定修改 <code>stash@&#123;&lt;num&gt;&#125;</code>。</p>
<p>命令 <code>git stash pop</code> 用于应用栈顶修改并从 Git 栈中删除之。</p>
<p>命令 <code>git stash</code> 存在若干变种，我们简单介绍一二：</p>
<ul>
<li><p><code>git stash --keep-index</code></p>
<p>该命令不仅将工作目录中未完成的修改保存至 Git 栈中，同时将已暂存文件仍然保留在暂存区中。</p>
</li>
<li><p><code>git stash --include-untracked</code></p>
<p>该命令不仅将工作目录中未完成的修改保存至 Git 栈中，也会将未追踪文件保存至 Git 栈中。</p>
</li>
<li><p><code>git stash branch &lt;new branchname&gt;</code></p>
<p>创建新分支，并将栈顶修改应用至该分支，随后丢弃栈顶修改。</p>
</li>
</ul>
<p>如果希望删除工作目录中未追踪文件或文件夹，可使用命令 <code>git clean -d -f</code> (<code>-f</code> 表示强制删除)。为防止错删，可先行执行命令 <code>git clean -d --dry-run</code> ，它会列出将要删除的文件和文件夹。</p>
<h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><p>Git 提供两个工具用于快速从其数据库中搜索指定内容。</p>
<p>命令 <code>git grep &lt;searchContent&gt;</code> 用于从工作目录中搜索指定内容，同时显示该内容所在文件名。该命令存在若干参数可以选择：</p>
<ul>
<li><p><code>-n</code></p>
<p> 用于显示搜索内容在相应文件中的行号。</p>
</li>
<li><p><code>-c/--count</code></p>
<p>搜索结果的统计信息，包括指定内容出现在哪些文件，指定内容在这些文件中出现的次数。</p>
</li>
<li><p><code>-p/--show-function</code></p>
</li>
</ul>
<p>命令 <code>git log -S &lt;searchContent&gt;</code> 用于从提交记录中搜索指定内容。</p>
<h2 id="重置"><a href="#重置" class="headerlink" title="重置"></a>重置</h2><p>重置操作可用于任意切换仓库区中的历史版本，它具体通过命令 <code>git reset</code> 实现。</p>
<p>在具体说明命令 <code>git rest</code> 之前，简单回顾 Git 仓库：它由三部分组成 —— 工作区、暂存区、仓库区。借助于命令 <code>git add</code>，工作区文件可转至暂存区；借助于命令 <code>git commit</code>，暂存区文件转至仓库区。仓库区由一系列提交记录所组成，这些记录构成一个有向无环图。所谓分支便是一个指向提交记录的指针，<code>HEAD</code> 指针则指向当前分支。</p>
<p>命令 <code>git reset &lt;commit-id&gt;</code> 主要有三个版本：</p>
<ul>
<li><p><code>git reset --soft &lt;commit-id&gt;</code></p>
<p>该命令仅会调整当前分支使其指向特定提交记录，从而切换仓库区中当前版本为某特定历史版本。</p>
</li>
<li><p><code>git reset [--mixed] &lt;commit-id&gt;</code></p>
<p>命令 <code>git reset</code> 默认使用参数 <code>--mixed</code>，除 <code>git reset --soft &lt;commit-id&gt;</code> 所完成的工作外，该命令会使用仓库区中 <code>&lt;commit-id&gt;</code> 所示提交记录的快照更新暂存区。</p>
</li>
<li><p><code>git reset --hard &lt;commit-id&gt;</code></p>
<p>除 <code>git reset --mixed &lt;commit-id&gt;</code> 所完成的工作外，该命令会使用暂存区中内容更新工作区。</p>
</li>
</ul>
<p>除使用 <code>&lt;commit-id&gt;</code> 执行重置外，还可根据文件或文件夹路径进行重置。由于此时可能涉及多个提交记录，因此仓库区中内容不会发生变化 (也即 <code>git reset --soft</code> 所指代过程不会发生) 。具体涉及如下命令：</p>
<ul>
<li><p><code>git reset [--mixed] &lt;commit-id&gt; &lt;file&gt;</code></p>
<p>此命令使用 <code>&lt;commit-id&gt;</code> 所指代提交记录更新暂存区中的文件 <code>&lt;file&gt;</code>。</p>
<p>如果命令中 <code>&lt;commit-id&gt;</code> 具体为 <code>HEAD</code>，则其等价于取消对文件 <code>&lt;file&gt;</code> 的暂存。</p>
</li>
<li><p><code>git reset --hard &lt;commit-id&gt; &lt;file&gt;</code></p>
<p>此命令使用 <code>&lt;commit-id&gt;</code> 所指代提交记录更新暂存区中的文件 <code>&lt;file&gt;</code>，同时使用暂存区中文件更新工作区。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>git学习</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>git 学习(三)——分支操作</title>
    <url>/2020/10/05/git/gitstudy3/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文介绍使用 <code>git</code> 版本控制系统过程中所涉的各种分支命令。</p>
<a id="more"></a>

<p>几乎所有的版本控制系统都以某种形式支持分支。使用分支便意味着你可以把你的工作从开发主线上分离开来，<br>以免影响开发主线。在很多版本控制系统中，这是一个略微低效的过程——常常需要完全创建一个源代码副本。而对 Git 而言，其分支处理过程极其轻量。正是由于这一点，其分支模型也称为 Git 的 “必杀技特性” 。</p>
<blockquote>
<p>Git 分支模型实战网址：<a href="https://learngitbranching.js.org/?NODEMO=&amp;locale=zh_CN%E3%80%82">https://learngitbranching.js.org/?NODEMO=&amp;locale=zh_CN。</a></p>
</blockquote>
<h2 id="本地分支"><a href="#本地分支" class="headerlink" title="本地分支"></a>本地分支</h2><p>正如 <a href="/2020/09/29/git/gitstudy1/" title="git 学习(一)——缘起">git 学习(一)——缘起</a> 中所言，每次提交将会产生一个项目快照。另外，每次提交还会产生一个提交对象 ，该对象保存项目快照引用、提交人的姓名和电子邮箱、父提交对象引用等信息。经过若干提交，我们将会得到一张有向无环图，该图以提交对象为顶点，按照父提交对象引用进行构建边。</p>
<img src="/2020/10/05/git/gitstudy3/image-20201004103039132.png" alt="图一：提交后形成的有向无环图" width="80%">

<p>在 Git 之中，分支实质上就是指向该有向无环图中提交对象的可变指针，可变指针所指之处，即为当前分支最新状态。当构建 Git 仓库后，其默认存在初始分支 (主分支) <code>master</code>。每进行一次提交，有向无环图中就增加一个顶点及若干边，当前分支所示的可变指针便向前移动以使其指向当前分支的最新状态。</p>
<img src="/2020/10/05/git/gitstudy3/image-20201004111433763.png" alt="图二：master分支" width="50%">

<h3 id="分支创建"><a href="#分支创建" class="headerlink" title="分支创建"></a>分支创建</h3><p>命令 <code>git branch &lt;branchName&gt;</code> 即可创建新分支，该过程本质上就是：创建一个可变指针，并令其与当前分支的可变指针指向相同。需要注意的是：<strong>创建分支后，当前项目仍然处于当前分支，而不会自动切换到新分支</strong>。 </p>
<img src="/2020/10/05/git/gitstudy3/image-20201004112159576.png" alt="图三：创建分支" width="50%">

<blockquote>
<p><code>HEAD</code> 是 Git 中的特殊指针，它指向当前项目所在分支。之所以使用它，原因在于：需要确定当前项目具体在哪个分支之上。</p>
</blockquote>
<h3 id="分支切换"><a href="#分支切换" class="headerlink" title="分支切换"></a>分支切换</h3><p>命令 <code>git checkout &lt;branchName&gt;</code> 用于切换至指定分支。如下图所示，切换分支之后，<code>HEAD</code> 指针便指向分支 <code>testing</code>。</p>
<img src="/2020/10/05/git/gitstudy3/image-20201004192423480.png" alt="图四：切换分支" width="50%">

<p>此时，如果我们在当前分支中作一次提交，将会得到如图结果。可以看到：当前项目所在分支 <code>testing</code> 向前移动一步，而分支 <code>master</code> 并无任何变化。</p>
<img src="/2020/10/05/git/gitstudy3/image-20201004193043011.png" alt="图五：testing分支作一次提交" width="50%">

<p>随后，我们切换至分支 <code>master</code> 并完成一次提交，将会得到如图结果。可以看到：当前项目所在分支 <code>master</code> 向前移动一步，并与分支 <code>testing</code> 产生实际意义上的分支。</p>
<img src="/2020/10/05/git/gitstudy3/image-20201004193646647.png" alt="图六：master分支作一次提交" width="50%">

<blockquote>
<p>如果我们希望创建分支的同时，能够自动切换至新创建的分支，可使用命令 <code>git checkout -b &lt;branchName&gt;</code>。</p>
</blockquote>
<h3 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a>分支合并</h3><p>命令 <code>git merge &lt;branchName&gt; </code> 用于将分支 <code>branchName</code> 合并至当前分支。</p>
<p>分支合并存在两种情况：</p>
<ul>
<li><p>当前分支为分支 <code>branchName</code> 的前驱</p>
<p>这种情况的合并比较简单，只需要令当前分支所示指针与分支 <code>branchName</code> 所示指针指向相同即可 (进行合并之时，如果合并情况为此，GIt 将会提示 fast-forward)。</p>
<p>如图七所示，需要合并分支 <code>hotfix</code> 至当前分支 <code>master</code>，其正好满足此条件，故而只需要令分支 <code>master</code> 所示指针指向 <code>C4</code> 即可。</p>
<p><img src="/2020/10/05/git/gitstudy3/image-20201004210231197.png" alt="图七：分支合并:当前分支为分支branchName的前驱"></p>
</li>
<li><p>当前分支不为分支 <code>branchName</code> 的前驱</p>
<p>这种情况的合并比较麻烦，它会提取当前分支、分支 <code>branchName</code>、两分支公共祖先的项目快照，做一<em>三方合并</em>  (这是最简单的合并策略)，随后将合并内容作为当前分支的一次新提交。如果合并过程中发生冲突，需要手动处理冲突。</p>
<img src="/2020/10/05/git/gitstudy3/image-20201004193646647.png" alt="图八：分支合并：当前分支不为分支branchName的前驱" width="50%">

<blockquote>
<p>直观来看，应当直接合并当前分支、分支 <code>branchName</code> 的项目快照 (称为<em>两方合并</em>)。但是两方合并是不可行的，原因在于：我们无法根据二者差异决定合并策略 (具体见<a href="/2020/12/21/git/gitstudy6/" title="git 介绍(一)——git merge的合并策略">git 介绍(一)——git merge的合并策略</a>)。</p>
</blockquote>
</li>
</ul>
<h3 id="分支删除"><a href="#分支删除" class="headerlink" title="分支删除"></a>分支删除</h3><p>命令 <code>git branch -d/-D &lt;branchName&gt;</code> 用于删除指定分支。当使用 <code>-d</code> 参数时，如果分支 <code>branchName</code> 已合并至其他分支，则可成功删除；否则由于存在未合并内容，则会删除失败。此时如果需要强制删除，则可使用 <code>-D</code> 参数进行强制删除。</p>
<h3 id="分支查询"><a href="#分支查询" class="headerlink" title="分支查询"></a>分支查询</h3><p>命令 <code>git branch</code> 用于查询当前项目的所有分支。</p>
<p>命令 <code>git branch -v</code> 不仅可查询当前项目的所有分支，而且可查看每个分支的最后一次提交信息。</p>
<p>命令 <code>git branch --merged/--no-merged [&lt;branchName&gt;]</code> 用于查询已合并或未合并至分支 <code>branchName</code> (不加参数便是指当前分支) 的分支。</p>
<h2 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h2><p>远程分支 (remote branch) 指代位于远程服务器中的分支，此节介绍与其相关的两个内容 —— 远程跟踪分支 (remote-tracking branch) 、跟踪分支 (tracking branch)。</p>
<blockquote>
<p>通常存在 <strong>远程引用</strong> 这一概念，它是对远程仓库中分支、标签等内容的引用 (指针)。我们可借由命令 <code>git ls-remote</code> 显式获取远程引用的完整列表，也可使用命令 <code>git remote</code>  显式获取远程分支引用的完整列表。</p>
</blockquote>
<h3 id="远程跟踪分支"><a href="#远程跟踪分支" class="headerlink" title="远程跟踪分支"></a>远程跟踪分支</h3><p><strong>远程跟踪分支</strong> 是本地仓库对远程分支状态的记录，它们属于无法移动的本地引用，并以 <code>&lt;serverName&gt;/&lt;branchName&gt;</code> 形式命名。其作用类似于书签，用于标识该分支在远程仓库中的位置。当我们同步远程仓库内容时，它会自动更新其在远程仓库中的位置信息。</p>
<p>远程跟踪分支可能比较难理解，我们举例说明。</p>
<p>假定我们从 <code>git.ourcompany.com</code> 服务器中克隆项目至本地，<code>git clone</code> 命令会自动完成如下工作：设置远程服务器名为 <code>origin</code>、拉取项目完整内容、创建远程跟踪分支 <code>origin/master</code> 并自动设置其指向、创建本地分支 <code>master</code> 并令其与远程跟踪分支 <code>origin/master</code> 指向相同。克隆完成后，远程仓库与本地仓库可表示如下：</p>
<img src="/2020/10/05/git/gitstudy3/image-20201005102247388.png" alt="图九：克隆后的远程仓库与本地仓库" width="50%">

<p>随后我们在本地分支 <code>master</code> 做些提交，同时间段又有人在远程仓库的 <code>master</code> 分支做些提交，此时远程仓库与本地仓库可表示如下。可以看到：远程分支 <code>master</code> 发生变动，而远程跟踪分支 <code>origin/master</code> 未曾发生变动。</p>
<img src="/2020/10/05/git/gitstudy3/image-20201005104442560.png" alt="图十：若干提交后的远程仓库与本地仓库" width="50%">

<p>既然远程仓库内容有所变动，我们使用命令 <code>git fetch</code> 拉取其至本地，此时远程仓库与本地仓库可表示如下。可以看到：Git 会抓取本地仓库所没有的内容，随后更新远程跟踪分支 (如果存在相应的远程跟踪分支)。</p>
<img src="/2020/10/05/git/gitstudy3/image-20201005111447301.png" alt="图十一：拉取内容后的远程仓库与本地仓库" width="50%">

<p>此时可使用命令 <code>git merge</code> 合并分支 <code>origin/master</code> 与分支 <code>master</code>，从而更新本地分支 <code>master</code>；当然也可使用命令 <code>git checkout -b branchMaster origin/master</code> 新建分支 <code>branchMaster</code>，并令其与远程跟踪分支 <code>origin/master</code> 指向相同。</p>
<img src="/2020/10/05/git/gitstudy3/image-2020105.png" alt="图十二：与远程跟踪分支合并或新建分支与远程跟踪分支同步" width="50%">

<h3 id="跟踪分支"><a href="#跟踪分支" class="headerlink" title="跟踪分支"></a>跟踪分支</h3><p>基于远程跟踪分支 <code>checkout</code> 出来的本地分支便是 <strong>跟踪分支</strong>，该分支所对应的远程跟踪分支称为它的<em>上游分支</em>。跟踪分支是与远程分支有直接关联的本地分支，<strong>如果在跟踪分支之上输入 <code>git pull</code> 命令，Git 能够自动识别应当去哪个远程服务器的哪个分支上抓取内容，然后将其合并至当前分支</strong>。值得一说的是，使用命令 <code>git clone</code> 克隆项目时，它会基于远程跟踪分支 <code>origin/master</code> 自动创建跟踪分支 <code>master</code>。</p>
<p>跟踪分支的创建命令之前已经提及，就是 <code>git checkout -b &lt;branchName&gt; &lt;serverName/branchName&gt;</code>。由于此命令比较常用，故而存在两个简化命令，其一： <code>git checkout --track &lt;serverName/branchName&gt;</code>，其二：当使用命令 <code>git checkout &lt;branchName&gt;</code> 之时，如果该分支不存在、但是存在同名远程分支，则 Git 会自动创建相应的跟踪分支。</p>
<p>如果已经创建分支，但是需要将其关联至某远程分支，可使用命令 <code>git branch -u/--set-upsteam-to &lt;serverName/branchName&gt;</code> 设置当前分支的上游分支。</p>
<p>如果需要查看各分支的跟踪信息，可使用命令 <code>git branch -vv</code>。根据如下例子可以看到：分支 <code>testing</code> 没有跟踪任何远程分支；分支 <code>master</code> 跟踪远程分支 <code>master</code>，且两者处于同步状态；分支 <code>serverfix</code> 跟踪分支 <code>server-fix-good</code>，且存在 <code>ahead 3,behind 1</code>，此表示当前分支存在 3 个提交未曾推送至远程分支、远程分支存在 1 个提交未曾合并至本地分支。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch -vv</span><br><span class="line">testing 5ea463a trying something new</span><br><span class="line">master 1ae2a45 [origin/master] deploying index fix</span><br><span class="line">* serverfix f8674d9 [teamone/server-fix-good: ahead 3, behind 1] this should <span class="keyword">do</span> it</span><br></pre></td></tr></table></figure>
<blockquote>
<p>此命令并不涉及与远程分支的通信，其比较对象为最后一次从远程分支所获取的服务器数据 (通过命令 <code>git fetch</code> 做到)。</p>
</blockquote>
<h2 id="变基"><a href="#变基" class="headerlink" title="变基"></a>变基</h2><p><strong>变基</strong> (rebase) 属于分支合并中较为高级的操作，我们在此简单介绍。</p>
<h3 id="简单情景"><a href="#简单情景" class="headerlink" title="简单情景"></a>简单情景</h3><p>假定存在如图提交记录：</p>
<img src="/2020/10/05/git/gitstudy3/image-20201005170857635.png" width="50%">

<p>为合并两个分支，我们通常做法是采用命令 <code>git merge</code>，它会进行一次三方合并，并将合并结果作为一次提交。此时，提交记录如下：</p>
<img src="/2020/10/05/git/gitstudy3/image-20201005171258225.png" width="50%">

<p>可以看到，基于命令 <code>git merge</code> 的合并方式存在一大缺陷：使得提交记录不线性。为使得记录线性化，我们可使用命令 <code>git rebase &lt;topicBranch&gt;</code> ，它用于将当前分支上的所有修改移动至特定分支之上，这种操作便称为 <strong>变基</strong>。</p>
<blockquote>
<p>另有变基命令 <code>git rebase &lt;baseBranch&gt; &lt;topicBranch&gt;</code>，它用于将指定分支上的所有修改移动至特定分支之上。</p>
</blockquote>
<p>以上图为例，简述变基原理：首先找到当前分支 <code>experiment</code> 和分支 <code>master</code> 的公共祖先 <code>C2</code>，随后将公共祖先 <code>C2</code> 至当前分支所指之处的修改保存至临时文件之中，切换至分支 <code>master</code> 并将临时文件中的修改依次添加至该分支，随后再切换回分支 <code>experiment</code> 。经变基操作后，其提交记录如下：</p>
<blockquote>
<p><strong>经变基操作后，提交 <code>C4</code> 等都仍然在，只是当前分支通过日志记录查不到</strong>。</p>
</blockquote>
<img src="/2020/10/05/git/gitstudy3/image-20201005172538496.png" width="100%">

<p>此时切换至分支 <code>master</code>，执行命令 <code>git merge experiment</code>，可以发现它属于 “fast-forward”，合并过程简单，只需调整相关指针即可。可以看到：基于变基操作实现的合并结果是线性的。此时，其提交记录如下：</p>
<p><img src="/2020/10/05/git/gitstudy3/image-20201005183736856.png"></p>
<h3 id="复杂情景"><a href="#复杂情景" class="headerlink" title="复杂情景"></a>复杂情景</h3><p>上例仅涉及一个分支，比较简单。接下来我们看一个涉及多分支的例子。</p>
<p>假定存在如图提交记录，现在我们希望将分支 <code>client</code> 变基至分支 <code>master</code>，同时要求涉及分支 <code>server</code> 的任何修改不动。</p>
<img src="/2020/10/05/git/gitstudy3/image-20201005193209265.png" width="50%">

<p>基于此要求，我们可使用命令 <code>git rebase --onto master server client</code> 做到，该命令意思为：找到分支 <code>client</code> 与分支 <code>server</code> 的公共祖先，随后将公共祖先至分支 <code>client</code> 所指之处的修改移动并添加至分支 <code>master</code>。经过变基操作后，其提交记录如下：</p>
<img src="/2020/10/05/git/gitstudy3/image-20201005194221234.png" width="50%">

<h3 id="风险"><a href="#风险" class="headerlink" title="风险"></a>风险</h3><p>只要满足准则 —— “<strong>如果提交存在于你的仓库之外，而别人可能基于这些提交进行开发，那么不要执行变基</strong>”，变基操作就不会引人风险，否则就会引入麻烦。</p>
<p>我们同样通过例子说明该麻烦。假定我们从远程服务器克隆项目并对此执行若干提交，远程仓库与本地仓库的提交记录如下：</p>
<img src="/2020/10/05/git/gitstudy3/image-20201005204343785.png" width="50%">

<p>随后，其他人向远程服务器做若干提交，我们拉取其内容并合并至本地。此时，远程仓库与本地仓库的提交记录如下：</p>
<img src="/2020/10/05/git/gitstudy3/image-20201005204804646.png" width="50%">

<p>接下来，之前那个人决定使用变基操作替代合并操作，随后使用本地内容强制覆盖远程服务器中内容。如果我们此时拉取远程服务器中内容至本地，由于命令 <code>git fetch</code> 会将当前仓库中并不存在的内容拉取下来，故而会得到这样的提交记录：</p>
<img src="/2020/10/05/git/gitstudy3/image-20201005210031489.png" width="50%">

<p>为上传本地仓库至远程服务器，我们首先需要合并拉取下来的内容，这样我们就会重复合并提交 <code>C4</code> (<em>此为麻烦一，混乱日志信息</em>)。此时，远程仓库与本地仓库的提交记录如下：</p>
<img src="/2020/10/05/git/gitstudy3/image-20201005211515992.png" width="60%">

<p>此时如果我们将其上传至远程服务器，之前那个人不想要的提交 <code>C4</code> 和 <code>C6</code> 又会再次出现在远程服务器 (<em>此为麻烦二</em>)。为避免这种情况发生，最初我们应当将分支 <code>master</code> 变基至远程跟踪分支 <code>teamone/master</code>，这样就可以避免上面所述麻烦。此时，远程仓库与本地仓库的提交记录如下：</p>
<img src="/2020/10/05/git/gitstudy3/image-20201005213714608.png" width="60%">

<blockquote>
<p>对远程服务器中分支采用变基操作有两种命令，其一：首先使用命令 <code>git fetch</code> 获取数据，随后使用 <code>git rebase</code> 执行变基操作；其二：直接使用命令 <code>git pull --rebase</code> 代替前面的两条命令。</p>
</blockquote>
<h3 id="其他应用"><a href="#其他应用" class="headerlink" title="其他应用"></a>其他应用</h3><p>命令 <code>git rebase</code> 不仅可作用于不同分支以执行变基操作，也可作用于当前分支的若干提交以实现压缩提交功能。实现压缩提交功能的具体命令有 <code>git rabse -i HEAD~&lt;num&gt;</code>，它可压缩当前分支的最近 <code>&lt;num&gt;</code> 次提交为一次提交；<code>git rebase -i &lt;commit-id&gt;</code>，它可压缩当前分支提交 <code>commit-id</code> 之后的所有提交为一次提交。</p>
<h3 id="变基vs合并"><a href="#变基vs合并" class="headerlink" title="变基vs合并"></a>变基vs合并</h3><p>变基和合并均可实现分支合并，实际应用中应当着重选择哪种方式？</p>
<p>首先，我们需要回答问题：提交记录的作用何在？通常有两种观点：1. 提交记录用于记录实际发生过什么，它属于历史文档，不应当随意篡改；2. 提交记录用于记录项目开发过程中有意义的提交。如果持有观点 1，那么应当仅使用合并、杜绝使用变基以实现分支合并；如果持有观点 2，那么只有在满足准则情况下才使用变基、否则使用合并以实现分支合并。、</p>
<blockquote>
<p>除分支合并功能外，变基还可压缩提交。如果持有观点 1，则不应使用变基以压缩提交；如果持有观点 2，则可适当使用变基以压缩提交，从而使提交记录更为清晰。</p>
</blockquote>
<h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><p>命令 <code>git cherry-pick</code> 与命令 <code>git rebase</code> 类似，它不是将当前分支上全部提交作用于特定分支之上，而是将当前分支上某些提交作用于特定分支之上。其具体命令为 <code>git cherry-pick &lt;commit-id&gt;</code> ，应用 ID 为 <code>&lt;commit-id&gt;</code> 的提交至当前分支之上。</p>
]]></content>
      <categories>
        <category>git学习</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>git 学习(二)——基本操作</title>
    <url>/2020/09/30/git/gitstudy2/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文介绍使用 <code>git</code> 版本控制系统过程中所涉的各种基本命令。</p>
<a id="more"></a>

<blockquote>
<p>书写 <code>git</code> 命令时，如果参数使用 <code>[]</code> 括起来，则表明其可使用也可不使用；如果参数使用 <code>/</code> 进行分隔，则表示两者等价，可任选一个使用；如果某个参数使用 <code>&lt;&gt;</code> 括起来，则表明此为一个取值。</p>
</blockquote>
<h2 id="获取仓库"><a href="#获取仓库" class="headerlink" title="获取仓库"></a>获取仓库</h2><p>通常有两种方式用于获取 <code>git</code> 仓库：</p>
<ol>
<li><p>将尚未进行版本控制的本地目录转换为 Git 仓库。</p>
<p>进入到指定的本地目录，执行 <code>git init</code> 命令即可将当前目录转换为 <code>git</code> 仓库。</p>
</li>
<li><p>从其它服务器<em>克隆</em>一个已存在的 Git 仓库。</p>
<p>使用 <code>git clone &lt;url&gt; [folderName]</code> 命令可将位于 <code>url</code> 位置的 Git 仓库克隆至本地，并将其文件夹名更改为 <code>folderName</code>。</p>
</li>
</ol>
<blockquote>
<p><code>git init</code> 命令将会在本地创建一个 <code>.git</code> 文件夹，克隆得到的 <code>git</code> 仓库中同样存在 <code>.git</code> 文件夹。对于 <code>git</code> 仓库而言，此文件夹是十分重要的，它存放着当前 <code>git</code> 仓库的各种信息。关于此文件夹的详细信息，具体见 <a href="/2020/10/08/git/gitstudy5/" title="git 学习(五)——基本原理">git 学习(五)——基本原理</a>。</p>
</blockquote>
<h2 id="文件追踪"><a href="#文件追踪" class="headerlink" title="文件追踪"></a>文件追踪</h2><p>Git 仓库所在目录中的文件共有五种状态 —— 未追踪 (untracked)、未修改 (unmodified)、已修改 (modified)、已暂存 (staged)、已提交 (commited)。如果一个文件处于未追踪状态，则表明其尚未被 Git 仓库所管理；如果一个文件处于未修改状态，则表明自上次提交后，该文件尚未被修改；如果一个文件处于已修改状态，则表明自上次提交后，该文件已被修改；如果一个文件处于已暂存状态，则表明其位于暂存区；如果一个文件处于已提交状态，则表明其刚被提交。</p>
<p>文件状态间转换关系及所涉操作具体如下图所示 (未修改和已提交其实是一种状态，之所以如此写，希望与上篇文章中所提文件状态保持一致)：</p>
<img src="/2020/09/30/git/gitstudy2/image-20200930201714034.png" alt="图一：文件状态转换" width="80%">

<p>首先，我们介绍用于查看文件状态的两个命令：</p>
<ul>
<li><p><code>git status [--short]</code> </p>
<p>此命令用于查看当前目录中各文件所处状态 (如果文件处于未追踪、已修改、已暂存状态，则会列出其文件名)。添加 <code>--short</code> 参数后，该命令将会以一种简洁方式查看当前目录中各文件所处状态。</p>
<p><img src="/2020/09/30/git/gitstudy2/image-20200930210806912.png"></p>
<p>如图所示，输入 <code>git status</code> 命令后，它指出 <code>333.txt</code> 处于未追踪状态、<code>222.txt</code> 处于已修改状态、<code>111.txt</code> 处于已暂存状态。</p>
</li>
<li><p><code>git diff [--staged/--cached]</code></p>
<p>此命令用于查看工作区中文件与暂存区中文件的差异、暂存区中文件与仓库区中文件的差异 (此时需要使用 <code>--staged</code> 参数)。</p>
<p><img src="/2020/09/30/git/gitstudy2/image-20200930212317188.png"></p>
<p>如图所示，输入 <code>git diff</code> 命令后，它就指出工作区中 <code>222.txt</code> 与暂存区中 <code>222.txt</code> 的差异 ( <strong><code>diff</code> 命令输出中，使用 <code>a/</code>、<code>b/</code> 标识不同区内的文件，<code>a</code> 用于标识具有较旧内容的文件，<code>b</code> 用于标识具有较新内容的文件</strong>)。</p>
</li>
</ul>
<p>接下来，我们介绍与状态转换相关的命令：</p>
<ul>
<li><p><code>git checkout -- &lt;fileNmae&gt;</code></p>
<p>此命令用于将处于已修改状态的文件回退为未修改状态的文件，即撤销工作区中文件的已有修改。<strong>如此操作，工作区中文件的已有修改将被完全覆盖，并永远不可恢复</strong>。</p>
</li>
<li><p><code>git add</code></p>
<p>此命令用于将处于未追踪或已修改状态的文件加入暂存区，从而将文件状态转换为已暂存。</p>
<p>此命令通常有三种用法：</p>
<ol>
<li><code>git add .</code> ：将当前目录中所有符合条件的文件加入暂存区。</li>
<li><code>git add *.xxx</code>：将当前目录中满足 <code>*.xxx</code> 通配符匹配规则的文件加入暂存区。</li>
<li><code>git add xxx</code>：将当前目录中指定文件 <code>xxx</code> 加入暂存区。</li>
</ol>
</li>
<li><p><code>git reset HEAD &lt;fileName&gt;</code></p>
<p>此命令用于将处于已暂存状态的文件放回至工作区，从而将文件状态转换为已修改。该命令含有与 <code>git add</code> 命令含义刚好相反。</p>
</li>
<li><p><code>git commit[-m &quot;xxx&quot;]</code></p>
<p>此命令用于将处于已暂存状态的文件提交到仓库区，这便形成一次快照。</p>
<p>如果直接输入 <code>git commit</code> 命令，则其会跳转到编辑器页面，需要你输入提交说明，随后退出编辑器页面以完成提交；如果输入 <code>git commit -m &quot;xxx&quot;</code> 命令，则 <code>xxx</code> 作为提交说明并完成提交。</p>
<p>如果我们希望跳过暂存操作，直接执行提交操作，可使用 <code>git comit -am &quot;xxx&quot;</code> 命令，它等价于 <code>git add .,git commit -m &quot;xxx&quot;</code> 命令。</p>
<p>如果我们提交完一次快照后，发现若干文件忘记提交获取提交说明书写错误，此时可输入 <code>git commit --amend</code> 命令，它会将暂存区中内容提交至最新快照之中，同时启动编辑器页面，以允许你修改最新快照的提交说明。</p>
<p><img src="/2020/09/30/git/gitstudy2/image-20201001123912772.png"></p>
</li>
<li><p><code>git rm [-r] [--cached] xxx</code></p>
<p>如果直接输入 <code>git rm xxx</code>，则其会将文件 <code>xxx</code> 从暂存区中删除，同时删除工作区中文件 <code>xxx</code>。</p>
<p><img src="/2020/09/30/git/gitstudy2/image-20200930232540969.png"></p>
<p>如果输入 <code>git rm --cached xxx</code>，则其仅会将文件 <code>xxx</code> 从暂存区中删除，此时文件状态变更为未追踪 (<strong>将文件从暂存区中删除，此操作将等待被提交给仓库区，故而会出现于 <code>Changes to be commit</code></strong>)。</p>
<p><img src="/2020/09/30/git/gitstudy2/image-20200930233651644.png"></p>
<p>参数 <code>-r</code> 表明所删内容为文件夹。</p>
<blockquote>
<p><strong>如果工作区中文件与暂存区中文件不一致，则系统报错，此时可使用 <code>git rm -f xxx</code> 强制删除，这种操作的后果便是：工作区中修改部分将会永远不可恢复</strong>。</p>
<p><img src="/2020/09/30/git/gitstudy2/image-20200930235030276.png"></p>
<p>如果我们直接使用 <code>rm xxx</code> 命令，则其仅会删除工作区中文件 <code>xxx</code>，暂存区中的文件 <code>xxx</code> 仍然保留存在。</p>
</blockquote>
</li>
<li><p><code>git mv [-r]</code></p>
<p>此命令用于移动或重命名文件或文件夹。</p>
<p>Git 并不显式跟踪文件移动，为实现跟踪文件移动功能，实际上我们需要借由如下三条命令加以实现：<code>mv old new,git rm old,git add new</code>。<code>git rm</code> 命令则是此三者命令的集合版本，可帮助简化跟踪文件移动操作。</p>
</li>
<li><p><code>git </code></p>
</li>
</ul>
<p>最后我们介绍一下 <code>.gitignore</code> 文件。</p>
<p>对于一个项目而言，当前目录中的编译结果、日志输出等文件都是无需交由 Git 管理的，而且我们也不会希望它们处于未追踪状态，此时便可使用 Git 提供的 <code>.gitignore</code> 文件记录它们。如此操作，Git 便会忽略其中文件。</p>
<p>文件 <code>.gitignore</code> 的格式规范如下：</p>
<ul>
<li>所有空行或者以 <code>#</code> 开头的行都会被 Git 忽略。</li>
<li>可以使用标准的 glob 模式(正则表达式的阉割版) 匹配，它会递归地应用在整个工作区中。</li>
<li>匹配模式可以 (/) 开头防止递归。</li>
<li>匹配模式可以 (/) 结尾指定目录。</li>
<li>要忽略指定模式以外的文件或目录，可以在模式前加上叹号 (!)，以示取反。</li>
</ul>
<p><code>.gitignore</code> 所匹配文件集合应当为：前四条规范所示集合取并集，随后与第五条规范所示集合取交集 (<em>个人理解</em>)。假定存在 <code>.gitignore</code> 文件如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">*.a</span><br><span class="line">!lib.a</span><br></pre></td></tr></table></figure>
<p>此文件表示忽略除 <code>lib.a</code> 以外的所有以 <code>.a</code> 结尾的文件。</p>
<blockquote>
<p><code>.gitignore</code> 位于哪个文件夹之中，它就仅对此文件夹中所有文件起作用。</p>
<p>网址 <a href="https://github.com/github/gitignore">https://github.com/github/gitignore</a> 提供针对数十种项目及语言的 <code>.gitignore</code> 文件模板。</p>
</blockquote>
<h2 id="历史记录"><a href="#历史记录" class="headerlink" title="历史记录"></a>历史记录</h2><p>我们可使用 <code>git log</code> 命令获取已提交的历史记录，其默认按照时间顺序排列。对于每条历史记录而言，它会列出此次记录的 SHA-1 校验值、提交人、提交人的电子邮件、提交时间及提交说明。</p>
<p><img src="/2020/09/30/git/gitstudy2/image-20201001110236617.png"></p>
<p>对于 <code>git log</code> 命令而言，它存在很多参数可以选择，我们在此列出若干经常使用的参数：</p>
<ul>
<li><p><code>-p/--patch</code></p>
<p>使用此参数后，除显示基本记录信息外，它还会显示每次提交所引入的差异 (类似于 <code>git diff 当前记录 上次记录</code>)。</p>
<p><img src="/2020/09/30/git/gitstudy2/image-20201001111449919.png"></p>
</li>
<li><p><code>-&lt;n&gt;</code></p>
<p>此参数用于限制显示的历史记录条数。如果输入 <code>git log -2</code> 命令，它将仅显示最近的两条历史记录。</p>
<p>另外还有若干用于筛选历史记录的参数，我们在此简单介绍一二：<code>--since=&lt;date&gt;</code>，筛选时间节点 <code>date</code> 之后的历史记录；<code>--until=&lt;date&gt;</code>，筛选时间节点 <code>date</code> 之前的历史记录。</p>
</li>
<li><p><code>--stat</code></p>
<p>使用此参数后，除显示基本记录信息外，它还会显示每次提交的一些统计信息。</p>
<p><img src="/2020/09/30/git/gitstudy2/image-20201001111834198.png"></p>
</li>
<li><p><code>--pretty</code></p>
<p>此参数存在若干选值：<code>online</code>、<code>short</code>、<code>full</code>、<code>fuller</code> 等，选择不同选值，可以不同于默认格式的方式显示历史记录。</p>
<p>如果输入 <code>git log --pretty=online</code> 命令，它会简化记录信息，并将每个记录放在一行进行显示。</p>
<p><img src="/2020/09/30/git/gitstudy2/image-20201001112514711.png"></p>
<p>此参数存在一个特殊选值 <code>format</code>，它允许自定义显示方式 (具体比较麻烦，点到为止)。</p>
</li>
<li><p><code>--graph</code></p>
<p>使用此参数后，除显示基本记录信息外，它狐疑在日志旁以 ASCII 图形显示分支与合并历史。</p>
<p><img src="/2020/09/30/git/gitstudy2/image-20201001112911613.png"></p>
</li>
</ul>
<h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><p>远程仓库是指托管在因特网或其他网络中你的项目的版本库。借助于远程仓库，我们可方便实现多人合作项目开发。</p>
<p>为完成协作开发，我们需要管理此远程仓库。此节首先给出管理仓库命令之间的关系，随后详细介绍他们。</p>
<p><img src="/2020/09/30/git/gitstudy2/bg2014061202.jpg" alt="图二：远程仓库相关操作"></p>
<ul>
<li><p><code>git remote [-v]</code></p>
<p>此命令用于查看你所配置的远程服务器名。如果使用参数 <code>-v</code>，则不仅可看到远程服务器名，也可看到远程服务器的具体 URL。</p>
<p><img src="/2020/09/30/git/gitstudy2/image-20201001144519193.png"></p>
<p><code>git remote</code> 命令除查看配置的远程服务器信息外，也可执行与远程服务器配置相关的若干功能。</p>
<ol>
<li><code>git remote add  &lt;serverName&gt; &lt;serverUrl&gt;</code>：添加远程服务器。</li>
<li><code>git remote show &lt;serverName&gt;</code> ：显示指定远程服务器的详细信息。</li>
<li><code>git remote rm &lt;serverName&gt;</code>：删除指定远程服务器。</li>
<li><code>git remote rename &lt;oldserverName&gt; &lt;newserverName&gt;</code> ：指定远程服务器重命名。</li>
</ol>
</li>
<li><p><code>git fetch &lt;serverName&gt;</code></p>
<p>此命令用于从远程服务器 <code>serverName</code> 中拉取本地仓库中所没有的数据。需要注意的是：<strong>该命令只会拉取数据至本地仓库，而不会将其合并至工作区</strong>。</p>
<blockquote>
<p><code>git pull</code> 命令不仅会拉取数据至本地仓库，同时将其合并至工作区。</p>
</blockquote>
</li>
<li><p><code>git push &lt;serverName&gt; &lt;branch&gt;</code></p>
<p>此命令用于将本地仓库当前分支推送至远程服务器 <code>serverName</code> 的 <code>branch</code> 分支。</p>
</li>
</ul>
<h2 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h2><p>与其他版本控制系统一样，Git 可以给本地仓库历史记录中的某一个提交打上标签，以示其重要性。实际使用中，人们常用此功能标记发布的不同版本。</p>
<p>我们这里介绍与标签相关的若干命令：</p>
<ul>
<li><p><code>git tag [-l/--list &quot;通配模式&quot;]</code></p>
<p>此命令用于查看已有标签，其按照字母顺序列出。如果添加参数 <code>-l</code>，则其会列出与通配模式匹配的标签。</p>
</li>
<li><p><code>git tag ...</code></p>
<p>Git 支持两种标签 —— 轻量标签和附注标签。轻量标签只是某个特定提交的引用；附注标签则是存储于 Git 数据库中的完整对象，它包含打标签者的姓名、打标签者的电子邮件、打标签日期及标签信息 (可以看到，附注标签信息与提交快照信息基本一致)。通常情况下，建议使用附注标签。</p>
<p><code>git tag &lt;tagName&gt;</code> 命令用于创建最新提交的轻量标签；<code>git tag -a &lt;tagName&gt; -m &lt;tagMessage&gt;</code> 命令则用于创建最新提交的附注标签。</p>
<p>如果需要对以往提交打标签，则需使用 <code>git tag &lt;tagName&gt; &lt;以往提交的校验和&gt;</code> 或 <code>git tag -a &lt;tagName&gt; -m &lt;tagMessage&gt; &lt;以往提交的校验和&gt;</code> 命令。</p>
</li>
<li><p><code>git show &lt;tagName&gt;</code></p>
<p>此命令用于显示指定标签对应的详细信息。</p>
</li>
<li><p><code>git push &lt;serverName&gt; [&lt;tagName&gt;/--tags]</code></p>
<p>默认情况下，<code>git push</code> 命令并不会将标签信息传送至远程服务器。创建完标签后，我们需要显式推送标签至远程服务器。<code>git push &lt;serverName&gt; &lt;tagName&gt;</code> 便可做到这件事。</p>
<p>如果希望一次性推送很多标签，可使用 <code>git push &lt;serverName&gt; --tags</code> 命令，它会将远程服务器中不存在的标签全部传送过去 (两种标签都会传送过去)。</p>
</li>
<li><p><code>git tag -d &lt;tagName&gt;</code></p>
<p>此命令用于删除指定标签。</p>
<p>此命令仅会删除本地仓库中的标签，而不会删除远程服务器中的标签 (如果远程服务器中有此标签的话)，为删除远程服务器中的标签，我们可使用 <code>git push &lt;serverName&gt; :refs/tags/&lt;tagName&gt;</code> (将冒号前的空值推送至远程服务器中的指定标签名) 或 <code>git push &lt;serverName&gt; --delete &lt;tagName&gt;</code>。</p>
</li>
<li><p><code>git checkout &lt;tagName&gt;</code></p>
<p>此命令用于查看特定标签所指代的文件版本。此命令会使得本地仓库处于 <code>detachecd HEAD</code> 状态，它会存在一定副作用。</p>
</li>
</ul>
<p>由于某些命令比较复杂，具体使用比较繁琐，Git 提供 <strong>别名</strong> 功能以允许用户自定义简洁命令以替代复杂命令。我们在此举一个例子：<code>git config --global alias.unstage &#39;reset HEAD&#39;</code>，它将 <code>unstage</code> 定义为 <code>reset HEAD --</code> 的别名。以往取消暂存区文件至工作区，需要使用命令 <code>git reset HEAD &lt;fileName&gt;</code>，现在可使用命令 <code>git unstage &lt;fileName&gt;</code>。</p>
]]></content>
      <categories>
        <category>git学习</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>git 学习(一)——缘起</title>
    <url>/2020/09/29/git/gitstudy1/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文首先介绍了三种版本控制系统，并简要指明各自优缺点，随后介绍了 <code>git</code> 及首次安装所需的若干配置。</p>
<a id="more"></a>

<h2 id="版本控制系统"><a href="#版本控制系统" class="headerlink" title="版本控制系统"></a>版本控制系统</h2><p><strong>版本控制系统</strong> 就是一种记录若干文件内容变化，以便将来查阅特定版本修订情况的系统。换言之，借助于该系统，我们可以保存若干文件的历史版本，并根据需要能够快速获取指定版本的具体内容。</p>
<h3 id="本地版本控制系统"><a href="#本地版本控制系统" class="headerlink" title="本地版本控制系统"></a>本地版本控制系统</h3><p>最基本的版本控制系统应当是这样的 —— 复制整个项目所在目录以保存不同版本，同时为项目目录名添加时间以示区别。这种位于本机的版本控制系统称为 <em>本地版本控制系统</em>。</p>
<p>经过若干年发展，本地版本控制系统大多基于如下原理进行实现：使用某种简单数据库存储项目文件的历次更新差异。</p>
<img src="/2020/09/29/git/gitstudy1/image-20200927205659718.png" alt="图一：本地版本控制系统" width="50%">

<p>在这其中，最为流行的便是 RCS，它在硬盘之上保存补丁集 (即文件修订前后的变化)，通过应用所有补丁，可以计算得到各个版本的具体内容。</p>
<p>本地版本控制系统具有如下优缺点：</p>
<ul>
<li>优点<ul>
<li>便于个人管理项目。</li>
</ul>
</li>
<li>缺点<ul>
<li>无法实现多人合作同时开发项目。</li>
</ul>
</li>
</ul>
<h3 id="集中式版本控制系统"><a href="#集中式版本控制系统" class="headerlink" title="集中式版本控制系统"></a>集中式版本控制系统</h3><p>本地版本控制系统存在一个最大的问题：无法实现多人合作同时开发项目。为解决此问题，<em>集中式版本控制系统</em> 应运而生。集中式版本控制系统大多基于如下原理实现：单一集中管理的服务器存储项目文件的所有历史版本 (基于保存版本文件间差异而实现，也可以直接称为补丁集)，协同工作的人们通过客户端连接到服务器，取出最新项目文件开始工作，随后执行提交操作以更新项目文件。</p>
<img src="/2020/09/29/git/gitstudy1/image-20200927213559486.png" alt="图二：集中式版本控制系统" width="50%">

<p>集中式版本控制系统具有如下优缺点：</p>
<ul>
<li>优点<ul>
<li>方便管理、操作简单、易于上手。</li>
<li>集中式服务器更能保证安全性。</li>
<li>项目一致性非常高。</li>
</ul>
</li>
<li>缺点<ul>
<li>服务器性能要求极高。如果服务器发生宕机，这段时间便无法协同开发项目；如果服务器磁盘发生损坏，可能导致项目所有版本数据丢失。</li>
<li>必须联网以开发项目 (这是集中式版本控制系统的劣势)。</li>
<li>分支管控功能不够灵活。</li>
</ul>
</li>
</ul>
<h3 id="分布式版本控制系统"><a href="#分布式版本控制系统" class="headerlink" title="分布式版本控制系统"></a>分布式版本控制系统</h3><p>为解决集中式版本控制系统的若干缺点，分布式版本控制系统被提出。</p>
<img src="/2020/09/29/git/gitstudy1/image-20200928110410990.png" alt="图三：分布式版本控制系统" width="50%">

<p>相比于集中式版本控制系统而言，它具有如下特征：</p>
<ol>
<li>客户端不仅提取最新项目文件，而且将其所有历史版本一同提取到本机。如此操作，一旦存放项目文件的服务器 (此处的服务器与集中式版本控制系统中的服务器含义不同，此处的服务器仅用于托管项目文件) 发生故障，即可使用本地所存文件进行恢复。</li>
<li>客户端不仅可以同服务器进行交互以开发项目；而且可以直接与其他用户进行交互以开发项目。</li>
</ol>
<p>分布式版本控制系统具有如下优缺点：</p>
<ul>
<li>优点<ul>
<li>项目文件本地化，更能保证项目文件的完整性。</li>
<li>不联网时也可完成项目开发。</li>
<li>分支管控功能往往十分灵活、强大。</li>
</ul>
</li>
<li>缺点<ul>
<li>学习成本高，不容易上手。</li>
</ul>
</li>
</ul>
<h2 id="git"><a href="#git" class="headerlink" title="git"></a>git</h2><p>我们在此介绍一种十分著名、广泛使用的分布式版本控制系统 —— <code>git</code>。</p>
<p>经过多年发展，<code>git</code> 已日臻完善，并具有如下特征：</p>
<ol>
<li>设计简单、易于上手。</li>
<li>速度飞快，适合大项目管理。</li>
<li>完全分布式。</li>
<li>具有极其强大的分支管理系统，以保证对非线性开发模式的强力支持。</li>
</ol>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>这里，我们借由差异对比以介绍 <code>git</code> 工具：</p>
<ol>
<li><p>对于其他版本控制系统而言，它们将所需存储的项目文件看作是一组基本文件和每个文件随时间逐步积累的差异 (这种类型的版本控制系统可统称为 <em>基于差异的版本控制系统</em>)。</p>
<p><img src="/2020/09/29/git/gitstudy1/image-20200929085836559.png" alt="图四：其他版本控制系统的项目文件"></p>
<p>对于 <code>git</code> 而言，每更新一次项目状态，它就为项目所有文件创建快照 (可简单理解为当前项目所有文件的一个副本) 并保存该快照的索引。如果某文件未曾发生变动，则仅保留一个指向之前存储该文件的链接。故而，<code>git</code> 将所需存储的项目文件看作为 <strong>快照流</strong>。</p>
<p><img src="/2020/09/29/git/gitstudy1/image-20200929090912163.png" alt="图五：git 的项目文件"></p>
</li>
<li><p>为实现多人合作项目开发，其他版本控制系统基本都需要进行联网；对于 <code>git</code> 而言，绝大多数操作均为本地操作，仅有少数操作需要进行联网。</p>
</li>
<li><p><code>git</code> 底层使用 SHA-1 计算文件校验和，并以此作为文件索引。</p>
</li>
<li><p><code>git</code> 将项目中文件分为三种状态：已提交 (commited)、已暂存 (staged)、已修改 (modified)。已修改表示修改了文件，但还未对其做任何管理操作；已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中；已提交表示数据已经安全地保存在本地仓库中。</p>
<p>根据这三种文件状态，<code>git</code> 项目拥有三种阶段 —— 工作区、暂存区以及 Git 仓库 (也称仓库区、本地仓库、版本库)。</p>
<img src="/2020/09/29/git/gitstudy1/image-20200929105215986.png" alt="图六：git 项目阶段" width="80%">

<p>工作区是对项目的某个版本独立提取出来的内容。 这些从 Git 仓库的压缩数据库中提取出来，放在磁盘上供你使用或修改。</p>
<p>暂存区是一个文件，保存了下次将要提交的文件列表信息，一般在 Git 仓库目录中。 按照 Git 术语，其应当称为 “index”，但一般还是称为“暂存区”。</p>
<p>Git 仓库是 Git 用来保存项目元数据和对象数据库的地方。 这是 Git 中最重要的部分，它具体表现为 <code>.git</code> 文件夹。</p>
</li>
</ol>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>从 <a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a> 下载相应平台版本后，傻瓜式安装即可。</p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>首次下载 <code>git</code> 工具后，我们需要执行一些信息配置工作。<code>git</code> 提供 <code>git config</code> 命令帮助设置控制 Git 外观和行为相关的配置变量。根据使用命令的具体参数不同，这些变量将存储于三种不同的位置：</p>
<ol>
<li><code>/etc/gitconfig</code> 文件：包含系统级通用配置信息。如果使用 <code>git config --system</code> 配置变量，其将位于此文件中。在 Windows 系统中，其通常位于 <code>C:\Documents and Settings\All Users\Application Data\Git\config</code>。</li>
<li><code>~/.gitconfig</code> 文件：包含用户级通用配置信息。如果使用 <code>git config --global</code> 配置变量，其将位于此文件中。在 Windows 系统中，其通常位于 <code>C:/User/$User/.gitconfig</code>。</li>
<li>当前仓库下 <code>.git</code> 文件：包含本仓库的配置信息。如果直接使用 <code>git config</code> 配置变量，其将位于此文件中。</li>
</ol>
<blockquote>
<p>变量配置是否生效基于就近原则，即当前仓库下 <code>.git</code> 文件中的配置信息将会覆盖 <code>~/.gitconfig</code> 文件中的配置信息，<code>~/.gitconfig</code> 文件中的配置信息将会覆盖 <code>/etc/gitconfig</code> 文件中的配置信息。</p>
</blockquote>
<p>由于每次提交到 Git 仓库需要使用个人信息，因此我们需要配置用户名和邮件地址信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">&quot;John Doe&quot;</span></span><br><span class="line">$ git config --global user.email johndoe@example.com</span><br></pre></td></tr></table></figure>
<p>另外我们也可通过 <code>git config --list --show-orign</code> 查看所有已配置的变量信息及其所在文件位置。借于此，我们可以知道哪些变量可配置，从而使用 <code>git config</code> 命令修改现有配置。</p>
]]></content>
      <categories>
        <category>git学习</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-动态规划(十)</title>
    <url>/2020/09/20/algorithm/algorithm-dynamicprogramming10/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文主要介绍 DAG 上 DP，与其相关的题目有：嵌套矩形、硬币问题。</p>
<a id="more"></a>

<p>DAG 上 DP 问题，其本质在于将题目转换为有向无环图 (DAG) 上的最短路径、最长路径、路径计数等问题，从而使用动态规划进行求解。</p>
<h2 id="嵌套矩形"><a href="#嵌套矩形" class="headerlink" title="嵌套矩形"></a>嵌套矩形</h2><h3 id="题目描述及示例"><a href="#题目描述及示例" class="headerlink" title="题目描述及示例"></a>题目描述及示例</h3><p>有 $n$ 个矩形，每个矩形可以用 $a,b$ 来描述，分别表示长和宽。矩形 $X(a,b)$ 可以嵌套在矩形 $Y(c,d)$ 中当且仅当$a&lt;c,b&lt;d$ 或者 $b&lt;c,a&lt;d$。例如 $(1,5)$ 可以嵌套在 $(6,2)$ 内，但不能嵌套在 $(3,4)$ 中。你的任务是选出尽可能多的矩形排成一行，使得除最后一个外，每一个矩形都可以嵌套在下一个矩形内。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line"><span class="comment">// 第一行包含整数n，表示矩形数量。</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="comment">// 接下来n行，每行包含两个整数，分别表示矩形长和宽。</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">5</span> <span class="number">8</span></span><br><span class="line"><span class="number">6</span> <span class="number">10</span></span><br><span class="line"><span class="number">7</span> <span class="number">9</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span></span><br><span class="line"><span class="number">5</span> <span class="number">8</span></span><br><span class="line"><span class="number">12</span> <span class="number">10</span></span><br><span class="line"><span class="number">9</span> <span class="number">7</span></span><br><span class="line"><span class="number">2</span> <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">Output:</span><br><span class="line"><span class="comment">// 输出一个整数，表示最多符合条件的矩形数目。</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>数据存储</p>
<p>根据题意，可以看到：矩形嵌套成立条件有些复杂，为简化操作，对于每个矩形而言，我们将小值作为矩形的宽，大值作为矩形的长。此时只需判断两个矩形的宽长是否满足大小，即可判断矩形嵌套是否成立。</p>
<p>这道题目可以如此理解：每个矩形对应图中一个结点，如果矩形 $A$ 可以嵌套于矩形 $B$ 之内，则矩形 $B$ 所在结点引出一条有向边指向矩形 $A$ 所在结点。“最多符合嵌套条件的矩形数目” 便可理解为图中最长路径的所占结点数量。</p>
<p><code>graph[i][j]</code> 用于存储结点间权值信息，如果结点间存在边，则权值为 $1$，否则权值为 $0$。</p>
</li>
<li><p>状态表示</p>
<p>我们可以这样表示状态 $f[i]$：以当前结点 $i$ 作为终点，其路径上所占结点的最多数量。</p>
</li>
<li><p>状态转移</p>
<p>状态表示已然出现，状态转移便是比较简单。对于状态 $f[i]$ 而言，其应当由状态 $f[j]$ (结点 $j$ 需有边指向结点 $i$) 转移得到。</p>
<p>状态转移方程具体表示如下：</p>
<p>$$f[i] = max(f[j] + graph[j][i]),(0 \leq j &lt; n)$$</p>
<blockquote>
<p>因边权值设置，我们可如此表示状态。</p>
</blockquote>
</li>
<li><p>状态初始化</p>
<p>对于图而言，自然使用记忆化搜索实现。首先需要将所有状态置为未知 (可使用状态值为 $-1$ 表示未知)；搜索过程中，如果不存在指向当前结点 $i$ 的结点，则置 $f[i] = 1$。</p>
</li>
</ul>
<h2 id="硬币问题"><a href="#硬币问题" class="headerlink" title="硬币问题"></a>硬币问题</h2><h3 id="题目描述及示例-1"><a href="#题目描述及示例-1" class="headerlink" title="题目描述及示例"></a>题目描述及示例</h3><p>有 $n$ 种硬币，面值分别为 $V_1, V_2···,V_n$，每种都有无限多。给定非负整数 $S$ ，可以选用多少个硬币，使得面值之和恰好为 $S$？输出硬币数目的最小值和最大值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line"><span class="comment">// 第一行包含两个整数n,s。</span></span><br><span class="line"><span class="number">3</span> <span class="number">18</span></span><br><span class="line"><span class="comment">// 接下来n行，每行包含一个整数，表示硬币面值。</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line"><span class="comment">// 输出两个整数，分别表示硬币数目的最小值和最大值。</span></span><br><span class="line"><span class="number">5</span> <span class="number">18</span></span><br></pre></td></tr></table></figure>
<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>数据存储</p>
<p>该题可以这样理解：整数 $0 \sim S$ 分别表示图中一个顶点，对于整数 $i,j \ (j &gt; i)$ 而言，如果 $j - i$ 对应某种面值的硬币，则整数 $i$ 所在结点引出一条有向边指向整数 $j$ 所在结点。“硬币数目的最小值和最大值” 便可理解为：从整数 $0$ 所在结点到整数 $S$ 所在结点的所有路径中，最长路径的长度和最短路径的长度。</p>
<p><code>graph[i][j]</code> 用于存储结点间权值信息，如果结点间存在边，则权值为 $1$，否则权值为 $0$。</p>
</li>
<li><p>状态表示</p>
<p>我们可以这样表示状态 $f[i]$：以当前结点 $i$ 作为终点，其最长路径的长度，$p[i]$：以当前结点 $i$ 作为终点，其最短路径的长度。</p>
</li>
<li><p>状态转移</p>
<p>状态转移与上题类似，我们直接给出状态转移方程：</p>
<p>$$f[i] = max(f[j] + graph[j][i]),(0 \leq j &lt; n)$$</p>
<p>$$p[i] = min(p[j] + graph[j][i]),(0 \leq j &lt; n)$$</p>
</li>
<li><p>状态初始化</p>
<p>对于图而言，自然使用记忆化搜索实现。首先需要将所有状态置为未知 (可使用状态值为 $-1$ 表示未知)；搜索过程中，如果当前结点所示整数为 $0$，则置 $f[i] = 0,p[i] = 0$，如果当前结点没有任何结点指向，则置 $f[i] = -INF,p[i] = INF$ ($INF$ 表示无穷大)。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>DAG上DP</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-动态规划(九)</title>
    <url>/2020/09/20/algorithm/algorithm-dynamicprogramming9/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文主要介绍数位 DP，与其相关的题目有：度的数量、数字游戏。</p>
<a id="more"></a> 

<p>数位 DP 是在数位之上执行 DP，其实现往往有模板可循，我们在此列举并说明其模板：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数位DP通常需要求取指定区间[a,b]内满足条件的树的个数，为此我们可以求取[0,b] - [0,a-1]。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 状态表示：第i位为j时，满足条件的数的个数。</span></span><br><span class="line"><span class="keyword">int</span>[][] f;</span><br><span class="line"><span class="comment">// 基于某进制保存各位上的数。</span></span><br><span class="line"><span class="keyword">int</span>[] nums;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从高到底遍历各位。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = nums.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="comment">// 获取当前位</span></span><br><span class="line">    <span class="keyword">int</span> num = nums[i];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当前位取0~num-1时，统计个数。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当前位取num时，记录相关信息</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当i=0时，循环即将结束，可能需要做一些边界处理。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>数位 DP 其实就数位统计，只不过有些统计需要用到 DP 而已。</p>
</blockquote>
<h2 id="度的数量"><a href="#度的数量" class="headerlink" title="度的数量"></a>度的数量</h2><h3 id="题目描述及示例"><a href="#题目描述及示例" class="headerlink" title="题目描述及示例"></a>题目描述及示例</h3><p>求给定区间 $[X,Y]$ 中满足下列条件的整数个数：这个数恰好等于 $K$ 个互不相等的 $B$ 的整数次幂之和。</p>
<p>例如，设 $X=15,Y=20,K=2,B=2$，则有且仅有下列三个数满足题意：$17=2^4+2^0$$、18=2^4+2^1$、$20=2^4+2^2$。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line"><span class="comment">// 第一行包含两个整数，分别表示X、Y。</span></span><br><span class="line"><span class="number">15</span> <span class="number">20</span></span><br><span class="line"><span class="comment">// 第二行包含两个整数，分别表示K、B。</span></span><br><span class="line"><span class="number">2</span> <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">Output:</span><br><span class="line"><span class="comment">// 输出一个整数，表示满足条件的整数个数。</span></span><br></pre></td></tr></table></figure>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>数据存储</p>
<p><code>numX[i]</code> 用于存储 $B$ 进制表示的 $X$，<code>numY[i]</code> 用于表示 $B$ 进制表示的 $Y$。</p>
</li>
<li><p>状态表示</p>
<p>根据题意，如果一个数满足条件，则其 $B$ 进制表示中 $K$ 位为 $1$，其余位均为 $0$。我们在此先行给出状态表示 $f[i][j]$：组合数 $C_i^j$ ，具体原因后续将会看到。</p>
</li>
<li><p>状态转移</p>
<p>按照最上面所述的解题模板，我们应当从最高位第 $i$ 位进行枚举。假定需要求取指定区间 $[0,X]$ 内满足条件的数的个数、此时最高位为 $numX[i]$，如果 $numX[i] &gt; 1$，则其有两种选择：其一，当前位取 $1$，后续 $i$ 位任取 $k - 1$ 个 $1$，如此组合得到的数一定满足条件，其个数为 $C_i^{k - 1}$ (这就是我们的状态表示)；其二，当前位取 $0$，后续 $i$ 位任取 $k$ 个 $1$，如此组合得到的数也一定满足条件，其个数为 $C_i^k$；如果 $numX[i] = 1$，则其同样有两种选择：其一，当前位取 $0$，后续 $i$ 位任取 $k$ 个 $1$，如此组合得到的数也一定满足条件，其个数为 $C_i^k$；其二，当前位取 $1$，此时后续 $i$ 位无法任意取 $i - 1$ 个 $1$，因为任取得到的数可能大于 $X$，此时就需要枚举第 $i - 1$ 位，根据其情况再做判断；如果 $numX[i] = 0$，则直接枚举第 $i - 1$ 位即可。</p>
<blockquote>
<p>如果 $numX[i] &gt; 1$，统计两种选择所满足的数的个数后就可以直接退出循环了。如果按照解题模板那样，当前位取 $numX[i]$ 所得到的数都是不满足条件的。</p>
<p>如果 $numX[i] = 1$，当前位取 $1$ 并开始枚举第 $i - 1$ 位时，需要统计当前位前方已有多少个 $1$。</p>
<p>当枚举到第 $0$ 位时，如果当前位为 $0$ 且当前位前方已有 $K$ 个 $1$，则这也是一个满足条件的数。</p>
</blockquote>
<p>我们在此介绍简单说明 $f[i][j]$ 的状态转移方程 (就是组合公式 $C_i^k = C_{i - 1}^k + C_{i - 1}^{k - 1}$)：</p>
<p>$$f[i][j] = f[i - 1][j - 1] + f[i - 1][j]$$</p>
</li>
<li><p>状态初始化</p>
<p>我们只需置 $f[i][0] = 1,(i \leq 0 &lt; f.length)$ 即可。</p>
</li>
</ul>
<h2 id="数字游戏"><a href="#数字游戏" class="headerlink" title="数字游戏"></a>数字游戏</h2><h3 id="题目描述及示例-1"><a href="#题目描述及示例-1" class="headerlink" title="题目描述及示例"></a>题目描述及示例</h3><p>科协里最近很流行数字游戏。某人命名了一种不降数，这种数字必须满足从左到右各位数字呈非下降关系，如 $123,446$。现在大家决定玩一个游戏，指定一个整数闭区间 $[a,b]$，问这个区间内有多少个不降数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line"><span class="comment">// 输入两个整数，分别表示a,b。</span></span><br><span class="line"><span class="number">1</span> <span class="number">19</span></span><br><span class="line">    </span><br><span class="line">Output:</span><br><span class="line"><span class="comment">// 输出一个整数，表示满足条件的数的个数。</span></span><br><span class="line"><span class="number">18</span></span><br></pre></td></tr></table></figure>
<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>数据存储</p>
<p><code>numA[i]</code> 用于存储十进制表示的 $a$，<code>numB[i]</code> 用于存储十进制表示的 $b$ (假定数组高位对应数字的高位)。</p>
</li>
<li><p>状态表示</p>
<p>我们可以这样表示状态 $f[i][j]$：第 $i$ 位放置 $j$、其余位随意放置时，满足条件的数的个数。</p>
</li>
<li><p>状态转移</p>
<p>这道题与上题类似，假定需要求取指定区间 $[0,A]$ 内满足条件的数的个数，且最高有效位为第 $i$ 位、最高位数字为 $numA[i]$。当前位置取 $0 \sim (numA[i] - 1)$ 时，其余位可任取，故而我们统计 $\sum_{j = 0}^{numA[i]}(f[i][j])$ 以得到满足条件的数的个数；当前位置取 $numA[i]$ 时，其余位不可任取 (原因同上)，故而需要枚举第 $i - 1$ 位以根据其情况再做判断。</p>
<blockquote>
<p>当枚举第 $i - 1$ 位时，因为需要满足不降数条件，其取值需要小于等于 $numA[i]$，。</p>
</blockquote>
<p>对于状态 $f[i][j]$ 而言，它应当由状态 $f[i - 1][k],(k \leq j)$ 转移得到。其状态转移方程具体如下：</p>
<p>$$f[i][j] = \sum_{k = 0}^j(f[i - 1][k])$$</p>
</li>
<li><p>状态初始化</p>
<p>根据状态表示，我们如此初始化：指定 $f[0][j] = j,(0 \leq j &lt; 10)$。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>数位DP</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-动态规划(八)</title>
    <url>/2020/09/20/algorithm/algorithm-dynamicprogramming8/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文主要介绍树形 DP (简而言之，就是在树结构上完成 DP)，与其相关的题目有：没有上司的舞会、树的最长路径、树的中心、皇宫看守。</p>
<a id="more"></a>

<h2 id="没有上司的舞会"><a href="#没有上司的舞会" class="headerlink" title="没有上司的舞会"></a>没有上司的舞会</h2><h3 id="题目描述及示例"><a href="#题目描述及示例" class="headerlink" title="题目描述及示例"></a>题目描述及示例</h3><p>Ural 大学有 $N$ 名职员，编号为 $1~N$。他们的关系就像一棵以校长为根的树，父节点就是子节点的直接上司。每个职员有一个快乐指数，用整数 $Hi$ 给出，其中 $1 \leq i \leq N$。现在要召开一场周年庆宴会，不过，没有职员愿意和直接上司一起参会。在满足这个条件的前提下，主办方希望邀请一部分职员参会，使得所有参会职员的快乐指数总和最大，求这个最大值?</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line"><span class="comment">// 第一行包含一个整数。</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="comment">// 接下来N行，每行包含一个整数，表示职员的快乐指数。</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="comment">// 接下来N-1行，记录各职员的直接上司。</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">6</span> <span class="number">4</span></span><br><span class="line"><span class="number">7</span> <span class="number">4</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">3</span> <span class="number">5</span></span><br><span class="line">    </span><br><span class="line">Output:</span><br><span class="line"><span class="comment">// 输出一个整数，表示最大的快乐指数。</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>数据存储</p>
<p><code>w[i]</code> 用于存储各职员的快乐指数，<code>child[i][*]</code> 用于存储各职员的直接下级，<code>root</code> 用于存储根职员。</p>
</li>
<li><p>状态表示</p>
<p>对于树形 DP 而言，状态表示往往类似于：在以当前节点为根节点的子树中进行操作，所能得到的最大/最小价值。另外，本题中每个节点具有两种状态 —— 选或不选，则我们可以这样定义状态 $f[i][0]$：在以当前节点 $i$ 为根节点的子树中，选择职员参加舞会且当前节点所示职员不参加舞会情况下，所能得到的最大快乐指数，和 $f[i][1]$：在以当前节点 $i$ 为根节点的子树中，选择职员参加舞会且当前节点所示职员参加舞会情况下，所能得到的最大快乐指数。</p>
</li>
<li><p>状态转移</p>
<p>根据状态表示及题目描述，可很容易得到如下的状态转移方程：</p>
<p>当前节点所示职员参加舞会：</p>
<p>$$f[i][1] = \sum_{j = 1}^{child[j].length}(f[son][0]),(son = child[i][j])$$</p>
<p>当前节点所示职员不参加舞会：</p>
<p>$$f[i][0] = \sum_{j = 1}^{child[j].length}(max(f[son][0],f[son][1])),(son = child[i][j])$$</p>
</li>
<li><p>状态初始化</p>
<p>树形 DP 往往采用记忆化搜索实现，故而需要先将所有状态置为未知 (可使用状态值为 $-1$ 表示未知)；搜索过程中，如果当前节点为叶节点，则设置 $f[i][0] = 0,f[i][1] = w[i]$ 即可。</p>
<blockquote>
<p>执行记忆化搜索之时，需从根职员开始。</p>
</blockquote>
</li>
</ul>
<h2 id="树的最长路径"><a href="#树的最长路径" class="headerlink" title="树的最长路径"></a>树的最长路径</h2><h3 id="题目描述及示例-1"><a href="#题目描述及示例-1" class="headerlink" title="题目描述及示例"></a>题目描述及示例</h3><p>给定一棵树，树中包含 $n$ 个结点（编号 $1 \sim n$）和 $n−1$ 条无向边，每条边都有一个权值 (权值非负)。现在请你找到树中的一条最长路径，换句话说，要找到一条路径，使得路径两个端点的距离最远。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line"><span class="comment">// 第一行包含整数n。</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="comment">// 接下来n−1行，每行包含三个整数ai,bi,ci，表示点ai和bi之间存在一条权值为ci的边。</span></span><br><span class="line"><span class="number">5</span> <span class="number">1</span> <span class="number">6</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">6</span> <span class="number">3</span> <span class="number">9</span></span><br><span class="line"><span class="number">2</span> <span class="number">6</span> <span class="number">8</span></span><br><span class="line"><span class="number">6</span> <span class="number">1</span> <span class="number">7</span></span><br><span class="line">    </span><br><span class="line">Output:</span><br><span class="line"><span class="comment">// 输出一个整数，表示树的最长路径的长度。</span></span><br><span class="line"><span class="number">22</span></span><br></pre></td></tr></table></figure>
<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>数据存储</p>
<p><code>child[i][*]</code> 用于存储各节点间关系，<code>graph[i][k]</code> 用于存储节点间权值信息，<code>root</code> 用于存储根节点。</p>
</li>
<li><p>状态表示</p>
<p>根据题意：任意两点距离的最大值即为树的最长路径 (注意：该定义无视树边的有向性)。除使用基本的路径算法外，我们可以这样求取任意两个节点 $A,B$ 的距离：假定 $A,B$ 两点路径中最靠近树根的节点为 $C$，那么我们只需要求取节点 $C$ 到节点 $A,B$ 的距离，二者之和便是两节点的距离。这一求解方式是此题状态表示的基础，针对此题，我们可以这样定义状态 $f[i][0]$：当前节点到其子树节点的最大距离，和 $f[i][1]$：当前节点到其子树节点的次大距离。</p>
<p>当对所有节点求取两种状态后，树的最长路径值便是 $max(f[i][0] + f[i][1]),(0 \leq i &lt; n)$。</p>
</li>
<li><p>状态转移</p>
<p>此题目的状态转移比较特殊，我们我们使用方程进行表述：</p>
<p>$$(f[i][0]) = maxFirst(0,f[j][0] + graph[i][j]),(0 \leq j &lt; child[i].length)$$</p>
<p>$$(f[i][1]) = maxSecond(0,f[j][0] + graph[i][j]),(0 \leq j &lt; child[i].length)$$</p>
<blockquote>
<p><code>maxFirst</code> 表示最大值，<code>maxSecond</code> 表示次大值。</p>
</blockquote>
</li>
<li><p>状态初始化</p>
<p>此题同样需要使用记忆化搜索加以实现。首先需要将所有状态置为未知 (可使用状态值为 $-1$ 表示未知)；搜索过程中，如果当前节点为叶节点，则置 $f[i][0] = f[i][1] = 0$。</p>
</li>
</ul>
<h2 id="树的中心"><a href="#树的中心" class="headerlink" title="树的中心"></a>树的中心</h2><h3 id="题目描述及示例-2"><a href="#题目描述及示例-2" class="headerlink" title="题目描述及示例"></a>题目描述及示例</h3><p>给定一棵树，树中包含 $n$ 个结点（编号 $1~n$）和 $n−1$ 条无向边，每条边都有一个权值。请你在树中找到一个点，使得该点到树中其他结点的最远距离最近。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line"><span class="comment">// 第一行包含整数n。</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="comment">// 接下来n−1行，每行包含三个整数ai,bi,ci，表示点ai和bi之间存在一条权值为ci的边。</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">1</span> </span><br><span class="line"><span class="number">3</span> <span class="number">2</span> <span class="number">1</span> </span><br><span class="line"><span class="number">4</span> <span class="number">3</span> <span class="number">1</span> </span><br><span class="line"><span class="number">5</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">Output:</span><br><span class="line"><span class="comment">// 输出一个整数，表示所求点到树中其他结点的最远距离。</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>数据存储</p>
<p><code>child[i][*]</code> 用于存储各节点间关系，<code>graph[i][k]</code> 用于存储节点间权值信息，<code>root</code> 用于存储根节点。</p>
</li>
<li><p>状态表示</p>
<p>如果我们求得任意一点向下走和向上走所能到达树中其他节点的最远距离，那么此题便迎刃而解。我们首先简单看一个例子：</p>
<img src="/2020/09/20/algorithm/algorithm-dynamicprogramming8/image-20200919110935307.png" style="zoom:50%;">

<p>其中：我们求取节点 $3$ 向下走 (红线) 和向上走 (绿线) 所能达到树中其他节点的最远距离。</p>
<p>为求解向下走和向上走的最远距离，我们需要定义如下状态 $f[i][0]$：当前节点向下走所能走到的最远距离，$f[i][1]$：当前节点向下走所能走到的次远距离 (保存该值是有意义的，例子中节点 $3$ 向上走的最远距离就使用到节点 $8$ 的次远距离)；$f[i][3]$：当前节点向上走所能走到的最远距离。另外我们需要保存当前节点向下走最远距离时所选择的节点及当前节点向下走次远距离时所选择的节点，分别使用 $p0[i]$ 和 $p1[i]$ 进行存储。</p>
</li>
<li><p>状态转移</p>
<p>$f[i][0]$ 和 $f[i][1]$ 的状态转移与上题一致，我们主要介绍 $f[i][3]$ 的状态转移。</p>
<p>对于状态 $f[i][3]$ 而言，它一定经由父节点的状态转移得到。如果当前节点非为父节点向下走最远路径时所选择节点，则当前状态应当由 $f[i][3]$ 或 $f[i][0]$ 转移得到；否则应当由 $f[i][3]$ 或 $f[i][1]$ 转移得到，故而其状态转移方程可表示如下：</p>
<p>$$f[i][3] = max(f[parent][3],f[i][0]) + graph[parent][i],(i \neq p0[parent])$$</p>
<p>$$f[i][3] = max(f[parent][3],f[i][1]) + graph[parent][i],(i = p0[parent])$$</p>
<blockquote>
<p>实际实现中，我们会根据当前节点信息更新子节点状态，而非状态转移中根据父节点信息更新当前节点状态。</p>
<p>$f[i][0],f[i][1]$ 应当自底向上记忆化搜索，$f[i][3]$ 应当自顶向下搜索，且同时使用到状态 $f[i][0],f[i][1]$ ，故而此题应当分两次搜索，首先执行自底向上记忆化搜索，随后自顶向下搜索，以完成所有状态的更新。</p>
</blockquote>
</li>
<li><p>状态初始化</p>
<p>如上所述，此题使用记忆化搜索实现 DP。首先需要将所有状态置为未知 (可使用状态值为 $-1$ 表示未知)；当记忆化搜索 $f[i][0],f[i][1]$ 时，如果当前节点为叶节点，则置 $f[i][0] = f[i][1] = 0$；当搜索 $f[i][3]$ 时，我们直接置 $f[root][3] = 0$ 即可。</p>
</li>
</ul>
<h2 id="皇宫看守"><a href="#皇宫看守" class="headerlink" title="皇宫看守"></a>皇宫看守</h2><h3 id="题目描述及示例-3"><a href="#题目描述及示例-3" class="headerlink" title="题目描述及示例"></a>题目描述及示例</h3><p>太平王世子事件后，陆小凤成了皇上特聘的御前一品侍卫。皇宫各个宫殿的分布，呈一棵树的形状，宫殿可视为树中结点，两个宫殿之间如果存在道路直接相连，则该道路视为树中的一条边。已知，在一个宫殿镇守的守卫不仅能够观察到本宫殿的状况，还能观察到与该宫殿直接存在道路相连的其他宫殿的状况。</p>
<p>大内保卫森严，三步一岗，五步一哨，每个宫殿都要有人全天候看守，在不同的宫殿安排看守所需的费用不同。可是陆小凤手上的经费不足，无论如何也没法在每个宫殿都安置留守侍卫。帮助陆小凤布置侍卫，在看守全部宫殿的前提下，使得花费的经费最少。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line"><span class="comment">// 第一行包含整数n,表示树中结点个数。</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="comment">// 接下来n行，每行描述一个宫殿信息，具体包括该宫殿结点标号i，安置侍卫所需的经费k，子结点数m，具体的子结点。</span></span><br><span class="line"><span class="number">1</span> <span class="number">30</span> <span class="number">3</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">2</span> <span class="number">16</span> <span class="number">2</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line"><span class="number">3</span> <span class="number">5</span> <span class="number">0</span></span><br><span class="line"><span class="number">4</span> <span class="number">4</span> <span class="number">0</span></span><br><span class="line"><span class="number">5</span> <span class="number">11</span> <span class="number">0</span></span><br><span class="line"><span class="number">6</span> <span class="number">5</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">Output:</span><br><span class="line"><span class="comment">// 输出一个整数，表示最少的经费。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>数据存储</p>
<p><code>child[i][*]</code> 用于存储各节点间关系，<code>w[i]</code> 用于存储节点权值信息，<code>root</code> 用于存储根节点。</p>
</li>
<li><p>状态表示</p>
<p>题目要求每个结点都能够被看到，而且一个结点存在三种被看到的情况，故而我们可以这样定义状态 $f[i][0]$：当前子树的所有结点被看到、当前结点由父节点看到时，所需的最小代价，$f[i][1]$：当前子树的所有结点被看到、当前结点由子节点看到时，所需的最小代价，$f[i][2]$：当前子树的所有结点被看到、当前结点由自己看到时，所需的最小代价。</p>
</li>
<li><p>状态转移</p>
<p>对于 $f[i][0]$ 而言，当前节点已由父节点看到，那么子结点要么由自己看到，要么由其子结点看到；对于 $f[i][1]$ 而言，当前节点已由子结点看到，那么至少存在一个子结点需要由自己看到，其余子结点可选择由自己看到，也可选择由子节点看到；对于 $f[i][2]$ 而言，当前阶段已由自己看到，那么子结点要么由父节点看到，要么由自己看到，要么由子节点看到。</p>
<p>状态转移方程具体可表示如下：</p>
<p>$$f[i][0] = SUM,(SUM = \sum(min(f[j][1],f[j][2])),0 \leq j &lt; child[i].length)$$</p>
<p>$$f[i][1] = min(SUM - min(f[j][1],f[j][2]) + f[j][2]),(0 \leq j &lt; child[i].length)$$</p>
<p>$$f[i][2] = \sum(f[j][0],f[i][1],f[i][2]),(0 \leq &lt; j &lt; child[i].length)$$</p>
</li>
</ul>
<ul>
<li><p>状态初始化</p>
<p>本题同样使用记忆化搜索实现 DP。首先需要将所有状态置为未知 (可使用状态值为 $-1$ 表示未知)；搜索过程中，如果当前结点为叶结点，则置 $f[i][0] = 0,f[i][1] = INF,f[i][2] = w[i]$ ($INF$ 表示无穷大)。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-动态规划(七)</title>
    <url>/2020/09/18/algorithm/algorithm-dynamicprogramming7/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文主要介绍区间 DP，与其相关的题目有：石子合并、棋盘分割。</p>
<a id="more"></a>

<h2 id="石子合并"><a href="#石子合并" class="headerlink" title="石子合并"></a>石子合并</h2><h3 id="题目描述及示例"><a href="#题目描述及示例" class="headerlink" title="题目描述及示例"></a>题目描述及示例</h3><p>设有 $N$ 堆石子排成一排，其编号为 $1，2，3，…，N$。每堆石子有一定的质量，可以用一个整数来描述，现在要将这 $N$ 堆石子合并成为一堆。每次只能合并相邻的两堆，合并的代价为这两堆石子的质量之和，合并后与这两堆石子相邻的石子将和新堆相邻，合并时由于选择的顺序不同，合并的总代价也不相同。</p>
<p>例如有 $4$ 堆石子分别为 $1 3 5 2$， 我们可以先合并 $1、2$ 堆，代价为 $4$，得到 $4 \ 5 \ 2$， 又合并 $1，2$ 堆，代价为 $9$，得到 $9 \ 2$ ，再合并得到 $11$，总代价为 $4+9+11=24$。如果第二步是先合并 $2，3$ 堆，则代价为 $7$，得到 $4 7$，最后一次合并代价为 $11$，总代价为 $4+7+11=22$。</p>
<p>问题是：找出一种合理的方法，使总的代价最小?</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line"><span class="comment">// 第一行包含一个数N，表示石子的堆数。</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="comment">// 第二行包含N个数，表示每堆石子的质量。</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">5</span> <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">Output:</span><br><span class="line"><span class="comment">// 输出一个整数，表示最小代价。</span></span><br><span class="line"><span class="number">22</span></span><br></pre></td></tr></table></figure>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>数据存储</p>
<p><code>prefix[i]</code> 用于存储石子质量的前缀和。</p>
</li>
<li><p>状态表示</p>
<p>我们直接这样表示状态 $f[i][j]$：合并区间 $[i,j]$ 所示石子，所需的最小代价。</p>
</li>
<li><p>状态转移</p>
<p>题目要求 “只有相邻石子才能合并”，故而当前状态 $f[i][j]$ 一定是由 $f[i][k]$ 和 $f[k + 1][j]$ 转移得到。由于并不知道具体 $k$ 取值，故而需要枚举区间内所有合法 $k$ 值。</p>
<p>状态转移方程具体如下：</p>
<p>$$f[i][j] = min(f[i][j], f[i][k] + f[k + 1][j] + prefix[j] - prefix[i - 1]),(i \leq k &lt; j)$$</p>
</li>
<li><p>状态初始化</p>
<p>题意要求求取最小值，故而首先将全部状态初始化为无穷大，随后指定 $f[i][i] = 0,(0 \leq i \leq N)$。</p>
</li>
</ul>
<p>对于区间 DP 问题，使用记忆化搜索实现比较简单；使用递推实现则比较麻烦，但是它具有一定模板，我们在此列出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 状态表示(N*N矩阵)。</span></span><br><span class="line"><span class="keyword">int</span>[][] f;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 首先枚举步长，随后枚举起点。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j + i &lt; N; j++) &#123;</span><br><span class="line">        <span class="comment">// 获取区间左右端点。</span></span><br><span class="line">        <span class="keyword">int</span> L = j, R = j + i;</span><br><span class="line">        <span class="comment">// 枚举区间中间点，实现状态转移。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = j; k &lt; R; k++) &#123;</span><br><span class="line">            f[L][R] = transfer(f[L][k],f[k + <span class="number">1</span>][R]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>此题有一个十分重要的变体 —— 环形石子合并，即当石子环形放置时，如何合并才能使得代价最小。</p>
<p>我们可以枚举所有断点，从而将环形石子合并问题转换为 $N$ 个石子合并问题 (根据上面代码，可以知道其时间复杂度为 $O(N^3)$)，最终寻找 $N$ 个石子合并问题的最小代价即可。容易得知：这种方法的时间复杂度为 $O(N^4)$。</p>
<p>上面这种方法的时间复杂度偏高，另有一种取巧的方法可以大大降低时间复杂度：复制 $N$ 个石子并将它们按序排列在原先 $N$ 个石子序列之后，从而形成长度为 $2N$ 的石子序列 (举例：对于例题而言，形成的石子序列便是 <code>1 3 5 2 1 3 5 2</code>)。对此序列执行区间 DP 并寻找 $f[i,i + N],(0 \leq i &lt; N)$ 的最小值作为环形石子合并的最小代价即可。容易得知：此种方法的时间复杂度为 $(2N)^2 = 8N^2$。</p>
</blockquote>
<h2 id="棋盘分割"><a href="#棋盘分割" class="headerlink" title="棋盘分割"></a>棋盘分割</h2><h3 id="题目描述及示例-1"><a href="#题目描述及示例-1" class="headerlink" title="题目描述及示例"></a>题目描述及示例</h3><p>将一个 $8 \times 8$ 的棋盘进行如下分割：将原棋盘割下一块矩形棋盘并使剩下部分也是矩形，再将剩下的部分继续如此分割，这样割了 $(n-1)$ 次后，连同最后剩下的矩形棋盘共有 $n$ 块矩形棋盘 (每次切割都只能沿着棋盘格子的边进行)。</p>
<p><img src="/2020/09/18/algorithm/algorithm-dynamicprogramming7/image-20200917223418041.png"></p>
<p>原棋盘上每一格有一个分值，一块矩形棋盘的总分为其所含各格分值之和。现在需要把棋盘按上述规则分割成 $n$ 块矩形棋盘，并使各矩形棋盘总分的均方差最小 (均方差：$\sigma = \sqrt{\sum_{i = 1}^n(x_i - \overline{x})^2/n}$，其中 $x_i$ 为各棋盘分值，$\overline{x}$ 为各棋盘分值的平均值)。</p>
<p>请编程对给出的棋盘及n，求出均方差的最小值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line"><span class="comment">// 第一行包含一个整数n。</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="comment">// 接下来8行，每行8个整数，表示棋盘各位置的分值。</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line"><span class="comment">// 输出一个浮点数，表示最小均方差值。</span></span><br><span class="line"><span class="number">1.633</span></span><br></pre></td></tr></table></figure>
<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>数据存储</p>
<p>我们可以先行求取 $n \times \sigma^2$ 的最小值，随后一步转换便得到题目要求的均方差最小值。在求取 $n \times \sigma^2$ 时，我们需要动态获取棋盘分值，故而使用 <code>prefix[i][j]</code> 存储二维前缀和，随后基于此可一步求得指定棋盘分值。另外，我们需要获取各棋盘分值的平均值，此可通过  $prefix[7][7] / 8$ 求得。</p>
</li>
<li><p>状态表示</p>
<p>此题属于区间 DP 的二维扩展，另外题目涉及分割次数，故而我们直接给出状态表示 $f[x1][y1][x2][y2][k]$：将 $(x1,y1) \sim (x2,y2)$ 所示矩形区间分割 $k$ 次，所需的最小代价 (具体指代 $(x_i - \overline{x})^2$)。 </p>
</li>
<li><p>状态转移</p>
<p>根据题目而言，可以采取横向分割，也可采取纵向分割，故而状态转移方程可具体表示如下：</p>
<p>横向切割：</p>
<p>$$f[x1][y1][x2][y2][k] = min(f[x1][y1][x2][y2][k], f[x1][y1][t][y2][k - 1] + sum(x1,y1,t,y2),f[t + 1][y1][x2][y2][k - 1] + sum(t + 1,y1,x2,y2)),(x1 \leq t &lt; x2)$$</p>
<p>纵向切割：</p>
<p>$$f[x1][y1][x2][y2][k] = min(f[x1][y1][x2][y2][k],f[x1][y1][x2][t][k - 1] + sum(x1,y1,x2,k),f[x1][k + 1][x2][y2][k - 1] + sum(x1,k + 1,x2,y2)),(y1 \leq t &lt; y2)$$</p>
<blockquote>
<p><code>sum(x1,y1,x2,y2)</code> 使用二维前缀和求取矩形区间内元素之和，具体返回值为 <code>prefix[x2][y2] - prefix[x1 - 1][y2] - prefix[x2][y1 - 1] + prefix[x1 - 1][y1 - 1]</code>。</p>
</blockquote>
</li>
<li><p>状态初始化</p>
<p>这道题目没有办法使用递推，因为没有可用的初始化状态，故而应当使用记忆化搜索实现 DP。所有状态最初全部设为未知 (可使用状态值为 $-1$ 表示未知)；搜索过程中，如果无法继续分割，直接计算相关值即可。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>区间DP</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-动态规划(六)</title>
    <url>/2020/09/16/algorithm/algorithm-dynamicprogramming6/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文主要介绍状态压缩 DP，与其相关的题目有：玉米地、炮兵阵地、最短 Hamilton 路径、开宝箱。</p>
<a id="more"></a>

<p>状态压缩 DP 属于一种比较另类的动态规划，类似于暴力破解，常用于 NP 问题的小规模求解。其核心在于使用二进制表示集合状态，故而我们需要简单介绍基于二进制的集合。</p>
<p>对于 <code>int</code> 整形而言，它由 $32$ 个 $bit$ 位组成。每个 $bit$ 位存在两种取值，故而每个 $bit$ 位可以表示两种状态，这刚好可以表示集合中元素是否存在。故而我们可以基于整数表示集合中元素状态。举例而言：假定存在五个依序而放的坑位，每个坑位可以种胡萝卜，也可不种胡萝卜，如何表示其所有状态？我们使用五个 $bit$ 位表示五个坑位，如果 $bit$ 位取值为 $1$，表示此坑位种胡萝卜；否则表示此坑位不种胡萝卜。那么区间 $[0,2^5 - 1]$ 中每个整数都映射为一个集合状态，共计 $2^5$ 种状态。</p>
<p>接下来我们简单介绍一些位操作：</p>
<ul>
<li><p><code>&amp;​</code></p>
<p>当使用二进制表示集合时，它可用于求取两个集合的交集。</p>
</li>
<li><p><code>|</code></p>
<p>当使用二进制表示集合时，它可用于求取两个集合的并集。</p>
</li>
<li><p><code>~</code></p>
<p>当使用二进制表示集合时，它可用于求取一个集合的补集。</p>
</li>
<li><p><code>^</code></p>
<p>当使用二进制表示集合时，它可用于求取两个集合的对称差。</p>
</li>
<li><p><code>x | (1 &lt;&lt; (i - 1))</code></p>
<p>将数字 $x$ 的第 $i$ 位置为 $1$。</p>
</li>
<li><p><code>x &amp; (x - 1)</code></p>
<p>将数字 $x$ 的最低位 $1$ 变为 $0$。</p>
</li>
<li><p><code>x &amp; -x</code></p>
<p>将除最低位 $1$ 外的其余 $1$ 变为 $0$ (也就是树状数组中的 $lowBit$ 操作)。</p>
</li>
</ul>
<blockquote>
<p>状态压缩 DP 主要分为两种题型 —— 棋盘式、集合式。玉米地、炮兵阵地属于棋盘式题目，最短 Hamilton 路径、开宝箱属于集合式题目。棋盘式题目往往存在套路可用，而集合式题目则需随机应变 (换言之，就是难)。</p>
</blockquote>
<h2 id="玉米地"><a href="#玉米地" class="headerlink" title="玉米地"></a>玉米地</h2><h3 id="题目描述及示例"><a href="#题目描述及示例" class="headerlink" title="题目描述及示例"></a>题目描述及示例</h3><p>一块土地 $ m \times n $ 个小方格组成，现在要在土地中种植玉米。部分土地是不育的，无法种植；而且相邻的土地不能同时种植玉米，也就是种植玉米的所有方格之间都不会有公共边缘。现在给定土地的大小，请你求出有多少种种植方法。土地上什么都不种也算是一种方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数据范围：0 &lt;= n,m &lt;= 12。</span></span><br><span class="line">Input:</span><br><span class="line"><span class="comment">// 第一行包含两个整数M和N，用于表示土地长宽。</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> </span><br><span class="line"><span class="comment">// 接下来包含M行，每行包含N个整数，表示当前方格是否贫瘠(1表示土地肥沃，0表示土地贫瘠)。</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">Output:</span><br><span class="line"><span class="comment">// 输出一个整数，表示种植方法树。</span></span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>数据存储</p>
<p><code>g[i]</code> 用于存储每行方格状态，如果该方格所代表土地肥沃，则置相应位为 $0$；否则置相应位为 $1$。对于例子而言，$g[0] = 0b000 = 0,g[1] = 0b101 = 5$。<code>state[i]</code> 用于存储可用状态。</p>
</li>
<li><p>状态表示</p>
<p>对于这道题目而言，我们可以看到数据范围十分小，那么基本上可以确定它需要使用状态压缩 DP 进行解决。对于棋盘式题目，我们通常这样定义状态 $f[i][b]$：第 $i$ 行处于 $b$ 所示集合状态时，种植玉米的方案数。 </p>
</li>
<li><p>状态转移</p>
<p>进行状态转移之前，我们需要确定哪些集合状态可用。按照题目所言，横向相邻方格无法同时种植玉米，那么 $0b1001$ 这种状态是可用的，而 $0b110$ 这种状态是不可用的。我们需要从全体状态中选择所有可用状态至 <code>state[i]</code> 之中。</p>
<p>由于纵向相邻方格也无法同时种植玉米，而且当前行状态仅与上一行状态相关，故而我们应当先行循环遍历上一行状态 (记为 $a$)，随后遍历当前行状态 (记为 $b$)，如果两者不相容，则当前状态 $b$ 无效，否则使用如下状态转移方程进行更新：</p>
<p>$$f[i][b] = f[i][b] + f[i - 1][a],(a与b相容,b与g[i]相容)$$</p>
<p>这里探讨两个问题：如何判断状态 $a$ 与 $b$ 是否相容？如何判断状态 $b$ 与 $g[i]$ 是否相容？</p>
<p>首先回答第一个问题：$state[i]$ 中状态均满足“横向相邻方格无法同时种植玉米” 条件，现在需要判断满足 “纵向相邻方格也无法同时种植玉米”  这一条件。如果纵向相邻方格存在同时种植玉米，则相应位一定为 $1$，对状态 $a$、$b$ 执行与操作，其结果一定大于零。所以我们通过 <code>a &amp; b &gt; 0</code> 判断状态 $a$、$b$ 是否相容。</p>
<p>接下来回答第二个问题：正如上面给定的 $g[i]$ 定义，如果 <code>g[i] &amp; b &gt; 0</code>，则贫瘠土地中种有玉米，不符合种植要求。故而使用此式可判断状态 $b$ 与 $g[i]$ 是否相容。</p>
<blockquote>
<p>提前将可用状态放置在 $state[i]$ 之中，意在减小搜索量。</p>
</blockquote>
</li>
<li><p>状态初始化</p>
<p>为简化初始化操作，我们使用 $g[1]$ 存放第 $0$ 行状态，依次而行，使用 $g[m + 1]$ 存放第 $m$ 行状态，此时状态维度便是 $(m + 1) \times state.length$。这样我们只需初始化 $f[0][state] = 0,(0 \leq state &lt; state.length)$ 即可。</p>
</li>
</ul>
<p>棋盘式状态压缩 DP 解题代码往往具有一定程式，我们在此举一模板：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 状态表示存储(默认全部设为某值)。</span></span><br><span class="line"><span class="keyword">int</span>[][] f;</span><br><span class="line"><span class="comment">// 可用状态存储.</span></span><br><span class="line"><span class="keyword">int</span>[] state;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化相关状态。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; f[<span class="number">0</span>].length; i++) &#123;</span><br><span class="line">    f[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 状态转移（首先枚举行，随后枚举上一行状态，最后枚举当前行状态）。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; f.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">0</span>; a &lt; state.length; a++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> b = <span class="number">0</span>; b &lt; state.length; b++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (b 有效 &amp;&amp; a与b相容) &#123;</span><br><span class="line">                f[i][b] = transfer(f[i][a]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到题目答案。</span></span><br><span class="line"><span class="keyword">return</span> f[*][*];</span><br></pre></td></tr></table></figure>
<h2 id="炮兵阵地"><a href="#炮兵阵地" class="headerlink" title="炮兵阵地"></a>炮兵阵地</h2><h3 id="题目描述及示例-1"><a href="#题目描述及示例-1" class="headerlink" title="题目描述及示例"></a>题目描述及示例</h3><p>司令部的将军们打算在 $N \times M$ 的网格地图上部署他们的炮兵部队。一个 $N \times M$的地图由 $N$ 行 $M$ 列组成，地图的每一格可能是山地 (用“H” 表示)，也可能是平原 (用“P”表示)，如下图所示。在每一格平原地形上最多可以布置一支炮兵部队 (山地上不能够部署炮兵部队)；一支炮兵部队在地图上的攻击范围如图中黑色区域所示：</p>
<p><img src="/2020/09/16/algorithm/algorithm-dynamicprogramming6/1185_1.jpg"></p>
<p>如果在地图中的灰色所标识的平原上部署一支炮兵部队，则图中的黑色网格表示它能够攻击到的区域：沿横向左右各两格，沿纵向上下各两格。图上其它白色网格均攻击不到。从图上可见炮兵的攻击范围不受地形的影响。现在，将军们规划如何部署炮兵部队，在防止误伤的前提下 (保证任何两支炮兵部队之间不能互相攻击，即任何一支炮兵部队都不在其他支炮兵部队的攻击范围内)，在整个地图区域内最多能够摆放多少我军的炮兵部队?</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数据范围：0 &lt;= n &lt;= 100，0 &lt;= m &lt;= 10。</span></span><br><span class="line">Input:</span><br><span class="line"><span class="comment">// 第一行包含两个正整数，分别表示N和M。</span></span><br><span class="line"><span class="number">5</span> <span class="number">4</span></span><br><span class="line"><span class="comment">// 接下来N行，每一行含有连续的M个字符(&#x27;P&#x27;或者&#x27;H&#x27;)，表示地图具体情况。</span></span><br><span class="line">PHPP</span><br><span class="line">PPHH</span><br><span class="line">PPPP</span><br><span class="line">PHPP</span><br><span class="line">PHHP</span><br><span class="line">    </span><br><span class="line">Output:</span><br><span class="line"><span class="comment">// 输出一个整数，表示最多能摆放的炮兵部队的数量。</span></span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure>
<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>数据存储</p>
<p><code>g[i]</code> 用于存储每行方格状态，如果该方格可以放置炮兵，则置相应位为 $0$；否则置相应位为 $1$。对于例子而言，$g[0] = 0b0010 = 2,g[1] = 0b1100 = 12$。<code>state[i]</code> 用于存储可用状态，$cnt[i]$ 用于存储各可用状态中 $1$ 的个数。</p>
</li>
<li><p>状态表示</p>
<p>与上题基本一致，数据范围比较小，可以使用状态压缩 DP 加以解决。由于当前行状态与前两行状态均有关，故而我们这样表示状态 $f[i][a][b]$：第 $i$ 行处于 $b$ 所示集合状态，且第 $i - 1$ 行处于 $a$ 所示集合状态时，能够摆放的最多炮兵部队数量。</p>
</li>
<li><p>状态转移</p>
<p>我们首先确定哪些状态可用。按照题目所言，横向炮兵之间最少间隔两个方格，那么 $0b1001$ 这种状态是可用的，而 $0b0101$ 这种状态是不可用的。我们需要从全体状态中选择所有可用状态至 <code>state[i]</code> 之中，并计算相应的 $cnt[i]$。</p>
<p>由于当前状态与前两行状态均有关，并且纵向炮兵之间最少间隔两个方格，故而我们应当先行循环遍历倒数第二行状态 (记为 $c$)，随后遍历倒数第一行状态 (记为 $a$)，最后遍历当前行状态 (记为 $b$)，如果三者状态不相容，则当前状态 $b$ 无效，否则使用如下状态转移方程进行更新：</p>
<p>$$f[i][a][b] = max(f[i][a][b],f[i - 1][c][a] + cnt[i]),(a与g[i - 1]相容,b与g[i]相容，a,b,c之间相容)$$</p>
<blockquote>
<p>状态 $a$ 与 $g[i - 1]$、状态 $b$ 与 $g[i]$ 是否相容，与上题判断方法相同。我们使用 <code>a &amp; g[i - 1] &gt; 0、b &amp; g[i] &gt; 0</code> 进行判断即可。</p>
<p>状态 $a$、$b$、$c$ 之间是否相容，需要判断各状态相同位置是否同时放置炮兵，那么我们可以使用等式 <code>(a &amp; b) | (b &amp; c) | (a &amp; c) &gt; 0</code> 进行判断。</p>
</blockquote>
</li>
<li><p>状态初始化</p>
<p>为简化初始化操作，我们使用 $g[1]$ 存放第 $0$ 行状态，依次而行，使用 $g[n + 1]$ 存放第 $n$ 行状态，此时状态维度便是 $(n + 1) \times state.length$。此时我们直接将所有状态初始化为 $0$ 即可。</p>
</li>
</ul>
<h2 id="最短-Hamilton-路径"><a href="#最短-Hamilton-路径" class="headerlink" title="最短 Hamilton 路径"></a>最短 Hamilton 路径</h2><h3 id="题目描述及示例-2"><a href="#题目描述及示例-2" class="headerlink" title="题目描述及示例"></a>题目描述及示例</h3><p>给定一张 $N$ 个点的带权无向图，点从 $0 \sim N-1$ 标号，求起点 $0$ 到终点 $N-1$ 的最短Hamilton路径。 Hamilton路径的定义是从 $0$ 到 $N-1$ 不重不漏地经过每个点恰好一次。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数据范围：1 &lt;= N &lt;= 20。</span></span><br><span class="line">Input:</span><br><span class="line"><span class="comment">// 第一行输入整数N。</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="comment">// 接下来N行,每行N个整数，其中第i行第j个整数表示点i到j的距离。</span></span><br><span class="line"><span class="number">0</span> <span class="number">2</span> <span class="number">4</span> <span class="number">5</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">0</span> <span class="number">6</span> <span class="number">5</span> <span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="number">6</span> <span class="number">0</span> <span class="number">8</span> <span class="number">3</span></span><br><span class="line"><span class="number">5</span> <span class="number">5</span> <span class="number">8</span> <span class="number">0</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">3</span> <span class="number">5</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">Output:</span><br><span class="line"><span class="comment">// 输出一个整数，表示最短Hamilton路径的长度。</span></span><br><span class="line"><span class="number">18</span></span><br></pre></td></tr></table></figure>
<h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>数据存储</p>
<p><code>graph[i][j]</code> 用于存储图信息。</p>
</li>
<li><p>状态表示</p>
<p>这道题目同样是数据范围比较小，另外求取最短 Hamilton 路径属于 NP 问题，因而可以使用状态压缩 DP 进行求解。</p>
<p>题意需要获取从 $0$ 到 $N$ 的最短 Hamilton 路径，</p>
<p>此题属于集合式题目，状态表示一般没有定式。我们在此直接给出状态表示 $f[i][state]$：从起点 $0$ 开始，依次经过 $state$ 状态所示点 (如果经过该点，则置相应位为1)，最终到达 $i$ ，所需的最短路径长度。</p>
</li>
<li><p>状态转移</p>
<p>状态表示已经完成，状态转移就比较好理解：对于任意点 $k$ 而言，如果 $graph[k][i] != INF$，则我们由状态 $f[i][state - (1 &lt;&lt; (i - 1))]$ 转移到 $f[i][state]$。</p>
<p>状态转移方程具体表示如下：</p>
<p>$$f[i][state] = min(f[i][state],f[k][state - (1 &lt;&lt; (i - 1)) + graph[k][i]]),(0 \leq k &lt; graph.length \ 且 \ i \neq k)$$</p>
<blockquote>
<p><strong>注意</strong>：<code>state</code> 状态的第 $i$、$k$ 位均需为 1；考虑到状态转移所使用到的状态，我们应当先行循环 <code>state</code>，随后循环 $i$ (如果觉得别扭，可以将状态表示改为 $f[state][i]$)。</p>
</blockquote>
</li>
<li><p>状态初始化</p>
<p>题意要求求取最小值，故而首先全部初始化为无穷大，随后指定 $f[0][1] = 0$ 即可。</p>
</li>
</ul>
<h2 id="开宝箱"><a href="#开宝箱" class="headerlink" title="开宝箱"></a>开宝箱</h2><h3 id="题目描述及示例-3"><a href="#题目描述及示例-3" class="headerlink" title="题目描述及示例"></a>题目描述及示例</h3><p>我们有 $N$ 个上锁的藏宝箱，编号依次为 $1 \sim N$。现有一家商店售卖 $M$ 把钥匙，第 $i$ 把钥匙售价为 $a_i$ 元，并且它可以解锁 $b_i$ 个宝箱 (对应编号为 $c_{i1} \sim c_{ib_i}$ )。请问打开所有箱子，最少需要多少钱？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数据范围：1 &lt;= N &lt;= 12,1 &lt;= M &lt;= 1000。</span></span><br><span class="line">Input:</span><br><span class="line"><span class="comment">// 第一行包含两个整数，分别表示N和M。</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="comment">// 接下来包含M组数据，每组数据由两行组成，第一行包含两个整数，表示钥匙价格及解锁宝箱数，第二行包含一系列数，表示可以解锁的宝箱编号。</span></span><br><span class="line"><span class="number">10</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">15</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">30</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">Output:</span><br><span class="line"><span class="comment">// 输出一个整数，表示所需最少的钱。</span></span><br><span class="line"><span class="number">25</span></span><br></pre></td></tr></table></figure>
<h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>数据存储</p>
<p><code>price[i]</code> 用于存储第 $i$ 把钥匙价格，<code>g[i]</code> 用于存储第 $i$ 把钥匙所能打开的宝箱 (使用二进制进行存储)，<code>corr[i][*]</code> 用于存储能够开启第 $i$ 个宝箱的钥匙集合。</p>
</li>
<li><p>状态表示</p>
<p>$N$ 的数据范围比较小，那么可以考虑使用状态压缩 DP 进行解决。此为集合式题目，我们直接给出状态表示 $f[state]$：打开 $state$ 所示宝箱，所需的最少钱。</p>
</li>
<li><p>状态转移</p>
<p>以往状态转移都是根据已计算状态求解当前状态，这里我们采用另外一种状态转移方式：根据当前状态逐步求解未知状态。</p>
<p>为处理状态转移，我们需要遍历 $f[state]$ 并求解它。假定我们遍历到 $f[t]$ 且 $f[t]$ 已求解得到，随后我们找到第一个尚未被解开的宝箱，根据 <code>corr[i][*]</code> 执行如下状态转移：</p>
<p>$$f[t | g[key]] = min(f[t | g[key]],f[t] + price[key]),(key = corr[i][j],0 \leq j &lt; corr[i].length)$$</p>
</li>
<li><p>状态初始化</p>
<p>根据状态定义，首先全部初始化为无穷大，随后我们执行如下初始化：$f[0] = 0$。</p>
</li>
</ul>
<blockquote>
<p>对于此题而言，我们还可这样定义状态 $f[i][state]$：使用前 $i$ 把钥匙，打开 $state$ 所示宝箱，所需的最少钱。</p>
<p>那此时状态转移就略微麻烦：如果不使用当前钥匙，则 $f[i][state] = min(f[[i][state],f[i - 1][state]])$；如果使用当前钥匙，则 $f[i][state | key[i]] = min(f[i][state | key[i]], f[i][state] + price[i])$。</p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>状态压缩DP</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-动态规划(五)</title>
    <url>/2020/09/15/algorithm/algorithm-dynamicprogramming5/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文主要介绍状态机 DP，与其相关的题目有：大盗阿福、小 Q 假期、买卖股票的最佳时机 IV、最佳买卖股票时机含冷冻期。</p>
<a id="more"></a>

<p>对于一些动态规划题目而言，它们在某个时刻的状态仅涉及一个抉择 (例如：<a href="/2020/09/14/algorithm/algorithm-dynamicprogramming3/" title="最长上升子序列">最长上升子序列</a>，直接选择当前数字)；而对于另外一些动态规划题目而言，它们在某个时刻的状态可能涉及多个抉择 (例如：<a href="/2020/09/14/algorithm/algorithm-dynamicprogramming4/" title="01 背包">01 背包</a>，某个时刻可选择当前物品或者不选择当前物品；小 Q 假期，一天之内存在休息、工作、健身三种选择)，此时就需要使用状态机 DP 进行处理，它可以很好地展现状态间转移情况，同时易于理解。</p>
<p>状态机 DP 借助于有限状态自动机构建状态，并据此进行状态转移，从而实现动态规划。</p>
<p><img src="/2020/09/15/algorithm/algorithm-dynamicprogramming5/440px-DFAexample.svg.png" alt="图一：有限状态自动机机"></p>
<blockquote>
<p>如果所涉抉择数目为 2，可以选择使用普通 DP 进行处理，也可以选择使用状态机 DP 进行处理。</p>
</blockquote>
<h2 id="大盗阿福"><a href="#大盗阿福" class="headerlink" title="大盗阿福"></a>大盗阿福</h2><h3 id="题目描述及示例"><a href="#题目描述及示例" class="headerlink" title="题目描述及示例"></a>题目描述及示例</h3><p>阿福是一名经验丰富的大盗。趁着月黑风高，阿福打算今晚洗劫一条街上的店铺。这条街上一共有 $N$ 家店铺，每家店中都有一些现金。阿福事先调查得知，只有当他同时洗劫了两家相邻的店铺时，街上的报警系统才会启动，然后警察就会蜂拥而至。作为一向谨慎作案的大盗，阿福不愿意冒着被警察追捕的风险行窃。他想知道，在不惊动警察的情况下，他今晚最多可以得到多少现金？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line"><span class="comment">// 第一行包含整数N，表示一共有N家店铺。</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="comment">// 第二行包含N个整数，表示每一家店铺中的现金数量。</span></span><br><span class="line"><span class="number">10</span> <span class="number">7</span> <span class="number">6</span> <span class="number">14</span></span><br><span class="line">    </span><br><span class="line">Output:</span><br><span class="line"><span class="comment">// 输出一个整数，表示阿福在不惊动警察的情况下可以得到的最多现金数量。</span></span><br><span class="line"><span class="number">24</span></span><br></pre></td></tr></table></figure>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>我们先使用普通 DP 解决此问题。</p>
<ul>
<li><p>数据存储</p>
<p><code>money[i]</code> 用于存储各店铺现金数量。</p>
</li>
<li><p>状态表示</p>
<p>既然数据是一维的，状态表示大概率也是一维的。我们可以这样定义状态 $f[i]$：在不惊动警察情况下，从前 $i$ 家店铺抢劫，所能得到的最下现金数量。</p>
</li>
<li><p>状态转移</p>
<p>这道题目的难点在于：如何保证不会同时洗劫两家相邻的店铺？对于状态 $f[i]$ 而言，如果选择洗劫当前店铺，则其只能从状态 $f[i - 2]$ 转移得到；否则从状态 $f[i - 1]$ 转移得到。故而状态转移方程可表示如下：</p>
<p>$$f[i] = max(f[i - 1], f[i - 2] + money[i]),(2 \leq i &lt; money.length)$$</p>
</li>
<li><p>状态初始化</p>
<p>根据状态表示，我们可以这样初始化：指定 $f[0] = 0$。</p>
</li>
</ul>
<p>接下来我们使用状态机 DP 解决此问题。</p>
<ul>
<li><p>数据存储</p>
<p><code>money[i]</code> 用于存储各店铺现金数量。</p>
</li>
<li><p>状态表示</p>
<p>对于店铺而言，它具有两种选择：被阿福抢劫和不被阿福抢劫。故而我们可以这样定义状态 $f[i][0]$：在不惊动警察情况下，抢劫以往店铺并且不抢劫当前店铺，所能得到的最下现金数量，和 $f[i][1]$：在不惊动警察情况下，抢劫以往店铺并且抢劫当前店铺，所能得到的最下现金数量。</p>
</li>
<li><p>状态转移</p>
<p>根据上述状态表示及 “无法同时抢劫相邻两家店铺” 要求，我们可以得到如下状态转移图：</p>
<p><img src="/2020/09/15/algorithm/algorithm-dynamicprogramming5/image-20200915112352564.png"></p>
<p>故而状态转移方程可表示如下：</p>
<p>$$f[i][0] = max(f[i - 1][0], f[i - 1][1])$$</p>
<p>$$f[i][1] = f[i - 1][0] + money[i]$$</p>
</li>
<li><p>状态初始化</p>
<p>根据状态表示，我们可以这样初始化：指定 $f[0][0] = 0,f[0][1] = money[0]$。</p>
</li>
</ul>
<h2 id="小-Q-假期"><a href="#小-Q-假期" class="headerlink" title="小 Q 假期"></a>小 Q 假期</h2><h3 id="题目描述及示例-1"><a href="#题目描述及示例-1" class="headerlink" title="题目描述及示例"></a>题目描述及示例</h3><p>由于业绩优秀，公司给小 Q 放了 $N$ 天的假，身为工作狂的小 Q 打算在假期中工作、锻炼或者休息。他有个奇怪的习惯：不会连续两天工作或锻炼。只有当公司营业时，小 Q 才能去工作，只有当健身房营业时，小 Q 才能去健身，小 Q 一天只能干一件事。现给出假期中公司，健身房的营业情况，求小 Q 最少需要休息几天？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line"><span class="comment">// 第一行包含一个整数N，表示放假天数。</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="comment">// 第二行包含N个数，第i个数表示公司在第i天是否营业（1为营业 0为不营业）。</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="comment">// 第三行包含N个数，第i个数表示健身房在第i天是否营业（1为营业 0为不营业）。</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">Output：</span><br><span class="line"><span class="comment">// 输出一个整数，表示小Q休息的最少天数。</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>数据存储</p>
<p><code>company[i]</code> 用于存储公司营业信息，<code>gym[i]</code> 用于存储健身房营业信息。</p>
</li>
<li><p>状态表示</p>
<p>对于任意一天，小 Q 具有三种选择 —— 休息、健身、工作。故而我们可以这样定义状态 $f[i][0]$：当天选择休息时，累计的最小休息天数，$f[i][1]$：当天选择健身时，累计的最小休息天数，$f[i][2]$：当天选择工作时，累计的最小休息天数。</p>
</li>
<li><p>状态转移</p>
<p>根据上述状态表示及 “不会连续两天工作或锻炼” 要求，我们可以得到如下状态转移图：</p>
<p><img src="/2020/09/15/algorithm/algorithm-dynamicprogramming5/image-20200915171213037.png"></p>
<p>故而状态转移方程可表示如下：</p>
<p>$$f[i][0] = min(f[i - 1][0],f[i - 1][1],f[i - 1][2]) + 1$$</p>
<p>$$f[i][1] = min(f[i - 1][0],f[i - 1][2])$$</p>
<p>$$f[i][2] = min(f[i - 1][0],f[i - 1][1])$$</p>
<blockquote>
<p>只有当天允许健身或工作，才会有状态 $f[i][1]$、$f[i][2]$ 的转移，否则该状态非法。</p>
</blockquote>
</li>
<li><p>状态初始化</p>
<p>因为存储非法状态且需要求取最小值，故而我们首先将所有状态初始化为无穷大，随后指定合法初始状态：$f[0][0] = 1,f[0][1] = 0(if \ gym[i] = 1),f[0][2] = 0(if \ company[i]=1)$。</p>
</li>
</ul>
<h2 id="买卖股票的最佳时机-IV"><a href="#买卖股票的最佳时机-IV" class="headerlink" title="买卖股票的最佳时机 IV"></a>买卖股票的最佳时机 IV</h2><h3 id="题目描述及示例-2"><a href="#题目描述及示例-2" class="headerlink" title="题目描述及示例"></a>题目描述及示例</h3><p>给定一个数组，它的第 $i$ 个元素是一支给定的股票在第 $i$ 天的价格。设计一个算法来计算你所能获取的最大利润。你最多可以完成 $K$ 笔交易。注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line"><span class="comment">// 第一行包含整数N和K，表示数组长度以及可以完成的最大交易数量。</span></span><br><span class="line"><span class="number">6</span> <span class="number">2</span></span><br><span class="line"><span class="comment">// 第二行包含N个正整数，表示完整的数组。</span></span><br><span class="line"><span class="number">3</span> <span class="number">2</span> <span class="number">6</span> <span class="number">5</span> <span class="number">0</span> <span class="number">3</span></span><br><span class="line">    </span><br><span class="line">Output:</span><br><span class="line"><span class="comment">// 输出一个整数，表示最大利润。</span></span><br><span class="line"><span class="number">7</span></span><br></pre></td></tr></table></figure>
<h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>数据存储</p>
<p><code>price[i]</code> 用于存储股票价格。</p>
</li>
<li><p>状态表示</p>
<p>对于任意一天，”我” 具有两种状态：手中有股票和手中无股票。那么我们可以这样定义状态 $f[i][0]$：第 $i$ 天手中没有股票，所能获取的最大利益，和 $f[i][1]$：第 $i$ 天手中有股票，所能获取的最大利益。</p>
<p>另外，对于本题目而言，它考虑交易次数，故而我们这样定义状态 $f[i][0][k]$：第 $i$ 天手中没有股票，且处于第 $k$ 次交易已经完成时，所能获取的最大利益；和 $f[i][1][k]$：第 $i$ 天手中有股票，且正处于第 $k$ 次交易时，所能获取的最大利益。</p>
<blockquote>
<p>买入股票即看作一次交易的开始。</p>
</blockquote>
</li>
<li><p>状态转移</p>
<p>根据上述状态表示，我们可以得到如下状态转移图：</p>
<p><img src="/2020/09/15/algorithm/algorithm-dynamicprogramming5/image-20200915183417515.png"></p>
<p>故而状态转移方程可表示如下：</p>
<p>$$f[i][0][k] = max(f[i - 1][0][k],f[i - 1][1][k] + price[i])$$</p>
<p>$$f[i][1][k] = max(f[i - 1][1][k],f[i - 1][0][k - 1] - price[i])$$</p>
</li>
<li><p>状态初始化</p>
<p>为求取状态最大值，首先将所有状态初始化为无穷小。由于状态表示为第 $i$ 天，故而需要这样初始化：指定 $f[0][0][k] = 0(0 \leq k \leq K),f[0][1][1] = -price[0]$。</p>
</li>
</ul>
<h2 id="最佳买卖股票时机含冷冻期"><a href="#最佳买卖股票时机含冷冻期" class="headerlink" title="最佳买卖股票时机含冷冻期"></a>最佳买卖股票时机含冷冻期</h2><h3 id="题目描述及示例-3"><a href="#题目描述及示例-3" class="headerlink" title="题目描述及示例"></a>题目描述及示例</h3><p>给定一个长度为 $N$ 的数组，数组中的第 $i$ 个数字表示一个给定股票在第 $i$ 天的价格。设计一个算法计算出最大利润，在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）。你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。卖出股票后，你无法在第二天买入股票 (即冷冻期为 $1$ 天)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line"><span class="comment">// 第一行包含整数N，表示数组长度。</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="comment">// 第二行包含N个正整数，表示完整的数组。</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">0</span> <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">Output:</span><br><span class="line"><span class="comment">// 输出一个整数，表示最大利润。</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>数据存储</p>
<p><code>price[i]</code> 用于存储股票价格。</p>
</li>
<li><p>状态表示</p>
<p>相比上一道题目，”我” 具有三种状态：手中有股票、手中无股票的第一天、手中无股票的第 $i \geq 2$ 天。 那么我们可以这样定义状态 $f[i][0]$：第 $i$ 天且手中有股票，所能获取的最大利益，$f[i][1]$：第 $i$ 天且手中无股票的第一天，所能获取的最大利益，$f[i][2]$：第 $i$ 天且手中无股票的第 $i \geq 2$ 天，所能获取的最大利益。</p>
</li>
<li><p>状态转移</p>
<p>根据上述状态表示及 “冷冻期” 要求，我们可以得到如下状态转移图：</p>
<p><img src="/2020/09/15/algorithm/algorithm-dynamicprogramming5/image-20200915190433395.png"></p>
<p>故而状态转移方程可表示如下：</p>
<p>$$f[i][0] = max(f[i - 1][0],f[i - 1][2] - price[i])$$</p>
<p>$$f[i][1] = f[i - 1][0] + price[i]$$</p>
<p>$$f[i][2] = max(f[i - 1][2],f[i - 1][1])$$</p>
</li>
<li><p>状态初始化</p>
<p>为求取状态最大值，首先将所有状态初始化为无穷小。由于状态表示为第 $i$ 天，故而需要这样初始化：指定 $f[0][0] = -price[i],f[0][2] = 0$。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>状态机DP</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-动态规划(四)</title>
    <url>/2020/09/14/algorithm/algorithm-dynamicprogramming4/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文主要介绍背包 DP，与其相关的题目有：01 背包、完全背包、多重背包、混合背包、二维费用的背包、分组背包、有依赖的背包。</p>
<a id="more"></a>

<h2 id="01-背包"><a href="#01-背包" class="headerlink" title="01 背包"></a>01 背包</h2><h3 id="题目描述及示例"><a href="#题目描述及示例" class="headerlink" title="题目描述及示例"></a>题目描述及示例</h3><p>有 $N$ 件物品和一个容量是 $V$ 的背包。每件物品只能使用一次。第 $i$ 件物品的体积是 $v_i$，价值是 $w_i$。求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大?</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line"><span class="comment">// 第一行包含两个整数，分别表示物品数量和背包容积。</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="comment">// 接下来N行，每行两个整数vi,wi，分别表示第i件物品的体积和价值。</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span></span><br><span class="line">    </span><br><span class="line">Output:</span><br><span class="line"><span class="comment">// 输出一个整数，表示最大价值。</span></span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>数据存储</p>
<p><code>v[i]</code> 用于存储各物品体积，<code>w[i]</code> 用于存储各物品价值。</p>
</li>
<li><p>状态表示</p>
<p>对于背包问题而言，状态表示往往都是二维的。我们可以这样表示状态 $f[i][j]$：从前 $i$ 个物品中选择，并将它们装入容量为 $j$ 的背包中，所能得到的最大价值。</p>
</li>
<li><p>状态转移</p>
<p>对于状态 $f[i][j]$ 而言，如果它选择当前物品 $i$，则其应当由状态 $f[i - 1][j - v[i]]$ 转移得到；否则应当由状态 $f[i - 1][j]$ 转移得到。故而状态转移方程可表示如下：</p>
<p>$$f[i][j] = max(f[i - 1][j], f[i - 1][j - v[i]] + w[i]),(j \geq v[i])$$</p>
<blockquote>
<p>观察状态转移方程，可以发现：状态 $f[i][\ast]$ 的转移仅涉及 $f[i - 1][\ast]$。故而实现之中，我们可以使用滚动数组以优化空间。更进一步，我们发现：状态 $f[i][j]$ 仅从状态 $f[i - 1][k],(k &lt; j)$ 转移得到，故而我们可从后往前更新一维数组以达到滚动数组的效果 (<strong>此时状态表示优化为 $f[j]$，表示将物品装入容量为 $j$ 的背包中所能得到的最大价值</strong>)。</p>
</blockquote>
</li>
<li><p>状态初始化</p>
<p>根据状态表示，我们可这样初始化：指定 $f[0][j] = 0,(0 \leq j \leq  V)$。</p>
</li>
</ul>
<h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><h3 id="题目描述及示例-1"><a href="#题目描述及示例-1" class="headerlink" title="题目描述及示例"></a>题目描述及示例</h3><p>有 $N$ 种物品和一个容量是 $V$ 的背包，每种物品都有无限件可用。第 $i$ 种物品的体积是 $v_i$，价值是 $w_i$。求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大?</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line"><span class="comment">// 第一行包含两个整数，分别表示物品数量和背包容积。</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="comment">// 接下来N行，每行两个整数vi,wi，分别表示第i件物品的体积和价值。</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span></span><br><span class="line">    </span><br><span class="line">Output:</span><br><span class="line"><span class="comment">// 输出一个整数，表示最大价值。</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>
<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>数据存储</p>
<p><code>v[i]</code> 用于存储各物品体积，<code>w[i]</code> 用于存储各物品价值。</p>
</li>
<li><p>状态表示</p>
<p>与 <em>01 背包</em> 状态表示相同，我们可以这样表示状态 $f[i][j]$：从前 $i$ 个物品中选择，并将它们转入容量为 $j$ 的背包中，所能得到的最大价值。</p>
</li>
<li><p>状态转移</p>
<p>由于物品可无限次选用，故而对于状态 $f[i][j]$ 而言，如果它不选择当前物品 $i$，则应当由状态 $f[i - 1][j]$ 转移得到；如果它选择一个当前物品 $i$，则应当由状态 $f[i - 1][j - v[i]]$ 转移得到；如果它选择 $k$ 个当前物品 $i$，则应当由状态 $f[i - 1][j - k \times v[i]]$ 转移得到。</p>
<p>状态转移方程具体表示如下：</p>
<p>$$f[i][j] = max(f[i - 1][j],f[i - 1][j - v[i]] + w[i],\dots,f[i - 1][j - k \times v[i]] + k \times w[i]),(j \geq k*w[i])$$</p>
<blockquote>
<p>对于状态 $f[i][j - v[i]]$ 而言，其状态转移方程具体为：</p>
<p>$$f[i][j - v[i]] = max(f[i - 1][j - v[i]],f[i - 1][j - 2 \times v[i]] + w[i],\dots,f[i - 1][j - k \times v[i]] + k \times w[i])$$</p>
<p>将状态 $f[i][j - v[i]]$ 代入 $f[i][j]$ 的状态转移方程中，我们可以得到：</p>
<p>$$f[i][j] = max(f[i - 1][j], f[i][j - v[i]] + w[i])$$</p>
<p>该式与 <em>01 背包</em> 的状态转移方程十分相似，故而可使用相似的空间优化方法 —— 从后往前更新一维数组以更新相关状态。对于完全背包而言，其状态转移方程涉及 $f[i][j - v[i]]$，而非 $f[i - 1][j - v[i]]$，故而其应当从前往后更新一维数组。</p>
</blockquote>
</li>
<li><p>状态初始化</p>
<p>与 <em>01 背包</em> 状态初始化相同，我们这样初始化：指定 $f[0][j] = 0,(0 \leq j \leq  V)$。</p>
</li>
</ul>
<h2 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h2><h3 id="题目描述及示例-2"><a href="#题目描述及示例-2" class="headerlink" title="题目描述及示例"></a>题目描述及示例</h3><p>有 $N$ 件物品和一个容量是 $V$ 的背包。第 $i$ 种物品最多有 $s_i$ 件，每件体积是 $v_i$，价值是 $w_i$。求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大?</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line"><span class="comment">// 第一行包含两个整数，分别表示物品数量和背包容积。</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="comment">// 接下来N行，每行三个整数 vi,wi,si分别表示第i种物品的体积、价值和数量。</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">Output:</span><br><span class="line"><span class="comment">// 输出一个整数，表示最大价值。</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>
<h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>数据存储</p>
<p><code>v[i]</code> 用于存储各物品体积，<code>w[i]</code> 用于存储各物品价值，<code>s[i]</code> 用于存储各物品个数。</p>
</li>
<li><p>状态表示</p>
<p>与 <em>01 背包</em> 状态表示相同，我们可以这样表示状态 $f[i][j]$：从前 $i$ 个物品中选择，并将它们转入容量为 $j$ 的背包中，所能得到的最大价值。</p>
</li>
<li><p>状态转移</p>
<p>该题与 <em>01 背包</em>  和 <em>完全背包</em> 类似，仅是物品可有限次选用，类比于 <em>完全背包</em> 的状态转移方程，其状态转移方程可表示如下：</p>
<p>$$f[i][j] = max(f[i - 1][j],f[i - 1][j - v[i]] + w[i],\dots,f[i - 1][j - k \times v[i]] + k \times w[i]),(j \geq k*w[i] \  且 \ s[i] \geq k)$$</p>
<blockquote>
<p>该状态转移方程所具特性与 <em>01 背包</em> 的状态转移方程所具特性基本一致，故而其可使用相同的空间优化方法 —— 从后往前更新一维数组以更新相关状态。由于其中涉及众多状态取最大值，故而需要使用一个循环完成。</p>
</blockquote>
</li>
<li><p>状态初始化</p>
<p>与 <em>01 背包</em> 状态初始化相同，我们这样初始化：指定 $f[0][j] = 0,(0 \leq j \leq  V)$。</p>
</li>
</ul>
<p>上面这种属于最基本的解题思路，我们可以发现其时间复杂度为 $O(N \times S \times V)$ ($S$ 表示物品的平均个数)。</p>
<p>接下来我们从另一角度看待多重背包：如果一个物品存在 $m$ 件，我们便将其分解为 $m$ 个数量均为 $1$的不同物品，此时每个物品仅有选与不选两种选择，故而多重背包就转换为 01 背包。</p>
<p>现在我们思考一个问题：将 $m$ 拆分为 $m$ 个 $1$，可以表达 “选择区间 $[0,m]$ 内任意数”，那么有没有更简便地方法以达到此目的？</p>
<p>这种更为简便地方式就是：二进制。例如：我们希望选择区间 $[0,15]$ 内任意数，我们只需要 $(2^0 = 1,2^1 = 2, 2^2 = 4,2^3 = 8)$ 四个数即可；如果我们希望选择区间 $[0,12]$ 内任意数，我们只需要 $(2^0 = 1,2^1 = 2, 2^2 = 4,12-4-2-1=5)$ 四个数即可。</p>
<p>基于二进制，我们重新看待多重背包：如果一个物品存在 $m$ 件，我们便基于二进制将其分解为 $\lceil log_2^m \rceil$ 个具有不同数量的物品，此时每个物品同样仅具有选与不选两种选择，故而多重背包就转换为 01 背包。可以发现：该种解法的时间复杂度降低为 $O(N \times \lceil log_2^{S} \rceil \times V)$ 。</p>
<p>对于多重背包而言，另有一种基于单调队列的优化方案，它可将时间复杂度降低为 $O(N \times V)$。这种方法比较复杂，我们在此简单介绍。</p>
<p>经空间优化后，多重背包的状态表示为 $f[j]$，并且每次循环中，根据当前物品 $i$ 更新状态 $f[j]$ 。根据状态更新流程，我们可将状态分为如下几类：</p>
<p>$$f[0 + k \times v[i]],f[1 + k \times v[i]],\dots,f[m + k \times v[i]](m = v[i] - 1,k \times v[i] \leq V)$$</p>
<p>对于任意一类状态 $f[t + k \times v[i]](0 \leq t &lt; v[i],k \times v[i] \leq V)$，我们构建 $(f[t + k \times v[i]] - k \times w[i],k)$ 键值对 (该式可理解为所有状态在同等基准下的增益)，并排序它们。对于任意 $f[j]$ 而言，如果容量、物品数量条件满足，则从具有最大增益的状态转移将会使得更新后的 $f[j]$ 最大，此时具有最大增益的状态就是 $f[j]$ 转移所需的最佳状态。借助于排序，可使得一步找到状态转移所需的最佳状态，如此便可降低时间复杂度。</p>
<blockquote>
<p>具体实现中，我们并不需要使用排序，只需使用单调队列即可。</p>
</blockquote>
<h2 id="混合背包"><a href="#混合背包" class="headerlink" title="混合背包"></a>混合背包</h2><h3 id="题目描述及示例-3"><a href="#题目描述及示例-3" class="headerlink" title="题目描述及示例"></a>题目描述及示例</h3><p>有 $N$ 种物品和一个容量是 $V$ 的背包，物品一共有三类：</p>
<ul>
<li>第一类物品只能用 $1$ 次 (01背包)；</li>
<li>第二类物品可以用无限次 (完全背包)；</li>
<li>第三类物品最多只能用 $s_i$ 次 (多重背包)；</li>
</ul>
<p>每种体积是 $v_i$，价值是 $w_i$。求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大?</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line"><span class="comment">// 第一行包含两个整数，分别表示物品数量和背包容积。</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="comment">// 接下来N行，每行三个整数vi,wi,si，分别表示第i种物品的体积、价值和数量。</span></span><br><span class="line"><span class="comment">// 数量为-1，表示可使用无限次。</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> -<span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">0</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">Output:</span><br><span class="line"><span class="comment">// 输出一个整数，表示最大价值。</span></span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure>
<h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><p>这道题目属于上面三道题目的综合。首先我们可以基于二进制将多重背包转换为 01 背包；对于 01 背包和多重背包而言，二者区别仅在于从后往前更新一维数组还是从前往后更新一维数组，此时根据物品只能使用 $1$ 次还是无限次，动态选择循环方向即可。</p>
<h2 id="二维费用的背包"><a href="#二维费用的背包" class="headerlink" title="二维费用的背包"></a>二维费用的背包</h2><h3 id="题目描述及示例-4"><a href="#题目描述及示例-4" class="headerlink" title="题目描述及示例"></a>题目描述及示例</h3><p>有 $N$ 种物品和一个容量是 $V$ 的背包，背包能承受的最大重量是 $M$。每件物品只能用一次，体积是 $v_i$，重量是 $m_i$，价值是 $w_i$。求解将哪些物品装入背包，可使物品总体积不超过背包容量，总重量不超过背包可承受的最大重量，且价值总和最大?</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line"><span class="comment">// 第一行包含三个整数，分别表示物品数量、背包容积和背包所能承受的最大重量。</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line"><span class="comment">// 接下来N行，每行三个整数vi,mi,wi，分别表示第i种物品的体积、重量和价值。</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line">    </span><br><span class="line">Output:</span><br><span class="line"><span class="comment">// 输出一个整数，表示最大价值。</span></span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure>
<h3 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>数据存储</p>
<p><code>v[i]</code> 用于存储各物品体积，<code>m[i]</code> 用于存储各物品重量，<code>w[i]</code> 用于存储各物品价值。</p>
</li>
<li><p>状态表示</p>
<p>这道题目纯属 <em>01 背包</em> 的二维扩展，故而我们可以这样表示状态 $f[i][j][k]$：从前 $i$ 个物品中选择，并将它们装入容量为 $j$ 、所能承受的最大重量为 $k$ 的背包中，所能得到的最大价值。</p>
</li>
<li><p>状态转移</p>
<p>已有 <em>01 背包</em> 相关知识，该题目的状态转移方程可表示如下：</p>
<p>$$f[i][j][k] = max(f[i - 1][j][k], f[i - 1][j - v[i]][k - m[i]] + w[i]),(j \geq v[i] \ 且 \ k \geq m[i])$$</p>
<blockquote>
<p>类比于 <em>01 背包</em> ，我们可使用二维数组 $f[j][k]$ 优化空间。</p>
</blockquote>
</li>
<li><p>状态初始化</p>
<p>根据状态表示，我们可这样初始化：指定 $f[0][j][k] = 0,(0 \leq j \leq  V \ 且 \ 0 \leq k \leq M)$。</p>
</li>
</ul>
<h2 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a>分组背包</h2><h3 id="题目描述及示例-5"><a href="#题目描述及示例-5" class="headerlink" title="题目描述及示例"></a>题目描述及示例</h3><p>有 $N$ 组物品和一个容量是 $V$ 的背包，每组物品有若干个，同一组内的物品最多只能选一个。每件物品的体积是 $v_{ij}$，价值是 $w_{ij}$，其中 $i$ 是组号，$j$ 是组内编号。求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大?</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line"><span class="comment">// 第一行包含两个整数，分别表示物品数量和背包容积。</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="comment">// 接下来有N组数据：每组数据第一行有一个整数Si，表示第i个物品组的物品数量；</span></span><br><span class="line"><span class="comment">// 每组数据接下来有Si行，每行有两个整数vij,wij，分别表示第i个物品组的第j个物品的体积和价值；</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span></span><br><span class="line">    </span><br><span class="line">Output:</span><br><span class="line"><span class="comment">// 输出一个整数，表示最大价值。</span></span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure>
<h3 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>数据存储</p>
<p><code>id[i]</code> 用于存储各物品组号、<code>v[i]</code> 用于存储各物品体积，<code>w[i]</code> 用于存储各物品价值。</p>
</li>
<li><p>状态表示</p>
<p>与 <em>01 背包</em> 状态表示类似，我们可以这样表示状态 $f[i][j]$：从前 $i$ 个物品组中选择，并将它们转入容量为 $j$ 的背包中，所能得到的最大价值。</p>
</li>
<li><p>状态转移</p>
<p>对于状态 $f[i][j]$ 而言，如果它不选择当前物品组 $i$，则其应当由状态 $f[i - 1][j]$ 转移得到；否则就会选择当前物品组，由于一个物品组中只能选择一个物品，故而其应当由状态 $f[i - 1][j - v[k]],(id[k] = i)$ 转移得到。</p>
<p>$$f[i][j] = max(f[i - 1][j], f[i - 1][j - v[k]] + w[k]),(0 \leq k &lt; id.length \ 且 \ id[k] = i)$$</p>
<blockquote>
<p>与 <em>01 背包</em> 类似，其可使用相同的空间优化方法 —— 从后往前更新一维数组以更新相关状态。</p>
</blockquote>
</li>
<li><p>状态初始化</p>
<p>与 <em>01 背包</em> 状态初始化类似，我们这样初始化：指定 $f[0][j] = 0,(0 \leq j \leq  V)$。</p>
</li>
</ul>
<h2 id="有依赖的背包"><a href="#有依赖的背包" class="headerlink" title="有依赖的背包"></a>有依赖的背包</h2><h3 id="题目描述及示例-6"><a href="#题目描述及示例-6" class="headerlink" title="题目描述及示例"></a>题目描述及示例</h3><p>有 $N$ 个物品和一个容量是 $V$ 的背包，物品之间具有依赖关系，且依赖关系组成一棵树的形状。如果选择一个物品，则必须选择它的父节点。如下图所示：</p>
<p><img src="/2020/09/14/algorithm/algorithm-dynamicprogramming4/1_bb51ecbcd2-QQ%E5%9B%BE%E7%89%8720181018170337.png"></p>
<p>如果选择物品 5，则必须选择物品 1 和 2。这是因为 2 是 5 的父节点，1 是 2 的父节点。</p>
<p>每件物品的编号是 $i$，体积是 $v_i$，价值是 $w_i$，依赖的父节点编号是 $p_i$。物品的下标范围是 $1…N$。求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大?</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line"><span class="comment">// 第一行包含两个整数，分别表示物品数量和背包容积。</span></span><br><span class="line"><span class="number">5</span> <span class="number">7</span></span><br><span class="line"><span class="comment">// 接下来有N行数据，每行数据有三个整数vi,wi,pi，分别表示物品的体积、价值和依赖的物品编号。</span></span><br><span class="line"><span class="comment">// 如果依赖的物品编号为-1，表明该物品为根节点，数据保证所有物品构成一棵树。</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> -<span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">5</span> <span class="number">1</span></span><br><span class="line"><span class="number">4</span> <span class="number">7</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">6</span> <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">Output:</span><br><span class="line"><span class="comment">// 输出一个整数，表示最大价值。</span></span><br><span class="line"><span class="number">11</span></span><br></pre></td></tr></table></figure>
<h3 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>数据存储</p>
<p><code>v[i]</code> 用于存储各物品体积，<code>w[i]</code> 用于存储各物品价值，<code>graph[i][j]</code> 用于存储节点间依赖关系，表示物品 $j$ 依赖于物品 $i$。</p>
</li>
<li><p>状态表示</p>
<p>这道题目属于背包 DP 与树形 DP 的结合，比较困难。我们直接定义状态 $f[u][j]$：从物品 $u$ 所在子树中选择物品，并将它们转入容量为 $j$ 的背包中，所能得到的最大价值。</p>
</li>
<li><p>状态转移</p>
<p>对于状态 $f[u][j]$ 而言，如果不选择当前物品，则各子物品都无法选择，可直接置 $f[u][j] = 0$；否则就需要根据子物品及容量动态转移得到。</p>
<p>如果选择当前物品，则其状态转移方程为：</p>
<p>$$f[u][j] = max(f[son][t] + f[u][j - t - v[i]] + w[i]),(son = graph[u][k],0 \leq k &lt; graph[u].length, 0 \leq t \leq j - v[i])$$</p>
<p>如果不选择当前物品，则其状态转移方程为：</p>
<p>$$f[u][j] = 0,(0 \leq j \leq V)$$</p>
<blockquote>
<p>如果我们将当前物品的子物品所在子树看做一个个物品组，将具有不同容量的 $f[son][k]$ 看做一个个物品，那么一个物品组中只能选择一个物品，故而这是一个分组背包问题。按照分组背包解法可以求解得到 $f[u][j],(0 \leq j \leq V)$。</p>
</blockquote>
</li>
<li><p>状态初始化</p>
<p>此题的状态初始化比较简单，默认不选择所有物品，故而直接指定 $f[u][j] = 0,(0 \leq j \leq V)$。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>背包DP</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-动态规划(三)</title>
    <url>/2020/09/14/algorithm/algorithm-dynamicprogramming3/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文主要介绍线性 DP 中的最长上升子序列模型，与该模型相关的题目有：最长上升子序列、登山、友好城市、最大上升子序列和。</p>
<a id="more"></a>

<h2 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a>最长上升子序列</h2><h3 id="题目描述及示例"><a href="#题目描述及示例" class="headerlink" title="题目描述及示例"></a>题目描述及示例</h3><p>给定一个长度为 $N$ 的数列，求数值严格单调递增的子序列长度最长是多少?</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line"><span class="comment">// 第一行包含整数N。</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="comment">// 第二行包含N个整数，表示完整序列。</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">2</span> <span class="number">1</span> <span class="number">8</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line">    </span><br><span class="line">Output:</span><br><span class="line"><span class="comment">// 输出一个整数，表示最大长度。</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>数据存储</p>
<p><code>nums[i]</code> 用于存储完整序列。</p>
</li>
<li><p>状态表示</p>
<p>既然数据是一维的，状态表示大概率也是一维的。我们可以这样定义 $f[i]$：以 $nums[i]$ 为结尾、数值严格单调递增的所有子序列中最长的序列长度。</p>
</li>
<li><p>状态转移</p>
<p>子序列要求数值严格单调递增，故而 $f[i]$ 可由那些位于 $num[i]$ 前方、数值小于 $num[i]$ 的 $f[k]$ 转移得到，故而状态转移方程可表示如下：</p>
<p>$$f[i] = max(f[k] + 1,f[i]),(0\leq k &lt; i \  且 \ nums[k] &lt; nums[i])$$</p>
</li>
<li><p>状态初始化</p>
<p>对于此题目而言，状态初始化比较复杂，需要指定 $f[i] = 1,(0 \leq i &lt; nums.length)$ 。</p>
</li>
</ul>
<h2 id="登山"><a href="#登山" class="headerlink" title="登山"></a>登山</h2><h3 id="题目描述及示例-1"><a href="#题目描述及示例-1" class="headerlink" title="题目描述及示例"></a>题目描述及示例</h3><p>五一到了，ACM 队组织大家去登山观光，队员们发现山上一个有 $N$ 个景点，并且决定按照顺序来浏览这些景点，即每次所浏览景点的编号都要大于前一个浏览景点的编号。同时队员们还有另一个登山习惯，就是不连续浏览海拔相同的两个景点，并且一旦开始下山，就不再向上走了。队员们希望在满足上面条件的同时，尽可能多的浏览景点，你能帮他们找出最多可能浏览的景点数么？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line"><span class="comment">// 第一行包含整数N，表示景点数量。</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="comment">// 第二行包含N个整数，表示每个景点的海拔。</span></span><br><span class="line"><span class="number">186</span> <span class="number">186</span> <span class="number">150</span> <span class="number">200</span> <span class="number">160</span> <span class="number">130</span> <span class="number">197</span> <span class="number">220</span></span><br><span class="line">    </span><br><span class="line">Output:</span><br><span class="line"><span class="comment">// 输出一个整数，表示最多能浏览的景点数。</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>
<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>数据存储</p>
<p><code>nums[i]</code> 用于存储景点海拔序列。</p>
</li>
<li><p>状态表示</p>
<p>我们先对题意作一简单分析：队员所浏览景点海拔可看做先单调上升后单调下降的曲线，那么我们可首先求得从前往后到任意点的最长单调上升子序列长度，随后求取从后往前到任意点的最长单调上升子序列长度，统计各点作为最高点时的曲线长度，最长者便是最多可浏览的景点数。</p>
<p>这里我们需要定义两个状态 $f[i]$：以 $nums[i]$ 为结尾、数值严格单调递增的所有子序列中最长的序列长度， 和 $g[i]$：以 $nums[i]$ 为起始，数值严格单调递减的所有子序列中最长的序列长度。</p>
</li>
<li><p>状态转移</p>
<p>状态转移基本与 <em>最长上升子序列</em> 相同，两者的状态转移方程可表示如下：</p>
<p>$$f[i] = max(f[k] + 1,f[i]),(0\leq k &lt; i \  且 \ nums[k] &lt; nums[i])$$</p>
<p>$$g[i] = max(g[k] + 1, g[i]),(i &lt; k &lt; nums.length \ 且 \ nums[k] &lt; nums[i])$$</p>
</li>
<li><p>状态初始化</p>
<p>状态初始化也基本与 <em>最长上升子序列</em> 相同，需要指定 $f[i] = g[i] = 1,(0 \leq i &lt; nums.length)$ 。</p>
</li>
</ul>
<h2 id="友好城市"><a href="#友好城市" class="headerlink" title="友好城市"></a>友好城市</h2><h3 id="题目描述及示例-2"><a href="#题目描述及示例-2" class="headerlink" title="题目描述及示例"></a>题目描述及示例</h3><p>Palmia 国有一条横贯东西的大河，河有笔直的南北两岸，岸上各有位置各不相同的 $N$ 个城市。北岸的每个城市有且仅有一个友好城市在南岸，而且不同城市的友好城市不相同。每对友好城市都向政府申请在河上开辟一条直线航道连接两个城市，但是由于河上雾太大，政府决定避免任意两条航道交叉，以避免事故。编程帮助政府做出一些批准和拒绝申请的决定，使得在保证任意两条航线不相交的情况下，被批准的申请尽量多。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line"><span class="comment">// 第一行包含整数N，表示城市数。</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="comment">// 第二行到第n+1行，每行两个整数，分别表示南岸和北岸的一对友好城市的坐标。</span></span><br><span class="line"><span class="number">22</span> <span class="number">4</span></span><br><span class="line"><span class="number">2</span> <span class="number">6</span></span><br><span class="line"><span class="number">10</span> <span class="number">3</span></span><br><span class="line"><span class="number">15</span> <span class="number">12</span></span><br><span class="line"><span class="number">9</span> <span class="number">8</span></span><br><span class="line"><span class="number">17</span> <span class="number">17</span></span><br><span class="line"><span class="number">4</span> <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">Output:</span><br><span class="line"><span class="comment">// 输出一个整数，表示政府所能批准的最多申请数。</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>
<h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>数据存储</p>
<p><code>first[i]</code> 存储北岸城市坐标，<code>second[i]</code> 用于存储与北岸对应的友好城市坐标。</p>
</li>
<li><p>状态表示</p>
<p>如果两条航道发生交叉，一定满足如下条件：$(first[i] &lt; first[j] \ 且 \ second[i] &gt; second[j])$  或 $(first[i] &gt; first[j] \ 且 \ second[i] &lt; second[j])$。如果我们对 $first[i]$ 从小到大进行排序，并根据排序结果调整各友好城市在 $second[j]$ 中的坐标位置，为使得航道之间不会发生交叉结果，我们就需要保证：所选择的友好城市坐标满足单调递增。那么这样就将该题转换为 <em>最长上升子序列</em>。所以我们可以这样定义 $f[i]$：以 $second[i]$ 为结尾、坐标位置严格单调递增的所有子序列中最长的序列长度。</p>
</li>
<li><p>状态转移</p>
<p>状态转移基本与 <em>最长上升子序列</em> 相同，状态转移方程可表示如下：</p>
<p>$$f[i] = max(f[k] + 1,f[i]),(0\leq k &lt; i \  且 \ second[k] &lt; second[i])$$</p>
</li>
<li><p>状态初始化</p>
<p>状态初始化也基本与 <em>最长上升子序列</em> 相同，需要指定 $f[i] = g[i] = 1,(0 \leq i &lt; second.length)$ 。</p>
</li>
</ul>
<h2 id="最大上升子序列和"><a href="#最大上升子序列和" class="headerlink" title="最大上升子序列和"></a>最大上升子序列和</h2><h3 id="题目描述及示例-3"><a href="#题目描述及示例-3" class="headerlink" title="题目描述及示例"></a>题目描述及示例</h3><p>一个数的序列 $bi$，当 $b1&lt;b2&lt;…&lt;bS$ 时，我们称这个序列是上升的。对于给定的一个序列 (a1,a2,…,aN)，我们可以得到一些上升的子序列 (ai1,ai2,…,aiK)，其中 $1≤i1&lt;i2&lt;…&lt;iK≤N$。比如，对于序列 (1,7,3,5,9,4,8)，有它的一些上升子序列，如 (1,7),(3,4,8) 等。这些子序列中和最大为18，为子序列 (1,3,5,9) 的和。</p>
<p>你的任务，就是对于给定的序列，求出最大上升子序列和。注意：最长的上升子序列的和不一定是最大的，比如序列 (100,1,2,3) 的最大上升子序列和为 100，而最长上升子序列为 (1,2,3)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line"><span class="comment">// 第一行是序列长度N。</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="comment">// 第二行给出序列中的N个整数</span></span><br><span class="line"><span class="number">1</span> <span class="number">7</span> <span class="number">3</span> <span class="number">5</span> <span class="number">9</span> <span class="number">4</span> <span class="number">8</span></span><br><span class="line">    </span><br><span class="line">Output:</span><br><span class="line"><span class="comment">// 输出一个整数，表示最大上升子序列和。</span></span><br><span class="line"><span class="number">18</span></span><br></pre></td></tr></table></figure>
<h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>数据存储</p>
<p><code>nums[i]</code> 用于存储完整序列。</p>
</li>
<li><p>状态表示</p>
<p>与 <em>最长上升子序列</em> 类似，我们可以这样定义状态 $f[i]$：以 $nums[i]$ 为结尾、数值严格单调递增的所有子序列中最大的序列和。$f[i]$ 中最大值即为最长上升子序列和。</p>
</li>
<li><p>状态转移</p>
<p>状态转移基本与 <em>最长上升子序列</em> 相同，状态转移方程可表示如下：</p>
<p>$$f[i] = max(f[k] + nums[i],f[i]),(0\leq k &lt; i \  且 \ nums[k] &lt; nums[i])$$</p>
</li>
<li><p>状态初始化</p>
<p>由于状态存储序列和，故而需要如此初始化：指定 $f[i] = nums[i],(0 \leq i &lt; nums.length)$ 。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>线性DP</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-动态规划(二)</title>
    <url>/2020/09/13/algorithm/algorithm-dynamicprogramming2/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文主要介绍线性 DP 中的数字三角形模型，与该模型相关的题目有：数字三角形、摘花生、最低通行费、方格取数。</p>
<a id="more"></a>

<h2 id="数字三角形"><a href="#数字三角形" class="headerlink" title="数字三角形"></a>数字三角形</h2><h3 id="题目描述及示例"><a href="#题目描述及示例" class="headerlink" title="题目描述及示例"></a>题目描述及示例</h3><p>给定一个如下图所示的数字三角形，从顶部出发，在每一结点可以选择移动至其左下方的结点或移动至其右下方的结点，一直走到底层，要求找出一条路径，使路径上的数字的和最大。</p>
<p><img src="/2020/09/13/algorithm/algorithm-dynamicprogramming2/image-20200913101045695.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line"><span class="comment">// 第一行包含整数n，表示数字三角形的层数。</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="comment">// 接下来n行，每行包含若干整数，其中第i行表示数字三角形第i层包含的整数。</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">3</span> <span class="number">8</span></span><br><span class="line"><span class="number">8</span> <span class="number">1</span> <span class="number">0</span> </span><br><span class="line"><span class="number">2</span> <span class="number">7</span> <span class="number">4</span> <span class="number">4</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">2</span> <span class="number">6</span> <span class="number">5</span></span><br><span class="line">    </span><br><span class="line">Output:</span><br><span class="line"><span class="comment">// 输出一个整数，表示最大的路径数字和。</span></span><br><span class="line"><span class="number">30</span></span><br></pre></td></tr></table></figure>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>数据存储</p>
<p> <code>triangle[i][j]</code> 用于存储数字三角形 (存储方式与输入示例相同，每行数据从前往后依次存储即可)。</p>
</li>
<li><p>状态表示</p>
<p>既然数据是二维的，状态表示大概率也是二维的。我们可以这样定义 $f[i][j]$：以 $triangle[0][0]$ 为起点、$triangle[i][j]$ 为终点的所有路径中最大的路径数字和。</p>
</li>
<li><p>状态转移</p>
<p>“在每一结点可以选择移动至其左下方的结点或移动至其右下方的结点” 表明：对于 $f[i][j]$ 而言，它可由其左上方结点所示状态或右上方结点所示状态转移得到。故而状态转移方程可表示如下：</p>
<p>$$f[i][j] = max(f[i - 1][j - 1], f[i - 1][j]) + triangle[i][j]$$</p>
<blockquote>
<p>如果 $f[i][j]$ 为最左侧结点所示状态，则它只能由其右上方结点所示状态转移得到；如果 $f[i][j]$ 为最右侧结点所示状态，则它只能由其左上方结点所示状态转移得到。</p>
</blockquote>
</li>
<li><p>状态初始化</p>
<p>对于此题目而言，状态初始化比较简单，直接指定 $f[0][0] = triangle[0][0]$ 即可。</p>
</li>
</ul>
<h2 id="摘花生"><a href="#摘花生" class="headerlink" title="摘花生"></a>摘花生</h2><h3 id="题目描述及示例-1"><a href="#题目描述及示例-1" class="headerlink" title="题目描述及示例"></a>题目描述及示例</h3><p>Hello Kitty 想摘点花生送给她喜欢的米老鼠。她来到一片有网格状道路的矩形花生地 (如下图)，从西北角进去，东南角出来。地里每个道路的交叉点上都有种着一株花生苗，上面有若干颗花生，经过一株花生苗就能摘走该它上面所有的花生。Hello Kitty 只能向东或向南走，不能向西或向北走。问 Hello Kitty 最多能够摘到多少颗花生？</p>
<p><img src="/2020/09/13/algorithm/algorithm-dynamicprogramming2/20200831223250167.gif"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line"><span class="comment">// 第一行包含两个整数，分别代表花生苗的行数R和列数C。</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="comment">// 接下来R行数据，从北向南依次描述每行花生苗的情况。</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">6</span> <span class="number">5</span></span><br><span class="line">    </span><br><span class="line">Output:</span><br><span class="line"><span class="comment">// 输出一个整数，表示Hello Kitty能摘到得最多的花生颗数。</span></span><br><span class="line"><span class="number">16</span></span><br></pre></td></tr></table></figure>
<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>数据存储</p>
<p><code>rectangle[i][j]</code> 用于存储花生苗信息。</p>
</li>
<li><p>状态表示</p>
<p>与上题类似，我们可以这样定义状态 $f[i][j]$：以 $rectangle[0][0]$ 为起点、$rectangle[i][j]$ 为终点的所有路径中，Hello Kitty 所能摘到的最大花生数。</p>
</li>
<li><p>状态转移</p>
<p>“Hello Kitty 只能向东或向南走” 表明：对于 $f[i][j]$ 而言，它可由其左侧状态或其上侧状态转移得到。故而状态转移方程可表示如下：</p>
<p>$$f[i][j] = max(f[i][j - 1], f[i - 1][j]) + rectangle[i][j]$$</p>
<blockquote>
<p>如果 $f[i][j]$ 为最左侧状态，则它只能由其上侧状态转移得到；如果 $f[i][j]$ 为最上侧状态，则它只能由其右侧状态转移得到。</p>
</blockquote>
</li>
<li><p>状态初始化</p>
<p>对于此题目而言，状态初始化也是比较简单，直接指定 $f[0][0] = rectangle[0][0]$ 即可。</p>
</li>
</ul>
<h2 id="最低通行费"><a href="#最低通行费" class="headerlink" title="最低通行费"></a>最低通行费</h2><h3 id="题目描述及示例-2"><a href="#题目描述及示例-2" class="headerlink" title="题目描述及示例"></a>题目描述及示例</h3><p>一个商人穿过一个 $N\times N$ 的正方形网格，去参加一个非常重要的商务活动。他要从网格的左上角进，右下角出。<br>每穿越中间 1 个小方格，都要花费 1 个单位时间。商人必须在 (2N-1) 个单位时间内穿越出去，而在经过中间的每个小方格时，都需要缴纳一定的费用。这个商人期望在规定时间内用最少费用穿越出去。请问至少需要多少费用？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line"><span class="comment">// 第一行是一个整数，表示正方形的宽度N。</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="comment">// 接下来N行，为网格上每个小方格的费用。</span></span><br><span class="line"><span class="number">1</span>  <span class="number">4</span>  <span class="number">6</span>  <span class="number">8</span>  <span class="number">10</span> </span><br><span class="line"><span class="number">2</span>  <span class="number">5</span>  <span class="number">7</span>  <span class="number">15</span> <span class="number">17</span> </span><br><span class="line"><span class="number">6</span>  <span class="number">8</span>  <span class="number">9</span>  <span class="number">18</span> <span class="number">20</span> </span><br><span class="line"><span class="number">10</span> <span class="number">11</span> <span class="number">12</span> <span class="number">19</span> <span class="number">21</span> </span><br><span class="line"><span class="number">20</span> <span class="number">23</span> <span class="number">25</span> <span class="number">29</span> <span class="number">33</span></span><br><span class="line">    </span><br><span class="line">Output:</span><br><span class="line"><span class="comment">// 输出一个整数，表示至少需要的费用。</span></span><br><span class="line"><span class="number">109</span></span><br></pre></td></tr></table></figure>
<h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>数据存储</p>
<p><code>rectangle[i][j]</code> 用于存储网格费用。</p>
</li>
<li><p>状态表示</p>
<p>这道题目意思比较隐晦，我们先对题意作一简单分析：<em>“商人必须在 (2N-1) 个单位时间内穿越出去” ，这句话也就是说：商人只能向下或向右行走，而不能走回头路。</em></p>
<p>此时题意与上题基本类似，我们可以这样定义状态 $f[i][j]$：从 $rectangle[0][0]$ 出发、到达 $rectangle[i][j]$ 所需的最少费用。</p>
</li>
<li><p>状态转移</p>
<p>根据 “商人必须在 (2N-1) 个单位时间内穿越出去” ，状态转移方程可表示如下：</p>
<p>$$f[i][j] = min(f[i][j - 1],f[i - 1][j]) + rectangle[i][j]$$</p>
<blockquote>
<p>如果 $f[i][j]$ 为最左侧状态，则它只能由其上侧状态转移得到；如果 $f[i][j]$ 为最上侧状态，则它只能由其右侧状态转移得到。</p>
</blockquote>
</li>
<li><p>状态初始化</p>
<p>对于此题目而言，状态初始化也是比较简单，直接指定 $f[0][0] = rectangle[0][0]$ 即可。</p>
</li>
</ul>
<h2 id="方格取数"><a href="#方格取数" class="headerlink" title="方格取数"></a>方格取数</h2><h3 id="题目描述及示例-3"><a href="#题目描述及示例-3" class="headerlink" title="题目描述及示例"></a>题目描述及示例</h3><p>设有 $N \times N$ 的方格图，我们在其中的某些方格中填入正整数，而其它的方格中则放入数字 0。如下图所示：</p>
<p><img src="/2020/09/13/algorithm/algorithm-dynamicprogramming2/19_764ece6ed5-2.gif"></p>
<p>某人从图中的左上角 A 出发，可以向下行走，也可以向右行走，直到到达右下角的 B 点。在走过的路上，他可以取走方格中的数 (取走后的方格中将变为数字0)。此人从 A 点到 B 点共走了两次，试找出两条这样的路径，使得取得的数字和为最大。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line"><span class="comment">// 第一行为一个整数，表示方格图的宽度。</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="comment">// 接下来的每行有三个整数，第一个为行号数，第二个为列号数，第三个为在该行、该列上所放的数,一行“0 0 0”表示结束。</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">13</span></span><br><span class="line"><span class="number">2</span> <span class="number">6</span> <span class="number">6</span></span><br><span class="line"><span class="number">3</span> <span class="number">5</span> <span class="number">7</span></span><br><span class="line"><span class="number">4</span> <span class="number">4</span> <span class="number">14</span></span><br><span class="line"><span class="number">5</span> <span class="number">2</span> <span class="number">21</span></span><br><span class="line"><span class="number">5</span> <span class="number">6</span> <span class="number">4</span></span><br><span class="line"><span class="number">6</span> <span class="number">3</span> <span class="number">15</span></span><br><span class="line"><span class="number">7</span> <span class="number">2</span> <span class="number">14</span></span><br><span class="line">    </span><br><span class="line">Output:</span><br><span class="line"><span class="comment">// 输出一个整数，表示两条路径上取得的最大和。</span></span><br><span class="line"><span class="number">67</span></span><br></pre></td></tr></table></figure>
<h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>数据存储</p>
<p><code>rectangle[i][j]</code> 用于存储方格信息。</p>
</li>
<li><p>状态表示</p>
<p>这道题可以先执行 DP 求取一个最大和，随后将相关方格中的数置为 0，再次执行 DP 取得一个最大和，二者相加即是结果。</p>
<p>这道题目可以看做是数字三角形模型在二维空间中的扩展，所以我们直接在此空间之上构建状态。我们可以这样定义状态 $f[i1][j1][i2][j2]$：以 $rectangle[0][0]$ 为起点、 $rectangle[i1][j1]$ 和 $rectangle[i2][j2]$ 分别为终点的所有路径中，所能取得数字的最大和。</p>
</li>
<li><p>状态转移</p>
<p>由于涉及两个终点，类比数字三角形模型可知：当前状态 $f[i1][j1][i2][j2]$ 可由四个状态转移得到。具体的状态转移方程表示如下：</p>
<p>$$f[i1][j1][i2][j2] = max(f[i1][j1 - 1][i2][j2 - 1],f[i1 - 1][j1][i2 - 1][j2],f[i1][j1 - 1][i2 - 1][j2],f[i1 - 1][j1][i2][j2 - 1]) + rectangle[i1][j1] + rectangle[i2][j2] (i1 \neq i2 \ 或 \ j1 \neq j2)$$</p>
<p>$$f[i1][j1][i2][j2] = max(f[i1][j1 - 1][i2][j2 - 1],f[i1 - 1][j1][i2 - 1][j2],f[i1][j1 - 1][i2 - 1][j2],f[i1 - 1][j1][i2][j2 - 1]) + rectangle[i1][j1] (i1 = i2 \ 且 \ j1 = j2)$$</p>
</li>
<li><p>状态初始化</p>
<p>状态初始化仍然是比较简单的，直接指定 $f[0][0][0][0] = rectangle[0][0]$ 即可。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>线性DP</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-动态规划(一)</title>
    <url>/2020/09/12/algorithm/algorithm-dynamicprogramming1/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>动态规划</strong> 与分治法类似，皆是通过组合子问题解来求解原问题，二者不同点在于前者适用于子问题重叠场景，后者适用于子问题不重叠场景。正是由于存在子问题重叠，故而动态规划借助表格存储子问题解，通过多阶段决策以逐步组合得到原问题解。</p>
<a id="more"></a>

<p>动态规划所能求解的问题常具有如下三大特征：</p>
<ul>
<li><p>最优子结构</p>
<p>原问题解一定可由子问题解组合得到，换言之，通过组合子问题解一定可得到原问题的解。</p>
</li>
<li><p>重叠子问题</p>
<p>不同子问题之间存在公共子子问题。</p>
</li>
<li><p>无后效性</p>
<p>假定当前问题 A 由子问题 B 和 C 组成。无后效性指的是：求得 B、C 问题解后，A 问题求解过程中所使用到的决策不会对 B、C 问题解存在影响。</p>
</li>
</ul>
<p>动态规划求解过程主要涉及三个部分：</p>
<ul>
<li><p>状态表示</p>
<p>我们使用表格存储子问题解，那么状态表示指代表格中任意一格的具体含义是什么。例如，$f[i][j]$ 表示 xxx。</p>
</li>
<li><p>状态转移</p>
<p>状态转移指代一个子问题解应当根据哪些子问题解组合得到且以何种方式组合得到。例如，$f[i][j] = min(f[i - 1][j], f[i - 1][j - 1])$。</p>
</li>
<li><p>状态初始化</p>
<p>为得到原问题解，首先需要初始化相关子问题解，这样通过逐步递推将会得到原问题解。例如：$f[0][0] = 0$。</p>
</li>
</ul>
<p>动态规划求解过程看似简单，实际上没有比较多的积累是很难想到解法的。由于不是专业竞赛选手，故而我们只要简单了解一些动态规划题型就可以了。</p>
<p>本文之中，我们将简要介绍动态规划的两种实现方式，并比较二者区别。接下来几篇文章中，我们将进一步针对不同动态规划类型进行介绍，这些类型具体包括 —— 线性 DP (它所含内容比较多，主要介绍数字三角形模型和最长上升子序列模型)、背包 DP、状态机 DP、状态压缩 DP、区间 DP、树形 DP、数位 DP、DAG 上 DP。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>动态规划有两种实现方式 —— 递归和递推。</p>
<p>递归采用自顶向下方式进行实现。在该种实现方式中，为求得当前问题解，就需要递归求解子问题，随后基于子问题解组合得到当前问题解。由于存在子问题重叠，故而实现过程中需要使用公共空间存储子问题解 (正是由于使用公共空间存储子问题解，该种实现方式又称为 <strong>记忆化搜索</strong>)。</p>
<p>其实现代码大致如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 公共空间(默认初始化为-1，表明该子问题尚未被求解)。</span></span><br><span class="line"><span class="keyword">int</span> f[i][j];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记忆化搜索。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (f[i][j] != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> f[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 状态转移部分，首先求解子问题解，随后组合得到当前问题解。</span></span><br><span class="line">    ...</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>递推采用自底向上方式进行实现。在该种实现方式中，按照表格顺序依次求解各个子问题解即可。</p>
<p>其实现代码大致如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 表格。</span></span><br><span class="line"><span class="keyword">int</span> f[i][j];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; f.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; f[i].length; j++) &#123;</span><br><span class="line">        <span class="comment">// 状态转移部分。</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原问题解就在f[i][j]之中，返回相应值即可。</span></span><br><span class="line"><span class="keyword">return</span> f[][];</span><br></pre></td></tr></table></figure>
<p>既然存在两种实现方式，自然需要进行比较一番：</p>
<ul>
<li>两种方式往往可以自由转换。通常情况下，递推实现动态规划比较简单；而在某些情况下，递归实现动态规划比较简单。针对具体题目，选择方便实现的方式即可。</li>
<li>由于递归本身具有搜索特性，故而递归方式可使用剪枝以避免无效搜索 (换言之，可优化时间复杂度)，但是它无法对空间进行优化。</li>
<li>递推方式无法对时间进行优化，但是基于滚动数组等方式可大大优化空间复杂度。</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>动态规划</category>
      </categories>
  </entry>
  <entry>
    <title>算法-图搜索</title>
    <url>/2020/08/29/algorithm/algorithm-graphsearch/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>图搜索</strong> 最初用于遍历图内节点，现在往往用于最优解搜索等问题。</p>
<a id="more"></a>

<p>我们在此介绍五种搜索算法 —— DFS (深度优先搜索) 、BFS (广度优先搜索)、IDDFS (迭代深化深度优先搜索)、A*、IDA*。</p>
<blockquote>
<p>我们在此仅讨论搜索算法用于求解最优解搜索问题。随后在可行解内找具有最小代价的最优解。</p>
</blockquote>
<h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><p>DFS 属于盲目搜索，它会遍历解空间中所有解，故而其也是一种暴力搜索。</p>
<p>当用其解决最优解搜索问题时，首先需要找到解空间内所有可行解，随后在可行解内找具有最小代价的最优解。</p>
<h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><p>BFS 属于有目的搜索，它会按层次搜索解空间中的解。</p>
<p>当用其解决最优解搜索问题时，只要搜索到解，那么该解一定是最优解。</p>
<blockquote>
<p>最优解搜索问题中有一类称为最短路径搜索。该问题用于查找图中两点间最短路径。</p>
<p>如果图中任意两点间边代价相同，则从起点开始，BFS 动态搜索止点，一旦搜索到止点，其搜索路径就是最短路径。</p>
</blockquote>
<h2 id="IDDFS"><a href="#IDDFS" class="headerlink" title="IDDFS"></a>IDDFS</h2><p>对于 DFS 而言，深度越深，递归层级越高，此时容易栈溢出；对于 BFS 而言，广度越广，队列所需空间越大，此时容易内存溢出。当需要寻找最优解时，由于 DFS 往往需要遍历解空间，故而使得其时间复杂度过高。</p>
<p>实际中，内存溢出远比栈溢出容易 (深度越深，大概率意味着广度越广)。为在内存空间有限条件下快速搜索最优解，IDDFS (迭代深化深度优先搜索，即带有深度限制地深度优先搜索) 被提出，它借助于 DFS 以模拟 BFS，从而达到搜索效率和内存空间两不误。</p>
<p>我们简单描述其过程如下：</p>
<ol>
<li>初始化深度限制为 1，使用 DFS 搜索最优解。</li>
<li>如果 DFS 搜索得到最优解或者深度限制已达最大深度限制，则退出循环，否则设置深度限制为当前深度限制加一，重新进行 DFS 搜索最优解。</li>
</ol>
<blockquote>
<p>深度加一，解空间应当呈指数增加，之前搜索部分的时间复杂度便可忽略不计，故而 IDDFS 的时间复杂度主要由最优解所在深度那层深搜决定；BFS 同样需要搜索到最优解所在深度，但是由于它一次搜索到位，故而其时间复杂度仅略好于 IDDFS 。</p>
</blockquote>
<p>这里简单说明一下 IDDFS 的适用场景：深度未知、广度很大、同时最优解深度又比较低。</p>
<h2 id="A"><a href="#A" class="headerlink" title="A*"></a>A*</h2><p>当进行最短路径搜索时，BFS 会将当前搜索点的所有未搜索邻居点加入至队列 (简称为扩展当前搜索点)，然后按序取出队列内容进行扩展，这种扩展方式略显愚笨。</p>
<p>按照人们直观理解来看，我们应当优先扩展距离目标点更近地搜索点。那么这种搜索算法就称为 <strong>最佳优先搜索</strong>。</p>
<p>最佳优先搜索问题在于：没有考虑搜索点到起始点情况。在 A* 中，它优先扩展具有最小代价值 (该代价值与起始点和目标点均相关) 的搜索点，其中代价值基于启发函数确定。</p>
<p>在 A* 算法中，启发函数表示为 $f(x) = g(x) + h(x)$，其中 $g(x)$ 指代起始点至当前节点的所需代价，$h(x)$ 指代当前节点至目标点的预估代价。</p>
<p>$g(x)$ 在搜索过程中可以得到，而 $h(x)$ 通常需要精心设计。我们在此列举 $h(x)$ 的常见形式：</p>
<ul>
<li>如果图中搜索节点时仅允许上下左右探索，则其应为曼哈顿距离。</li>
<li>如果图中搜索节点时仅允许八方向 (即上、下、左、右、左上、右上、左下、右下) 探索，则其应为对角距离。</li>
<li>如果图中搜索节点时允许任意方向移动，则其应为欧几里得距离。</li>
</ul>
<h2 id="IDA"><a href="#IDA" class="headerlink" title="IDA*"></a>IDA*</h2><p>A* 算法等价于 BFS + 启发函数，IDA* 则等价于 IDDFS + 启发函数。</p>
<p>在 IDA* 中，启发函数可用于两处：1. 根据启发函数动态增加深度，而非每次加一。2. 根据启发函数判断当前解情况下是否需要继续进行深度优先搜索。</p>
<blockquote>
<p>我们在此简单介绍一些避免无效搜索地操作：</p>
<ol>
<li><p>记忆化搜索</p>
<p>如果搜索过程发生重复搜索，我们可以现行保存搜索结果，随后直接使用搜索结果替代搜索。</p>
</li>
<li><p>可行性剪枝</p>
<p>如果当前解已经无法满足要求，则无需再进行搜索。</p>
</li>
<li><p>最优性剪枝</p>
<p>如果当前解比已知最优解更差，则无需再进行搜索。</p>
</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>BFS</tag>
        <tag>IDDFS</tag>
        <tag>A*</tag>
        <tag>IDA*</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-最短路径</title>
    <url>/2020/08/28/algorithm/algorithm-shortestpath/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>最短路径</strong> 属于图论用语，它旨在求解图中任意两点间的最短距离。</p>
<a id="more"></a>

<p>我们在此介绍四种最短路径搜索算法 —— Dijkstra 算法、Floyd 算法、Bellman-Ford 算法及 SPFA 算法。</p>
<h2 id="Dijkstra-算法"><a href="#Dijkstra-算法" class="headerlink" title="Dijkstra 算法"></a>Dijkstra 算法</h2><p>Dijkstra 算法用于求取单源最短路径，它仅适用于无负权边场景。</p>
<p>该算法思想与 Prim 算法基本一致，均是基于贪心思想。其步骤描述如下 (假定图中节点集合为 $V$)：</p>
<ol>
<li>选定图中某一节点指定为单源，记为 $root$。</li>
<li>构建两个集合 $S$ 和 $T$ ($S$ 表示节点集合中已求得最短路径的节点集，$T$ 表示节点集合中未求得最短路径的节点集)，并初始化它们为 $S = {root}, T = V - {root}$。</li>
<li>选择 $T$ 中距离 $root$ 节点最近的节点，将其从 $T$ 中删去并将其加入至 $S$ 中，根据此节点更新 $T$ 中其余节点到 $root$ 节点的距离信息。</li>
<li>循环迭代步骤 3，直至 $S == V$。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] dijkstra(<span class="keyword">int</span>[][] graph) &#123;</span><br><span class="line">    <span class="comment">// 存放最短路径值及具体路径信息。</span></span><br><span class="line">    <span class="keyword">int</span>[] distance = <span class="keyword">new</span> <span class="keyword">int</span>[graph.length];</span><br><span class="line">    <span class="keyword">int</span>[][] paths = <span class="keyword">new</span> <span class="keyword">int</span>[graph.length][graph[<span class="number">0</span>].length];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认求取0号节点到其余节点的最短路径，首先初始化相关信息。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.length; i++) &#123;</span><br><span class="line">        distance[i] = graph[<span class="number">0</span>][i];</span><br><span class="line">        Arrays.fill(paths[i], INF);</span><br><span class="line">        <span class="keyword">if</span> (distance[i] != INF) &#123;</span><br><span class="line">            paths[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            paths[i][<span class="number">1</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    distance[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    paths[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环迭代获取最短路径。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> minIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minDistance = INF;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到T中距离0号节点最近的节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; graph.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (distance[j] &gt; <span class="number">0</span> &amp;&amp; distance[j] &lt; minDistance) &#123;</span><br><span class="line">                minIndex = j;</span><br><span class="line">                minDistance = distance[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果一个节点到0号节点的距离为负数，表明该点已加入S中。</span></span><br><span class="line">        distance[minIndex] = -distance[minIndex];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果T中节点经由minIndex节点后到达0号节点的距离变短，则更新之。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; graph.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (distance[j] &gt; <span class="number">0</span> &amp;&amp; minDistance + graph[minIndex][j] &lt; distance[j]) &#123;</span><br><span class="line">                distance[j] = minDistance + graph[minIndex][j];</span><br><span class="line">                <span class="comment">// 更新路径信息。</span></span><br><span class="line">                Arrays.fill(paths[j], INF);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; paths[minIndex].length; s++) &#123;</span><br><span class="line">                    paths[j][s] = paths[minIndex][s];</span><br><span class="line">                    <span class="keyword">if</span> (paths[j][s] == INF) &#123;</span><br><span class="line">                        paths[j][s] = j;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回最短路径。</span></span><br><span class="line">    <span class="keyword">return</span> paths;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Floyd-算法"><a href="#Floyd-算法" class="headerlink" title="Floyd 算法"></a>Floyd 算法</h2><p>Floyd 算法用于求取全局最短路径，它适用于有无负权边场景，但是不适用于负环回路场景，它基于动态规划而实现。</p>
<p>从任意节点 $i$ 到任意节点 $j$ 的最短路径不外乎两种情况：从 $i$ 直接到达 $j$ 、从 $i$ 出发借助于中间节点 $k$ 到达 $j$。基于此我们可构建状态 $f[k][i][j]$，它表示借助于前 $k$ 个节点作为中间节点所构建 $i$ 到 $j$ 的最短路径值。那么容易得到状态方程：</p>
<p>$$f[k][i][j] = min(f[k - 1][i][j], f[k - 1][i][k], f[k - 1][k][j])$$</p>
<p>初始状态即为 $f[0][i][j] = edge[i][j]$ ($edge[i][j]$ 表示边权重)，循环迭代处理至 $f[V.size()][i][j]$ ($V$ 表示图顶点集) 便得到全局最短路径。</p>
<p>观察该状态转换方程，我们可以发现：当前状态 $f[k][<em>][</em>]$ 仅依赖于 $f[k - 1][<em>][</em>]$，故而使用两个矩阵迭代更新即可完成循环迭代过程。</p>
<p>更进一步，我们发现：$f[k - 1][i][k] == f[k][i][k] 且  f[k - 1][k][j] == f[k][k][j]$，此时我们可直接在当前矩阵中完成更新操作 (<strong>非常神奇地观察</strong>)。</p>
<p>此时可以给出 Floyd 算法，十分地简洁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] floyd(<span class="keyword">int</span>[][] graph) &#123;</span><br><span class="line">    <span class="comment">// 存放借助于前k个节点作为中间节点时i到j的最短路径。</span></span><br><span class="line">    <span class="keyword">int</span>[][] D = <span class="keyword">new</span> <span class="keyword">int</span>[graph.length][graph[<span class="number">0</span>].length];</span><br><span class="line">    <span class="comment">// 存放i到j的最短路径中第一个使用地中间节点(借助它可获取最短路径信息)。</span></span><br><span class="line">    <span class="keyword">int</span>[][] P = <span class="keyword">new</span> <span class="keyword">int</span>[graph.length][graph[<span class="number">0</span>].length];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化矩阵。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; graph[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">            D[i][j] = graph[i][j];</span><br><span class="line">            P[i][j] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 三重循环迭代处理。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; graph.length; k++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; graph[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="comment">// 这个看似简单，主要基于上面那个观察。</span></span><br><span class="line">                <span class="keyword">if</span> (D[i][k] + D[k][j] &lt; D[i][j]) &#123;</span><br><span class="line">                    D[i][j] = D[i][k] + D[k][j];</span><br><span class="line">                    P[i][j] = P[i][k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> P;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Bellman-Ford-算法"><a href="#Bellman-Ford-算法" class="headerlink" title="Bellman-Ford 算法"></a>Bellman-Ford 算法</h2><p>Bellman-Ford 算法用于求取单源最短路径，它适用于有无负权边场景，同时可判断是否存在负环回路。</p>
<p>Bellman-Ford 算法步骤描述如下 (假定图中节点集合为 $V$)：</p>
<ol>
<li>选定图中某一节点指定为单源，记为 $root$。</li>
<li>初始化所有节点到 $root$ 的最短路径值，记为 $distance[i]$。</li>
<li>对图中所有边尝试执行松弛操作，即对于边 $edge[i][j]$ 而言，如果 $distance[i] + edge[i][j] &lt; distance[j]$，则更新 $distance[j] = distance[i] + edge[i][j]$。</li>
<li>循环迭代步骤 3 $V.size() - 1$ 次即可得到结果。</li>
</ol>
<p>重点解释：为什么循环迭代 $V.size() - 1$ 次可以得到单源最短路径结果？</p>
<p>松弛操作具有一个性质：如果 $p = (v_0,v_1,\dots,v_k)$ 是从源点 $v_0$ 到终点 $v_k$ 的最短路径，并且我们执行松弛操作的顺序为 $edge[v_0][v_1],\dots,edge[v_{k-1},v_k]$，那么这些松弛操作完成后得到的 $distance[v_k]$ 必定是源点 $v_0$ 到终点 $v_k$ 的最短路径值。并且该性质成立条件与其他松弛操作无关，即可在这些松弛操作中穿插其他松弛操作，只要保证这些松弛操作按序执行即可。</p>
<p>该性质比较容易理解，故而我们不予证明 (好吧，就是不会 😅)。由于组成单源最短路径的边数不可能超过 $V.size() - 1$，根据松弛操作性质，我们可在 $V.size() - 1$ 次内得到单源最短路径。如果我们再次循环一次，此时如果存在松弛操作被执行，便可判断图中存在负环回路。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] bellmanFord(<span class="keyword">int</span>[][] graph) &#123;</span><br><span class="line">    <span class="comment">// 存放各节点到单源的最短路径值及最短路径信息。</span></span><br><span class="line">    <span class="keyword">int</span>[] distance = <span class="keyword">new</span> <span class="keyword">int</span>[graph.length];</span><br><span class="line">    <span class="keyword">int</span>[][] paths = <span class="keyword">new</span> <span class="keyword">int</span>[graph.length][graph[<span class="number">0</span>].length];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化相关信息。</span></span><br><span class="line">    Arrays.fill(distance, INF);</span><br><span class="line">    distance[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.length; i++) &#123;</span><br><span class="line">        Arrays.fill(paths[i], INF);</span><br><span class="line">    &#125;</span><br><span class="line">    paths[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环v.size()-1次。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; graph.length; k++) &#123;</span><br><span class="line">        <span class="comment">// 对图中所有边执行松弛操作。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; graph[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="comment">// 松弛操作。</span></span><br><span class="line">                <span class="keyword">if</span> (graph[i][j] != INF &amp;&amp; distance[i] + graph[i][j] &lt; distance[j]) &#123;</span><br><span class="line">                    distance[j] = distance[i] + graph[i][j];</span><br><span class="line">                    <span class="comment">// 更新路径信息。</span></span><br><span class="line">                    Arrays.fill(paths[j], INF);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; paths[i].length; s++) &#123;</span><br><span class="line">                        paths[j][s] = paths[i][s];</span><br><span class="line">                        <span class="keyword">if</span> (paths[j][s] == INF) &#123;</span><br><span class="line">                            paths[j][s] = j;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> paths;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="SPFA-算法"><a href="#SPFA-算法" class="headerlink" title="SPFA 算法"></a>SPFA 算法</h2><p>SPFA 算法是 Bellman-Ford 算法的优化版本，其优化点在于：针对需要进行松弛操作的边执行松弛操作。</p>
<p>在 Bellman-Ford 算法中，直接对图中所有边尝试执行松弛操作，然而并非所有的边都是需要进行松弛操作的。如果可以避免无效的尝试松弛操作，那么就可以进一步降低算法的时间复杂度。</p>
<p>第一轮执行 Bellman-Ford 算法时，我们将会发现只有以单源为出发点的那些边才是真正需要进行松弛操作的，其余边的松弛操作尝试均是没有必要地，并且记基于松弛操作更新最短路径信息的点集为 $v$；第二轮执行 Bellman-Ford 算法时，我们又会发现只有以 $v$ 中点为出发点的那些边才是真正需要进行松弛操作的，其余边的松弛操作尝试均是没有必要地，以此类推，均是如此规律。</p>
<p>基于此规律，我们可将待松弛点依次放入队列之中，按序松弛点对应边。当队列为空时，松弛操作完成并且最短路径求取完成，这基本上是 SPFA 算法的核心要义。</p>
<blockquote>
<p>在 SPFA 算法中，如果需要判断图中是否存在负环回路，只要判断特定待松弛点进入队列次数是否超过 $V.size() - 1$ 次即可。</p>
<p>在代码实现中，如果待松弛点已经入队，则无需再次入队。如此操作的原因在于：即使不将该点再次放入队列之中，已放入队列的该点它会完成所需的松弛操作，将其再次放入队列之中完全是没有必要的。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] spfa(<span class="keyword">int</span>[][] graph) &#123;</span><br><span class="line">    <span class="comment">// 存放各节点到单源的最短路径值及最短路径信息。</span></span><br><span class="line">    <span class="keyword">int</span>[] distance = <span class="keyword">new</span> <span class="keyword">int</span>[graph.length];</span><br><span class="line">    <span class="keyword">int</span>[][] paths = <span class="keyword">new</span> <span class="keyword">int</span>[graph.length][graph[<span class="number">0</span>].length];</span><br><span class="line">    <span class="comment">// 用于存放待松弛点的队列。</span></span><br><span class="line">    ArrayDeque&lt;Integer&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    <span class="comment">// 判断点是否位于队列之中。</span></span><br><span class="line">    <span class="keyword">boolean</span>[] in = <span class="keyword">new</span> <span class="keyword">boolean</span>[graph.length];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化相关信息。</span></span><br><span class="line">    Arrays.fill(distance, INF);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.length; i++) &#123;</span><br><span class="line">        Arrays.fill(paths[i], INF);</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.fill(in, <span class="keyword">false</span>);</span><br><span class="line">    distance[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    paths[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    in[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">    queue.push(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 队列中吐出一个节点。</span></span><br><span class="line">        Integer index = queue.pop();</span><br><span class="line">        <span class="comment">// 对节点对应边尝试执行松弛操作。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph[<span class="number">0</span>].length; i++) &#123;</span><br><span class="line">            <span class="comment">// 松弛操作。</span></span><br><span class="line">            <span class="keyword">if</span> (graph[index][i] != INF &amp;&amp; distance[index] + graph[index][i] &lt; distance[i]) &#123;</span><br><span class="line">                distance[i] = distance[index] + graph[index][i];</span><br><span class="line">                <span class="comment">// 更新路径信息。</span></span><br><span class="line">                Arrays.fill(paths[i], INF);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; paths[index].length; s++) &#123;</span><br><span class="line">                    paths[i][s] = paths[index][s];</span><br><span class="line">                    <span class="keyword">if</span> (paths[i][s] == INF) &#123;</span><br><span class="line">                        paths[i][s] = i;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果i位于队列之中，则无需再入队列。</span></span><br><span class="line">                <span class="keyword">if</span> (in[i] == <span class="keyword">false</span>) &#123;</span><br><span class="line">                    queue.push(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> paths;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>算法-最小生成树</title>
    <url>/2020/08/27/algorithm/algorithm-minimumspanningtree/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>最小生成树</strong> 属于图论用语，它是连通图中具有最小边代价和的生成树。求取它的实际意义在于：如果需要为城镇部署线网，按照最小生成树进行部署，既可保证用户全覆盖，又可保证代价最小。</p>
<a id="more"></a>

<p>我们在此介绍两种最小生成树求解算法 —— Prim 算法 (又称 “加点法”) 和 Kruskal 算法 (又称 “加边法”)。</p>
<h2 id="Prim-算法"><a href="#Prim-算法" class="headerlink" title="Prim 算法"></a>Prim 算法</h2><p>Prim 算法步骤描述如下 (假定图中节点集合为 $V$)：</p>
<ol>
<li>选定图中某一节点为根节点，记为 $root$。</li>
<li>构建两个集合 $S$ 和 $T$ ($S$ 表示节点集合中属于最小生成树中节点的节点集，$T$ 表示节点集合中不属于最小生成树中节点的节点集)，并初始化它们为 $S = {root}, T = V - {root}$。</li>
<li>选择 $T$ 中距离 $S$ 中节点最近的节点，将其从 $T$ 中删去并加入到 $S$ 中。</li>
<li>循环迭代步骤 3，直至 $S == V$。</li>
</ol>
<blockquote>
<ul>
<li>从步骤描述中可以看到：需要时刻维护 $T$ 中节点到 $S$ 中节点的距离 (即边代价)。</li>
<li>最小生成树基于添加点而构建，故而其称为 “加点法”。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果边权重为INF，表明该边不存在。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] prim(<span class="keyword">int</span>[][] graph) &#123;</span><br><span class="line">    <span class="comment">// 维护T中节点到S中节点的边代价</span></span><br><span class="line">    <span class="keyword">int</span>[] destination = <span class="keyword">new</span> <span class="keyword">int</span>[graph.length];</span><br><span class="line">    <span class="keyword">int</span>[] distance = <span class="keyword">new</span> <span class="keyword">int</span>[graph.length];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认使用0号节点作为最小生成树树根，首先初始化相关信息。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph[<span class="number">0</span>].length; i++) &#123;</span><br><span class="line">        destination[i] = <span class="number">0</span>;</span><br><span class="line">        distance[i] = graph[<span class="number">0</span>][i];</span><br><span class="line">    &#125;</span><br><span class="line">    distance[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环迭代以构建最小生成树。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; graph.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> minIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minDistance = INF;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到T中最小代价边。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; distance.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (distance[j] != <span class="number">0</span> &amp;&amp; distance[j] &lt; minDistance) &#123;</span><br><span class="line">                minIndex = j;</span><br><span class="line">                minDistance = distance[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        distance[minIndex] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 依据最小代价边更新信息。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; distance.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (distance[j] != <span class="number">0</span> &amp;&amp; distance[j] &gt; graph[minIndex][j]) &#123;</span><br><span class="line">                destination[j] = minIndex;</span><br><span class="line">                distance[j] = graph[minIndex][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> destination;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Kruskal-算法"><a href="#Kruskal-算法" class="headerlink" title="Kruskal 算法"></a>Kruskal 算法</h2><p>Kruskal 算法步骤描述如下 (假定图中节点集合为 $V$)：</p>
<ol>
<li>将图中所有边按照边代价从小到大进行排序。</li>
<li>清空图中所有边，使得图仅剩所有顶点。</li>
<li>从小到大依次选择边，如果该边对应的两个顶点已经连通，则不作任何处理，否则在图中添加此边。</li>
<li>循环迭代步骤 3， 直至图中添加地边数为 $V.size - 1$。</li>
</ol>
<blockquote>
<ul>
<li>判断顶点是否连通，可使用并查集快速做到。</li>
<li>最小生成树基于添加边而构建，故而其称为 “加边法”。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 边信息(包含起止点、边代价)，用于排序及最后输出记录。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EdgeInfo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> distance;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EdgeInfo</span><span class="params">(<span class="keyword">int</span> distance, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.distance = distance;</span><br><span class="line">        <span class="keyword">this</span>.i = i;</span><br><span class="line">        <span class="keyword">this</span>.j = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;EdgeInfo&gt; <span class="title">kruskal</span><span class="params">(<span class="keyword">int</span>[][] graph)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 并查集，用于判断两点是否连通。</span></span><br><span class="line">    UnionFind uf = <span class="keyword">new</span> UnionFind(graph.length);</span><br><span class="line">    <span class="comment">// 存放最小生成树记录。</span></span><br><span class="line">    ArrayList&lt;EdgeInfo&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 使用优先队列按照边代价对图中所有边从小到大排序。</span></span><br><span class="line">    PriorityQueue&lt;EdgeInfo&gt; edges = <span class="keyword">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; &#123;</span><br><span class="line">        EdgeInfo edge1 = (EdgeInfo) o1;</span><br><span class="line">        EdgeInfo edge2 = (EdgeInfo) o2;</span><br><span class="line">        <span class="keyword">return</span> (edge1.distance - edge2.distance);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化优先队列。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; graph[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (graph[i][j] != INF) &#123;</span><br><span class="line">                edges.add(<span class="keyword">new</span> EdgeInfo(graph[i][j], i, j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!edges.isEmpty()) &#123;</span><br><span class="line">        EdgeInfo tmp = edges.remove();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 边对应的两个顶点不连通，则合并之，同时将该边置于最终结果。</span></span><br><span class="line">        <span class="keyword">if</span> (uf.find(tmp.i) != uf.find(tmp.j)) &#123;</span><br><span class="line">            uf.union(tmp.i, tmp.j);</span><br><span class="line">            result.add(tmp);</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果结果集中已有v.size-1条边，则最小生成树已构建完成，退出循环。</span></span><br><span class="line">        <span class="keyword">if</span> (k == graph.length - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构-LSM树</title>
    <url>/2020/08/26/dataStructure/dataStructure-lsmtree/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>LSM 树</strong> 是一种文件组织数据结构，它常用作非关系型数据库的底层实现 (B+ 树则常用作关系型数据库的底层实现)。</p>
<a id="more"></a>

<p>通常情况下，数据读取需求大于数据写入需求，故而产生了 B+ 树这种文件组织结构。由于物联网地兴起，数据写入需求大于数据读取需求的情况发生，此时如果仍然使用 B+ 树组织文件，则性能较差，故而产生了 LSM 树这种文件组织结构。</p>
<p>我们首先看看磁盘访问性能比较图：</p>
<p><img src="/2020/08/26/dataStructure/dataStructure-lsmtree/16b47414ad22f35a.png" alt="图一：磁盘访问性能比较图"></p>
<p>观察该图，容易得知：磁盘顺序访问性能远大于磁盘随机访问性能，且甚至超越了内存随机访问性能。<strong>正是基于这一点观察，LSM 树将磁盘随机访问操作转换为磁盘顺序访问操作，从而使得随机写操作性能大大提升，与之对应的便是随机读性能有所下降 (可通过布隆过滤器等操作弥补随机读性能)。</strong></p>
<h2 id="LSM-树"><a href="#LSM-树" class="headerlink" title="LSM 树"></a>LSM 树</h2><p><img src="/2020/08/26/dataStructure/dataStructure-lsmtree/v2-37576525d52091fd713bb13556c92861_720w.jpg" alt="图二：LSM树结构"></p>
<p>LSM 树通常由三部分组成：</p>
<ul>
<li><p>memtable</p>
<p>它是位于内存之中的数据结构，用于存储最近更新地数据，而且这些数据按照键值有序排列，故而 memtable 通常表现为红黑树、跳跃表等高效排序结构。</p>
<p>由于内存属于不稳定介质，故而插入元素至 memtable 之前，需通过 WAL(Write-ahead logging) 将其插入至日志之中，以保证数据的可靠性。</p>
</li>
<li><p>immutable memtable</p>
<p>它是位于内存之中、不可修改的数据结构。它是将 memtable 转变为 sstable 的中间状态，其目的在于：转存过程中仍然可以通过 memtable 进行写操作。</p>
</li>
<li><p>sstable</p>
<p>它是有序键值对集合，是位于磁盘之中的数据结构。如果希望加快 sstable 读取性能，可为其建立索引或使用布隆过滤器。</p>
<p><img src="/2020/08/26/dataStructure/dataStructure-lsmtree/v2-9eeda5082f56b1df20fa555d36b0e0ae_720w.png" alt="图三：sstable结构"></p>
</li>
</ul>
<p>接下来简单介绍其上的插入、删除、查询、修改操作。</p>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>为保证数据完整性，首先需要基于 WAL 将数据插入至日志之中，随后将其插入至 memtable 之中。如果 memtable 所存数据量超过阈值，则需要将其转换为 immutable memtable，随后 immutable memtable 又将转存为 sstable。如果 sstable 数量过多，则需要进一步合并 sstable。</p>
<blockquote>
<p>如果单纯仅转存为 sstable，如此将会引入大量 sstable，此时查找性能将大大下降，故而需要根据一定规则适当合并 sstable (<strong>合并规则是 LSM 树的重中之重</strong>)。</p>
</blockquote>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>如果直接删除待删除元素，这样会直接导致磁盘内容发生变更，不利于顺序访问磁盘。</p>
<p>为删除一个元素，我们需要将其关键字及删除标志插入至 LSM 树中。当 sstable 合并时，此时根据删除标志将该元素删去。</p>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>查询操作比较复杂，从上述结构中可以看到：memtable 中数据最新、immutable memtable 中数据其次、sstable 中数据最旧。</p>
<p>当进行查询操作时，我们首先在 memtable 中进行查找，如果找到则返回，否则继续查找 immutable memtable，最后查找 sstable。</p>
<h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><p>与删除操作类似，修改操作亦是基于插入操作实现。</p>
<p>为修改一个元素，我们需要将其关键字及修改内容插入至 LSM 中。当 sstable 合并时，将关键字对应数据内容更新至最新内容即可。</p>
<h2 id="合并策略"><a href="#合并策略" class="headerlink" title="合并策略"></a>合并策略</h2><p>从 LSM 树的各项操作中，可以看到：所有操作中都涉及合并操作，故而合并策略就显得尤为重要。</p>
<p>在介绍合并策略之前，首先介绍三个概念：</p>
<ul>
<li><p>读放大</p>
<p>读取数据时实际读取地数据量大于真正地数据量。例如：在 LSM 树中需要先在 memtable 查看指定关键字是否存在，不存在继续从immutable memtable、sstable 中寻找。</p>
</li>
<li><p>写放大</p>
<p>写入数据时实际写入的数据量大于真正地数据量。例如：在 LSM 树中写入数据引发合并操作，合并操作将会涉及大量写入。</p>
</li>
<li><p>空间放大</p>
<p>数据实际占用的磁盘空间大于真正地数据量。例如：在 LSM 树中，由于删除、修改操作均基于插入实现，故而将会引入大量重复关键字及其对应数据。</p>
</li>
</ul>
<p>接下来我们介绍两种合并策略：size-tiered 和 leveled。</p>
<h3 id="size-tiered"><a href="#size-tiered" class="headerlink" title="size-tiered"></a>size-tiered</h3><p><img src="/2020/08/26/dataStructure/dataStructure-lsmtree/v2-bedb057fde7a4ce4d5be2ea34fe86f59_720w.jpg" alt="图四：size-tiered合并策略"></p>
<p>size-tiered 策略对 sstable 进行分级，如果当前层级 sstable 个数超过阈值，则合并这些 sstable 以得到一个更高层级的 sstable。容易得知：sstable 层级越高，其所含数据越多，对应文件就越大。</p>
<p>在这种策略中，同一层级的 sstable 可以包含具有相同关键字的数据，这使得耗费多余空间且存在过多旧副本，故而其空间放大问题较为严重，同时读放大问题较为严重。相比于下面的 leveled 策略而言，该种策略的写放大问题并不明显。</p>
<blockquote>
<p>当进行合并时，首先顺序读取当前层级 sstable，然后按照外部归并排序操作依次合并，随后将合并结果 sstable 顺序存入磁盘之中。</p>
</blockquote>
<h3 id="leveled"><a href="#leveled" class="headerlink" title="leveled"></a>leveled</h3><p><img src="/2020/08/26/dataStructure/dataStructure-lsmtree/v2-5f8de2e435e979936693631617a60d16_720w.jpg" alt="图五：leveled合并策略"></p>
<p>leveled 策略基于层级文件大小进行分级，每一层级由若干 sstable 组成，而且这些 sstable 有序排列且互相不含相同关键字。</p>
<p>进行合并之时，如果某一层级文件大小超过阈值，则从中选择一个 sstable 并将其与下一层级中与此部分所含关键字存在交集部分的 sstable 合并，随机继续判断当前层级文件大小是否超过阈值，如果超过则继续选择 sstable 进行类似合并操作，否则递归判断下一层级文大小是否超过阈值。</p>
<p><img src="/2020/08/26/dataStructure/dataStructure-lsmtree/v2-663d136cefaaf6f8301833bf29c833e9_720w.jpg" alt="图六：leveled策略举例"></p>
<p>在这种策略中，同一层级的 sstable 不会包含具有相同关键字的数据，故而其空间放大问题及读放大问题得以缓解。但是其合并策略可能使得写放大问题较为严重，例如：某个层级文件大小超过阈值，而且选择合并的 sstable 所含关键字范围几乎囊括下一层级中所有 sstable，此时就涉及极大地写入问题。</p>
<h2 id="LSM-VS-B"><a href="#LSM-VS-B" class="headerlink" title="LSM VS B+"></a>LSM VS B+</h2><p>这里简单比较 LSM 树和 B+ 树：</p>
<ol>
<li>两者均为文件组织数据结构，用于处理大数据存取问题。</li>
<li>前者基于 “磁盘顺序访问性能远大于磁盘随机访问性能，且甚至超越了内存随机访问性能” 观察而产生，后者则基于 “磁盘随机访问性能较差，应当尽可能减少随机访问操作” 观察而产生。</li>
<li>前者适用于写多读少场景，后者则适用于写少读多场景。</li>
</ol>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-R树</title>
    <url>/2020/08/25/dataStructure/dataStructure-rtree/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>R 树</strong> 是一种处理高维空间存储问题的数据结构。值得注意的是：(R 树，B 树) 和 (k-d 树，二叉查找树) 具有类似关系，即前者是后者在高维空间的扩展，不同点在于 R 树是平衡的而 k-d 树是不平衡的。</p>
<a id="more"></a>

<p>虽然网上资料显示 “R 树是 B 树在高维空间的扩展”，但是随着对 R 树的深入了解，我觉得 “R 树应当是 B+ 树在高维空间的扩展”。故而我将以 B+ 树为例引出 R 树。</p>
<p>首先看一个 B+ 树示例：</p>
<p><img src="/2020/08/25/dataStructure/dataStructure-rtree/image-20200825143929462.png" alt="图一：B+树示例"></p>
<p>在 B+ 树中，叶节点存放所有关键字及相应数据；索引节点存放索引关键字，根据这些索引关键字可进一步找到部分关键字及其数据，如此我们可称索引节点掌管若干关键字及其数据。例如：R 节点掌管所有关键字及其数据，其下三个子节点 A、B、C 各掌管 R 节点所掌管关键字及其数据的一部分。当进行查询时，首先在 R 节点处根据索引关键字确定待查找关键字在哪个子节点的掌管范围之内，随后递归到子节点中进行处理，直至到达叶节点。如果叶节点中包含指定关键字，则查询成功，否则查询失败。如此一个查询过程，其本质就是基于索引信息逐步缩减待查找范围。</p>
<p>其次我们看一个高维空间查找示例：如何快速查询中国地图内的某一村庄？最愚蠢的办法就是遍历所有村庄，一一比对。而更为高效地做法便是：首先根据村庄位置信息锁定搜索范围到省、市、县、镇，最后在镇中遍历所有村庄，一一比对。</p>
<p>从上述两个例子中可以看出：无论高维空间查询还是低维空间查询，其本质都是建立数据索引，随后在查找过程中逐步缩减待查找范围 (<strong>所有加快查询速度的数据结构都是这样做的，只不过缩减时所依据的信息不同而已</strong>)。</p>
<p>接下来，简单看看 R 树是如何缩减待查找范围的，这里以二维空间例子说明 (图中仅 R3 区域数据详细标识，其余区域数据直接省略)：</p>
<p><img src="/2020/08/25/dataStructure/dataStructure-rtree/1051369-20170404131434878-399064987.jpg" alt="图二：R树示例"></p>
<p>关于此图，我们可以这样看：所有点散布于平面之上，根据某些规则首先将点划分为块 R8、R9 … R19；在此基础之上，我们划分块为 R3、R4 … R7；更进一步划分块为 R1、R2；最终划分为一个整块。对于点而言，其中保存关键字 (标识为 ${x,y}$) 及其数据信息；对于块而言，其中保存子块索引及当前块所含点的 MBR 位置信息。当进行查询时，根据待查询关键字及块信息，可逐步缩减查询范围至块 R8、R9 … R19 中之一，然后将其中点信息与待查询关键字一一比对，从而判断查询是否成功。</p>
<blockquote>
<p>MBR (Minimum Bounding Retangle)：假定存在若干点，最小限定矩形就是可以包含这些点的最小矩形，它可通过获取所有点的最大最小坐标值得到，假定获取的坐标值依次为 $minX,minY,maxX,maxY$，此时最小限定矩形可表示为 ${(minX,minY),(maxX,maxY)}$。</p>
<p><img src="/2020/08/25/dataStructure/dataStructure-rtree/1051369-20170404131435300-1195117158.jpg" alt="图三：MBR示意图"></p>
</blockquote>
<p>维基百科中并未给出 R 树具体定义。根据所查资料，基本上可以这样说：R 树定义与 B+ 树定义基本一样，二者不同点则在于节点实现。</p>
<blockquote>
<p>下面实现中，我们直接以二维空间中的 R 树为例，以说明各项操作 (不作实现)。当然，二维空间扩展为多维空间是很简单的。</p>
</blockquote>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>在 B+ 树中，节点分为索引节点和叶节点。R 树中亦是如此，故而这里以伪代码形式给出两种节点结构的详细信息 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 索引节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">indexNode</span> <span class="keyword">extends</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 两者综合表征MBR。</span></span><br><span class="line">    <span class="keyword">private</span> Point bottomLeft, TopRight;</span><br><span class="line">    <span class="comment">// 子节点索引。</span></span><br><span class="line">    ArrayList&lt;Node&gt; childrens;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 叶节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">leafNode</span> <span class="keyword">extends</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 两者综合表征MBR。</span></span><br><span class="line">    <span class="keyword">private</span> Point bottomLeft, TopRight;</span><br><span class="line">    <span class="comment">// 两者共同构建键值对。</span></span><br><span class="line">    ArrayList&lt;Ponit&gt; keys;</span><br><span class="line">    ArrayList&lt;value&gt; values;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>查询操作与 B+ 树类似，这里简单描述：</p>
<ol>
<li>置当前子树根节点为 $root$。</li>
<li>如果 $root$ 为索引节点，则一一判断子节点的 MBR 是否与待搜索关键字重合，如果重合则递归处理子节点，并返回递归结果。</li>
<li>如果 $root$ 为叶节点，则一一判断各关键字是否与待搜索关键字相同，如果相同则返回该关键字及相应数据。</li>
</ol>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>插入操作比较复杂，首先简单描述其过程：</p>
<ol>
<li>将待插入关键字及其数据插入至合适的叶节点之中。</li>
<li>如果叶节点所含关键字个数 (或者索引节点所含关键字个数) 大于阈值，则分裂为两个叶节点。父节点中删除原始节点索引，并新建这两个叶节点的节点索引。</li>
<li>如果当前节点发生分裂，则递归处理父节点。</li>
</ol>
<p>关于插入操作，我们需要着重说明两个问题：1. 如何插入至合适叶节点？2. 如何分裂节点？</p>
<ol>
<li><p>如何插入至合适叶节点？</p>
<p>关于这个问题，R 树具体操作方法是十分巧妙的。简要描述如下：</p>
<ul>
<li>如果当前节点为叶节点，则直接插入即可。</li>
<li>如果当前节点为索引节点，则首先更新当前节点的 MBR，随后依次遍历所有子节点，找到添加待插入关键字后使得子节点的 MBR 扩张最小的节点 (如果存在多个，则选择 MBR 面积最小的那个节点)，然后递归处理子节点。</li>
</ul>
<p><img src="/2020/08/25/dataStructure/dataStructure-rtree/image-xxx.png" alt="图三：扩张示意图"></p>
</li>
<li><p>如何分裂节点？</p>
<p>通过执行分裂算法以分裂节点，现有多种分裂算法，最常用地便是二次方方案。</p>
<p>在二次方方案中，首先，它将两重循环遍历所有子节点，对于任意两个子节点 $N1$ 和 $N2$，计算可包裹这两个节点中所有关键字的 MBR，随后计算增量 $d = MBR - N1.MBR - N2.MBR$，接下来找到具有最大增量的两个子节点 (记为 $d1$ 和 $d2$)，并将它们分别放置到分裂后的两个节点之中。最后，对于其余节点而言，如果该节点距离 $d1$ 更近，则将其放置到 $d1$ 所在的分裂节点之中，否则放置到 $d2$ 所在的分裂节点之中。</p>
<p><img src="/2020/08/25/dataStructure/dataStructure-rtree/image-20200826121048565.png" alt="图四：分裂示意图"></p>
<blockquote>
<p>增量越大，表明两个节点的对角线距离越远。选择具有最大增量的两个节点，就是选择对角线距离最大的两个节点，如此操作可尽可能保证分裂后两个节点的 MBR 相交较少。</p>
</blockquote>
</li>
</ol>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>在 B+ 树中，删除指定关键字后，通过借调关键字或合并节点完成调整操作；而在 R 树中，删除指定关键字后，它通过重新插入至 R 树中完成调整操作。具体操作如下：</p>
<ol>
<li>找到待删除关键字所在的叶节点，并将该关键字及其数据从中删除。</li>
<li>如果删除后的叶节点所含关键字 (或者索引节点所含关键字个数) 小于阈值，则将这些关键字及其数据 (或者索引节点) 放置到链表 Q 中，并在父节点中删除对应的节点索引。</li>
<li>递归处理父节点。</li>
<li>经过以上调整之后，将 Q 中所有数据重新插入至 R 树之中。如果数据为关键字及其数据，则按照普通插入操作插入即可；如果数据为索引节点，需要将其插入至原先所在层级，如此做的原因在于保证所有叶节点仍然处于同一层级。</li>
</ol>
<p><img src="/2020/08/25/dataStructure/dataStructure-rtree/image-20200826123646166.png" alt="图五：删除图例"></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-字符串匹配(三)</title>
    <url>/2020/08/20/algorithm/algorithm-stringmatch3/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Sunday 算法是一种经典地字符串匹配算法。它通过简化 BM 算法操作而成，并且实践证明：Sunday 算法查询性能好于 BM 算法，故而该种算法在字符串匹配问题上应用最为广泛。 </p>
 <a id="more"></a>

<p>我们首先简单回顾一下 BM 算法：它采用从后往前方式比较字符，使用坏字符规则和好后缀规则实现跳跃无效匹配。值得注意的是：BM 算法实践之中，有人统计发现：绝大多数地跳跃操作均来自于坏字符规则。另外，由于好后缀表构造比较麻烦而坏字符表构造简单，所以就提出了一种 BM 算法阉割版——仅使用坏字符规则实现跳跃。</p>
<p>Sunday 算法就属于 BM算法阉割版地一种，但是它对坏字符规则进行了修改：在 BM 算法中，匹配失败的字符称为坏字符；而在 Sunday 算法中，匹配失败时参与匹配的最末位字符的下一位字符称为坏字符。举例而言：对于 BM 算法而言，图中 <code>text[1] = &#39;u&#39;</code> 属于坏字符；对于 Sunday 算法而言，图中 <code>text[6] = &#39;i&#39;</code> 属于坏字符。</p>
<p><img src="/2020/08/20/algorithm/algorithm-stringmatch3/image-20200820223650493.png" alt="图一：坏字符归属"></p>
<p>正是由于这样地修改，使得 Sunday 算法并不局限于从后往前比较字符，它同样可以采用从前往后比较字符。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>BM 已然实现，这种实现就比较简单。其实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] genBc(String pattern) &#123;</span><br><span class="line">    <span class="comment">// 假定所有字符均为ascii，如果存在其他字符，这里也可使用map加以实现。</span></span><br><span class="line">    <span class="keyword">int</span>[] bc = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">    <span class="comment">// 初始化为-1，表示未曾出现。</span></span><br><span class="line">    Arrays.fill(bc, -<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从前往后，根据字符信息覆盖数组该位置原始信息。</span></span><br><span class="line">    <span class="comment">// 正是如此操作，才可保证所存位置信息均为对应字符的最右侧位置。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pattern.length(); i++) &#123;</span><br><span class="line">        bc[pattern.charAt(i)] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> bc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">match</span><span class="params">(String text, String pattern)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">int</span>[] bc = genBc(pattern);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= text.length() - pattern.length(); ) &#123;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="comment">// 尝试匹配pattern与text[i,i+pattern.length()]</span></span><br><span class="line">        <span class="keyword">for</span> (j = pattern.length() - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; text.charAt(i + j) == pattern.charAt(j); j--);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// j=-1表明完全匹配成功，退出即可。</span></span><br><span class="line">        <span class="keyword">if</span> (j == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 匹配失败，如果坏字符不存在，则直接返回-1。</span></span><br><span class="line">        <span class="keyword">if</span> (i + pattern.length() &gt;= text.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 获取坏字符，并根据坏字符规则确定移动步数。</span></span><br><span class="line">            i += (pattern.length() - bc[text.charAt(i + pattern.length())]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="时空复杂度"><a href="#时空复杂度" class="headerlink" title="时空复杂度"></a>时空复杂度</h3><p>理论证明：最坏时间复杂度为 $O(text.length * pattern.length)$，平均时间复杂度为 $O(text.length)$，空间复杂度为 $O(pattern.length)$。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>字符串匹配</category>
      </categories>
      <tags>
        <tag>Sunday</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-字符串匹配(二)</title>
    <url>/2020/08/20/algorithm/algorithm-stringmatch2/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>BM 算法是一种经典地字符串匹配算法，而且实践证明：该算法比 KMP 算法匹配性能快 $3$ ~ $5$ 倍，故而文本编辑器的 “查询” 功能通常基于此算法实现。</p>
 <a id="more"></a>

<p>在 KMP 算法中，文本串 <code>text</code> 与模式串 <code>pattern</code> 中字符采用从前往后方式进行比较。而在 BM 算法中，文本串 <code>text</code> 与模式串 <code>pattern</code> 中字符采用从后往前方式进行比较，其原因在于：1. 当采用从前往后方式比较时，如果第一个字符匹配失败，则 <code>text</code> 仅能前进一步 (即 <code>i = i + 1</code>)；当采用从后往前方式比较时，如果最后一个字符匹配失败，则 <code>text</code> 可前进 <code>pattern.length()</code> 步 (即 <code>i = i + pattern.length()</code> ) 。故而采用从后往前方式比较可取得更大的前进步数。2. 采用从后往前方式比较，存在多种事实规则以跳过无效匹配。</p>
<p>接下来，我们将首先给出从后往前比较字符以实施匹配字符串的算法，随后在此基础之上介绍 BM 算法。</p>
<h2 id="基础算法"><a href="#基础算法" class="headerlink" title="基础算法"></a>基础算法</h2><p>从后往前比较字符以实现字符串匹配算法，其实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">match</span><span class="params">(String text, String pattern)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; text.length() - pattern.length(); ) &#123;</span><br><span class="line">            <span class="comment">// 尝试匹配pattern与text[i,i+pattern.length()]</span></span><br><span class="line">            <span class="keyword">for</span> (j = pattern.length() - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; text.charAt(i + j) == pattern.charAt(j); j--);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// j=-1表明完全匹配成功，退出即可。</span></span><br><span class="line">            <span class="keyword">if</span> (j == -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 移动一步。</span></span><br><span class="line">            i += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="BM-算法"><a href="#BM-算法" class="headerlink" title="BM 算法"></a>BM 算法</h2><p>BM 算法对基础算法的修改点就在于：基于某些事实规则尽可能多地移动步数 ( 即<code>i += ?</code> )。</p>
<p>BM 算法中，存在两种事实规则 —— 坏字符规则和好后缀规则 (详细内容可参见 <a href="https://www.ruanyifeng.com/blog/2013/05/boyer-moore_string_search_algorithm.html">字符串匹配的Boyer-Moore算法</a>)。</p>
<p>当 <code>text</code> 与 <code>pattern</code> 中字符匹配失败时，根据两种规则计算移动步数，随后根据二者大者进行移动，然后继续进行匹配。</p>
<h3 id="坏字符表"><a href="#坏字符表" class="headerlink" title="坏字符表"></a>坏字符表</h3><p>坏字符表用于实现坏字符规则，它是一个数组 <code>bc[]</code>，其中 <code>bc[i]</code> 具有如下含义：<code>bc[i]</code> 所示字符在 <code>pattern</code> 中最右侧出现位置。</p>
<p>坏字符表实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] genBc(String pattern) &#123;</span><br><span class="line">    <span class="comment">// 假定所有字符均为ascii，如果存在其他字符，这里也可使用map加以实现。</span></span><br><span class="line">    <span class="keyword">int</span>[] bc = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">    <span class="comment">// 初始化为-1，表示未曾出现。</span></span><br><span class="line">    Arrays.fill(bc, -<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从前往后，根据字符信息覆盖数组该位置原始信息。</span></span><br><span class="line">    <span class="comment">// 正是如此操作，才可保证所存位置信息均为对应字符的最右侧位置。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pattern.length(); i++) &#123;</span><br><span class="line">        bc[pattern.charAt(i)] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> bc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="好后缀表"><a href="#好后缀表" class="headerlink" title="好后缀表"></a>好后缀表</h3><p>好后缀表用于实现好后缀规则，它由两个数组组成，一个是 <code>suffix[]</code>，其中 <code>suffix[k]</code> 具有如下含义：长度为 $k$ 的后缀在 <code>pattern</code> 中出现时其首字母位置下标，一个是 <code>prefix[]</code>，其中 <code>prefix[k]</code> 具有如下含义：长度为 $k$ 的后缀是否存在一个相同的前缀。</p>
<p>此时重点就在于：如何根据 <code>pattern</code> 求取 <code>suffix[]</code> 和 <code>prefix[]</code>。求取方式十分巧妙：遍历 <code>pattern</code> 的所有真前缀，随后求取真前缀与 <code>pattern</code> 的公共后缀。在求取公共后缀过程中，我们可以动态得到这两个数组。具体参见如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">genGs</span><span class="params">(String pattern, <span class="keyword">int</span>[] suffix, <span class="keyword">boolean</span>[] prefix)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化。</span></span><br><span class="line">    Arrays.fill(suffix, -<span class="number">1</span>);</span><br><span class="line">    Arrays.fill(prefix, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有真前缀与pattern匹配</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pattern.length() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = i;</span><br><span class="line">        <span class="comment">// k表示已匹配字符串长度</span></span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 真前缀与pattern从后往前匹配各个字符。</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; pattern.charAt(j) == pattern.charAt(pattern.length() - <span class="number">1</span> - j)) &#123;</span><br><span class="line">            <span class="comment">// 匹配成功则k++</span></span><br><span class="line">            k++;</span><br><span class="line">            <span class="comment">// 根据suffix定义可设置该值。</span></span><br><span class="line">            suffix[k] = j;</span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// j=-1表明真前缀与某个后缀相同，则可设置prefix为true。</span></span><br><span class="line">        <span class="keyword">if</span> (j == -<span class="number">1</span>) &#123;</span><br><span class="line">            prefix[k] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="匹配过程"><a href="#匹配过程" class="headerlink" title="匹配过程"></a>匹配过程</h3><p>BM 匹配过程十分简单，就是根据匹配失败位置及两种规则计算移动步数，随后选择大者进行移动即可。具体实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">moveByGs</span><span class="params">(<span class="keyword">int</span>[] suffix, <span class="keyword">boolean</span>[] prefix, <span class="keyword">int</span> j, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 确定好后缀长度</span></span><br><span class="line">    <span class="keyword">int</span> k = length - <span class="number">1</span> - j;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果出现相同后缀，则根据其首字母位置计算步数。</span></span><br><span class="line">    <span class="keyword">if</span> (suffix[k] != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> j + <span class="number">1</span> - suffix[k];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果存在与好后缀相同的前缀，则根据前缀计算步数。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> r = k - <span class="number">1</span>; r &gt;= <span class="number">1</span>; r--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prefix[r]) &#123;</span><br><span class="line">            <span class="keyword">return</span> length - r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 否则，直接设移动步数为length。</span></span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BM</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">match</span><span class="params">(String text, String pattern)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">int</span>[] bc = genBc(pattern);</span><br><span class="line">    <span class="keyword">int</span>[] suffix = <span class="keyword">new</span> <span class="keyword">int</span>[pattern.length() + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">boolean</span>[] prefix = <span class="keyword">new</span> <span class="keyword">boolean</span>[pattern.length() + <span class="number">1</span>];</span><br><span class="line">    genGs(pattern, suffix, prefix);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt;= text.length() - pattern.length(); ) &#123;</span><br><span class="line">        <span class="comment">// 尝试匹配pattern与text[i,i+pattern.length()]</span></span><br><span class="line">        <span class="keyword">for</span> (j = pattern.length() - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; text.charAt(i + j) == pattern.charAt(j); j--);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// j=-1表明完全匹配成功，退出即可。</span></span><br><span class="line">        <span class="keyword">if</span> (j == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 基于坏字符规则确定需要移动的步数</span></span><br><span class="line">        <span class="keyword">int</span> x = j - bc[text.charAt(i + j)];</span><br><span class="line">        <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 如果存在好后缀，则基于好后缀规则确定需要移动的步数。</span></span><br><span class="line">        <span class="keyword">if</span> (j &lt; pattern.length() - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 基于好后缀计算移动步数比较复杂，故而需要封装为函数。</span></span><br><span class="line">            y = moveByGs(suffix, prefix, j, pattern.length());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取最大移动步数。</span></span><br><span class="line">        i += Math.max(x, y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="时空复杂度"><a href="#时空复杂度" class="headerlink" title="时空复杂度"></a>时空复杂度</h3><p>理论证明：最坏时间复杂度为 $O(text.length + pattern.length)$，最好时间复杂度为 $O(text.length)$，空间复杂度为 $O(pattern.length)$。</p>
<h3 id="与-KMP-比较"><a href="#与-KMP-比较" class="headerlink" title="与 KMP 比较"></a>与 KMP 比较</h3><p>简单说明 KMP 与 BM 匹配算法的异同点：</p>
<ol>
<li>两种算法均基于某些事实规则以跳跃无效匹配。</li>
<li>在 KMP 算法中，基于相同前后缀实施跳跃；在 BM 中，基于坏字符规则和好后缀规则实施跳跃，并且好后缀规则中包含了相同前后缀。</li>
<li>在 KMP 算法中，从前往后匹配 <code>text</code> 与 <code>pattern</code> 中字符；在 BM 算法中，从后往前匹配 <code>text</code> 与 <code>pattern</code> 中字符。</li>
<li>在 KMP 算法中，主要移动 <code>pattern</code> ；在 BM 算法中，主要移动 <code>text</code>。</li>
</ol>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>字符串匹配</category>
      </categories>
      <tags>
        <tag>BM</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-字符串匹配(一)</title>
    <url>/2020/08/20/algorithm/algorithm-stringmatch1/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>字符串匹配：判断模式串 <code>pattern</code> 是否出现于文本串 <code>text</code> 之中。常见匹配算法有：BF、KMP、BM、Sunday。</p>
 <a id="more"></a>

<p>字符串匹配算法构建十分精妙，往往难于理解，因此我们将通过三篇文章详细介绍字符串匹配算法。第一篇文章介绍 BF 和 KMP 算法，第二篇文章介绍 BM 算法，第三篇文章介绍 Sunday 算法。</p>
<h2 id="BF-算法"><a href="#BF-算法" class="headerlink" title="BF 算法"></a>BF 算法</h2><p>BF 全称为 Brute Force，即暴力匹配字符串——遍历 <code>text</code> 所有子串，将其与 <code>pattern</code> 进行匹配，其实现如下： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">match</span><span class="params">(String text, String pattern)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; text.length() - pattern.length(); i++)  &#123;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; pattern.length(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (text.charAt(i + j) != pattern.charAt(j)) &#123;</span><br><span class="line">                flag = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析上述代码，容易得知：BF 算法的时间复杂度为 $O(text.length * pattern.length)$，空间复杂度为 $O(1)$。</p>
<h2 id="KMP-算法"><a href="#KMP-算法" class="headerlink" title="KMP 算法"></a>KMP 算法</h2><p>BF 算法匹配过程十分粗暴，致使匹配效率过低。那么不由得思考：是否能够借助某些技巧加快匹配过程？换言之，是否能够借助某些事实以尽可能多地跳过无效匹配？</p>
<p>我们首先看一个字符串匹配示例：</p>
<p><img src="/2020/08/20/algorithm/algorithm-stringmatch1/bg2013050107.png" alt="图一：字符串匹配示例"></p>
<p>此时 <code>text[10] != pattern[6]</code>，故而需要重新匹配。如果按照 BF 算法的尿性，它会置 $i = 5, j = 0$ 并重新匹配 <code>pattern</code>。</p>
<p>我们简单观察字符串 <code>pattern</code> ，可以发现未匹配字符 <code>D</code> 之前的子串 <code>ABCDAB</code> 具有一个性质：前缀 <code>AB</code> 与后缀 <code>AB</code> 相同。另外，观察 <code>text</code>，可以发现 <code>text[10]</code> 之前的子串就是 <code>ABCDAB</code> (原因十分简单：这部分属于匹配成功部分)。</p>
<p><strong>综合这二者观察，我们可以这样执行重新匹配操作：$i$ 标识下标保持不变，置 $j = 2$ (之所以能够置为 2，原因在于：<code>text</code> 未匹配字符之前的内容是 <code>AB</code> (对应 <code>pattern</code> 后缀)，<code>pattern</code> 开始的内容也是 <code>AB</code> (对应 <code>pattern</code> 前缀)，二者相同故无需再次匹配)。</strong>  这基本就是 KMP 的思想 —— 借助于相同的前后缀以跳过无效匹配。</p>
<p>在 KMP 中，跳转操作是基于 <code>next[]</code> 实现的，其中 <code>next[j]</code> 具有如下含义：如果 <code>pattern[j]</code> 与 <code>text[i]</code> 匹配失败，则 <code>j</code> 需赋值为 <code>next[j]</code>，随后与 <code>text[i]</code> 再次匹配。如果 <code>next[j] = -1</code>，此时需要置 <code>i = i + 1, j = 0</code>，并重新开始匹配。</p>
<h3 id="匹配过程"><a href="#匹配过程" class="headerlink" title="匹配过程"></a>匹配过程</h3><p>我们将基于例子说明 KMP 匹配过程，随后给出 KMP 匹配代码 (这里先不指明 <code>next</code> 如何求取)。</p>
<p>初始状态：</p>
<p><img src="/2020/08/20/algorithm/algorithm-stringmatch1/image-20200820175009712.png"></p>
<p><code>text[0] != pattern[0]</code>，则 <code>j = next[j] = -1</code>，因为 <code>next[j] = -1</code>，故而需要执行 <code>i = i + 1, j = 0</code> ：</p>
<p><img src="/2020/08/20/algorithm/algorithm-stringmatch1/image-20200820175256179.png"></p>
<p><code>text[1,2,3] = pattern[0,1,2]</code>，则继续比较下一位：</p>
<p><img src="/2020/08/20/algorithm/algorithm-stringmatch1/image-20200820175437260.png"></p>
<p><code>text[4] != pattern[3]</code>，则 <code>j = next[j] = 1</code> ：</p>
<p><img src="/2020/08/20/algorithm/algorithm-stringmatch1/image-20200820175618987.png"></p>
<p><code>text[4] != pattern[1] </code>，则 <code>j = next[j] = 0</code> ：</p>
<p><img src="/2020/08/20/algorithm/algorithm-stringmatch1/image-20200820175949982.png"></p>
<p><code>text[4] != pattern[0]</code>，则 <code>j = next[j] = -1</code>，因为 <code>next[j] = -1</code>，故而需要执行 <code>i = i + 1, j = 0</code> ：</p>
<p><img src="/2020/08/20/algorithm/algorithm-stringmatch1/image-20200820180049495.png"></p>
<p><code>text[5,6,7,8] = pattern[0,1,2,3]</code> ，匹配成功。</p>
<p>根据上述过程，可以知道：在 KMP 匹配过程中，<code>i</code> 总是向前行进地，<code>j</code> 则随 <code>next[]</code> 进行调整。</p>
<p>KMP 匹配实现代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">match</span><span class="params">(String text, String pattern)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取next[]。</span></span><br><span class="line">    <span class="keyword">int</span>[] next = getNext(pattern);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; text.length(); ) &#123;</span><br><span class="line">        <span class="comment">// j=-1或者字符匹配成功，i,j均加一。</span></span><br><span class="line">        <span class="keyword">if</span> (j == -<span class="number">1</span> || text.charAt(i) == pattern.charAt(j)) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 字符匹配失败，j根据next[]进行调整。</span></span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 表明pattern中所有字符均已匹配，则返回匹配字符子串的开始位置。</span></span><br><span class="line">        <span class="keyword">if</span> (j == pattern.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> i - j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 匹配失败，返回-1。</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="next-求取"><a href="#next-求取" class="headerlink" title="next 求取"></a>next 求取</h3><p><code>next[]</code> 求取过程比较复杂，我们直接给代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] getNext(String pattern) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[pattern.length()];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化。</span></span><br><span class="line">    next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = -<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (i &lt; next.length - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == -<span class="number">1</span> || pattern.charAt(i) == pattern.charAt(j)) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            next[i] = j;</span><br><span class="line">            <span class="comment">// 这几行注释代码是对 next[i]=j 的进一步优化。</span></span><br><span class="line">            <span class="comment">// next[j]表示匹配失败时需要重新匹配的下标位置。如果i,j所在字符相同，则当i所示字符与text中指定字符匹配失败时，重新匹配下标位置j也一定会匹配失败，故而这里直接赋值next[j]。</span></span><br><span class="line">            <span class="comment">// if (pattern.charAt(i) == pattern.charAt(j)) &#123;</span></span><br><span class="line">            <span class="comment">//     next[i] = next[j];</span></span><br><span class="line">            <span class="comment">// &#125; else &#123;</span></span><br><span class="line">            <span class="comment">//     next[i] = j;</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果 <code>next</code> 求取实现代码看不懂，可以先看一下 <a href="https://oi-wiki.org/string/kmp/">优化求解前缀函数</a>。</p>
</blockquote>
<h3 id="时空复杂度"><a href="#时空复杂度" class="headerlink" title="时空复杂度"></a>时空复杂度</h3><p>理论证明：时间复杂度为 $O(text.length + pattern.length)$，空间复杂度为 $O(pattern.length)$。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>字符串匹配</category>
      </categories>
      <tags>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-排序</title>
    <url>/2020/08/17/algorithm/algorithm-sort/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>排序算法</strong> 用于将无序数组转换为有序数组。常见排序算法有：冒泡排序、选择排序、插入排序、希尔排序、归并排序、快速排序、堆排序、计数排序、桶排序、基数排序。</p>
<a id="more"></a>

<p>我们将实现上述常见排序算法，并给出相应算法的时间复杂度、空间复杂度及稳定性。</p>
<blockquote>
<ul>
<li><p>假定待排序数组中存在关键字相同的元素，我们使用排序算法排序该数组。如果排序前后，具有相同关键字的元素在数组中相对顺序保持不变，则该排序算法是稳定的。举例：以数组元素的第一个值为关键字排序数组 $a = [[1,11],[2,22],[1,9]]$，如果排序算法稳定，则排序结果中元素 $[1,11]$ 总是在元素 $[1,9]$ 之前。</p>
</li>
<li><p>假定我们需要基于多关键字 $[a,b,c]$ 排序待排序数组，通常做法就是重新编写比较函数。如果一个排序算法是稳定的，我们还可以这样做：首先基于关键字 $a$ 排序待排序数组，随后基于关键字 $b$ 排序待排序数组，最后基于关键字 $c$ 排序待排序数组。</p>
</li>
<li><p>冒泡排序、选择排序、插入排序、希尔排序、归并排序、快速排序、堆排序均基于比较元素实现排序，计数排序、桶排序、基数排序则不是如此。</p>
</li>
</ul>
</blockquote>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>实现各排序算法之前，首先做如下声明：</p>
<ol>
<li>为简化实现流程，假定数组元素中仅有关键字一项内容。</li>
<li>所有排序算法按照从小到大进行排序。</li>
</ol>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>冒泡排序的思想在于：遍历未排序部分数组，如果当前元素关键字大于下一个元素关键字，则交换二者，如此操作会将未排序部分数组中含最大关键字的元素逐步交换 (冒泡) 至排序部分数组首部/未排序部分数组尾部。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(Integer[] objects)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 每次循环可冒泡一个元素。为实现排序，只需冒泡objects.length-1次即可。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; objects.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 遍历未排序部分数组。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; objects.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="comment">// 相邻元素关键字大小关系不符递增要求，则交换二者。</span></span><br><span class="line">            <span class="keyword">if</span> (objects[j] &gt; objects[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                Integer tmp = objects[j];</span><br><span class="line">                objects[j] = objects[j + <span class="number">1</span>];</span><br><span class="line">                objects[j + <span class="number">1</span>] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>时间复杂度</p>
<p>排序算法使用双重循环，而且每次循环所需 $O(N)$ 时间，故而该算法的时间复杂度为 $O(N^2)$。</p>
</li>
<li><p>空间复杂度</p>
<p>排序算法需要一个额外空间以实现元素交换，故而该算法的空间复杂度为 $O(1)$。</p>
</li>
<li><p>稳定性</p>
<p>代码实现中，只有当前元素关键字大于下一个元素关键字，元素交换才会发生。如果当前元素关键字等于下一个元素关键字，交换不会发生，从而保证具有相同关键字元素之间的相对顺序保持不变，故而该算法是稳定的。</p>
</li>
</ul>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>选择排序的思想在于：遍历未排序部分数组，将其中含最小关键字的元素置于排序部分数组尾部。</p>
<p>选择排序与冒泡排序的区别有两点：</p>
<ol>
<li>选择排序的排序部分数组位于未排序部分数组的前方，冒泡排序则正好相反。</li>
<li>选择排序将含最小关键字的元素置于排序部分数组尾部，冒泡排序则是将含最大关键字的元素置于排序部分数组首部。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(Integer[] objects)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 每次循环排序一个元素。为实现排序，只需循环objects.length-1次即可。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; objects.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 记录当前位置下标。</span></span><br><span class="line">        <span class="keyword">int</span> k = i;</span><br><span class="line">        <span class="comment">// 遍历未排序部分数组，获取具有最小关键字的元素下标。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; objects.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (objects[j] &lt; objects[k]) &#123;</span><br><span class="line">                k = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果当前位置与具有最小关键字的元素位置不同，则需交换二者(以此实现插入含最小关键字的元素至排序部分数组尾部)。</span></span><br><span class="line">        <span class="keyword">if</span> (k != i) &#123;</span><br><span class="line">            Integer tmp = objects[i];</span><br><span class="line">            objects[i] = objects[k];</span><br><span class="line">            objects[k] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>时间复杂度</p>
<p>排序算法使用双重循环，而且每次循环所需 $O(N)$ 时间，故而该算法的时间复杂度为 $O(N^2)$。</p>
</li>
<li><p>空间复杂度</p>
<p>排序算法需要两个额外空间，一个用于记录当前位置下标，一个用于实现元素交换，故而该算法的空间复杂度为 $O(1)$。</p>
</li>
<li><p>稳定性</p>
<p>代码实现中，从前往后遍历未排序部分数组以获取具有最小关键字的元素下标，并且只有当前元素的关键字小于当前最小关键字时才更新具有最小关键字的元素下标，如此两项操作足以保证具有相同关键字元素之间的相对顺序保持不变，故而该算法是稳定的。</p>
</li>
</ul>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>插入排序的思想在于：将未知元素依次插入至排序部分数组之中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(Integer[] objects)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将未知元素插入至排序部分数组之中，故而从下标1处开始即可。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; objects.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 获取未知元素。</span></span><br><span class="line">        Integer item = objects[i];</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 寻找插入位置，并插入。</span></span><br><span class="line">        <span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (objects[j] &gt; item) &#123;</span><br><span class="line">                objects[j + <span class="number">1</span>] = objects[j];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        objects[j + <span class="number">1</span>] = item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>时间复杂度</p>
<p>排序算法使用双重循环，而且每次循环所需 $O(N)$ 时间，故而该算法的时间复杂度为 $O(N^2)$。</p>
</li>
<li><p>空间复杂度</p>
<p>排序算法需要两个额外空间，一个用于记录未知元素，一个用于记录插入位置，故而该算法的空间复杂度为 $O(1)$。</p>
</li>
<li><p>稳定性</p>
<p>寻找插入位置的代码实现中，只有当前元素的关键字大于未知元素的关键字，才将当前元素后移一位。另外，所有元素采用从前往后顺序依次插入。如此两项操作足以保证具有相同关键字元素之间的相对顺序保持不变，故而该算法是稳定的。</p>
</li>
</ul>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>希尔排序是插入排序的一种改进版本。在插入排序中，为将未知元素插入至排序部分数组，我们需要按位后移元素。如果未知元素位于排序部分数组前部，则其所需后移元素过多。在希尔排序中，它基于步长将数组划分为若干子数组，对子数组实行插入排序，此时基于步长可将元素快速放至合适位置，最后通过逐步减少步长到1实现整个数组的排序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 开始位置为begin，步长为k所构建的子数组进行排序(过程类似插入排序)。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">shell</span><span class="params">(Integer[] objects, <span class="keyword">int</span> begin, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = begin; i &lt; objects.length; i = i + k) &#123;</span><br><span class="line">        Integer item = objects[i];</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">for</span> (j = i - k; j &gt;= <span class="number">0</span>; j = j - k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (objects[j] &gt; item) &#123;</span><br><span class="line">                objects[j + k] = objects[j];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        objects[j + k] = item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(Integer[] objects)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义步长数组，最后一个元素一定为1。</span></span><br><span class="line">    <span class="keyword">int</span>[] steps = &#123;<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="comment">// 逐步缩小步长。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; steps.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 按照步长对所有子数组进行插入排序。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; steps[i]; j++) &#123;</span><br><span class="line">            shell(objects, j, steps[i]);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>时间复杂度</p>
<p>其复杂度分析比较困难，而且不同步长具有不同的时间复杂度。这里给出一个大致的时间复杂度：$O(N^{3/2})$。</p>
</li>
<li><p>空间复杂度</p>
<p>基本与插入排序相同，故而该算法的空间复杂度为 $O(1)$。</p>
</li>
<li><p>稳定性</p>
<p>子数组排序过程可保证具有相同关键字元素之间的相对顺序保持不变。如果具有相同关键字的元素位于不同子数组之中，元素之间的相对顺序则难以保证，故而该算法是不稳定的。</p>
</li>
</ul>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>归并排序的思想在于：基于分治思想将未排序数组划分为若干子数组，排序子数组后依次合并各个子数组，从而得到整个数组的排序结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 递归合并objects[l,r]中元素。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(Integer[] objects, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 仅有一个元素，无需合并，直接返回即可。</span></span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取中间位置，递归合并左右部分子数组。</span></span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    merge(objects, l, mid);</span><br><span class="line">    merge(objects, mid + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 借助临时数组合并两个子数组。</span></span><br><span class="line">    Integer[] tmp = <span class="keyword">new</span> Integer[objects.length];</span><br><span class="line">    <span class="keyword">int</span> index1 = l, index2 = mid + <span class="number">1</span>, index3 = l;</span><br><span class="line">    <span class="keyword">for</span> (; index1 &lt;= mid &amp;&amp; index2 &lt;= r;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (objects[index1] &lt;= objects[index2]) &#123;</span><br><span class="line">            tmp[index3++] = objects[index1++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tmp[index3++] = objects[index2++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (index1 &lt;= mid) &#123;</span><br><span class="line">        tmp[index3++] = objects[index1++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (index2 &lt;= r) &#123;</span><br><span class="line">        tmp[index3++] = objects[index2++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制临时数组中内容至objects。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">        objects[i] = tmp[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(Integer[] objects)</span> </span>&#123;</span><br><span class="line">    merge(objects, <span class="number">0</span>, objects.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>时间复杂度</p>
<p>记归并排序的时间复杂度为 $T(N)$，其中 $N$ 为待排序数组长度。</p>
<p>根据递归过程，我们可得到：$T(N) = 2 \times T(N/2) + N$。求解该式，最终将得到：$T(N) = Nlog^N$。故而该算法的时间复杂度为 $O(Nlog^N)$。</p>
</li>
<li><p>空间复杂度</p>
<p>排序算法需要一个额外数组空间用于合并子数组、若干额外空间用于记录下标位置。故而该算法的空间复杂度为 $O(N)$。</p>
</li>
<li><p>稳定性</p>
<p>代码实现中，子数组合并过程可以保证具有相同关键字元素之间的相对顺序保持不变，故而该算法是稳定的。</p>
</li>
</ul>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>快速排序的思想在于：每个过程将数组中一个元素放置到正确位置 (即其前方元素的关键字均小于该元素的关键字，其后方元素的关键字均大于该元素的关键字)，随后递归处理左半部分和右半部分即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 递归排序objects[l,r]中元素。(这是一个快排模板)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quick</span><span class="params">(Integer[] objects, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 仅有一个元素，无需排序，直接返回即可。</span></span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>;</span><br><span class="line">    Integer x = objects[(l + r) &gt;&gt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调整元素顺序，使得x之前元素关键字均小于其关键字，x之后元素关键字均大于其关键字。</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">while</span> (objects[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125; <span class="keyword">while</span> (objects[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">            Integer tmp = objects[i];</span><br><span class="line">            objects[i] = objects[j];</span><br><span class="line">            objects[j] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归处理左右部分。</span></span><br><span class="line">    quick(objects, l, j);</span><br><span class="line">    quick(objects, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(Integer[] objects)</span> </span>&#123;</span><br><span class="line">    quick(objects, <span class="number">0</span>, objects.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>时间复杂度</p>
<p>记快速排序的时间复杂度为 $T(N)$，其中 $N$ 为待排序数组长度。</p>
<p>根据递归过程，我们可得到：$T(N) = 2 \times T(N/2) + N$。求解该式，最终将得到：$T(N) = Nlog^N$。故而该算法的时间复杂度为 $O(Nlog^N)$。</p>
</li>
<li><p>空间复杂度</p>
<p>排序算法需要若干额外空间用于记录下标位置，故而该算法的空间复杂度为 $O(1)$。</p>
</li>
<li><p>稳定性</p>
<p>调整元素顺序的代码实现中，交换元素将会使得位于后面的元素被放置到前方，这种操作无法保证具有相同关键字的元素之间相对顺序保持不变，故而该算法是不稳定的。</p>
</li>
</ul>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>堆排序借助于堆数据结构实现排序数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调整index位置元素至堆中合适位置(堆结构从数组下标0开始，故而左儿子为2*index+1，右儿子为2*index+2)。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">heap</span><span class="params">(Integer[] objects, <span class="keyword">int</span> index, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    Integer x = objects[index];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 寻找合适位置。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span> * index + <span class="number">1</span>; j &lt;= end; j = <span class="number">2</span> * j + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j &lt; end &amp;&amp; objects[j] &lt; objects[j + <span class="number">1</span>]) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (objects[j] &gt; x) &#123;</span><br><span class="line">            objects[index] = objects[j];</span><br><span class="line">            index = j;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 填入原本index位置的值。</span></span><br><span class="line">    objects[index] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 堆排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(Integer[] objects)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 建堆过程。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = objects.length / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        heap(objects, i, objects.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每次循环将堆顶元素与堆数组中最后一个元素交换，随后堆数组长度减一并调整堆顶元素。当堆数组长度为1时，该数组就是递增的。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = objects.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        Integer tmp = objects[<span class="number">0</span>];</span><br><span class="line">        objects[<span class="number">0</span>] = objects[i];</span><br><span class="line">        objects[i] = tmp;</span><br><span class="line"></span><br><span class="line">        heap(objects, <span class="number">0</span>, i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>时间复杂度</p>
<p>堆是一棵完全二叉树，其树高为 $O(log^N)$，故而 <code>heap()</code> 的时间复杂度为 $O(log^N)$。</p>
<p>建堆过程的时间复杂度为 $O(N)$，循环操作的时间复杂度为 $O(Nlog^N)$，故而该算法的时间复杂度为 $O(N + Nlog^N) = O(Nlog^N)$。</p>
</li>
<li><p>空间复杂度</p>
<p>排序算法需要若干额外空间用于记录下标位置，故而该算法的空间复杂度为 $O(1)$。</p>
</li>
<li><p>稳定性</p>
<p>与快速排序类似，由于元素交换存在跳跃性，排序算法无法保证具有相同关键字的元素之间相对顺序保持不变，故而该算法是不稳定的。</p>
</li>
</ul>
<h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><p>计数排序的思想在于：使用额外数组统计待排序数组中各元素出现次数，遍历额外数组将各元素按照出现次数输出，输出结果便是排序结果。</p>
<p>计数排序的代码实现与思想描述有些差别，原因在于：代码实现考虑了稳定性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countSort</span><span class="params">(Integer[] objects)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构建额外数组，它指代关键字数据范围。</span></span><br><span class="line">    Integer[] count = <span class="keyword">new</span> Integer[MAX];</span><br><span class="line">    Arrays.fill(count, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 构建临时数组，用于存放排序结构。</span></span><br><span class="line">    Integer[] sorted = <span class="keyword">new</span> Integer[objects.length];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计关键字出现次数。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; objects.length; i++) &#123;</span><br><span class="line">        count[objects[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建前缀值，此时count[i]表示i应当位于元素数组中的下标位置(此部分作用类似于基数排序)。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; count.length; i++) &#123;</span><br><span class="line">        count[i] += count[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据count[i]将原始数组中元素依次放入到临时数组之中(必须为逆序放入)。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = objects.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        sorted[--count[objects[i]]] = objects[i];</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 拷贝排序结果至原始数组。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; objects.length; i++) &#123;</span><br><span class="line">        objects[i] = sorted[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>时间复杂度</p>
<p>排序算法的时间复杂度依赖于额外数组 (即关键字数据范围)，我们假定其长度为 $M$。</p>
<p>排序算法实现中，多次需要遍历额外数组及原始数组。通常关键字数据范围远大于数组元素个数，故而该算法的时间复杂度为 $O(M + N) \approx O(M)$ 。</p>
</li>
<li><p>空间复杂度</p>
<p>排序算法的空间复杂度同样依赖于额外数组，故而该算法的空间复杂度为 $O(M)$。</p>
</li>
<li><p>稳定性</p>
<p>该算法是稳定的，其稳定性基于此实现——根据前缀值将原始数组中元素逆序放入临时数组。</p>
</li>
</ul>
<h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>基数排序的思想在于：它将元素关键字 (限定为数字) 拆分为若干数位，例如 789 可拆分为 7\8\9 三个数位。从低到高依次对数位执行计数排序可实现排序元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假定关键字为十进制数字，则数位取值范围为[0,9]。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">radixSort</span><span class="params">(Integer[] objects)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构建数位数组，它指代数位取值范围。</span></span><br><span class="line">    Integer[] buckets = <span class="keyword">new</span> Integer[<span class="number">10</span>];</span><br><span class="line">    <span class="comment">// 构建临时数组，存储排序结果。</span></span><br><span class="line">    Integer[] tmp = <span class="keyword">new</span> Integer[objects.length];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 十进制数字第0位基数为1,第1位基数为10,...，主要用于求解指定位置的数位。</span></span><br><span class="line">    Integer radix = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 按照从低到高排序数位，即首先根据个位排序，随后根据十位排序,...。</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 重置数位数组。</span></span><br><span class="line">        Arrays.fill(buckets, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 统计数位出现次数。</span></span><br><span class="line">        <span class="comment">// (objects[i] / radix) % 10表示获取当前待处理位置的数位。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; objects.length; i++) &#123;</span><br><span class="line">            buckets[(objects[i] / radix) % <span class="number">10</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果所有元素当前位置的数位均为0，表明已无需再做排序，退出即可。</span></span><br><span class="line">        <span class="keyword">if</span> (buckets[<span class="number">0</span>] == objects.length) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建前缀值。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; buckets.length; i++) &#123;</span><br><span class="line">            buckets[i] += buckets[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据数位信息将原始数组中元素逆序填入临时数组。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = objects.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            tmp[--buckets[(objects[i] / radix) % <span class="number">10</span>]] = objects[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拷贝排序结果至原始数组。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; objects.length; i++) &#123;</span><br><span class="line">            objects[i] = tmp[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新数位为下一位。</span></span><br><span class="line">        radix *= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>时间复杂度</p>
<p>排序算法实现中，需要多次循环数位数组和原始数组。通常数位数组远小于原始数组，故而该算法的时间复杂度为 $O(N)$。</p>
</li>
<li><p>空间复杂度</p>
<p>排序算法需要使用数位数组及临时数组。如上所述，数位数组通常远小于原始数组，故而该算法的空间复杂度为 $O(N)$。</p>
</li>
<li><p>稳定性</p>
<p>就本质而言，基数排序基于多次使用计数排序而实现的。由于计数排序是稳定的，该算法亦是稳定的。</p>
</li>
</ul>
<h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><p>桶排序十分简单，首先将数组元素映射到若干桶 (桶表示区间范围)，随后桶内排序元素，最后按序输出桶内元素即可。</p>
<p>如果将桶区间范围的大小限定为 1，此时桶排序就是计数排序。</p>
<p>桶排序比较简单，故而不再实现。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-二分搜索</title>
    <url>/2020/08/17/algorithm/algorithm-binarysearch/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>二分搜索</strong> 用于有序数组查询操作，它可将操作时间复杂度降为 $O(log^N)$。</p>
<a id="more"></a>

<p>二分搜索思想十分简单：首先确定待搜索区间，随后获取区间中间值并将其与待搜索值进行比对，如果区间中间值大于待搜索值，则待搜索区间应为左半部分，反之待搜索区间应为右半部分，最后递归处理待搜索区间即可。</p>
<p>二分搜索实现比较困难，原因在于：若干边界条件需要判断。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>如上所言，二分搜索实现较为困难。我们在此引入两个简洁地二分搜索模板，第一个模板用于寻找最后一个 $\leq item$ 的元素位置下标，第二个模板用于寻找第一个 $\geq item$ 的元素位置下标。</p>
<p>模板一：</p>
<p>该模板根据中间值将区间划分为 $[l,mid]$ 和 $[mid + 1, r]$。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(Integer[] objects, Integer item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = objects.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (objects[mid].compareTo(item) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            r = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>模板二：</p>
<p>该模板根据中间值将区间划分为 $[l,mid - 1]$ 和 $[mid, r]$。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(Integer[] objects, Integer item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = objects.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="comment">// 为防止死循环，需要如此取值。</span></span><br><span class="line">        <span class="keyword">int</span> mid = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">if</span> (objects[mid].compareTo(item) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            l = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>针对模板二中 <code>mid</code> 取值，做如下说明：</p>
<p>假定待搜索区间为 $[l,l+1]$ 且 $objects[l] \leq item$，此时如果采用 <code>mid = (l + r) &gt;&gt; 1</code> ，则 <code>mid = l</code>，由于 $objects[mid] \leq item$，则更新后的待搜索区间仍为 $[l,l+1]$，此时即造成死循环；如果采用 <code>mid = (l + r + 1) &gt;&gt; 1</code>，则不会造成这种情况。</p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>二分思想</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-B树</title>
    <url>/2020/08/09/dataStructure/dataStructure-btree/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>B 树</strong> 是一种自平衡的多叉查找树，它可在对数时间内完成查询、插入、删除操作，常用于大规模数据存取场景，例如：数据库、文件系统。</p>
<a id="more"></a>

<p>其结构图大致如下：</p>
<p><img src="/2020/08/09/dataStructure/dataStructure-btree/image-20200808220113024.png" alt="图一：B树"></p>
<p>当处理大规模数据时，由于内存无法存放所有数据，故而程序运行期间，往往是部分数据位于内存之中，部分数据位于磁盘之中。如果程序访问数据位于磁盘之中，操作系统则调用磁盘内容到内存之中，随后按照内存访问规则进行访问。由于磁盘访问速度远低于内存访问速度，故而此时程序运行时间主要依托于磁盘访问次数。</p>
<p>为降低程序运行时间，我们就要确保磁盘访问次数尽可能的少。为减少磁盘访问次数，我们就需要存储一定信息以实现跳跃搜索，自然而然可以想到二叉查找树。如果直接应用二叉查找树，那么磁盘访问次数基本等于树高。为进一步降低程序运行时间，我们可以使用多叉查找树以降低树高，从而减少磁盘访问次数。同时，为保证磁盘访问次数明确界限于树高，那么就需要对多叉查找树施加平衡条件。</p>
<p>上述所言基本是 B 树原理。接下来，我们将简要定义 B 树。</p>
<p>B 树是一棵满足如下性质的 $t$ 叉树 ($t$ 指代节点所含孩子节点个数，亦称为节点的阶)：</p>
<ol>
<li>所有叶节点到根节点的路径长度相同，即具有相同高度。</li>
<li>所有非叶节点和非根节点至少含有 $t$ 个孩子节点，根节点至少含有 $2$ 个孩子节点。</li>
<li>每个非叶节点至多含有 $2t$ 个孩子节点。</li>
<li>每个节点内部键值依次递增。</li>
<li>每个非叶节点所含孩子节点数总是比所含键值数多 $1$。</li>
</ol>
<blockquote>
<p>2-3 树、2-3-4 树均为 B 树特例，B+树、B*树均为 B 树扩展。</p>
</blockquote>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>B 树结构比较复杂，我们在代码中加以描述。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BTree</span>&lt;<span class="title">K</span> <span class="keyword">extends</span> <span class="title">Comparable</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 二元组，存放键值对。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span> <span class="keyword">extends</span> <span class="title">Comparable</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        K k;</span><br><span class="line">        V v;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Entry</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Entry</span><span class="params">(K k, V v)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.k = k;</span><br><span class="line">            <span class="keyword">this</span>.v = v;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> K <span class="title">getK</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> k;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setK</span><span class="params">(K k)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.k = k;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> V <span class="title">getV</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setV</span><span class="params">(V v)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.v = v;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 比较键值。</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(K k)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.k.compareTo(k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点结构</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span> <span class="keyword">extends</span> <span class="title">Comparable</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">// 关键字键值对(0号位置不使用，方便后续代码编写)</span></span><br><span class="line">        ArrayList&lt;Entry&lt;K, V&gt;&gt; entries;</span><br><span class="line">        <span class="comment">// 孩子节点</span></span><br><span class="line">        ArrayList&lt;Node&lt;K, V&gt;&gt; childrens;</span><br><span class="line">        <span class="comment">// 是否为叶节点</span></span><br><span class="line">        Boolean leaf;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 初始化，占位entries[0]、设非叶节点。</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.entries = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">this</span>.entries.add(<span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">this</span>.childrens = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">this</span>.leaf = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> ArrayList&lt;Entry&lt;K, V&gt;&gt; getEntries() &#123;</span><br><span class="line">            <span class="keyword">return</span> entries;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEntries</span><span class="params">(ArrayList&lt;Entry&lt;K, V&gt;&gt; entries)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.entries = entries;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> ArrayList&lt;Node&lt;K, V&gt;&gt; getChildrens() &#123;</span><br><span class="line">            <span class="keyword">return</span> childrens;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setChildrens</span><span class="params">(ArrayList&lt;Node&lt;K, V&gt;&gt; childrens)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.childrens = childrens;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Boolean <span class="title">getLeaf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> leaf;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeaf</span><span class="params">(Boolean leaf)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.leaf = leaf;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到&lt;=key的关键字位置(查找过程也可使用二分)。</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> SearchResult&lt;V&gt; <span class="title">search</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (index = <span class="number">1</span>; index &lt; <span class="keyword">this</span>.entries.size(); index++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.entries.get(index).compareTo(key) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            SearchResult&lt;V&gt; searchResult = <span class="keyword">new</span> SearchResult();</span><br><span class="line">            searchResult.setIndex(index - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (index == <span class="number">1</span> || <span class="keyword">this</span>.entries.get(index - <span class="number">1</span>).compareTo(key) != <span class="number">0</span>) &#123;</span><br><span class="line">                searchResult.setExist(<span class="keyword">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                searchResult.setExist(<span class="keyword">true</span>);</span><br><span class="line">                searchResult.setValue(<span class="keyword">this</span>.entries.get(index - <span class="number">1</span>).getV());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> searchResult;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 搜索结果</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SearchResult</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">// 对应关键字是否存在</span></span><br><span class="line">        <span class="keyword">boolean</span> exist;</span><br><span class="line">        <span class="comment">// 位置信息(如果关键字存在，则表示其在entries中位置下标，否则表示在childrens中待插入子树的位置下标)</span></span><br><span class="line">        <span class="keyword">int</span> index;</span><br><span class="line">        <span class="comment">// 关键字对应值</span></span><br><span class="line">        V value;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isExist</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> exist;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setExist</span><span class="params">(<span class="keyword">boolean</span> exist)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.exist = exist;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> index;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.index = index;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// B树根节点</span></span><br><span class="line">    <span class="keyword">private</span> Node&lt;K, V&gt; root;</span><br><span class="line">    <span class="comment">// B树阶(动态调整)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> order;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="辅助方法"><a href="#辅助方法" class="headerlink" title="辅助方法"></a>辅助方法</h3><ul>
<li><p>当前子树中查找指定键值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">searchTree</span><span class="params">(Node&lt;K, V&gt; root, K key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取查询结果</span></span><br><span class="line">    SearchResult&lt;V&gt; result = root.search(key);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果查询成功，直接返回值。</span></span><br><span class="line">    <span class="keyword">if</span> (result.exist) &#123;</span><br><span class="line">        <span class="keyword">return</span> result.getValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前节点为叶节点，无孩子节点可搜索，故而返回null。</span></span><br><span class="line">    <span class="keyword">if</span> (root.getLeaf()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前节点为非叶节点，在孩子节点中递归查找即可。</span></span><br><span class="line">    <span class="keyword">return</span> searchTree(root.getChildrens().get(result.getIndex()), key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>分裂指定节点的某个子节点</p>
<p>如果某个节点所含孩子节点数等于 $2t$，那么就需要分裂该节点。</p>
<p>分裂规则：节点含有 $2t$ 个孩子节点，那么对应含有 $2t - 1$ 个关键字。提升第 $t$ 个关键字到父节点，前 $t - 1$ 个关键字及 $t$ 个孩子节点组成一个节点，后 $t - 1$ 个关键字及 $t$ 个孩子节点组成一个节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">splitNode</span><span class="params">(Node&lt;K, V&gt; root, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取子节点</span></span><br><span class="line">    Node&lt;K, V&gt; child = root.getChildrens().get(index);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新建一个邻居子节点，该节点与子节点具有相同的节点属性(是否为叶节点)。</span></span><br><span class="line">    Node&lt;K, V&gt; siblingNode = <span class="keyword">new</span> Node&lt;&gt;();</span><br><span class="line">    siblingNode.setLeaf(child.getLeaf());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里通过拆分方式构成两个节点。</span></span><br><span class="line">    <span class="comment">// 转移[order + 1, order * 2 - 1]区间元素至siblingNode。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>.order; i++) &#123;</span><br><span class="line">        siblingNode.getEntries().add(child.getEntries().remove(<span class="keyword">this</span>.order + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取order位置关键字键值对，并将其从child中删去。</span></span><br><span class="line">    Entry&lt;K, V&gt; midEntry = child.getEntries().remove(<span class="keyword">this</span>.order);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果子节点并非叶节点，则需要转移[order, order * 2 - 1]区间元素至siblingNode。</span></span><br><span class="line">    <span class="keyword">if</span> (!child.getLeaf()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.order; i++) &#123;</span><br><span class="line">            siblingNode.getChildrens().add(child.getChildrens().remove(<span class="keyword">this</span>.order));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向指定节点中添加order位置关键字键值对</span></span><br><span class="line">    root.getEntries().add(index + <span class="number">1</span>, midEntry);</span><br><span class="line">    <span class="comment">// 向指定节点中添加siblingNode子节点</span></span><br><span class="line">    root.getChildrens().add(index + <span class="number">1</span>, siblingNode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>当前非满子树中添加键值对</p>
<p>为保证 B 树向下搜索过程中不会产生回溯过程，我们会对待插入节点进行预处理：如果待插入节点含有 $2t$ 个孩子节点，则需要拆分该节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insertNotFull</span><span class="params">(Node&lt;K, V&gt; root, K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取查询结果</span></span><br><span class="line">    SearchResult&lt;V&gt; result = root.search(key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表明当前节点内部存在该关键字，直接退出即可。</span></span><br><span class="line">    <span class="keyword">if</span> (result.isExist()) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前节点内部不存在该关键字，根据节点是否为叶节点，选择不同方式进行插入。</span></span><br><span class="line">    <span class="keyword">if</span> (root.getLeaf()) &#123;</span><br><span class="line">        <span class="comment">// 当前节点为叶节点，直接插入即可(注意result.index字段含义)。</span></span><br><span class="line">        root.getEntries().add(result.getIndex() + <span class="number">1</span>, <span class="keyword">new</span> Entry&lt;&gt;(key, value));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 对待插入节点进行预处理，然后递归插入。</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取待插入孩子节点。</span></span><br><span class="line">        Node&lt;K, V&gt; child = root.getChildrens().get(result.getIndex());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 孩子节点已满，需进行拆分。</span></span><br><span class="line">        <span class="comment">// 关键字个数为order * 2 - 1时表明已满，又因为代码实现中位置0处并未使用，故而条件判断为order * 2。</span></span><br><span class="line">        <span class="keyword">if</span> (child.getEntries().size() == <span class="keyword">this</span>.order * <span class="number">2</span>) &#123;</span><br><span class="line">            splitNode(root, result.getIndex());</span><br><span class="line">            <span class="comment">// 如果提升的关键字值小于待插入关键字值，则需要更新待插入孩子节点。</span></span><br><span class="line">            <span class="keyword">if</span> (root.getEntries().get(result.getIndex() + <span class="number">1</span>).compareTo(key) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                child = root.getChildrens().get(result.getIndex() + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归插入。</span></span><br><span class="line">        insertNotFull(child, key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>当前子树中删除指定键值</p>
<p>删除过程主要涉及如下情景：</p>
<p><strong>情景1：</strong>关键字 $key$ 位于节点 $x$ 之中，并且节点为叶节点，则直接从节点 $x$ 中删除 $key$ 表示的键值对即可。</p>
<p><strong>情景2：</strong>关键字 $key$ 位于节点 $x$ 之中，但是节点为非叶节点，则进行如下操作：</p>
<ul>
<li><p>如果节点 $x$ 中位于关键字 $key$ 之前的子节点 $y$ 中至少含有 $t$ 个关键字，则使用 $y$ 的最后一个关键字替换节点 $x$ 中的关键字 $key$，并递归调用子节点 $y$ 以删除它的最后一个关键字。</p>
</li>
<li><p>如果节点 $x$ 中位于关键字 $key$ 之后的子节点 $z$ 中至少含有 $t$ 个关键字，则使用 $z$ 的第一个关键字替换节点 $x$ 中的关键字 $key$ ，并递归调用子节点 $z$ 以删除它的第一个关键字。</p>
</li>
<li><p>子节点 $y$ 和 $z$ 均仅含有 $t - 1$ 个关键字，则融合 $z$ 中关键字及关键字 $key$ 至子节点 $y$，随后递归调用子节点 $y$ 以删除关键字 $key$ 。</p>
</li>
</ul>
<p><strong>情景3：</strong>关键字并不位于节点 $x$ 之中，此时需进入孩子节点以期删除关键字 $key$，故而需格外注意孩子节点状态，故而需进行如下操作：</p>
<ul>
<li><p>孩子节点至少含有 $t$ 个关键字，直接进入孩子节点，递归删除关键字 $key$。</p>
</li>
<li><p>孩子节点仅含有 $t - 1$ 个关键字，如果左兄弟孩子节点或右兄弟孩子节点至少含有 $t$ 个关键字，则借调一个关键字使得孩子节点含有 $t$ 个关键字，随后进入孩子节点，递归删除关键字 $key$。</p>
</li>
<li><p>孩子节点仅含有 $t - 1$ 个关键字，并且左兄弟孩子节点或右兄弟孩子节点也仅有 $t - 1$ 个关键字，则融合一个兄弟节点中关键字及节点 $x$ 中位于关键字 $x$ 之前的关键字至孩子节点，从而使得孩子节点含有 $2t - 1$ 个关键字，随后进入孩子节点，递归删除关键字 $key$。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteTree</span><span class="params">(Node&lt;K, V&gt; root, K key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取查询结果。</span></span><br><span class="line">    SearchResult&lt;V&gt; result = root.search(key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关键字存在于当前节点之中。</span></span><br><span class="line">    <span class="keyword">if</span> (result.isExist()) &#123;</span><br><span class="line">        <span class="comment">// 当前节点为叶节点，直接删除即可，对应情景1。</span></span><br><span class="line">        <span class="keyword">if</span> (root.getLeaf()) &#123;</span><br><span class="line">            root.getEntries().remove(result.getIndex());</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前节点为非叶节点，那么删除就需要考虑替换策略，对应情景2。</span></span><br><span class="line">        <span class="comment">// 获取key对应的左右孩子。</span></span><br><span class="line">        Node&lt;K, V&gt; leftChild = root.getChildrens().get(result.getIndex() - <span class="number">1</span>);</span><br><span class="line">        Node&lt;K, V&gt; rightChild = root.getChildrens().get(result.getIndex());</span><br><span class="line">        <span class="comment">// 左孩子含有关键字个数大于order-1，则可用其最后一个关键字替换key，并递归调用左孩子以删除该关键字，对应情景2.1。</span></span><br><span class="line">        <span class="keyword">if</span> (leftChild.getEntries().size() &gt; <span class="keyword">this</span>.order) &#123;</span><br><span class="line">            <span class="comment">// 获取左孩子的最后一个关键字。</span></span><br><span class="line">            Entry&lt;K, V&gt; next = leftChild.getEntries().get(leftChild.getEntries().size() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 替换key。</span></span><br><span class="line">            root.getEntries().remove(result.getIndex());</span><br><span class="line">            root.getEntries().add(result.getIndex(), next);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 递归删除。</span></span><br><span class="line">            deleteTree(leftChild, next.getK());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rightChild.getEntries().size() &gt; <span class="keyword">this</span>.order) &#123;</span><br><span class="line">            <span class="comment">// 右孩子含有关键字个数大于order-1，则可用其第一个关键字替换key，并递归调用左孩子以删除该关键字，对应情景2.2。</span></span><br><span class="line">            <span class="comment">// 获取右孩子的第一个关键字。</span></span><br><span class="line">            Entry&lt;K, V&gt; pre = rightChild.getEntries().get(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 替换key。</span></span><br><span class="line">            root.getEntries().remove(result.getIndex());</span><br><span class="line">            root.getEntries().add(result.getIndex(), pre);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 递归删除。</span></span><br><span class="line">            deleteTree(rightChild, pre.getK());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 此时左右孩子所含关键字个数均为order-1，则合并左右孩子关键字及当前关键字为一个节点，对应情景2.3。</span></span><br><span class="line">            <span class="comment">// 从当前节点中删除该关键字及其右孩子。</span></span><br><span class="line">            Entry&lt;K, V&gt; deleteKV = root.getEntries().remove(result.getIndex());</span><br><span class="line">            root.getChildrens().remove(result.getIndex());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 合并关键字。</span></span><br><span class="line">            leftChild.getEntries().add(deleteKV);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>.order; i++) &#123;</span><br><span class="line">                leftChild.getEntries().add(rightChild.getEntries().remove(<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如若右孩子为非叶节点，则需合并孩子节点。</span></span><br><span class="line">            <span class="keyword">if</span> (!rightChild.getLeaf()) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.order; i++) &#123;</span><br><span class="line">                    leftChild.getChildrens().add(rightChild.getChildrens().remove(<span class="number">0</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 合并可能导致树高降1，从而使得根节点发生变化。</span></span><br><span class="line">            <span class="keyword">if</span> (root == <span class="keyword">this</span>.root &amp;&amp; root.getEntries().size() == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.root = leftChild;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 递归删除。</span></span><br><span class="line">            deleteTree(leftChild, key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 当前节点不存在关键字，对应情景3。</span></span><br><span class="line">        <span class="comment">// 当前节点为叶节点，表明不存在该关键字，直接返回即可。</span></span><br><span class="line">        <span class="keyword">if</span> (root.getLeaf()) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取待搜索孩子节点</span></span><br><span class="line">        Node&lt;K, V&gt; childNode = root.getChildrens().get(result.getIndex());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 待搜索孩子节点所含关键字个数大于order-1，则直接递归删除即可，对应情景3.1。</span></span><br><span class="line">        <span class="keyword">if</span> (childNode.getEntries().size() &gt; <span class="keyword">this</span>.order) &#123;</span><br><span class="line">            deleteTree(childNode, key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 待搜索孩子节点所含关键字个数等于order-1，则需预处理使其所含关键字个数大于order-1。</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 尝试获取待搜索孩子节点的左右兄弟节点</span></span><br><span class="line">            Node&lt;K, V&gt; leftChild = <span class="keyword">null</span>;</span><br><span class="line">            Node&lt;K, V&gt; rightChild = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 是否存在一个兄弟节点所含关键字个数大于order-1</span></span><br><span class="line">            Boolean flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (result.getIndex() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                leftChild = root.getChildrens().get(result.getIndex() - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (leftChild.getEntries().size() &gt; <span class="keyword">this</span>.order) &#123;</span><br><span class="line">                    flag = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (result.getIndex() &lt; root.getChildrens().size() - <span class="number">1</span>) &#123;</span><br><span class="line">                rightChild = root.getChildrens().get(result.getIndex() + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (rightChild.getEntries().size() &gt; <span class="keyword">this</span>.order) &#123;</span><br><span class="line">                    flag = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// flag=true表明至少一个兄弟节点所含关键字个数大于order-1，则调用借调一个关键字给待搜索孩子节点，对应情景3.2，否则需要将待搜索孩子节点与一个兄弟节点进行合并，对应情景3.3。</span></span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                <span class="comment">// 左兄弟节点存在，且其所含关键字个数大于order-1，则将其一个关键字转移到待搜索孩子节点</span></span><br><span class="line">                <span class="keyword">if</span> (leftChild != <span class="keyword">null</span> &amp;&amp; leftChild.getEntries().size() &gt; <span class="keyword">this</span>.order) &#123;</span><br><span class="line">                    <span class="comment">// 将当前节点中小于指定关键字的第一个关键字下放至待搜索孩子节点的第一个关键字。</span></span><br><span class="line">                    childNode.getEntries().add(<span class="number">1</span>, root.getEntries().remove(result.getIndex()));</span><br><span class="line">                    <span class="comment">// 将左兄弟节点的最后一个关键字上升至当前节点</span></span><br><span class="line">                    root.getEntries().add(result.getIndex(), leftChild.getEntries().remove(leftChild.getEntries().size() - <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 左兄弟节点不为叶节点，则需要转移它的最后一个孩子节点到待搜索孩子节点</span></span><br><span class="line">                    <span class="keyword">if</span> (!leftChild.getLeaf()) &#123;</span><br><span class="line">                        childNode.getChildrens().add(<span class="number">0</span>, leftChild.getChildrens().remove(leftChild.getChildrens().size() - <span class="number">1</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 右兄弟节点存在，且其所含关键字个数大于order-1，则将其一个关键字转移到待搜索孩子节点。</span></span><br><span class="line">                    <span class="comment">// 将当前节点中大于指定关键字的第一个关键字下放至待搜索孩子节点的最后一个关键字。</span></span><br><span class="line">                    childNode.getEntries().add(root.getEntries().remove(result.getIndex() + <span class="number">1</span>));</span><br><span class="line">                    <span class="comment">// 将右兄弟节点的第一个关键字上升至当前节点。</span></span><br><span class="line">                    root.getEntries().add(result.getIndex() + <span class="number">1</span>, rightChild.getEntries().remove(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 右兄弟节点不为叶节点，则需要转移它的第一个孩子节点到待搜索孩子节点。</span></span><br><span class="line">                    <span class="keyword">if</span> (!rightChild.getLeaf()) &#123;</span><br><span class="line">                        childNode.getChildrens().add(rightChild.getChildrens().remove(<span class="number">0</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 递归删除。</span></span><br><span class="line">                deleteTree(childNode, key);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 左右兄弟节点都含有order-1个关键字，此时选择一个非空兄弟节点合并即可。</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> != leftChild) &#123;</span><br><span class="line">                    <span class="comment">// 左兄弟节点不为空</span></span><br><span class="line">                    <span class="comment">// 当前节点中删除小于指定关键字的第一个关键字及其右孩子，并将该关键字下放至待搜索孩子节点。</span></span><br><span class="line">                    childNode.getEntries().add(<span class="number">1</span>, root.getEntries().remove(result.getIndex()));</span><br><span class="line">                    root.getChildrens().remove(result.getIndex() - <span class="number">1</span>);</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 合并关键字。</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="keyword">this</span>.order - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                        childNode.getEntries().add(<span class="number">1</span>, leftChild.getEntries().remove(i));</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 待搜索孩子节点不为叶节点，则合并孩子节点。</span></span><br><span class="line">                    <span class="keyword">if</span> (!childNode.getLeaf()) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="keyword">this</span>.order - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                            childNode.getChildrens().add(<span class="number">0</span>, leftChild.getChildrens().remove(i));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">null</span> != rightChild)&#123;</span><br><span class="line">                    <span class="comment">// 右兄弟节点不为空</span></span><br><span class="line">                    <span class="comment">// 当前节点中删除大于指定关键字的第一个关键字及其右孩子，并将该关键字下放至待搜索孩子节点。</span></span><br><span class="line">                    childNode.getEntries().add(root.getEntries().remove(result.getIndex() + <span class="number">1</span>));</span><br><span class="line">                    root.getChildrens().remove(result.getIndex() + <span class="number">1</span>);</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 合并关键字。</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>.order; i++) &#123;</span><br><span class="line">                        childNode.getEntries().add(rightChild.getEntries().remove(<span class="number">1</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 待搜索孩子节点不为叶节点，则合并孩子节点。</span></span><br><span class="line">                    <span class="keyword">if</span> (!childNode.getLeaf()) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.order; i++) &#123;</span><br><span class="line">                            childNode.getChildrens().add(rightChild.getChildrens().remove(<span class="number">0</span>));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 合并可能导致树高降1，从而使根节点发生变化。</span></span><br><span class="line">                <span class="keyword">if</span> (root == <span class="keyword">this</span>.root &amp;&amp; root.getEntries().size() == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.root = childNode;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 递归删除。</span></span><br><span class="line">                deleteTree(childNode, key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p><strong>要点：</strong> 根节点需要初始化为叶节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BTree</span><span class="params">(<span class="keyword">int</span> order, Comparator&lt;? <span class="keyword">super</span> K&gt; comparator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.root = <span class="keyword">new</span> Node&lt;&gt;();</span><br><span class="line">    <span class="keyword">this</span>.root.setLeaf(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">this</span>.order = order;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><ul>
<li><p>查询指定关键字</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">search</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> searchTree(<span class="keyword">this</span>.root, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="操纵"><a href="#操纵" class="headerlink" title="操纵"></a>操纵</h3></li>
<li><p>B 树中添加键值对</p>
<p>根节点分裂涉及重新设置 <code>root</code>，我们将其单独处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">ublic <span class="keyword">void</span> <span class="title">add</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根节点已满，需分裂并重新设置根节点。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.root.getEntries().size() == <span class="keyword">this</span>.order * <span class="number">2</span>) &#123;</span><br><span class="line">        Node&lt;K, V&gt; newRoot = <span class="keyword">new</span> Node&lt;&gt;();</span><br><span class="line">        newRoot.getChildrens().add(<span class="keyword">this</span>.root);</span><br><span class="line">        splitNode(newRoot, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">this</span>.root = newRoot;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    insertNotFull(<span class="keyword">this</span>.root, key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>B 树中删除键值对</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    deleteTree(<span class="keyword">this</span>.root, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2></li>
</ul>
<p>B+ 树是 B 树的一种重要变体。相比于 B 树而言，其查询性能更为高效、更为稳定。</p>
<p>各种资料中 B+ 树的定义略有差异，我们采用维基百科上提供的定义。基于此定义，我们首先给出 B+ 树与 B 树之间的差异：</p>
<ul>
<li>在 B+ 树中，节点分为两种类型——内部节点 (索引节点) 和叶节点。内部节点 (索引节点) 存放关键字及孩子指针，叶节点存放关键字及其对应数据。在B 树中，节点只具有一种类型，它存放关键字、对应数据及孩子指针。基于此差异，我们可知：相比 B 树而言，B+ 树更为 <em>矮胖</em>。</li>
<li>在 B+ 树中，对于索引节点中关键字而言，其左子树中节点均小于该关键字，右子树中节点均大于等于该关键字 (以此保证能够索引至相应叶节点)。在 B 树中，对于节点中关键字而言，其左子树中节点均小于该关键字，右子树中节点均大于该关键字，此关键字及对应数据亦存于此节点之中。基于此差异，我们可知：B+ 树中同一关键字可能出现在多个节点之中。</li>
<li>在 B+ 树中，叶节点依关键字大小顺序进行链接。在 B 树中，叶节点之间并无任何关系。基于此差异，我们可知：B+ 树中可高效实现范围查询。</li>
<li>在 B+ 树中，需要存储根节点及最小关键字节点引用。在 B 树中，仅需存储根节点引用。</li>
</ul>
<p><img src="/2020/08/09/dataStructure/dataStructure-btree/ds_bplus_tree_def.png" alt="图二：B+ 树(前者定义)"></p>
<img src="/2020/08/09/dataStructure/dataStructure-btree/v2-5f069fd820637db1b877fdd6799a2b67_1440w.jpg" alt="图三：B+ 树(后者定义)" style="zoom: 33%;">

<blockquote>
<p>不同 B+ 树定义的差异点在于：如何处理节点内部关键字个数与孩子节点个数之间的关系。一种定义方式为：节点内部孩子节点个数等于关键字个数加一 (就是B 树原始定义)，另一种定义方式为：节点内部关键字个数与孩子节点个数相等。</p>
<p>我们很容易将基于前者定义的 B+ 树改造为基于后者的 B+ 树。在前者定义中，对于索引节点中关键字而言，其左子树中节点均小于该关键字，右子树中节点均大于等于该关键字。将其改造为后者定义便是，对于索引节点中关键字而言，其对应子树中节点均大于等于该关键字 。在该种定义中，我们舍弃小于当前节点中最小关键字的子树，这一点可使用如下操作进行替代：如果待插入关键字小于当前节点中最小关键字，我们就将当前节点中最小关键字修改为待插入关键字，随后进行插入。</p>
<p>当采用第二种定义方式时， 基于 B+ 树的一种变体 B* 树被定义。相比于 B+ 树，B* 树具有如下特点：1. 如果节点不为叶节点或根节点，则其内部需要存储一个指向右邻居关键字的引用。2. 节点内部所含关键字个数至少为 $\frac{2}{3}t$ (<strong>这使得其节点空间使用率更高</strong>)。由于节点所含最小关键字个数定义发生变动，故而其分裂规则亦发生变动：当插入关键字之时，如果当前节点所含关键字个数为 $2t - 1$ (已满)，则会判断右邻居节点所含关键字个数是否已满，如果未满则转移部分关键字至右邻居节点，否则新建一个右邻居节点，并将当前节点及原先右邻居节点的$\frac{1}{3}t$ 个关键字转移至其内。</p>
<p><strong>B+ 树肯定是很重要的，因为维基百科有定义且广泛应用于数据库之中；B* 树未必有用，因为维基百科没有定义且基本搜不到资料，了解就行了。</strong></p>
</blockquote>
<p>接下来，我们简单描述 B+ 树结构及其相关操作：</p>
<ul>
<li><p>结构</p>
<p>B+ 树涉及两种节点类型——内部节点和叶节点。对于内部节点而言，需使用数组存储关键字及孩子指针；对于叶节点，需使用数组存储关键字、对应数据及右邻居关键字引用。对于这两种节点而言，它们均需使用一个引用存储父节点、一个布尔值表示当前节点是否为叶节点。</p>
<p>对于 B+ 树而言，它需要存储根节点及具有最小关键字节点的引用，同时需要存储树阶。</p>
</li>
<li><p>查询</p>
<p>查询操作与 B 树基本一致，只是必须递归至叶节点完成查询。</p>
</li>
<li><p>插入</p>
<p>插入操作与 B 树存在较大差异，但是思路基本不变。</p>
<p>首先需要根据关键字索引至叶节点，然后将该数据插入其中。如果叶节点所含关键字个数已到达上限 (即含有 $2t$ 个关键字)，此时需要拆分为两个叶节点，前 $t$ 关键字位于左叶节点，后 $t$ 关键字位于右叶节点，并将右叶节点的第一个关键字插入至父节点。如果父节点所含关键字个数已达上限，此时需要拆分为两个索引节点，前 $t - 1$ 个关键字位于左索引节点，后 $t$ 个关键字位于右索引节点，并将第 $t$ 个关键字插入于父节点之中，随后递归更新父节点。</p>
</li>
<li><p>删除</p>
<p>删除操作与 B 树基本相同。</p>
<p>首先需要根据关键字索引至叶节点，随后删除该关键字。如果叶节点所含关键字个数已到达下限 (即含有 $t - 2$ 个关键字)，此时需要从左右邻居节点中借调一个关键字、或者合并邻居节点，随后更新父节点相应位置的关键字。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-后缀数组</title>
    <url>/2020/08/02/dataStructure/dataStructure-suffixarray/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>后缀数组</strong> 是特定字符串的所有后缀有序排列而成的一个数组。它比后缀树更为实用，常用于全文索引。</p>
<a id="more"></a>

<p>其结构图大致如下：</p>
<img src="/2020/08/02/dataStructure/dataStructure-suffixarray/sa1.png" alt="图一：后缀数组" style="zoom:50%;">

<p>后缀数组比较特殊，本文简单介绍其构建方法及应用。</p>
<h2 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h2><p>后缀数组并非直接存储后缀，而是后缀在特定字符串中的起始下标。</p>
<p>我们在此说明如下构造算法中可能使用到的重要变量名称：</p>
<ul>
<li><code>sa[i]</code> ：排名为 $i$ 的后缀在特定字符串中的起始下标。</li>
<li><code>rk[i]</code> ：起始下标为 $i$ 的后缀在所有后缀中的排名。</li>
<li><code>height[i]</code> ：排名为 $i$ 的后缀与排名为 $i - 1$ 的后缀的最长公共前缀。</li>
<li><code>LCP(str1,str2)</code> ：两个字符串的最长公共前缀。</li>
<li><code>sub[i][k]</code> ：特定字符串区间 $[i,i + 2^k - 1]$ 所表示的子串。</li>
<li><code>sa[i][k]</code> ：长度为 $2^k$ 的所有子串中，排名为 $i$ 的子串在特定字符串中的起始下标。 </li>
<li><code>rk[i][k]</code> ：长度为 $2^k$ 的所有子串中，起始下标为 $i$ 的子串在所有子串中的排名。</li>
<li><code>prefixs[i]</code> ：特定字符串的前缀哈希值。</li>
<li><code>squares[i]</code> ：存放 $2^i$ 系列值。</li>
</ul>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuffixArray</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 特定字符串</span></span><br><span class="line">    <span class="keyword">private</span> String T;</span><br><span class="line">    <span class="comment">// 排名对应起始下标数组(下标从1开始)</span></span><br><span class="line">    <span class="keyword">private</span> Integer[] sa;</span><br><span class="line">    <span class="comment">// 起始下标对应排名数组(下标从1开始)</span></span><br><span class="line">    <span class="keyword">private</span> Integer[] rk;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="朴素构造算法"><a href="#朴素构造算法" class="headerlink" title="朴素构造算法"></a>朴素构造算法</h3><p>朴素构造算法十分简单：排序所有后缀，然后按顺序存储各后缀在特定字符串中的起始下标。</p>
<p>排序操作的时间复杂度为 $O(Nlog^N)$，比较字符串的时间复杂度为 $O(N)$，故而该构造算法的时间复杂度为 $O(N^2log^N)$。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SuffixArray</span><span class="params">(String T)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 添加前缀，方便后续代码编写。</span></span><br><span class="line">    T = <span class="string">&quot;$&quot;</span> + T;</span><br><span class="line">    <span class="keyword">this</span>.T = T;</span><br><span class="line">    <span class="keyword">this</span>.sa = <span class="keyword">new</span> Integer[T.length()];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化sa</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>.sa.length; i++) &#123;</span><br><span class="line">        <span class="keyword">this</span>.sa[i]= i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Arrays.sort(<span class="keyword">this</span>.sa, <span class="number">1</span>, <span class="keyword">this</span>.sa.length, (o1, o2) -&gt; &#123;</span><br><span class="line">        <span class="keyword">int</span> index1 = (<span class="keyword">int</span>) o1;</span><br><span class="line">        <span class="keyword">int</span> index2 = (<span class="keyword">int</span>) o2;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.T.substring(index1).compareTo(<span class="keyword">this</span>.T.substring(index2));</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二分思想-Hash-优化"><a href="#二分思想-Hash-优化" class="headerlink" title="二分思想 + Hash 优化"></a>二分思想 + Hash 优化</h3><p>针对朴素构造算法中的字符串比较操作，我们可基于二分思想及 Hash 将其时间复杂度优化为 $O(log^N)$。</p>
<p>该优化操作源于如下观察：通过比较最长公共前缀所在位置的下一个字符，即可得到两个字符串的大小关系。</p>
<p>为获取最长公共前缀所在位置，我们可使用二分思想：如果 $[l1, l1 + mid - 1]$ 表示字符串的哈希值与 $[l2,l2 + mid - 1]$ 表示字符串的哈希值相等，表明最长公共前缀所在位置处于右半部分 ，否则表明最长公共前缀所在位置处于左半部分。</p>
<blockquote>
<ul>
<li>采用的哈希函数为：$\sum_{i = l}^{i = r}2^i * T[i]$ 。</li>
<li>如果需要获取指定区间 $[L,R]$ 表示字符串的哈希值，可借由前缀哈希值数组 <code>prefixs</code> 和 $2^k$ 预存数组 <code>squares</code> 推导得到：$(prefixs[R] - prefixs[L - 1]) / squares[L]$ 。</li>
<li><code>mid</code> 表示步长 (与普通二分算法中 <code>mid</code> 含义不同)。</li>
</ul>
</blockquote>
<p>由于字符串比较操作的时间复杂度降为 $O(log^N)$，故而该构造算法的时间复杂度为 $O(N(log^N)^2)$ 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SuffixArray</span><span class="params">(String T)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 添加前缀，方便后续代码编写。</span></span><br><span class="line">    T = <span class="string">&quot;$&quot;</span> + T;</span><br><span class="line">    <span class="keyword">this</span>.T = T;</span><br><span class="line">    <span class="keyword">this</span>.sa = <span class="keyword">new</span> Integer[T.length()];</span><br><span class="line">	<span class="keyword">this</span>.prefixs = <span class="keyword">new</span> Integer[<span class="keyword">this</span>.T.length()];</span><br><span class="line">    <span class="keyword">this</span>.squares = <span class="keyword">new</span> Integer[<span class="keyword">this</span>.T.length()];</span><br><span class="line">    prefixs[<span class="number">0</span>] = <span class="string">&#x27;$&#x27;</span> - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    squares[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化相关数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>.sa.length; i++) &#123;</span><br><span class="line">        <span class="keyword">this</span>.sa[i]= i;</span><br><span class="line">        squares[i] = squares[i - <span class="number">1</span>] * <span class="number">2</span>;</span><br><span class="line">        prefixs[i] = prefixs[i - <span class="number">1</span>] + (<span class="keyword">this</span>.T.charAt(i) - <span class="string">&#x27;a&#x27;</span>) * squares[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Arrays.sort(<span class="keyword">this</span>.sa, <span class="number">1</span>, <span class="keyword">this</span>.sa.length, (o1, o2) -&gt; &#123;</span><br><span class="line">        <span class="keyword">int</span> index1 = (<span class="keyword">int</span>) o1;</span><br><span class="line">        <span class="keyword">int</span> index2 = (<span class="keyword">int</span>) o2;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义步长左端、右端。</span></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = Math.min(<span class="keyword">this</span>.T.length() - index1, <span class="keyword">this</span>.T.length() - index2);</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="comment">// 获取中间步长</span></span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取相应子串的哈希值</span></span><br><span class="line">            <span class="keyword">int</span> strHash1 = (prefixs[index1 + mid - <span class="number">1</span>] - prefixs[index1 - <span class="number">1</span>]) / squares[index1];</span><br><span class="line">            <span class="keyword">int</span> strHash2 = (prefixs[index2 + mid - <span class="number">1</span>] - prefixs[index2 - <span class="number">1</span>]) / squares[index2];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果二者不等，表明步长应小于等于mid，否则表明步长应大于mid。</span></span><br><span class="line">            <span class="keyword">if</span> (strHash1 != strHash2) &#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 二分过程后，[index1,index + l - 1 - 1]对应字符串为最长公共前缀，那么只需比较对应位置下一个字符即可。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.T.charAt(index1 + l - <span class="number">1</span>) - <span class="keyword">this</span>.T.charAt(index2 + l - <span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="倍增思想"><a href="#倍增思想" class="headerlink" title="倍增思想"></a>倍增思想</h3><p>上述两种算法将两个后缀视为独立字符串进行比较，倍增思想则考虑后缀之间的内在联系。</p>
<p>倍增思想中主要涉及如下三个数组：<code>sub[i][k]</code> 、<code>rk[i][k]</code> 、<code>sa[i][k]</code> 。</p>
<p>假定我们已经获知 $sub[i][k]$ 对应排名为 $rk[i][k]$。如果需要判断任意两个子串 $sub[i][k+1]$ 和 $sub[j][k+1]$ 之间的大小关系，只需先行比较 $sub[i][k]$ 与 $sub[j][k]$ 对应排名，如果二者排名相同，则再比较 $sub[i + 2^k][k]$ 和 $sub[j + 2^k][k]$ 对应排名。</p>
<p>按照上述描述，基于 $rk[i][k]$ 可顺利推导得到长度为 $2^{k+1}$ 的各子串排序 (亦即 $sa[i][k+1]$)，基于 $sa[i][k+1]$ 又可方便得到 $rk[i][k+1]$。如此循环迭代，最终我们将得到 $sa[i][k],2^k \geq T.length$，此亦为特定字符串 $T$ 的后缀数组。</p>
<p>现在问题就在于：如何排序各子串得到 $sa[i][k+1]$ ？</p>
<p>一种可行做法是直接调用快速排序等方式。由于快速排序等方式的时间复杂度为 $O(Nlog^N)$，倍增循环 $O(log^N)$ 次，故而此时构造算法的时间复杂度为 $O(N(log^N)^2)$ 。</p>
<p>一种更为优秀做法是使用基数排序，这是因为 $rk[i][k + 1] \in (0,T.length)$ 。此时排序方式的时间复杂度为 $O(N)$，外加倍增循环 $O(log^N)$ 次，故而此时构造算法的时间复杂度为 $O(Nlog^N)$ 。</p>
<p>我们在此实现第二种做法。</p>
<p>实现代码与描述存在些许出入，故而在此总结一下：</p>
<ul>
<li>由于需要使用 $rk[i + 2^k][k]$，故而 $rk[i][k]$ 数组空间大小至少为特定字符串长度的两倍。由于 $rk[i][k]$ 数组与特定字符串存在一一对应关系，我们默认 $T[i] = ‘Null’, i \in [T.length,T.length * 2)$ ($Null$ 表示 ascii 码中的空字符)。</li>
<li>最初需要初始化 <code>rk[i][0]</code> 和 <code>sa[i][0]</code>。<code>rk[i][0]</code> 可直接使用对应字符的 ascii 码进行赋值 (如果 $i \geq T.length$，由于 $T[i]$ 为空，故而可设 <code>rk[i][0] = 0</code>)，随后基于基数排序可得到 <code>sa[i][0]</code> 。</li>
<li>由于最初使用 ascii 码赋值 <code>rk[i][0]</code>，故而 <code>rk[]</code> 和 <code>cnt[]</code> (基数排序中的桶) 空间最小需设为最大 ascii 码值。</li>
<li>倍增循环中，我们需要根据 $sub[i][k]$ 和 $sub[i + 2^k][k]$ 对应排名进行排序各子串。当使用基数排序进行排序各子串时，我们首先使用  $sub[i + 2^k][k]$ 对应排名(第二关键字) 排序各子串，然后使用 $sub[i][k]$ 对应排名 (第一关键字) 排序各子串即可。</li>
<li>代码实现中采用数组实现基数排序。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SuffixArray</span><span class="params">(String T)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 添加前缀，方便后续代码编写。</span></span><br><span class="line">    T = <span class="string">&quot;$&quot;</span> + T;</span><br><span class="line">    <span class="keyword">this</span>.T = T;</span><br><span class="line">    <span class="keyword">this</span>.sa = <span class="keyword">new</span> Integer[T.length()];</span><br><span class="line">    <span class="keyword">this</span>.rk = <span class="keyword">new</span> Integer[<span class="number">1000</span>];</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 桶</span></span><br><span class="line">    Integer[] cnt = <span class="keyword">new</span> Integer[<span class="number">1000</span>];</span><br><span class="line">    <span class="comment">// 临时存放sa</span></span><br><span class="line">    Integer[] id = <span class="keyword">new</span> Integer[<span class="keyword">this</span>.T.length()];</span><br><span class="line">    <span class="comment">// 存放旧rank</span></span><br><span class="line">    Integer[] oldRank;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始置0</span></span><br><span class="line">    Arrays.fill(cnt, <span class="number">0</span>, cnt.length, <span class="number">0</span>);</span><br><span class="line">    Arrays.fill(<span class="keyword">this</span>.rk, <span class="number">0</span>, <span class="keyword">this</span>.rk.length, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用基数排序初始化。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>.T.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">this</span>.rk[i] = Integer.valueOf(<span class="keyword">this</span>.T.charAt(i));</span><br><span class="line">        ++cnt[<span class="keyword">this</span>.rk[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; cnt.length; i++) &#123;</span><br><span class="line">        cnt[i] += cnt[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="keyword">this</span>.T.length() - <span class="number">1</span>; i &gt;=<span class="number">1</span> ; i--) &#123;</span><br><span class="line">        <span class="keyword">this</span>.sa[cnt[<span class="keyword">this</span>.rk[i]]--] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> w = <span class="number">1</span>; w &lt; <span class="keyword">this</span>.T.length(); w = w * <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 清空桶</span></span><br><span class="line">        Arrays.fill(cnt, <span class="number">0</span>, cnt.length, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>.T.length(); i++) &#123;</span><br><span class="line">            id[i] = <span class="keyword">this</span>.sa[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 基数排序第二关键字</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>.T.length(); i++) &#123;</span><br><span class="line">            ++cnt[<span class="keyword">this</span>.rk[id[i] + w]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; cnt.length; i++) &#123;</span><br><span class="line">            cnt[i] += cnt[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="keyword">this</span>.T.length() - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">this</span>.sa[cnt[<span class="keyword">this</span>.rk[id[i] + w]]--] = id[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 清空桶</span></span><br><span class="line">        Arrays.fill(cnt, <span class="number">0</span>, cnt.length, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>.T.length(); i++) &#123;</span><br><span class="line">            id[i] = <span class="keyword">this</span>.sa[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 基数排序第一关键字</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>.T.length(); i++) &#123;</span><br><span class="line">            ++cnt[<span class="keyword">this</span>.rk[id[i]]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; cnt.length; i++) &#123;</span><br><span class="line">            cnt[i] += cnt[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="keyword">this</span>.T.length() - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">this</span>.sa[cnt[<span class="keyword">this</span>.rk[id[i]]]--] = id[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        oldRank = Arrays.copyOf(<span class="keyword">this</span>.rk, <span class="keyword">this</span>.rk.length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新rank。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">1</span>, i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>.T.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">1</span> || (oldRank[<span class="keyword">this</span>.sa[i]] == oldRank[<span class="keyword">this</span>.sa[i - <span class="number">1</span>]] &amp;&amp; oldRank[<span class="keyword">this</span>.sa[i] + w] == oldRank[<span class="keyword">this</span>.sa[i - <span class="number">1</span>] + w])) &#123;</span><br><span class="line">                <span class="keyword">this</span>.rk[<span class="keyword">this</span>.sa[i]] = p;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.rk[<span class="keyword">this</span>.sa[i]] = ++p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>存在 $O(N)$ 复杂度构建后缀数组的方法，但是由于其过于复杂并不常用，故而不再介绍。</p>
</blockquote>
<h3 id="求取-Height"><a href="#求取-Height" class="headerlink" title="求取 Height"></a>求取 Height</h3><p>上面的构造算法仅能初始化数组 $sa[i]$ 和 $rk[i]$，数组 $height[i]$ 需单独初始化。</p>
<p>初始化数组 $height[i]$ 仍然存在多种方法，我们一一讲述：</p>
<ul>
<li><p>暴力解法</p>
<p>遍历整个数组，每次按序比较两个字符串，从而得到最长公共前缀。</p>
<p>容易得知：此种解法的时间复杂度为 $O(N^2)$。</p>
</li>
<li><p>二分 + hash</p>
<p>对应第二种构造算法。</p>
<p>容易得知：此种解法的时间复杂度为 $O(Nlog^N)$。</p>
</li>
<li><p>线性解法</p>
<p>线性解法基于一个定理：</p>
<p>$height[rk[i]] \geq height[rk[i - 1]] - 1，height[rk[i]] \approx LCP(suffix(i), suffix(rk[i] - 1))$。</p>
<p>该定理证明比较简单，在此简单说明：</p>
<ul>
<li>当 $height[rk[i - 1]] \leq 1$ 时，$height[rk[i]]$ 需要大于等于零，这显然成立。</li>
<li>当 $height[rk[i - 1]] &gt; 1$ 时，我们可以得知：$suffix(i - 1)$ 与 $suffix(rk[i - 1] - 1)$ 的最长公共前缀大于 $1$。我们将第一个公共字符消去，则此时二者的最长公共前缀变为 $height[rk[i - 1]] - 1$。由于 $suffix(i - 1)$ 消去第一个字符的结果就是 $suffix(i)$，那么可以知道 $height[rk[i]]$ 的结果至少等于 $height[rk[i - 1]] - 1$。</li>
</ul>
<p>基于这个定理，我们可按照 $height[rk[i]]$ 顺序递推求解高度：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">calHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// k = height[rk[i - 1]]</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>, k = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.T.length(); i++) &#123;</span><br><span class="line">        <span class="comment">// height[rk[i]] &gt;= height[rk[i - 1]] - 1，故而k值需减一</span></span><br><span class="line">        <span class="keyword">if</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从k开始继续探索当前后缀与对应排名的上一个后缀相应位置字符是否相等，相等则继续探索，否则k对应就是最长公共前缀。</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">this</span>.T.charAt(i + k) == <span class="keyword">this</span>.T.charAt(<span class="keyword">this</span>.sa[<span class="keyword">this</span>.rk[i] - <span class="number">1</span>] + k)) &#123;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">this</span>.height[<span class="keyword">this</span>.rk[i]] = k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>顾名思义：此种解法的时间复杂度为 $O(N)$。</p>
</li>
</ul>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="两后缀最长公共前缀"><a href="#两后缀最长公共前缀" class="headerlink" title="两后缀最长公共前缀"></a>两后缀最长公共前缀</h3><p>对于相邻后缀而言，其最长公共前缀就是 $height[i]$。</p>
<p>对于不相邻后缀而言，由于所有后缀按照字典序进行排序，故而不相邻后缀的最长公共前缀应当等于此二者在数组 $sa$ 对应区间内 $height[i]$ 的最小值。</p>
<h3 id="不同子串的数目"><a href="#不同子串的数目" class="headerlink" title="不同子串的数目"></a>不同子串的数目</h3><p>子串最初被定义为 $T[i,j]$，当然它也可以被定义为某个后缀的前缀。</p>
<p>那么为求解不同子串数目，我们可以首先计算所有子串的数目，随后减去公共前缀的数目即可。</p>
<p>故而不同子串数目 $sum = (N * (N + 1)) / 2 - \sum height[i]$。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-前缀树/后缀树</title>
    <url>/2020/07/26/dataStructure/dataStructure-tiretree/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>前缀树</strong> 是一种专门用于处理字符串匹配问题的树形结构，它利用字符串公共前缀以减少查询所需时间。其典型应用为搜索引擎的搜索提示。</p>
<a id="more"></a>

<p>其结构图大致如下：</p>
<img src="/2020/07/26/dataStructure/dataStructure-tiretree/trie.png" alt="图一：前缀树" style="zoom:80%;">

<p>当面对字符串查询问题时，前缀树和哈希表通常会被同时提及，故而在此说明二者在此问题上的异同点：</p>
<ol>
<li>前者基于 “空间换时间” 加速查询；后者基于字符串公共前缀加速查询。</li>
<li>前者查询过程中存在 <em>冲突</em> 问题，如果散列函数选择得当，其查询操作的平均时间复杂度为 $O(1)$；后者按序匹配字符串中字符可实现查找，故而其查询操作的时间复杂度为 $O(k),k = str.length$。</li>
</ol>
<blockquote>
<p>前缀树中节点需要维护一个映射所有字符的引用数组，故而其耗费空间往往大于哈希表。</p>
<p>如果需要使用前缀树，现实情况应最好满足以下两点：字符集相对较小、字符串前缀重合较多。</p>
<p>前缀树又称为 Trie 树、字典树。</p>
</blockquote>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieTree</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 节点结构</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 词尾次数(end=0,表示当前节点并非任何字符串尾部;end=?,表示当前节点为?个字符串尾部)</span></span><br><span class="line">        <span class="keyword">int</span> end;</span><br><span class="line">        <span class="comment">// 26个元素的数组，表征26个字母</span></span><br><span class="line">        Node[] childrens;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.end = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">this</span>.childrens = <span class="keyword">new</span> Node[<span class="number">26</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根节点</span></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="辅助方法"><a href="#辅助方法" class="headerlink" title="辅助方法"></a>辅助方法</h3><ul>
<li><p>当前节点的孩子节点是否均为空</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isNullChildren</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Node node : root.childrens) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != node) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>当前子树中插入子串，并返回插入后的子树</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">insertTree</span><span class="params">(Node root, String str, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果当前子树为空，则先构建该子树。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == root) &#123;</span><br><span class="line">        root = <span class="keyword">new</span> Node();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果已到达字符串尾部，需更新当前节点end字段，否则找到相应字符，递归下去。</span></span><br><span class="line">    <span class="keyword">if</span> (index == str.length()) &#123;</span><br><span class="line">        root.end++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> charIndex = str.charAt(index) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        root.childrens[charIndex] = insertTree(root.childrens[charIndex], str, index + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>当前子树中删除指定字符串，并返回删除后的子树</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">deleteTree</span><span class="params">(Node root, String str, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前子树为空，直接返回。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已到达字符串尾部，择情处理，否则找到相应字符，递归下去。</span></span><br><span class="line">    <span class="keyword">if</span> (index == str.length()) &#123;</span><br><span class="line">        <span class="comment">// 表明存在该字符串，则次数减一。</span></span><br><span class="line">        <span class="keyword">if</span> (root.end &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            root.end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> charIndex = str.charAt(index) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        root.childrens[charIndex] = deleteTree(root.childrens[charIndex], str, index + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断当前节点是否需要删去。</span></span><br><span class="line">    <span class="keyword">if</span> (root.end == <span class="number">0</span> &amp;&amp; isNullChildren(root)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>当前子树中查询子串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">searchTree</span><span class="params">(Node root, String str, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前子树为空，直接返回false即可。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已到达字符串尾部，如果存在该字符串，则返回true，否则找到相应字符，递归下去。</span></span><br><span class="line">    <span class="keyword">if</span> (index == str.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> (root.end &gt; <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> charIndex = str.charAt(index) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> searchTree(root.childrens[charIndex], str, index + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TrieTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 无需任何操作。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><ul>
<li><p>查询字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> searchTree(<span class="keyword">this</span>.root, str, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="操纵"><a href="#操纵" class="headerlink" title="操纵"></a>操纵</h3></li>
<li><p>前缀树中添加字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 节点仅存储a-z的引用，故而需有此操作。</span></span><br><span class="line">    str = str.toLowerCase();</span><br><span class="line">    <span class="keyword">this</span>.root = insertTree(<span class="keyword">this</span>.root, str, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>前缀树中删除字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 节点仅存储a-z的引用，故而需有此操作。</span></span><br><span class="line">    str = str.toLowerCase();</span><br><span class="line">    <span class="keyword">this</span>.root = deleteTree(<span class="keyword">this</span>.root, str, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2></li>
</ul>
<h3 id="优化前缀树"><a href="#优化前缀树" class="headerlink" title="优化前缀树"></a>优化前缀树</h3><p>如上所述，前缀树中节点需要维护一个映射所有字符的引用数组，这使得其将耗费巨大空间。</p>
<p>我们以小写英文单词构建前缀树举例：树中节点需要维护一个引用数组，该数组映射字符集 $[a-z]$。如果向该前缀树中插入许多小写英文单词，我们将看到如下现象 (可参见图一)：</p>
<ol>
<li>引用数组的使用率很低。一个节点含有 $26$ 个引用，通常最多仅 $10$ 余个引用处于使用之中，其余引用均为 <code>null</code>。</li>
<li>部分节点往往仅有一个子节点，即该节点仅 $1$ 个引用处于使用之中。</li>
</ol>
<p>优化前缀树即在于如何管理引用数组。常见优化策略有如下两种：</p>
<ol>
<li>使用平衡二叉树代替引用数组，此时如果需要映射相关字符，就向平衡二叉树中动态插入一个引用节点。</li>
<li>如果节点仅含有一个子节点，则压缩两个节点为一个节点，此时节点内容为 “原节点内容 + 原子节点内容”。这种前缀树又被称为 <strong>压缩前缀树</strong>。</li>
</ol>
<h3 id="后缀树"><a href="#后缀树" class="headerlink" title="后缀树"></a>后缀树</h3><p>前缀树用于处理字符串查询匹配问题，后缀树则用于处理特定字符串的模式匹配问题，即模式是否出现于特定字符串之中？、模式在特定字符串中出现了几次，具体出现在哪些位置？</p>
<p>首先讲明一个结论：如果模式出现于特定字符串中，那么它一定是某个后缀的前缀。</p>
<p>基于此结论及前缀树的用法，我们可将特定字符串的所有后缀输入至空的前缀树之中，并使用此树解决特定字符串的模式匹配问题，而该树即是后缀树。</p>
<blockquote>
<p>后缀树又称为 <em>后缀压缩前缀树</em>，故而其实际上是将特定字符串的所有后缀输入至压缩前缀树之中。</p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-主席树</title>
    <url>/2020/07/24/dataStructure/dataStructure-hjttree/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>主席树</strong> 全称为 “可持久化权值线段树”，它可在 $O(log^N)$ 时间复杂度内实现查询任意指定区间 $[L,R]$ 内的第 $K$ 大/小元素。</p>
<a id="more"></a>

<p>其结构图大致如下：</p>
<img src="/2020/07/24/dataStructure/dataStructure-hjttree/image-20200724193347751.png" alt="图一：主席树" style="zoom: 50%;">

<p>主席树基于权值线段树实现，故而首先说明权值线段树的两个性质：</p>
<ol>
<li>权值线段树可以 $O(log^N)$ 时间查找整个区间内第 K 大/小元素。</li>
<li>假定所有元素按序尾部插入到数组之中，那么数组 $[0,R]$ 对应的权值线段树减去数组 $[0,L-1]$ 对应的权值线段树就是数组 $[L,R]$ 对应的权值线段树。</li>
</ol>
<p>基于上述两个性质，可以知道：如果保存插入任意元素后的所有权值线段树，那么就可实现在 $O(log^N)$ 时间复杂度内实现查询任意指定区间 $[L,R]$ 内的第 $K$ 大/小元素。如果保存所有权值线段树，其所需空间将是无法承受的。</p>
<p>观察权值线段树的插入操作，可以发现：一次操作仅会使得对应路径上的 $log^N$ 个节点内容发生变化。故而我们可以通过共用未修改节点使得所需空间降下来。当然，这也就是主席树的基本思想。</p>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HJTTree</span></span>&#123;</span><br><span class="line">    <span class="comment">// 权值数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] tree;</span><br><span class="line">    <span class="comment">// 历史根节点数组(基于此找到历史权值线段树)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] root;</span><br><span class="line">    <span class="comment">// 左儿子</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] left;</span><br><span class="line">    <span class="comment">// 右儿子</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] right;</span><br><span class="line">    <span class="comment">// 节点计数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> nodeCount;</span><br><span class="line">    <span class="comment">// 最新根节点位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> rootIndex;</span><br><span class="line">    <span class="comment">// 最大边界</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> Bound = <span class="number">1000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="辅助方法"><a href="#辅助方法" class="headerlink" title="辅助方法"></a>辅助方法</h3><ul>
<li><p>构建空的权值线段树</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前子树所负责区间仅有一个值，故直接赋值0即可。</span></span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        <span class="keyword">this</span>.tree[root] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取中间位置。</span></span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 基于nodeCount构建左右儿子节点。</span></span><br><span class="line">    <span class="keyword">this</span>.left[root] = ++<span class="keyword">this</span>.nodeCount;</span><br><span class="line">    <span class="keyword">this</span>.right[root] = ++<span class="keyword">this</span>.nodeCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归构建左右子树。</span></span><br><span class="line">    build(<span class="keyword">this</span>.left[root], l, mid);</span><br><span class="line">    build(<span class="keyword">this</span>.right[root], mid + <span class="number">1</span>, r);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 子树构建结果为空子树，故而无需更新根节点值。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>当前子树插入指定元素</p>
<p>插入指定元素过程中所经过路径上的节点均需拷贝以生成新节点，并更新这些节点的内容。这样新节点与未曾更改的旧节点就构成了插入指定元素后所对应的权值线段树。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">updateTree</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 复制该节点，并更新节点信息。</span></span><br><span class="line">    <span class="keyword">int</span> newNode = ++<span class="keyword">this</span>.nodeCount;</span><br><span class="line">    <span class="keyword">this</span>.left[newNode] = <span class="keyword">this</span>.left[root];</span><br><span class="line">    <span class="keyword">this</span>.right[newNode] = <span class="keyword">this</span>.right[root];</span><br><span class="line">    <span class="keyword">this</span>.tree[newNode] = <span class="keyword">this</span>.tree[root] + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前子树所负责区间仅有一个值，则直接返回复制的节点即可。</span></span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        <span class="keyword">return</span> newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取中间位置。</span></span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果mid&gt;=k，表明k应当位于左子树之中，故而需在左子树中进行更新；否则需在右子树中进行更新。</span></span><br><span class="line">    <span class="keyword">if</span> (mid &gt;= k) &#123;</span><br><span class="line">        <span class="keyword">this</span>.left[newNode] = updateTree(<span class="keyword">this</span>.left[newNode], l, mid, k);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.right[newNode] = updateTree(<span class="keyword">this</span>.right[newNode], mid + <span class="number">1</span>, r, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素的结果便是所经路径上各节点的值加一，第六行代码已经加过了，故而无需再更新根节点值。</span></span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>查询指定区间内第 $k$ 小元素</p>
<p>”概述“ 中通过二者相减得到指定区间 $[L.R]$ 对应的权值线段树，然后在此树上进行查找第 $k$ 小元素。实际代码实现中，这两步可直接合为一步，具体如代码示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getKthTree</span><span class="params">(<span class="keyword">int</span> startRoot, <span class="keyword">int</span> endRoot, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前子树所负责区域仅有一个值，如果对应元素个数(指代[L,R]对应权值线段树中的元素个数)大于k，则返回该元素，否则表明不存在，直接返回一个负数。</span></span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">this</span>.tree[endRoot] - <span class="keyword">this</span>.tree[startRoot] &gt; k) ? l : -HJTTree.Bound;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取中间位置。</span></span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 获取[L,R]对应权值线段树中左子树所包含的元素个数</span></span><br><span class="line">    <span class="keyword">int</span> x = <span class="keyword">this</span>.tree[<span class="keyword">this</span>.left[endRoot]] - <span class="keyword">this</span>.tree[<span class="keyword">this</span>.left[startRoot]];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果x&gt;k，表明第k小元素位于左子树之中，故而应在左子树中进行查找；否则应在右子树中进行查找。</span></span><br><span class="line">    <span class="keyword">if</span> (x &gt; k) &#123;</span><br><span class="line">        <span class="keyword">return</span> getKthTree(<span class="keyword">this</span>.left[startRoot], <span class="keyword">this</span>.left[endRoot], l, mid, k);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getKthTree(<span class="keyword">this</span>.right[startRoot], <span class="keyword">this</span>.right[endRoot], mid + <span class="number">1</span>, r, k - x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HJTTree</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 为各数组赋予足够大的空间。</span></span><br><span class="line">    <span class="keyword">this</span>.tree = <span class="keyword">new</span> <span class="keyword">int</span>[HJTTree.Bound &lt;&lt; <span class="number">5</span>];</span><br><span class="line">    <span class="keyword">this</span>.root = <span class="keyword">new</span> <span class="keyword">int</span>[HJTTree.Bound &lt;&lt; <span class="number">5</span>];</span><br><span class="line">    <span class="keyword">this</span>.left = <span class="keyword">new</span> <span class="keyword">int</span>[HJTTree.Bound &lt;&lt; <span class="number">5</span>];</span><br><span class="line">    <span class="keyword">this</span>.right = <span class="keyword">new</span> <span class="keyword">int</span>[HJTTree.Bound &lt;&lt; <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化各字段</span></span><br><span class="line">    <span class="keyword">this</span>.nodeCount = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">this</span>.rootIndex = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在this.root[0]处构建空的权值线段树</span></span><br><span class="line">    <span class="keyword">this</span>.root[++<span class="keyword">this</span>.rootIndex] = ++<span class="keyword">this</span>.nodeCount;</span><br><span class="line">    build(<span class="keyword">this</span>.root[<span class="keyword">this</span>.rootIndex], <span class="number">0</span>, HJTTree.Bound);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将元素依次插入，从而构建权值线段树集。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        update(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><ul>
<li><p>查询指定区间内的第$K$ 小元素</p>
<p>代码实现与 “概述” 中的描述同样有些不同。由于初始化时 <code>this.root[0]</code> 对应空权值线段树，故而区间 $[0,R]$ 对应的权值线段树为 <code>this.root[r + 1]</code>、区间 $[0,L]$ 对应的权值线段树为 <code>this.root[l + 1]</code>。此时按照 “概述” 所述，区间 $[L,R]$ 对应的权值线段树为 <code>this.root[r + 1] - this.root[l]</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getKth</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getKthTree(<span class="keyword">this</span>.root[l], <span class="keyword">this</span>.root[r + <span class="number">1</span>], <span class="number">0</span>, HJTTree.Bound, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="操纵"><a href="#操纵" class="headerlink" title="操纵"></a>操纵</h3></li>
<li><p>插入指定元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果该值不在当前值域之中，则直接返回。</span></span><br><span class="line">    <span class="keyword">if</span> (k &lt; <span class="number">0</span> || k &gt; HJTTree.Bound) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 每次插入元素后，需更新this.root[]。</span></span><br><span class="line">    ++<span class="keyword">this</span>.rootIndex;</span><br><span class="line">    <span class="keyword">this</span>.root[<span class="keyword">this</span>.rootIndex] = updateTree(<span class="keyword">this</span>.root[<span class="keyword">this</span>.rootIndex - <span class="number">1</span>], <span class="number">0</span>, HJTTree.Bound, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2></li>
</ul>
<p>另有两种数据结构可在 $O(log^N)$ 时间复杂度内实现查询任意指定区间 $[L,R]$ 内的第 $K$ 大/小元素——划分树和归并树。前者基于线段树和快速排序而成，后者基于线段树和归并排序而成。在这两种数据结构中，线段树中节点维护的不再是特定信息 (例如区间最大值)，而是区间具体内容。</p>
<h3 id="划分树"><a href="#划分树" class="headerlink" title="划分树"></a>划分树</h3><ul>
<li><p>构建过程</p>
<p>假定初始数组为 <code>a</code>，排序后的数组为 <code>b</code>。首先置 <code>level0</code> 为初始数组，故而其所负责区间为 $[0,a.length -1]$；随后利用 <code>level0</code> 所负责区间所在数组的中间值 (即 $b[a.length / 2]$) 将当前区间及所在数组划分为左右两部分，这两部分将构成 <code>level1</code>，随后递归处理 <code>level1</code> 左右两部分以构成最终的线段树。</p>
<p>另外在构建过程中，每个层级区间所在数组中每个元素 $i$ 还会存储 <code>cnt</code> 信息，它表示当前区间前 $i - 1$ 个元素被划分到左半部分的元素个数。</p>
<blockquote>
<p>划分过程中两点需要注意：</p>
<ol>
<li>如果中间值存在多个，需保证一部分中间值位于左半部分，一部分中间值位于右半部分。为达到这一目的，我们需要统计小于中间值的元素个数，按照左半部分区间大小即可确定左半部分需要放置的中间值个数。</li>
<li>划分过程需保证 <strong>元素相对顺序保持不变</strong>。例如：<code>level1</code> 中 <code>[3, 1, 4, 2]</code> 一定可以在 <code>[5, 3, 1, 7, 4, 2, 8, 6]</code> 上按序找到，而不会发生元素顺序倒逆的情况。</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a: [<span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">6</span>]</span><br><span class="line">b: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line"></span><br><span class="line">level0: [<span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">6</span>] </span><br><span class="line">    cnt:[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>]</span><br><span class="line">level1: [<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>][<span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">6</span>] </span><br><span class="line">    cnt:[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>][<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">level2: [<span class="number">1</span>, <span class="number">2</span>][<span class="number">3</span>, <span class="number">4</span>][<span class="number">5</span>, <span class="number">6</span>][<span class="number">7</span>, <span class="number">8</span>] </span><br><span class="line">    cnt:[<span class="number">0</span>, <span class="number">1</span>][<span class="number">0</span>, <span class="number">1</span>][<span class="number">0</span>, <span class="number">1</span>][<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">level3: [<span class="number">1</span>][<span class="number">2</span>][<span class="number">3</span>][<span class="number">4</span>][<span class="number">5</span>][<span class="number">6</span>][<span class="number">7</span>][<span class="number">8</span>] </span><br><span class="line">    cnt:[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] (这行信息没意义)</span><br></pre></td></tr></table></figure></li>
<li><p>查询过程</p>
<p>假定当前节点所在区间为 $[l,r]$、查找指定区间 $[L,R]$ 内的第 $K$ 个元素，$count = cnt[R + 1] - cnt[L]$ 即表示当前区间有多少个元素进入了左子树。如果 $count &gt; K$，则表明我们需在左子树中查找第 $K$ 个元素，由于元素区间已经发生变化，所以我们需要更新区间为 $[l + cnt[L],l + cnt[R + 1] - 1]$ ；否则我们需要在右子树中查找第 $K - count$ 个元素，此时更新区间为 $[mid + 1 + L - l - cnt[L],mid + 1 + R - l - cnt[R]]$。</p>
<blockquote>
<p>可以如此更新区间的原因在于：划分过程中元素相对顺序保持不变。</p>
</blockquote>
</li>
</ul>
<h3 id="归并树"><a href="#归并树" class="headerlink" title="归并树"></a>归并树</h3><ul>
<li><p>构建过程</p>
<p>由于归并排序过程与线段树构建过程高度一致，因此可以很容易构建归并树：</p>
<p><img src="/2020/07/24/dataStructure/dataStructure-hjttree/20160420202824621.png" alt="图二：构建归并树"></p>
</li>
<li><p>查询过程</p>
<p>归并树的查询过程比较废物。</p>
<p>为完成查询过程，首先需要构建一个函数 <code>rank</code>，它用于查询指定元素 <code>x</code> 在待查找区间 $[L,R]$ 中属于第几小元素。我们可以从线段树根节点开始，如果当前子树根节点所在区间在 $[L,R]$ 之内，则使用二分查找判断 <code>x</code> 在当前区间内属于第几小元素，否则递归左右子树，并将左右子树递归结构相加返回。二分过程的时间复杂度为 $O(log^N)$，查找区间过程的时间复杂度平均为 $O(log^N)$，故而该函数的时间复杂度平均为 $O(log^N * log^N)$ 。</p>
<p>由于线段树根节点所保存数组为有序的，那么我们可以再次使用二分算法搜索待查找区间 $[L,R]$ 内的第 $K$ 小元素。我们首先取中间位置元素，并且假定该元素为待查找区间 $[L,R]$ 中第 $k$ 小元素。如果 $k &gt; K$，则待查找区间 $[L,R]$ 内的第 $K$ 小元素应当位于左半部分；否则位于右半部分，然后进一步缩小区间查找即可。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-权值线段树</title>
    <url>/2020/07/24/dataStructure/dataStructure-weightsegmenttree/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>权值线段树</strong> 属于一种特殊的线段树。普通线段树基于元素个数开辟节点空间，节点之内维护特定信息 (例如，区间最大值、区间最小值)，权值线段树则基于元素值域开辟节点空间，节点之内维护当前区间内的元素个数。</p>
<a id="more"></a>

<p>其结构图大致如下：</p>
<p><img src="/2020/07/24/dataStructure/dataStructure-weightsegmenttree/image-20200724111818405.png" alt="图一：权值线段树"></p>
<p>由于节点维护当前区间内的元素个数，故而权值线段树可以 $O(log^N)$ 时间查找整个区间内第 $K$ 大/小元素。</p>
<p>权值线段树具有一个非常重要的性质：假定所有元素按序尾部插入到数组之中，那么数组 $[0,R]$ 对应的权值线段树减去数组 $[0,L-1]$ 对应的权值线段树就是数组 $[L,R]$ 对应的权值线段树。如果保存以往的权值线段树，那么就可以在 $log^N$ 时间复杂度内实现查询任意指定区间 $[L,R]$ 内的第 $K$ 大/小元素，这也是主席树的基本思想。</p>
<blockquote>
<ul>
<li>如果了解桶排序，容易知道：权值线段树维护的是桶信息。</li>
</ul>
</blockquote>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>在 <a href="/2020/07/16/dataStructure/dataStructure-segmenttree/" title="数据结构-线段树">数据结构-线段树</a> 中，我们直接使用数组实现线段树。这里采用一种不同的写法，我们选用静态链表进行实现。另外我们直接指定元素类型为 <code>int</code> 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeightSegmentTree</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 权值数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] tree;</span><br><span class="line">    <span class="comment">// 左儿子</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] left;</span><br><span class="line">    <span class="comment">// 右儿子</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] right;</span><br><span class="line">    <span class="comment">// 节点计数(以此方式指定左右儿子节点在tree中位置)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> nodeCount;</span><br><span class="line">    <span class="comment">// 最大边界，故而值域范围为[0,1000]</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> Bound = <span class="number">1000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="辅助方法"><a href="#辅助方法" class="headerlink" title="辅助方法"></a>辅助方法</h3><ul>
<li><p>构建权值线段树</p>
<p>以 <code>root</code> 为根节点、所负责区间为 $[l,r]$ 的子树基于含有元素个数信息的 <code>sum</code> 进行构建权值线段树。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> l, <span class="keyword">int</span> r, HashMap&lt;Integer, Integer&gt; sum)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 区间内仅有一个值，则赋值sum中该值对应的个数，如果没有就赋值为0。</span></span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        <span class="keyword">this</span>.tree[root] = sum.containsKey(l) ? sum.get(l) : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取中间位置。</span></span><br><span class="line">    <span class="keyword">int</span> mid = (l + r ) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 基于nodeCount构建左右儿子节点。</span></span><br><span class="line">    <span class="keyword">this</span>.left[root] = ++nodeCount;</span><br><span class="line">    <span class="keyword">this</span>.right[root] = ++nodeCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归构建左右子树。</span></span><br><span class="line">    build(<span class="keyword">this</span>.left[root], l, mid, sum);</span><br><span class="line">    build(<span class="keyword">this</span>.right[root], mid + <span class="number">1</span>, r, sum);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新根节点值。</span></span><br><span class="line">    <span class="keyword">this</span>.tree[root] = <span class="keyword">this</span>.tree[<span class="keyword">this</span>.left[root]] + <span class="keyword">this</span>.tree[<span class="keyword">this</span>.right[root]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>当前子树内查询第 $K$ 小元素 ($K \in[0,\infty)$)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getKthTree</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前子树所负责区域仅有一个值，如果对应元素个数大于k，则返回该元素，否则表明不存在，直接返回一个负数。</span></span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">this</span>.tree[root] &gt; k) ? l : -WeightSegmentTree.Bound;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取中间位置。</span></span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取左子树所负责区间中的元素个数</span></span><br><span class="line">    <span class="keyword">int</span> x = <span class="keyword">this</span>.tree[<span class="keyword">this</span>.left[root]];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// x&gt;k，表明第k小元素在左子树之中，故而应在左子树中进行查询；否则在右子树中进行查询。</span></span><br><span class="line">    <span class="keyword">if</span> (x &gt; k) &#123;</span><br><span class="line">        <span class="keyword">return</span> getKthTree(<span class="keyword">this</span>.left[root], l, mid, k);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getKthTree(<span class="keyword">this</span>.right[root], mid + <span class="number">1</span>, r, k - x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第 $K$ 大元素代码与此类似，故不赘述。</p>
</blockquote>
</li>
<li><p>当前子树插入/删除指定元素若干次</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> num, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        <span class="comment">// 如果更新有效，则更新，否则不更新。</span></span><br><span class="line">        <span class="keyword">this</span>.tree[root] = (<span class="keyword">this</span>.tree[root] + count &gt;= <span class="number">0</span>) ? <span class="keyword">this</span>.tree[root] + count : <span class="keyword">this</span>.tree[root];</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取中间位置。</span></span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据中间位置判断指定元素位于何处。如果位于左子树，则在左子树中更新，否则在右子树中更新。</span></span><br><span class="line">    <span class="keyword">if</span> (mid &gt;= num) &#123;</span><br><span class="line">        update(<span class="keyword">this</span>.left[root], l, mid, num ,count);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        update(<span class="keyword">this</span>.right[root], l, mid, num ,count);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更新根节点值。</span></span><br><span class="line">    <span class="keyword">this</span>.tree[root] = <span class="keyword">this</span>.tree[<span class="keyword">this</span>.left[root]] + <span class="keyword">this</span>.tree[<span class="keyword">this</span>.right[root]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">WeightSegmentTree</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 为各数组赋予足够大的空间。</span></span><br><span class="line">    <span class="keyword">this</span>.tree = <span class="keyword">new</span> <span class="keyword">int</span>[WeightSegmentTree.Bound &lt;&lt; <span class="number">5</span>];</span><br><span class="line">    <span class="keyword">this</span>.left = <span class="keyword">new</span> <span class="keyword">int</span>[WeightSegmentTree.Bound &lt;&lt; <span class="number">5</span>];</span><br><span class="line">    <span class="keyword">this</span>.right = <span class="keyword">new</span> <span class="keyword">int</span>[WeightSegmentTree.Bound &lt;&lt; <span class="number">5</span>];</span><br><span class="line">    <span class="keyword">this</span>.nodeCount = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计各元素的个数信息。</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; sum = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> element : arr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sum.containsKey(element)) &#123;</span><br><span class="line">            sum.replace(element, sum.get(element) + <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sum.put(element, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建根节点</span></span><br><span class="line">    <span class="keyword">int</span> root = ++<span class="keyword">this</span>.nodeCount;</span><br><span class="line">    build(root, <span class="number">0</span>, WeightSegmentTree.Bound, sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><ul>
<li><p>查询第$K$小元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getKth</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getKthTree(<span class="number">0</span>, <span class="number">0</span>, WeightSegmentTree.Bound, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="操纵"><a href="#操纵" class="headerlink" title="操纵"></a>操纵</h3></li>
<li><p>插入/删除指定元素若干次</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果该值不在当前值域之中，则直接返回。</span></span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="number">0</span> || num &gt; WeightSegmentTree.Bound) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    update(<span class="number">0</span>, <span class="number">0</span>, WeightSegmentTree.Bound, num, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-树状数组(二叉索引树)</title>
    <url>/2020/07/17/dataStructure/dataStructure-binaryindexedtree/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>树状数组 (二叉索引树)</strong> 是一种用以维护<em>区间信息</em> 的数据结构。它具有实现简单、操作时间复杂度常数低于线段树等优点，但是它的适用范围小于线段树。</p>
<a id="more"></a>

<p>其结构图大致如下：</p>
<img src="/2020/07/17/dataStructure/dataStructure-binaryindexedtree/v2-9534bfb8a16941e7bba2af2e8cc934eb_b.png" alt="图一：树状数组" style="zoom:80%;">

<p>树状数组常用于求取指定区间元素之和，故而我们以此为引，讲述树状数组的思想。</p>
<p>假定存在一个数组 $A = [a_1, a_2, \dots, a_n]$ ，其上有两种操作：求取指定区间 $[fromIndex, toIndex]$ 元素之和、动态修改指定位置 $index$ 所在元素。我们很容易想到如下两种方案以满足这两种操作：</p>
<ol>
<li><p>基于普通数组</p>
<p>直接在该数组之上执行这两种操作。对于第一个操作而言，遍历指定区间，求和各元素，其时间复杂度为 $O(N)$；对于第二个操作，直接修改指定位置元素，其时间复杂度为 $O(1)$ 。</p>
</li>
<li><p>基于前缀数组</p>
<p>将该数组转换为前缀数组 $prefix[]$ 以执行这两种操作。对于第一种操作而言，$prefix(toIndex) - prefix(fromIndex - 1)$ 即为指定区间元素之和，其时间复杂度为 $O(1)$；对于第二种操作，由于该位置之后的前缀元素都涉及加和该元素，故而需修改区间 $[index, prefix.length - 1]$ 内的所有元素，其时间复杂度为 $O(N)$ 。</p>
</li>
</ol>
<p>从上述描述中，可以看到：两种方案各有优缺点，一种操作的时间复杂度极低，另一种操作的时间复杂度极高。对于树状数组而言，它可保证两种操作的时间复杂度均为 $O(log^N)$，这一点通过 “分层构造前缀和” 而做到。</p>
<p>树状数组其本质是一个数组，只不过基于数组索引的二进制位将数组逻辑映射为一棵树。我们首先介绍若干概念：</p>
<ol>
<li><p>$lowBit(index)$ </p>
<p>$lowBit(index)$ 定义为非负整数 $index$ 在二进制位表示下 “最低位的 $1$ 及其后所有的 $0$ “ 构成的数值。</p>
<p>举例：$lowBit(24) = lowBit(0b00011000) = 0b1000 = 8$ 。</p>
</li>
<li><p>$rangSum(index)$</p>
<p>$rangSum(index)$ 定义为当前位置开始前 $i$ 个数之和，其中 $i = 2^k$，$k$ 为 $index$ 的二进制位表示下低位连续 $0$ 的个数。该定义同样可表示为当前位置开始前 $lowBit(index)$ 个数之和。</p>
<p>举例：$rangSum(24) = rangSum(0b00011000)$，其为当前位置 $24$ 开始前 $2^3 = 8$ 个数之和，即区间 $[17,24]$ 元素之和。</p>
</li>
</ol>
<p>基于此二者概念，按照 $rangSum(index)$ 所覆区间范围，可将其抽象为一棵树，具体如图一所示。</p>
<p>如果修改指定位置所在元素，只要向上依次修改其对应父节点所在元素即可，这一点可基于 $lowBit(index)$ 实现。例如：$parent(5) = 5 + lowBit(5) = 6， parent(6) = 6 + lowBit(6) = 8$ 。</p>
<p>另外，我们还可容易计算 $prefix(index)$ (假定数组开始位置为 $1$)，同样以图一举例说明：</p>
<p>$$prefix(6) = rangSum(6) + rangSum(6 - lowBit(6)) = rangSum(6) + rangSum(4) = [5,6] + [1,4]$$</p>
<blockquote>
<p>树状数组不仅可用于指定区间求和，还可用于指定区间求最大值、指定区间求最小值等操作，但是为叙述方便，上述均以指定区间求和为例进行解释。</p>
</blockquote>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryIndexedTree</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 树状数组</span></span><br><span class="line">    <span class="keyword">private</span> Object[] bitArr;</span><br><span class="line">    <span class="comment">// 合并函数</span></span><br><span class="line">    <span class="keyword">private</span> Merge&lt;E&gt; merger;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Merge</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">E <span class="title">merge</span><span class="params">(E o1, E o2)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对应到求取 $prefix(index)$，接口实现应当为 $merger = (o1, o2) -&gt; o1 + o2$ 。</p>
</blockquote>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="辅助方法"><a href="#辅助方法" class="headerlink" title="辅助方法"></a>辅助方法</h3><ul>
<li><p>$lowBit()$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lowBit</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> index &amp; (-index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3></li>
</ul>
<p>树状数组初始化有两种方式，在此一一叙述：</p>
<ol>
<li><p>基于更新实现</p>
<p>最初置 $bitArr$ 中元素均为 $0$，顺序使用 $update()$ 更新每位。这种做法的时间复杂度为 $O(Nlog^N)$，但是它揭示了树状数组可在尾部插入元素这一事实。</p>
</li>
<li><p>直接遍历实现</p>
<p>首先置 $bitArr$ 中元素均为元素数组对应元素，然后顺序遍历该数组，当遍历到某一个位置时，将当前元素合并到其父节点所在元素之中即可。这种做法的时间复杂度为 $O(N)$。代码实现中使用的便是这种做法。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BinaryIndexedTree</span><span class="params">(E[] arr, Merge&lt;E&gt; merger)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 相比于原始数组而言，树状数组元素需后移一位。</span></span><br><span class="line">    <span class="keyword">this</span>.bitArr = <span class="keyword">new</span> Object[arr.length + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">this</span>.merger = merger;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>.bitArr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">this</span>.bitArr[i] = arr[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>.bitArr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = i + lowBit(i);</span><br><span class="line">        <span class="keyword">if</span> (j &lt; <span class="keyword">this</span>.bitArr.length) &#123;</span><br><span class="line">            <span class="keyword">this</span>.bitArr[j] = <span class="keyword">this</span>.merger.merge((E) <span class="keyword">this</span>.bitArr[j], (E) <span class="keyword">this</span>.bitArr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><ul>
<li><p>查询指定区间 $[0,index]$ 值 </p>
<p>该值可以是区间元素之和、区间最大值、区间最小值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">query</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// bitArr中元素均后移一位，故而需有此操作。</span></span><br><span class="line">    index++;</span><br><span class="line">    <span class="comment">// 输入非法，直接返回。</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt;= <span class="number">0</span> || index &gt;= <span class="keyword">this</span>.bitArr.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    E result = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (index != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == result) &#123;</span><br><span class="line">            result = (E) <span class="keyword">this</span>.bitArr[index];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result = <span class="keyword">this</span>.merger.merge(result, (E) <span class="keyword">this</span>.bitArr[index]);</span><br><span class="line">        &#125;</span><br><span class="line">        index -= lowBit(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="操纵"><a href="#操纵" class="headerlink" title="操纵"></a>操纵</h3></li>
<li><p>为指定位置元素加上某一差值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> index, E delta)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// bitArr中元素均后移一位，故而需有此操作。</span></span><br><span class="line">    index++;</span><br><span class="line">    <span class="comment">// 输入非法，直接返回。</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt;= <span class="number">0</span> || index &gt;= <span class="keyword">this</span>.bitArr.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (index &lt; <span class="keyword">this</span>.bitArr.length) &#123;</span><br><span class="line">        <span class="keyword">this</span>.bitArr[index] = <span class="keyword">this</span>.merger.merge((E) <span class="keyword">this</span>.bitArr[index], delta);</span><br><span class="line">        index += lowBit(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>这里介绍一种类似的数据结构——ST表。</p>
<p>ST表常用于解决 <strong>可重复贡献问题</strong> 。它可实现 $O(Nlog^N)$ 内建表、$O(1)$ 内查询，但是无法动态修改。</p>
<blockquote>
<p><strong>可重复贡献问题：</strong></p>
<p>对于运算 $opt$，如果满足 $x \ opt \ x = x $，则对应的区间查询就是一个可重复贡献问题。例如，区间最大值、区间最小值，但是区间求和就不是一个可重复贡献问题。</p>
</blockquote>
<p>ST表其本质是基于倍增思想、动态规划构建的一张二维表格。这里以求取区间最大值为例。</p>
<p>我们规定：$A$ 为元素数组、$f[i][j]$ 表示区间 $[i,i + 2^j - 1]$ 内元素最大值。</p>
<p>初始化条件即为：$f[i][0] = A[i], i \in [0, A.length]$ 。</p>
<p>状态转换方程即为：$f[i][j] = max(f[i][j - 1],f[i + 2^{j - 1}][j - 1])$ 。</p>
<p>基于上面两个等式，即可构建这张表。表大小为 $O(Nlog^N)$，故而建表的时间复杂度亦是如此。</p>
<p>对于任意指定区间 $[L,R]$，区间内最大值即为 $max(f[L][k],f[R - 2^{k} + 1][k]), \  k= \lfloor log_2^{(R - L + 1)}\rfloor$ 。</p>
<blockquote>
<p>该等式成立原因即在于：$2^{\lfloor log_2^{(R - L + 1)}\rfloor} &gt;= (R - L + 1) / 2$。正因如此，从 $L$ 开始前向 $2^k$ 个元素对应区间与从 $R$ 开始后向 $2^k$ 个元素对应区间的并集一定等于 $[L,R]$，故而二者之间的最大值亦为区间 $[L,R]$ 的最大值。从中也可看出，$f[L][k]$ 与 $f[R - 2^{k} + 1][k]$ 所覆盖区间是有重叠的，这也正是 “ST表只能解决可重复贡献问题” 的原因。</p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>线性表</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-线段树</title>
    <url>/2020/07/16/dataStructure/dataStructure-segmenttree/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>线段树</strong> 是一种用以维护<em>区间信息</em> 的数据结构，它可在 $O(log^N)$ 时间内实现单点修改、区间修改、区间查询（区间求和，求区间最大值，求区间最小值）等操作。</p>
<a id="more"></a>

<p>其结构图大致如下：</p>
<img src="/2020/07/16/dataStructure/dataStructure-segmenttree/2971b5df5eba05a50650ec77e938d28689108333de3802c194b0b9982e881999-u=1091946519,1765257349&amp;fm=26&amp;gp=0.png" alt="图一：线段树" style="zoom:50%;">

<p>关于线段树，以下几点需要注意：</p>
<ol>
<li>线段树与区间树没有任何关系。</li>
<li>线段树不支持插入、删除操作。</li>
<li>叶节点保存数组中指定位置元素，非叶节点保存所在区间的值 (例如：区间最大值、区间最小值)。</li>
</ol>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>观察图一，发现其结构基本等同于一棵完全二叉树，故而我们使用数组加以实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SegmentTree</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 基础数组(从0开始)</span></span><br><span class="line">    <span class="keyword">private</span> Object[] elementData;</span><br><span class="line">    <span class="comment">// 线段树元素个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="comment">// 合并接口</span></span><br><span class="line">    <span class="keyword">private</span> Merge&lt;E&gt; merger;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Merge</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">E <span class="title">merge</span><span class="params">(E o1, E o2)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="辅助方法"><a href="#辅助方法" class="headerlink" title="辅助方法"></a>辅助方法</h3><ul>
<li><p>构建线段树</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> treeIndex, <span class="keyword">int</span> l, <span class="keyword">int</span> r, E[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 到达叶节点，直接赋值、返回即可。</span></span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData[treeIndex] = arr[l];</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取中间位置、左节点位置、右节点位置。</span></span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> leftTreeIndex = treeIndex * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> rightTreeIndex = treeIndex * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 递归构建左右子树，并更新当前节点所在区间值。</span></span><br><span class="line">    build(leftTreeIndex, l, mid, arr);</span><br><span class="line">    build(rightTreeIndex, mid + <span class="number">1</span>, r, arr);</span><br><span class="line">    <span class="keyword">this</span>.elementData[treeIndex] = merger.merge((E) <span class="keyword">this</span>.elementData[leftTreeIndex], (E) <span class="keyword">this</span>.elementData[rightTreeIndex]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>当前子树查询指定区间值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">queryTree</span><span class="params">(<span class="keyword">int</span> treeIndex, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 满足查询区间，直接返回即可。</span></span><br><span class="line">    <span class="keyword">if</span> (l == left &amp;&amp; r == right) &#123;</span><br><span class="line">        <span class="keyword">return</span> (E) <span class="keyword">this</span>.elementData[treeIndex];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取中间位置、左节点位置、右节点位置。</span></span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> leftTreeIndex = treeIndex * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> rightTreeIndex = treeIndex * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查询区间在左子树所在区间之中，则在左子树中进行查询。</span></span><br><span class="line">    <span class="keyword">if</span> (mid &gt;= right) &#123;</span><br><span class="line">        <span class="keyword">return</span> queryTree(leftTreeIndex, l, mid, left, right);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mid &lt; left) &#123;</span><br><span class="line">        <span class="comment">// 查询区间在右子树所在区间之中，则在右子树中进行查询。</span></span><br><span class="line">        <span class="keyword">return</span> queryTree(rightTreeIndex, mid + <span class="number">1</span>, r, left, right);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 查询区间横贯左右子树所在区间，则在左右子树中进行相应查找，然后合并查询结果即可。</span></span><br><span class="line">        <span class="keyword">return</span> merger.merge(queryTree(leftTreeIndex, l, mid, left, mid), queryTree(rightTreeIndex, mid + <span class="number">1</span>, r, mid + <span class="number">1</span>, right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>当前子树更新指定位置元素内容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateTree</span><span class="params">(<span class="keyword">int</span> treeIndex, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> index, E value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 找到指定位置元素，直接修改即可。</span></span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData[treeIndex] = value;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取中间位置、左节点位置、右节点位置。</span></span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> leftTreeIndex = treeIndex * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> rightTreeIndex = treeIndex * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果指定位置在左子树所在区间之中，则在左子树中进行修改，反之则在右子树中进行修改。</span></span><br><span class="line">    <span class="keyword">if</span> (mid &gt;= index) &#123;</span><br><span class="line">        updateTree(leftTreeIndex, l, mid, index, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        updateTree(rightTreeIndex, mid + <span class="number">1</span>, r, index, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新当前节点所在区间值。</span></span><br><span class="line">    <span class="keyword">this</span>.elementData[treeIndex] = merger.merge((E) <span class="keyword">this</span>.elementData[leftTreeIndex], (E) <span class="keyword">this</span>.elementData[rightTreeIndex]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SegmentTree</span><span class="params">(E[] arr, Merge&lt;E&gt; merger)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据相关推理，如果数组长度为N,对应线段树最多需要4N空间。</span></span><br><span class="line">    <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[<span class="number">4</span> * arr.length];</span><br><span class="line">    <span class="keyword">this</span>.size = arr.length;</span><br><span class="line">    <span class="keyword">this</span>.merger = merger;</span><br><span class="line"></span><br><span class="line">    build(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">this</span>.size - <span class="number">1</span>, arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><ul>
<li><p>查询指定区间的值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">query</span><span class="params">(<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; <span class="number">0</span> || right &gt;= <span class="keyword">this</span>.size || left &lt; right) &#123;</span><br><span class="line">        <span class="comment">// 输入非法，直接返回。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queryTree(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">this</span>.size - <span class="number">1</span>, left, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="操纵"><a href="#操纵" class="headerlink" title="操纵"></a>操纵</h3></li>
<li><p>更新指定位置元素内容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> index, E value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="keyword">this</span>.size) &#123;</span><br><span class="line">        <span class="comment">// 输入非法，直接返回。</span></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    updateTree(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">this</span>.size - <span class="number">1</span>, index, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>更新指定区间内容</p>
<p>更新指定区间内容涉及更新具体操作，我们在此规定情景，并指明更新区间内容的方法。</p>
<p>我们规定情景如下：</p>
<ol>
<li>非叶节点保存所在区间元素的最大值。</li>
<li>更新操作为：为指定区间所有元素均加上某一常数。</li>
</ol>
<p>搜索找到区间内所有元素，并为其加上某一常数，这样即可达到更新目的。显而易见，这种方式的时间复杂度为 $O(N)$。为使得更新操作复杂度降为 $O(log^N)$，线段树引入懒更新。</p>
<p>首先在节点结构中引入 <code>mark</code> 字段 (其意义：为左右子树各元素需要加上的常数)。进行更新操作时，我们找到需要更新区间对应的节点，然后仅更新这些节点的所在区间值和 <code>mark</code> 字段。后续查询到某个节点时，如果该节点的 <code>mark</code> 字段非零，表明左右子树需要更新，则更新左右子树根节点的信息 (如果左右子树根节点被访问，则进一步更新对应节点的左右子树根节点，直至到达叶节点)。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-块状链表</title>
    <url>/2020/07/13/dataStructure/dataStructure-blocklist/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>块状链表</strong> 是一种比较中庸的数据结构。它将 “分块思想” 应用于链表之中，从而整合了线性表与链表的优缺点，使得其上操作的时间复杂度均为 $O(\sqrt{N})$。</p>
<a id="more"></a>

<p>其结构图大致如下：</p>
<p><img src="/2020/07/13/dataStructure/dataStructure-blocklist/image-20200713144042279.png" alt="图一：块状链表"></p>
<p>假定数据总量为 $N$，将这些数据均分为 $\sqrt{N}$ 块，块内数据使用线性表进行存储，块间使用引用进行链接，如此组织便是块状链表。对块状链表操作时，首先需要花费 $O(\sqrt{N})$ 时间定位到块，随后花费 $O(\sqrt{N})$ 在块内执行操作，故而操作的时间复杂度为 $O(\sqrt{N})$。</p>
<blockquote>
<p>“分块思想” 其本质为一棵仅有三层的多叉树，其结构如图所示。</p>
<img src="/2020/07/13/dataStructure/dataStructure-blocklist/20200115105823531.png" alt="图二：分块思想" style="zoom: 25%;">
</blockquote>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>块状链表中存储的数据量大小通常是未知的，故而通常需要预估数据量大小以指定块大小。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlockList</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 节点结构</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">// 块内元素个数</span></span><br><span class="line">        <span class="keyword">int</span> blockSize;</span><br><span class="line">        <span class="comment">// 块内线性表</span></span><br><span class="line">        Object[] blockArr;</span><br><span class="line">        <span class="comment">// 后继块</span></span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.blockSize = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">this</span>.blockArr = <span class="keyword">new</span> Object[BlockList.BLOCK_SIZE];</span><br><span class="line">            <span class="keyword">this</span>.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 块大小</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BLOCK_SIZE = <span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 链首</span></span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>块状链表中块大小及块个数决定着操作的时间复杂度，因此每次操作后需要对此二者进行一定调整。</p>
<h3 id="辅助方法"><a href="#辅助方法" class="headerlink" title="辅助方法"></a>辅助方法</h3><ul>
<li><p>相邻块合并</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unionBlock</span><span class="params">(Node&lt;E&gt; e1, Node&lt;E&gt; e2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 合并线性表中元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; e2.blockSize; i++) &#123;</span><br><span class="line">        e1.blockArr[e1.blockSize + i] = e2.blockArr[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新相关字段</span></span><br><span class="line">    e1.blockSize += e2.blockSize;</span><br><span class="line">    e1.next = e2.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>维护链形态</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">maintain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">this</span>.head;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">null</span> != node &amp;&amp; <span class="keyword">null</span> != node.next) &#123;</span><br><span class="line">        <span class="comment">// 如果相邻块中元素个数小于指定的块大小，则需要进行合并。</span></span><br><span class="line">        <span class="keyword">if</span> (node.blockSize + node.next.blockSize &lt; BlockList.BLOCK_SIZE) &#123;</span><br><span class="line">            unionBlock(node, node.next);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在指定位置处分割块</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">splitBlock</span><span class="params">(Node&lt;E&gt; e1, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// index非法，直接返回即可。</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; e1.blockSize) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建新块，并调整引用。</span></span><br><span class="line">    Node&lt;E&gt; e2 = <span class="keyword">new</span> Node&lt;&gt;();</span><br><span class="line">    e2.next = e1.next;</span><br><span class="line">    e1.next = e2;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 分割线性表中元素。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; e1.blockSize; i++) &#123;</span><br><span class="line">        e2.blockArr[i - index] = e1.blockArr[i];</span><br><span class="line">        e2.blockSize++;</span><br><span class="line">        e1.blockArr[i] = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    e1.blockSize = index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BlockList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    head = <span class="keyword">new</span> Node&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><ul>
<li><p>查询指定位置的元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">this</span>.head;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">null</span> != node) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= node.blockSize) &#123;</span><br><span class="line">            index = index - node.blockSize;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span> == node ? <span class="keyword">null</span> : (E) node.blockArr[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="操纵"><a href="#操纵" class="headerlink" title="操纵"></a>操纵</h3></li>
<li><p>块状链表中添加元素</p>
<p>我们假定块中元素个数始终小于指定的块大小。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> index, E item)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 寻找待插入块及待插入位置</span></span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">this</span>.head;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; node.blockSize) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != node.next) &#123;</span><br><span class="line">                index = index - node.blockSize;</span><br><span class="line">                node = node.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 插入位置有误，直接返回即可。</span></span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素至指定位置。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = node.blockSize; i &gt; index; i--) &#123;</span><br><span class="line">        node.blockArr[i] = node.blockArr[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    node.blockArr[index] = item;</span><br><span class="line">    node.blockSize++;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 插入元素后，如果块已满，则需要从中部分割块。</span></span><br><span class="line">    <span class="keyword">if</span> (node.blockSize == BlockList.BLOCK_SIZE) &#123;</span><br><span class="line">        splitBlock(node, BlockList.BLOCK_SIZE / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    maintain();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>块状链表中删除元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 寻找待删除块及待删除位置</span></span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">this</span>.head;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">null</span> != node) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= node.blockSize) &#123;</span><br><span class="line">            index = index - node.blockSize;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有找到，直接返回即可。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == node) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除指定元素。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; node.blockSize - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        node.blockArr[i] = node.blockArr[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    node.blockSize--;</span><br><span class="line">    node.blockArr[node.blockSize] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    maintain();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>线性表</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-配对堆</title>
    <url>/2020/07/12/dataStructure/dataStructure-pairheap/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>配对堆</strong> 是斐波那契堆的简化版本。其不仅具有斐波那契堆那般优秀的操作复杂度，同时易于实现。</p>
<a id="more"></a>

<p>其结构图大致如下：</p>
<p><img src="/2020/07/12/dataStructure/dataStructure-pairheap/%E4%B8%8B%E8%BD%BD.png" alt="图一：配对堆"></p>
<p>相比斐波那契堆实现而言，配对堆主要在如下两个方面进行优化：1. 优化节点结构，节省节点所需内存空间；2. 降低各种操作的编码复杂度。</p>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>配对堆中节点除保存具体元素外，仅需保存三个引用即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PairHeap</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 节点结构</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">// 具体元素</span></span><br><span class="line">        E item;</span><br><span class="line">        <span class="comment">// 左儿子</span></span><br><span class="line">        Node&lt;E&gt; leftChild;</span><br><span class="line">        <span class="comment">// 兄弟节点</span></span><br><span class="line">        Node&lt;E&gt; nextSibling;</span><br><span class="line">        <span class="comment">// 前驱节点，如果当前节点为第一个左儿子，其指向即为父节点。</span></span><br><span class="line">        Node&lt;E&gt; pre;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E item, Node&lt;E&gt; leftChild, Node&lt;E&gt; nextSibling, Node&lt;E&gt; pre)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.item = item;</span><br><span class="line">            <span class="keyword">this</span>.leftChild = leftChild;</span><br><span class="line">            <span class="keyword">this</span>.nextSibling = nextSibling;</span><br><span class="line">            <span class="keyword">this</span>.pre = pre;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根节点</span></span><br><span class="line">    Node&lt;E&gt; root;</span><br><span class="line">    <span class="comment">// 比较函数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> E&gt; comparator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="辅助方法"><a href="#辅助方法" class="headerlink" title="辅助方法"></a>辅助方法</h3><ul>
<li><p>重置 <code>pre</code> 与 <code>nextSibling</code> 引用</p>
<p>重置此二者，保证配对堆合法（配对堆根节点的 <code>pre</code> 与 <code>nextSibling</code> 应当为 <code>null</code>）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">(Node&lt;E&gt; root)</span> </span>&#123;</span><br><span class="line">    root.pre = <span class="keyword">null</span>;</span><br><span class="line">    root.nextSibling = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>合并两个配对堆</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;E&gt; <span class="title">merge</span><span class="params">(Node&lt;E&gt; root1, Node&lt;E&gt; root2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 只要一者为空，直接返回另一者即可。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == root1) &#123;</span><br><span class="line">        <span class="keyword">return</span> root2;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">null</span> == root2) &#123;</span><br><span class="line">        <span class="keyword">return</span> root1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果前者大于后者，则应交换二者。</span></span><br><span class="line">    <span class="keyword">if</span> (comparator.compare(root1.item, root2.item) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> merge(root2, root1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保证配对堆合法。</span></span><br><span class="line">    reset(root1);</span><br><span class="line">    reset(root2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调整相关引用。</span></span><br><span class="line">    root2.nextSibling = root1.leftChild;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != root1.leftChild) &#123;</span><br><span class="line">        root1.leftChild.pre = root2;</span><br><span class="line">    &#125;</span><br><span class="line">    root1.leftChild = root2;</span><br><span class="line">    root2.pre = root1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>合并一个节点的所有兄弟节点</p>
<p>合并兄弟节点的顺序是有要求的：所有兄弟节点按顺序从前往后两两配对进行合并，随后从后往前依次合并即可。只有按照此种方式进行合并，才能够保证 $O(log^N)$ 的复杂度界限。</p>
<img src="/2020/07/12/dataStructure/dataStructure-pairheap/image-20200712214247925.png" alt="图二：合并一个节点的所有兄弟节点" style="zoom: 50%;">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;E&gt; <span class="title">merges</span><span class="params">(Node&lt;E&gt; root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前节点为空，或者没有任何儿子节点，直接返回该节点即可。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == root || <span class="keyword">null</span> == root.nextSibling) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != root) &#123;</span><br><span class="line">            reset(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出前两个兄弟节点</span></span><br><span class="line">    Node&lt;E&gt; first = root;</span><br><span class="line">    Node&lt;E&gt; second = first.nextSibling;</span><br><span class="line">    root = second.nextSibling;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> merge(merge(first, second), merges(root));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PairHeap</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><ul>
<li><p>查询最小元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span> == <span class="keyword">this</span>.root ? <span class="keyword">null</span> : <span class="keyword">this</span>.root.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="操纵"><a href="#操纵" class="headerlink" title="操纵"></a>操纵</h3></li>
<li><p>配对堆合并</p>
<p>直接合并即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(PairHeap&lt;E&gt; pairHeap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.root = merge(<span class="keyword">this</span>.root, pairHeap.root);</span><br><span class="line">    pairHeap.root = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>配对堆中添加元素</p>
<p>将待添加元素包装为一个配对堆，然后合并两个堆即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E item)</span> </span>&#123;</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;&gt;(item, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">this</span>.root = merge(<span class="keyword">this</span>.root, node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>配对堆中删除最小元素</p>
<p>合并根节点的所有儿子节点，然后将合并结果赋值给 <code>this.root</code> 即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == <span class="keyword">this</span>.root) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.root = merges(<span class="keyword">this</span>.root.leftChild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>配对堆中指定节点降低元素值</p>
<p>将指定节点所表示的配对堆从当前配对堆中剔除，合并两个配对堆即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decreaseKey</span><span class="params">(Node&lt;E&gt; node, E item)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果修改值大于当前值，则直接返回。</span></span><br><span class="line">    <span class="keyword">if</span> (comparator.compare(node.item, item) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node.item = item;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定节点为根节点，直接返回即可。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == node.pre) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从配对堆中剔除指定节点所表示的子配对堆。</span></span><br><span class="line">    <span class="comment">// 当前节点为第一个儿子节点</span></span><br><span class="line">    <span class="keyword">if</span> (node.pre.leftChild == node) &#123;</span><br><span class="line">        node.pre.leftChild = node.nextSibling;</span><br><span class="line">        node.nextSibling.pre = node.pre;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node.pre.nextSibling = node.nextSibling;</span><br><span class="line">        node.nextSibling.pre = node.pre;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.root = merge(<span class="keyword">this</span>.root, node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>配对堆中删除指定节点</p>
<p>通过降低元素值方式使指定节点称为根节点，然后删除根节点即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">    decreaseKey(node, <span class="keyword">this</span>.root.item);</span><br><span class="line">    deleteMin();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-k-d树</title>
    <url>/2020/07/11/dataStructure/dataStructure-kdtree/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>k-d 树</strong> 是在 $k$ 维欧几里德空间中组织点的一种数据结构。其可应用于多种场合，例如多维键值查询、范围查询、最近邻搜索。</p>
<a id="more"></a>

<p>其结构图大致如下：</p>
<p><img src="/2020/07/11/dataStructure/dataStructure-kdtree/111.jpg" alt="图一：k-d树"></p>
<p>k-d 树看似复杂，其实原理十分简单。本文之中，我们便以 1-d树、2-d树为例说明 k-d树的原理。</p>
<ul>
<li><p>1-d 树</p>
<p>1-d 树是在一维空间 (直线) 中组织点的一种数据结构，其实就是二叉查找树。观察该种数据结构，可以发现：它借由某个点将直线划分为两部分，前半部分直线中点所表示的数据均小于该点所表示的数据，后半部分直线中点所表示的数据均大于该点所表示的数据。通过这种有序组织数据，可避免无效的搜索，从而降低查询操作的时间复杂度。</p>
<img src="/2020/07/11/dataStructure/dataStructure-kdtree/image-20200711165142924.png" alt="图二：1-d树映射于直线" width="50%">
</li>
<li><p>2-d 树</p>
<p>2-d 树是在二维空间 (平面) 中组织点的一种数据结构。为降低查询操作的时间复杂度，我们同样需要有序组织数据。按照升维的一般规律，我们可以这样设想该种数据结构 (实际上也是这么做的)：它借由某条直线将平面划分为两部分，前半部分平面中点所表示的数据均小于该条直线上点所表示的数据，后半部分平面中点所表示的数据均大于该条直线上点所表示的数据。</p>
<p><img src="/2020/07/11/dataStructure/dataStructure-kdtree/1359957049_9183.jpg" alt="图三：2-d树映射于平面"></p>
</li>
</ul>
<p>从上面例子中，可以窥知：k-d 树会借由某种方式将 $k$ 维空间划分为两部分，并以此有序组织数据，从而更为快速地完成数据查询。</p>
<p>考虑到 2-d树易于实现，因此本文仅涉及 2-d树的代码实现。上面例子仅说明了 2-d树的原理，接下来通过几个问题详细描述一下 2-d树的实现方式。</p>
<ol>
<li><p>如何表示这条直线？</p>
<p>对于一个 $k$ 维空间，仅以某一维度的数据值进行排序，这样便会将该空间划分为两部分。对于二维空间而言，其将映射为一条直线；对于三维空间而言，其将映射为一个平面。</p>
</li>
<li><p>如何选择维度？</p>
<p>通常有两种维度选择方式：</p>
<ul>
<li>按原始维度顺序依次指定为排序维度，循环往复。对于 2-d树而言，树的第一层按照 $x$ 轴进行排序，树的第二层按照 $y$ 轴进行排序，树的第三层按照 $x$ 轴进行排序，$\dots$。</li>
<li>对初始数据集计算各维度方差，方差大者在前，方差小者在后，以此构建一个维度顺序。按此维度顺序依次指定为排序维度，循环往复。假定根据构建的维度顺序为 $(y,x)$，那么对于 2-d树而言，树的第一层按照 $y$ 轴进行排序，树的第二层按照 $x$ 轴进行排序，树的第三层按照 $y$ 轴进行排序，$\dots$。</li>
</ul>
</li>
<li><p>如何选择这条直线？</p>
<p>假定对数据集中所有数据按照排序维度进行排序，排序结果位于中间的那个多维数据即为划分点。指定当前划分点为根结点，如果一个多维数据的排序维度值小于划分点的排序维度值，那么其将位于左子树之中，否则其将位于右子树之中。</p>
</li>
</ol>
<blockquote>
<p>k-d树查询操作的最好时间复杂度为 $O(log^N)$，最坏时间复杂度为 $O(N^{1 - 1/k})$。如果数据维度较低，综合考虑时间复杂度及编程复杂度，应当选择使用 k-d树，；如果数据维度较高，应当着重考虑时间复杂度，此时需选择使用 R树。</p>
</blockquote>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>为支撑众多功能，2-d树结构比较复杂。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KDTree</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 位置坐标</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> x;</span><br><span class="line">        <span class="keyword">double</span> y;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Point</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.x = x;</span><br><span class="line">            <span class="keyword">this</span>.y = y;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 与指定坐标的曼哈顿距离</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">distance</span><span class="params">(Point point)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Math.abs(<span class="keyword">this</span>.x - point.x) + Math.abs(<span class="keyword">this</span>.y - point.y);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 比较函数</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Point point, <span class="keyword">boolean</span> dimension)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (dimension) &#123;</span><br><span class="line">                <span class="keyword">return</span> Double.compare(<span class="keyword">this</span>.x, point.x);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> Double.compare(<span class="keyword">this</span>.y, point.y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 比较器</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Comparator <span class="title">comparator</span><span class="params">(<span class="keyword">boolean</span> dimension)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (dimension) &#123;</span><br><span class="line">                <span class="keyword">return</span> (o1, o2) -&gt; Double.compare(((Point) o1).x, ((Point) o2).x);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> (o1, o2) -&gt; Double.compare(((Point) o1).y, ((Point) o2).y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 克隆</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Point <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 节点结构</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 具体元素</span></span><br><span class="line">        Point item;</span><br><span class="line">        <span class="comment">// 节点所覆盖区域左下角的位置坐标</span></span><br><span class="line">        Point leftBottom;</span><br><span class="line">        <span class="comment">// 节点所覆盖区域右上角的位置坐标</span></span><br><span class="line">        Point rightUp;</span><br><span class="line">        <span class="comment">// 左儿子</span></span><br><span class="line">        Node left;</span><br><span class="line">        <span class="comment">// 右儿子</span></span><br><span class="line">        Node right;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Point item, Point leftBottom, Point rightUp, Node left, Node right)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.item = item;</span><br><span class="line">            <span class="keyword">this</span>.leftBottom = leftBottom;</span><br><span class="line">            <span class="keyword">this</span>.rightUp = rightUp;</span><br><span class="line">            <span class="keyword">this</span>.left = left;</span><br><span class="line">            <span class="keyword">this</span>.right = right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新节点所覆盖区域</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">maintain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.leftBottom.x = Math.min(Math.min(<span class="keyword">this</span>.left.leftBottom.x, <span class="keyword">this</span>.right.leftBottom.x), <span class="keyword">this</span>.item.x);</span><br><span class="line">            <span class="keyword">this</span>.leftBottom.y = Math.min(Math.min(<span class="keyword">this</span>.left.leftBottom.y, <span class="keyword">this</span>.right.leftBottom.y), <span class="keyword">this</span>.item.y);</span><br><span class="line">            <span class="keyword">this</span>.rightUp.x = Math.max(Math.max(<span class="keyword">this</span>.left.rightUp.x, <span class="keyword">this</span>.right.rightUp.x), <span class="keyword">this</span>.item.x);</span><br><span class="line">            <span class="keyword">this</span>.rightUp.y = Math.max(Math.max(<span class="keyword">this</span>.left.rightUp.y, <span class="keyword">this</span>.right.rightUp.y), <span class="keyword">this</span>.item.y);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指定坐标与当前节点所覆盖区域的最近曼哈顿距离</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">minDistance</span><span class="params">(Point point)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 如果当前节点为空节点，直接返回无穷大。</span></span><br><span class="line">            <span class="keyword">if</span> (KDTree.nullNode == <span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> KDTree.INF;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">this</span>.leftBottom.x &lt; point.x &amp;&amp; point.x &lt; <span class="keyword">this</span>.rightUp.x)</span><br><span class="line">                    &amp;&amp; (<span class="keyword">this</span>.leftBottom.y &lt; point.y &amp;&amp; point.y &lt; <span class="keyword">this</span>.rightUp.y)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Point leftUp = <span class="keyword">new</span> Point(<span class="keyword">this</span>.leftBottom.x, <span class="keyword">this</span>.rightUp.y);</span><br><span class="line">            Point rightBottom = <span class="keyword">new</span> Point(<span class="keyword">this</span>.rightUp.x, <span class="keyword">this</span>.leftBottom.y);</span><br><span class="line">            <span class="keyword">return</span> Math.min(Math.min(<span class="keyword">this</span>.leftBottom.distance(point), <span class="keyword">this</span>.rightUp.distance(point)),</span><br><span class="line">                    Math.min(leftUp.distance(point), rightBottom.distance(point)));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指定坐标与当前节点所覆盖区域的最远曼哈顿距离</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">maxDistance</span><span class="params">(Point point)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 如果当前节点为空节点，直接返回负无穷大。</span></span><br><span class="line">            <span class="keyword">if</span> (KDTree.nullNode == <span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> -KDTree.INF;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Point leftUp = <span class="keyword">new</span> Point(<span class="keyword">this</span>.leftBottom.x, <span class="keyword">this</span>.rightUp.y);</span><br><span class="line">            Point rightBottom = <span class="keyword">new</span> Point(<span class="keyword">this</span>.rightUp.x, <span class="keyword">this</span>.leftBottom.y);</span><br><span class="line">            <span class="keyword">return</span> Math.max(Math.max(<span class="keyword">this</span>.leftBottom.distance(point), <span class="keyword">this</span>.rightUp.distance(point)),</span><br><span class="line">                    Math.max(leftUp.distance(point), rightBottom.distance(point)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 状态（大小堆之用）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Status</span> <span class="keyword">implements</span> <span class="title">Comparable</span> </span>&#123;</span><br><span class="line">        Point point;</span><br><span class="line">        <span class="keyword">double</span> distance;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Status</span><span class="params">(Point point, <span class="keyword">double</span> distance)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.point = point;</span><br><span class="line">            <span class="keyword">this</span>.distance = distance;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Double.compare(<span class="keyword">this</span>.distance, ((Status) o).distance);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 无穷值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="comment">// 空节点（方便编码）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Node nullNode = <span class="keyword">new</span> Node(<span class="keyword">null</span>, <span class="keyword">new</span> Point(KDTree.INF, KDTree.INF),</span><br><span class="line">            <span class="keyword">new</span> Point(-KDTree.INF, -KDTree.INF), <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 根节点</span></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="辅助方法"><a href="#辅助方法" class="headerlink" title="辅助方法"></a>辅助方法</h3><ul>
<li><p>基于 <code>arr[l,r)</code> 间元素、按照指定维度构建 KDTree</p>
<p>该代码实现需要注意两部分：</p>
<ol>
<li>代码实现中直接排序 <code>arr[l,r)</code> 中全部元素，其时间复杂度为 $O(nlog^n)$。实际上没有必要这样做，只要找到一个元素将其放置中间位置，使得前面元素均小于它，后面元素均大于它即可。这一操作的平均时间复杂度为 $O(n)$ (具体实现可参见 <code>C++</code> 中的 <code>nth_element</code> 函数)。故而构建 KDTree 的时间复杂度为 $O(Nlog^N)$ 。</li>
<li>构建节点时，<code>item</code>、<code>leftBottom</code> 与 <code>rightUp</code> 应当是互相独立的，故而其无法引用同一对象，应当引用内容相同的对象。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dimension为true,表示应当按 x轴排序，反之应当按 y轴排序。后面同此，故不再赘述。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, Point[] arr, <span class="keyword">boolean</span> dimension)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 基于零个元素构建KDTree，直接返回空节点即可。</span></span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">        <span class="keyword">return</span> KDTree.nullNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 排序这部分元素</span></span><br><span class="line">    Arrays.sort(arr, l, r, arr[l].comparator(dimension));</span><br><span class="line">    <span class="comment">// 获取中间位置</span></span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建节点及其子树</span></span><br><span class="line">    Node root = <span class="keyword">new</span> Node(arr[mid], arr[mid].clone(), arr[mid].clone(), <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    root.left = build(l, mid, arr, !dimension);</span><br><span class="line">    root.right = build(mid + <span class="number">1</span>, r, arr, !dimension);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新节点所覆盖区域</span></span><br><span class="line">    root.maintain();</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>当前子树中获取KNN</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">KNNTree</span><span class="params">(Point point, <span class="keyword">int</span> k, PriorityQueue&lt;Status&gt; priorityQueue, Node root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 空子树中一定不存在，直接返回即可。</span></span><br><span class="line">    <span class="keyword">if</span> (KDTree.nullNode == root) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前子树根节点与指定节点的曼哈顿距离</span></span><br><span class="line">    <span class="keyword">double</span> distance = root.item.distance(point);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果搜索到的邻居节点数不足，则直接插入。如果搜索到的邻居节点数已满，但是当前子树根节点与指定节点的曼哈顿距离小于大顶堆堆顶元素，则应当移除堆顶元素，并将该曼哈顿距离置于堆中。</span></span><br><span class="line">    <span class="keyword">if</span> (priorityQueue.size() &lt; k || distance &lt; priorityQueue.peek().distance) &#123;</span><br><span class="line">        <span class="keyword">if</span> (priorityQueue.size() == k) &#123;</span><br><span class="line">            priorityQueue.remove();</span><br><span class="line">        &#125;</span><br><span class="line">        priorityQueue.add(<span class="keyword">new</span> Status(root.item, distance));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> leftDistance = root.left.minDistance(point);</span><br><span class="line">    <span class="keyword">double</span> rightDistance = root.right.minDistance(point);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (leftDistance &lt; rightDistance) &#123;</span><br><span class="line">        KNNTree(point, k, priorityQueue, root.left);</span><br><span class="line">        <span class="comment">// 如果搜索到的邻居节点数不足或者邻居节点数已足但是右子树最近距离小于大顶堆堆顶元素，就需要搜索右子树。</span></span><br><span class="line">        <span class="keyword">if</span> (priorityQueue.size() &lt; k || rightDistance &lt; priorityQueue.peek().distance) &#123;</span><br><span class="line">            KNNTree(point, k, priorityQueue, root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        KNNTree(point, k, priorityQueue, root.right);</span><br><span class="line">        <span class="comment">// 如果搜索到的邻居节点数不足或者邻居节点数已足但是左子树最近距离小于大顶堆堆顶元素，就需要搜索左子树。</span></span><br><span class="line">        <span class="keyword">if</span> (priorityQueue.size() &lt; k || leftDistance &lt; priorityQueue.peek().distance) &#123;</span><br><span class="line">            KNNTree(point, k, priorityQueue, root.left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>当前子树中获取KNF</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">KNFTree</span><span class="params">(Point point, <span class="keyword">int</span> k, PriorityQueue&lt;Status&gt; priorityQueue, Node root)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 空子树中一定不存在，直接返回即可。</span></span><br><span class="line">    <span class="keyword">if</span> (KDTree.nullNode == root) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 获取当前子树根节点与指定节点的曼哈顿距离</span></span><br><span class="line">    <span class="keyword">double</span> distance = root.item.distance(point);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果搜索到的邻居节点数不足，则直接插入。如果搜索到的邻居节点数已满，但是当前子树根节点与指定节点的曼哈顿距离大于小顶堆堆顶元素，则应当移除堆顶元素，并将该曼哈顿距离置于堆中。</span></span><br><span class="line">    <span class="keyword">if</span> (priorityQueue.size() &lt; k || distance &gt; priorityQueue.peek().distance) &#123;</span><br><span class="line">        <span class="keyword">if</span> (priorityQueue.size() == k) &#123;</span><br><span class="line">            priorityQueue.remove();</span><br><span class="line">        &#125;</span><br><span class="line">        priorityQueue.add(<span class="keyword">new</span> Status(root.item, distance));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> leftDistance = root.left.minDistance(point);</span><br><span class="line">    <span class="keyword">double</span> rightDistance = root.right.minDistance(point);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (leftDistance &gt; rightDistance) &#123;</span><br><span class="line">        KNFTree(point, k, priorityQueue, root.left);</span><br><span class="line">        <span class="comment">// 如果搜索到的邻居节点数不足或者邻居节点数已足但是右子树最远距离大于小顶堆堆顶元素，就需要搜索右子树。</span></span><br><span class="line">        <span class="keyword">if</span> (priorityQueue.size() &lt; k || rightDistance &gt; priorityQueue.peek().distance) &#123;</span><br><span class="line">            KNFTree(point, k, priorityQueue, root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        KNFTree(point, k, priorityQueue, root.right);</span><br><span class="line">        <span class="comment">// 如果搜索到的邻居节点数不足或者邻居节点数已足但是左子树最远距离大于小顶堆堆顶元素，就需要搜索左子树。</span></span><br><span class="line">        <span class="keyword">if</span> (priorityQueue.size() &lt; k || leftDistance &gt; priorityQueue.peek().distance) &#123;</span><br><span class="line">            KNFTree(point, k, priorityQueue, root.left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>当前子树中获取具有指定维度最小值的节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">findminTree</span><span class="params">(Node root, <span class="keyword">boolean</span> dimension, <span class="keyword">boolean</span> specDim, Node min)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前子树为空，直接返回传入的min。</span></span><br><span class="line">    <span class="keyword">if</span> (KDTree.nullNode == root) &#123;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果min为空节点，或者当前子树根节点指定维度值小于min，则赋值min为当前子树根节点。</span></span><br><span class="line">    <span class="keyword">if</span> (KDTree.nullNode == min || root.item.compareTo(min.item, specDim) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        min = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前维度为指定维度，只需在左子树中查找即可。否则左右子树均需查找。</span></span><br><span class="line">    <span class="keyword">if</span> (dimension == specDim) &#123;</span><br><span class="line">        <span class="keyword">return</span> findminTree(root.left, !dimension, specDim, min);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node leftMin = findminTree(root.left, !dimension, specDim, min);</span><br><span class="line">        Node rightMin = findminTree(root.right, !dimension, specDim, min);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> leftMin.item.compareTo(rightMin.item, specDim) &lt; <span class="number">0</span> ? leftMin : rightMin;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>当前子树中添加指定元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addTree</span><span class="params">(Point point, Node root, <span class="keyword">boolean</span> dimension)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前子树为空，直接创建节点并返回即可。</span></span><br><span class="line">    <span class="keyword">if</span> (KDTree.nullNode == root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Node(point, point.clone(), point.clone(), KDTree.nullNode, KDTree.nullNode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 待添加元素小于当前子树根节点值，表明应插入于左子树之中。</span></span><br><span class="line">    <span class="keyword">if</span> (root.item.compareTo(point,dimension) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        root.left = addTree(point, root.left, !dimension);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        root.right = addTree(point, root.right, !dimension);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新节点所覆盖区域</span></span><br><span class="line">    root.maintain();</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>当前子树中删除指定元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">deleteTree</span><span class="params">(Point point, Node root, <span class="keyword">boolean</span> dimension)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前子树为空，直接返回即可。</span></span><br><span class="line">    <span class="keyword">if</span> (KDTree.nullNode == root) &#123;</span><br><span class="line">        <span class="keyword">return</span> KDTree.nullNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前子树根节点并非待删除元素，根据维度顺序，在左右子树中删除即可。</span></span><br><span class="line">    <span class="keyword">if</span> (root.item.x != point.x || root.item.y != point.y) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root.item.compareTo(point, dimension) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            root.left = deleteTree(point, root.left, !dimension);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root.right = deleteTree(point, root.right, !dimension);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 表明当前子树根节点就是待删除元素</span></span><br><span class="line">        <span class="comment">// 当前子树右子树不为空，将当前子树根节点的元素值与其后继节点元素值交换，然后删除其后继节点即可。</span></span><br><span class="line">        <span class="keyword">if</span> (KDTree.nullNode != root.right) &#123;</span><br><span class="line">            root.item = findminTree(root.right, !dimension, dimension, KDTree.nullNode).item;</span><br><span class="line">            root.right = deleteTree(root.item, root.right, !dimension);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (KDTree.nullNode != root.left)&#123;</span><br><span class="line">            <span class="comment">// 当前子树左子树不为空，将当前子树根节点的元素值与左子树中具有指定维度最小值的节点的元素值交换，然后删除左子树中具有指定维度最小值的节点，最后为保证有序，将当前子树的左右子树交换即可。</span></span><br><span class="line">            root.item = findminTree(root.left, !dimension, dimension, KDTree.nullNode).item;</span><br><span class="line">            root.left = deleteTree(root.item, root.left, !dimension);</span><br><span class="line">            root.right = root.left;</span><br><span class="line">            root.left = KDTree.nullNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 左右子树为空，删除该节点后，应当返回空节点。</span></span><br><span class="line">            <span class="keyword">return</span> KDTree.nullNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新节点所覆盖区域</span></span><br><span class="line">    root.maintain();</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">KDTree</span><span class="params">(Point[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.root = build(<span class="number">0</span>, arr.length, arr, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><ul>
<li><p>KNN（K邻近）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">KNN</span><span class="params">(Point point, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构建大顶堆</span></span><br><span class="line">    PriorityQueue&lt;Status&gt; priorityQueue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Status&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Status o1, Status o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Double.compare(o2.distance, o1.distance);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    KNNTree(point, k, priorityQueue, <span class="keyword">this</span>.root);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;KNN: &quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (!priorityQueue.isEmpty()) &#123;</span><br><span class="line">        Status tmp = priorityQueue.remove();</span><br><span class="line">        System.out.println(<span class="string">&quot;X: &quot;</span> + tmp.point.x + <span class="string">&quot;,Y: &quot;</span> + tmp.point.y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>KNF（K最远）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">KNF</span><span class="params">(Point point, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构建小顶堆</span></span><br><span class="line">    PriorityQueue&lt;Status&gt; priorityQueue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Status&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Status o1, Status o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Double.compare(o1.distance, o2.distance);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    KNFTree(point, k, priorityQueue, <span class="keyword">this</span>.root);</span><br><span class="line">    System.out.println(<span class="string">&quot;KNF: &quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (!priorityQueue.isEmpty()) &#123;</span><br><span class="line">        Status tmp = priorityQueue.remove();</span><br><span class="line">        System.out.println(<span class="string">&quot;X: &quot;</span> + tmp.point.x + <span class="string">&quot;,Y: &quot;</span> + tmp.point.y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="操纵"><a href="#操纵" class="headerlink" title="操纵"></a>操纵</h3></li>
<li><p>KDTree 中添加元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Point point)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.root = addTree(point, <span class="keyword">this</span>.root, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>KDTree 中删除元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Point point)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.root = deleteTree(point, <span class="keyword">this</span>.root, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-跳跃表</title>
    <url>/2020/07/04/dataStructure/dataStructure-skiplist/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>跳跃表</strong> 是一种基于链表实现的数据结构。它具有实现简单、查找性能媲美甚至优于平衡树、内存占用较少等特点。</p>
<a id="more"></a>

<p>其结构图大致如下：</p>
<p><img src="/2020/07/04/dataStructure/dataStructure-skiplist/580b14b344513bbead4d1b188f94bb25.png" alt="图一：跳跃表"></p>
<p>对于排序数组而言，基于二分思想可将查找操作的时间复杂度降为 $O(log^N)$；而对于排序链表而言，由于其节点只保存后继节点的引用信息，故而其查找操作的时间复杂度只能是 $O(N)$。受 “空间换时间” 思想的启发，我们会产生这样一种想法：如果一部分节点不仅保存后继节点的引用信息，而且保存后继节点的后继节点的引用信息，甚至于保存后继节点的后继节点的后继节点的引用信息，那么一定可以降低查询操作的时间复杂度。最终我们可以得到这样一种理想的跳跃表：第零层级存在所有节点，第一层级只有 $1/2$ 的节点，而且是均匀间隔的，第二层级只有 $1/4$ 的节点，同样是均匀间隔的，以此类推，直至最高层级仅有两个节点。这种跳跃表共有 $log^N$ 层，故而其查询操作的时间复杂度为 $O(log^N)$。</p>
<p><img src="/2020/07/04/dataStructure/dataStructure-skiplist/d88e4d282ec5981c207c.png" alt="图二：理想的跳跃表"></p>
<p>理想的跳跃表存在一个非常大的问题：结构过于严谨，致使插入操作和删除操作非常复杂。为简化操作复杂度，不确定性跳跃表和确定性跳跃表应运而生。前者基于概率模拟理想的跳跃表，故而其查询操作的平均时间复杂度为 $O(log^N)$，后者基于结构限制模拟理想的跳跃表，故而其查询操作的时间复杂度为 $O(log^N)$ 。</p>
<blockquote>
<p>因为确定性跳跃表并不常用，故而本文着重于不确定性跳跃表的代码实现，仅在 <em>拓展</em> 一节简要介绍确定性跳跃表。</p>
</blockquote>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SkipList</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 节点结构</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">// 具体元素</span></span><br><span class="line">        E item;</span><br><span class="line">        <span class="comment">// 后继节点的引用数组</span></span><br><span class="line">        Node&lt;E&gt;[] next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E item, <span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.item = item;</span><br><span class="line">            <span class="keyword">this</span>.next = <span class="keyword">new</span> Node[level + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最大层级数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxLevel;</span><br><span class="line">    <span class="comment">// 概率参数，指定层级数之用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> p;</span><br><span class="line">    <span class="comment">// 当前跳跃表中最大层级数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> level;</span><br><span class="line">    <span class="comment">// 首节点</span></span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; head;</span><br><span class="line">    <span class="comment">// 随机函数，指定层级数之用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random random = <span class="keyword">new</span> Random(System.currentTimeMillis());</span><br><span class="line">    <span class="comment">// 比较函数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> E&gt; comparator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="辅助方法"><a href="#辅助方法" class="headerlink" title="辅助方法"></a>辅助方法</h3><ul>
<li><p>指定层级数</p>
<p>跳跃表中指定节点层级数的方法十分有趣。最初设置层级数为零，如果随机数值小于指定的概率参数，且当前层级数小于指定的最大层级数，则层级数加一；反之当前层级数就是该节点的最终层级数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">randomLevel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (random.nextDouble() &lt; <span class="keyword">this</span>.p &amp;&amp; level &lt; <span class="keyword">this</span>.maxLevel) &#123;</span><br><span class="line">        level++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> level;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SkipList</span><span class="params">(<span class="keyword">int</span> maxLevel, <span class="keyword">double</span> p, Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 赋值相关参数。</span></span><br><span class="line">    <span class="keyword">this</span>.maxLevel = maxLevel;</span><br><span class="line">    <span class="keyword">this</span>.p = p;</span><br><span class="line">    <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化相关参数</span></span><br><span class="line">    <span class="keyword">this</span>.head = <span class="keyword">new</span> Node&lt;&gt;(<span class="keyword">null</span>, <span class="keyword">this</span>.maxLevel);</span><br><span class="line">    <span class="keyword">this</span>.level = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><ul>
<li><p>查询指定元素是否存在</p>
<p>从最高层级开始向前搜索，如果下一个节点元素值大于等于待查找元素值，则转向下一层级并向前搜索，依此而行，直至转向第零层级。如果第零层级不存在该值则查找失败，否则查找成功。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(E item)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 栈，用于存放各个层级上最后一个小于待查找元素的节点。</span></span><br><span class="line">    ArrayDeque&lt;Node&lt;E&gt;&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    <span class="comment">// 当前搜索节点</span></span><br><span class="line">    Node&lt;E&gt; current = <span class="keyword">this</span>.head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="keyword">this</span>.maxLevel; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 当前层级之下当前节点的下一个节点存在，且值小于或等于待查找元素，则继续向前搜索。</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">null</span> != current.next[i] &amp;&amp; comparator.compare(current.next[i].item, item) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            current = current.next[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前节点为当前层级之上最后一个小于或等于待查找元素的节点，故将其添加至栈中。</span></span><br><span class="line">        stack.push(current);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第零层级当前搜索节点的下一个节点不存在或者节点元素值不等于待查找元素，则查找失败。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == current.next[<span class="number">0</span>] || comparator.compare(current.next[<span class="number">0</span>].item, item) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="操纵"><a href="#操纵" class="headerlink" title="操纵"></a>操纵</h3></li>
<li><p>跳跃表中添加元素</p>
<p>插入过程与查询过程类似，只是需要从下往上依次插入待添加元素即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E item)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 栈，用于存放各个层级上最后一个小于待添加元素的节点。</span></span><br><span class="line">    ArrayDeque&lt;Node&lt;E&gt;&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    <span class="comment">// 当前搜索节点</span></span><br><span class="line">    Node&lt;E&gt; current = <span class="keyword">this</span>.head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="keyword">this</span>.maxLevel; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 当前层级之下当前节点的下一个节点存在，且值小于待添加元素，则继续向前搜索。</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">null</span> != current.next[i] &amp;&amp; comparator.compare(current.next[i].item, item) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            current = current.next[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前节点为当前层级之上最后一个小于待添加元素的节点，故将其添加至栈中。</span></span><br><span class="line">        stack.push(current);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定层级数，同时更新当前跳跃表中最大层级数。</span></span><br><span class="line">    <span class="keyword">int</span> rLevel = randomLevel();</span><br><span class="line">    <span class="keyword">if</span> (rLevel &gt; <span class="keyword">this</span>.level) &#123;</span><br><span class="line">        <span class="keyword">this</span>.level = rLevel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从下往上插入节点</span></span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;&gt;(item, rLevel);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= rLevel; i++) &#123;</span><br><span class="line">        current = stack.pop();</span><br><span class="line">        node.next[i] = current.next[i];</span><br><span class="line">        current.next[i] = node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>跳跃表中删除元素</p>
<p>删除过程与查询过程类似，只是需要从下往上依次删除待删除元素即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(E item)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 栈，用于存放各个层级上最后一个小于待删除元素的节点。</span></span><br><span class="line">    ArrayDeque&lt;Node&lt;E&gt;&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    <span class="comment">// 当前搜索节点</span></span><br><span class="line">    Node&lt;E&gt; current = <span class="keyword">this</span>.head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="keyword">this</span>.maxLevel; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 当前层级之下当前节点的下一个节点存在，且值小于或等于待删除元素，则继续向前搜索。</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">null</span> != current.next[i] &amp;&amp; comparator.compare(current.next[i].item, item) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            current = current.next[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前节点为当前层级之上最后一个小于或等于待删除元素的节点，故将其添加至栈中。</span></span><br><span class="line">        stack.push(current);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node&lt;E&gt; deleteNode = current.next[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果待删除节点不存在，则直接退出即可。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == deleteNode || comparator.compare(deleteNode.item, item) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> deleteLevel = deleteNode.next.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除待删除节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= deleteLevel; i++) &#123;</span><br><span class="line">        current = stack.pop();</span><br><span class="line">        current.next[i] = deleteNode.next[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新当前跳跃表中最大层级数。</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">this</span>.level &gt; <span class="number">0</span> &amp;&amp; <span class="keyword">null</span> == <span class="keyword">this</span>.head.next[<span class="keyword">this</span>.level]) &#123;</span><br><span class="line">        <span class="keyword">this</span>.level--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2></li>
</ul>
<h3 id="不确定性跳跃表"><a href="#不确定性跳跃表" class="headerlink" title="不确定性跳跃表"></a>不确定性跳跃表</h3><p>这里探讨两个比较简单的问题：</p>
<ol>
<li><p>跳跃表中节点包含的平均引用数目是多少？</p>
<p>查看函数 “指定层级数”，我们可以发现节点包含的引用数目满足一个概率分布：</p>
<ul>
<li>节点包含的引用数目为一的概率为 $(1 - p)$；</li>
<li>节点包含的引用数目为二的概率为 $p(1 - p)$；</li>
<li>节点包含的引用数目为三的概率为 $p^2(1 - p)$；</li>
<li>$\dots$</li>
</ul>
<p>那么跳跃表中节点包含的平均引用数目可计算如下：</p>
<p>$1 \times (1 - p) + 2 \times p(1 - p) + 3 \times p^2(1 - p) + \dots = (1 - p)\sum_{i = 1}^{\infty}(i \times p^{i - 1}) = (1 - p) \times \frac{1}{(1 - p)^2} = \frac{1}{1 - p}$</p>
<p>依据推导结果，我们可以看到：节点包含的平均引用数目与指定的概率参数相关，且指定的概率参数值越小，节点包含的平均引用数目越少。</p>
<p>当 $p = 1/2$ 时，节点包含的平均引用数目为 $2$；当 $p = 1/4$ 时，节点包含的平均引用数目为 $1.33$。</p>
</li>
<li><p>与平衡树、哈希表的比较？</p>
<p>查找性能比较优良的数据结构就这三种：平衡树、哈希表和跳跃表。故而在此简要对比一下三者：</p>
<ul>
<li>哈希表中元素无序排列，而平衡树与跳跃表中元素有序排列。故而前者只能进行单个查询，后者即可进行单个查询，又可进行范围查询。</li>
<li>进行单个查询时，哈希表可达到 $O(1)$ 的时间复杂度，平衡树和跳跃表的时间复杂度为 $O(log^N)$。</li>
<li>进行范围查询时，平衡树操作较为复杂，原因在于：找到范围起点后，需中序遍历平衡树直至范围终点。而对跳跃表而言，只要在第零层级向前搜索到范围终点即可。</li>
<li>平衡树插入、删除操作可能引发子树调整，故而逻辑复杂。哈希表和跳跃表只需要修改相关节点引用即可，比较简单。</li>
<li>从无关数据的内存占用上来说，平衡树通常需要 $2-3$ 个节点引用 (左右儿子节点、父节点)；跳跃表通过指定概率参数可仅使用 $1.33$ 个节点引用。</li>
</ul>
</li>
</ol>
<h3 id="确定性跳跃表"><a href="#确定性跳跃表" class="headerlink" title="确定性跳跃表"></a>确定性跳跃表</h3><p>此处简要介绍其中一种确定性跳跃表—— 1-2-3 确定性跳跃表。</p>
<p>我们首先做出如下两个定义：</p>
<ol>
<li>如果至少存在一个链从一个元素指向另一个元素，我们就称两个元素是 <strong>链接的</strong>。</li>
<li>第 $h$ 层级之上的两个链接元素间的 <strong>间隙容量</strong> 等于第 $h - 1$ 层级中这两个元素间的元素个数。</li>
</ol>
<p>1-2-3 确定性跳跃表满足如下性质：任意链接元素间的间隙容量只可能是 1 或 2 或 3。 </p>
<p>图三即为确定性跳跃表的一个例子。其中第一层级之上的两个链接元素 ( $10$ 与 $25$ ) 间的间隙容量等于第零层级中这两个元素间的元素个数 ( $15$ 与 $20$，共计两个元素 )。<br><img src="/2020/07/04/dataStructure/dataStructure-skiplist/image-20200708194847004.png" alt="图三：确定性跳跃表"></p>
<p>接下来我们介绍一下确定性跳跃表中的插入与删除操作：</p>
<ul>
<li><p>插入操作</p>
<p>插入操作可能使得某链接元素间的间隙容量扩大为 $4$，故而需要进行适当拆分。</p>
<p>一种可行的做法为：向下搜索插入位置之时，如果当前节点与后继节点间的间隙容量为 $3$，则令下一层级中位于中间的那个节点的层级加一，使得其成为当前节点的后继节点。</p>
<p>图四所示为向跳跃表中插入元素 $27$ 。由于第二层级之上首尾两个元素间的间隙容量为 $3$，故而提升下一层级中的 $25$，使得其与首节点的间隙容量、其与尾节点的间隙容量均为 $1$，此时在这两者间插入元素则不再会破坏性质。</p>
<p><img src="/2020/07/04/dataStructure/dataStructure-skiplist/image-20200708201043243.png" alt="图四：插入元素27"></p>
</li>
<li><p>删除操作</p>
<p>删除操作可能使得某链接元素间的间隙容量缩小为 $0$，故而需要进行适当合并。</p>
<p>一种可行的做法为：向下搜索删除元素过程中，如果当前节点与后继节点间的间隙容量为 $1$，那么删除指定元素后，可能会破坏此处的性质，因此我们需要扩大当前节点与后继节点间的间隙容量。如果后继节点与后继节点的后继节点的间隙容量大于 $1$，我们便从后继节点借 $1$ 个间隙容量；如果后继节点与后继节点的后继节点的间隙容量等于 $1$，我们便降低后继节点的层级，此时当前节点与新后继节点的间隙容量就为 $3$。</p>
</li>
</ul>
<blockquote>
<p>图中所示仅为确定性跳跃表的表示图，其逻辑结构与此还是有一定区别的。</p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-Treap树/替罪羊树</title>
    <url>/2020/07/03/dataStructure/dataStructure-treaptree/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>Treap 树</strong> 是一个附加域满足堆性质的二叉查找树，其基本操作的期望时间复杂度为 $O(log^N)$。相比于 AVL、红黑树而言，其实现简单，且能基本实现随机平衡。</p>
<a id="more"></a>

<p>其结构图大致如下：</p>
<p><img src="/2020/07/03/dataStructure/dataStructure-treaptree/2012073000522678.png" alt="图一：Treap树"></p>
<p>对于二叉查找树而言，特殊插入序列将会使得二叉查找树退化为一个链表，这样会大大降低二叉查找树的性能。为避免这一情况的发生，AVL 限制左右子树高度差不超过 1、红黑树要求任意节点到其所有后代叶节点的简单路径均包含相同数目的黑色节点。对于 Treap 树而言，要求附加域满足堆性质使得不存在特殊插入序列，从而避免这一情况的发生 (查看下面的插入过程就可理解这句话)。</p>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>附加域即是该节点的优先级，它在建立节点时随机指定。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Treap</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 节点结构</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">// 具体元素</span></span><br><span class="line">        E item;</span><br><span class="line">        <span class="comment">// 左儿子</span></span><br><span class="line">        Node&lt;E&gt; left;</span><br><span class="line">        <span class="comment">// 右儿子</span></span><br><span class="line">        Node&lt;E&gt; right;</span><br><span class="line">        <span class="comment">// 优先级</span></span><br><span class="line">        <span class="keyword">int</span> priority;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E item, <span class="keyword">int</span> priority)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.item = item;</span><br><span class="line">            <span class="keyword">this</span>.left = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.right = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.priority = priority;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 比较函数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> E&gt; comparator;</span><br><span class="line">    <span class="comment">// 根节点</span></span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; root;</span><br><span class="line">    <span class="comment">// 随机函数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random random = <span class="keyword">new</span> Random(System.currentTimeMillis());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="辅助方法"><a href="#辅助方法" class="headerlink" title="辅助方法"></a>辅助方法</h3><ul>
<li><p>右旋</p>
<p>Treap 树中两大基本操作之一，用于维持堆性质。</p>
<p><img src="/2020/07/03/dataStructure/dataStructure-treaptree/image-20200630184952581.png" alt="图二：右旋"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;E&gt; <span class="title">rightRotate</span><span class="params">(Node&lt;E&gt; root)</span> </span>&#123;</span><br><span class="line">    Node&lt;E&gt; k1 = root;</span><br><span class="line">    Node&lt;E&gt; k2 = root.left;</span><br><span class="line"></span><br><span class="line">    k1.left = k2.right;</span><br><span class="line">    k2.right = k1;</span><br><span class="line">    <span class="keyword">return</span> k2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>左旋</p>
<p>Treap 树中两大基本操作之一，用于维持堆性质。</p>
<p><img src="/2020/07/03/dataStructure/dataStructure-treaptree/image-20200630185055765.png" alt="图三：左旋"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;E&gt; <span class="title">leftRotate</span><span class="params">(Node&lt;E&gt; root)</span> </span>&#123;</span><br><span class="line">    Node&lt;E&gt; k1 = root;</span><br><span class="line">    Node&lt;E&gt; k2 = root.right;</span><br><span class="line"></span><br><span class="line">    k1.right = k2.left;</span><br><span class="line">    k2.left = k1;</span><br><span class="line">    <span class="keyword">return</span> k2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>当前子树中插入元素，并返回插入元素后的该子树</p>
<p>插入过程与二叉查找树插入过程基本相同，不同点即在于：将元素插入到合适位置之后，如果堆性质不满足，需借助于左旋或右旋进行调整。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;E&gt; <span class="title">addTree</span><span class="params">(E item, Node&lt;E&gt; root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前子树为空，创建该节点并返回即可。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Node&lt;&gt;(item, random.nextInt());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前子树根节点值大于指定元素，则应当插入于左子树之中。</span></span><br><span class="line">    <span class="keyword">if</span> (comparator.compare(root.item, item) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        root.left = addTree(item, root.left);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果子节点优先级低于当前节点优先级，则需进行右旋。</span></span><br><span class="line">        <span class="keyword">if</span> (root.left.priority &lt; root.priority) &#123;</span><br><span class="line">            root = rightRotate(root);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (comparator.compare(root.item, item) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 当前子树根节点值小于指定元素，则应当插入于右子树之中。</span></span><br><span class="line">        root.right = addTree(item, root.right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果子节点优先级低于当前节点优先级，则需进行左旋。</span></span><br><span class="line">        <span class="keyword">if</span> (root.right.priority &lt; root.priority) &#123;</span><br><span class="line">            root = leftRotate(root);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>当前子树中删除元素，并返回删除元素后的该子树</p>
<p>删除元素过程比较巧妙。借助于左旋与右旋，逐步将待删除节点下沉至叶节点，然后直接删除即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;E&gt; <span class="title">deleteTree</span><span class="params">(E item, Node&lt;E&gt; root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前子树为空，直接返回空即可。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前子树根节点值大于待删除元素，则待删除元素一定位于左子树之中。</span></span><br><span class="line">    <span class="keyword">if</span> (comparator.compare(root.item, item) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        root.left = deleteTree(item, root.left);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (comparator.compare(root.item, item) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 当前子树根节点值小于待删除元素，则待删除元素一定位于右子树之中。</span></span><br><span class="line">        root.right = deleteTree(item, root.right);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 当前子树根节点值等于待删除元素，此即为待删除元素。</span></span><br><span class="line">        <span class="comment">// 只要左右儿子一者为空，则直接使用另一儿子节点所在子树代替当前子树即可。</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == root.right) &#123;</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">null</span> == root.left) &#123;</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 当前子树根节点的左右儿子均不为空。</span></span><br><span class="line">            <span class="comment">// 借助左旋或右旋使待删除节点下沉至叶节点，然后删除即可。</span></span><br><span class="line">            <span class="keyword">if</span> (root.left.priority &lt; root.right.priority) &#123;</span><br><span class="line">                root = rightRotate(root);</span><br><span class="line">                root.right = deleteTree(item, root.right);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                root = leftRotate(root);</span><br><span class="line">                root.left = deleteTree(item, root.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Treap</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="操纵"><a href="#操纵" class="headerlink" title="操纵"></a>操纵</h3><ul>
<li><p>Treap 树中添加元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.root = addTree(item, <span class="keyword">this</span>.root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Treap 树中删除元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(E item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.root = deleteTree(item, <span class="keyword">this</span>.root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2></li>
</ul>
<h3 id="替罪羊树"><a href="#替罪羊树" class="headerlink" title="替罪羊树"></a>替罪羊树</h3><p><strong>替罪羊树</strong> 是一种非常优雅的二叉查找树。如果当前子树极度不平衡，替罪羊树首先将中序遍历该子树的结果置于数组之中，然后按照 “以中间值元素为根节点，左半部分元素构建左子树，右半部分元素构建右子树” 的方式重构该子树。</p>
<p>接下来我们谈谈替罪羊树上的一些操作：</p>
<ul>
<li><p>插入操作</p>
<p>与普通二叉查找树的插入操作基本相同，不同点在于：插入完成后，递归向上至根节点过程中，找到最后一棵极度不平衡的子树，然后重构它。由于此过程并不常发生，所以其平均时间复杂度为 $O(log^N)$ 。</p>
</li>
<li><p>删除操作</p>
<p>删除过程采用 “懒惰删除”，即并不立即删除该节点，只是标记该节点为已删除节点。如果当前子树中已删除节点个数/当前子树中所有节点个数大于某一阈值，则在重构过程中删除这些节点。理论已经证明，其平均时间复杂度仍为 $O(log^N)$ 。</p>
</li>
<li><p>查询操作</p>
<p>与普通二叉查找树的查询操作基本相同，不同点在于：如果当前节点为已删除节点，直接忽略它即可。故而其平均时间复杂度为 $O(log^N)$ 。</p>
</li>
</ul>
<blockquote>
<p>“当前子树极度不平衡” 的衡量条件为：$$size(root.left) / size(root) &gt; \alpha \ || \  size(root.right) / size(root) &gt; \alpha$$，其中 $size(x)$ 表示以当前节点为根节点的子树中节点数量、$\alpha$ 为衡量阈值。</p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-红黑树</title>
    <url>/2020/06/30/dataStructure/dataStructure-rbtree/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>红黑树</strong> 是一种自平衡的二叉查找树。通过为树中节点添加颜色属性并施以一定规则，红黑树可保证针对二叉查找树各种操作的最坏时间复杂度为 $O(log^N)$。</p>
<a id="more"></a>

<p>其结构图大致如下：</p>
<p><img src="/2020/06/30/dataStructure/dataStructure-rbtree/251730074203156.jpg" alt="图一：红黑树"></p>
<p>一棵红黑树是满足如下 <em>红黑性质</em> 的二叉查找树：</p>
<ol>
<li>每个节点的颜色属性要么是红色，要么是黑色。</li>
<li>根节点的颜色属性为黑色。</li>
<li>每个叶节点 (<code>NIL</code>) 的颜色属性为黑色。</li>
<li>如果一个节点的颜色属性为红色，则其孩子节点的颜色属性一定为黑色。</li>
<li>对于每个节点而言，从该节点到其所有后代叶节点的简单路径中，均包含相同数目的黑色节点。</li>
</ol>
<p>基于上述红黑性质，我们可以得到如下结论：一棵含有 $N$ 个内部节点的红黑树，其高度至多为 $O(2log^{N + 1})$。正是此结论，保证了针对二叉查找树各种操作的最坏时间复杂度为 $O(log^N)$。</p>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>红黑树需额外保存节点的颜色信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RBTree</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 节点结构</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">// 具体元素</span></span><br><span class="line">        E item;</span><br><span class="line">        <span class="comment">// 父节点</span></span><br><span class="line">        Node&lt;E&gt; parent;</span><br><span class="line">        <span class="comment">// 左儿子</span></span><br><span class="line">        Node&lt;E&gt; left;</span><br><span class="line">        <span class="comment">// 右儿子</span></span><br><span class="line">        Node&lt;E&gt; right;</span><br><span class="line">        <span class="comment">// 节点颜色</span></span><br><span class="line">        <span class="keyword">boolean</span> isBlack;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 默认将节点颜色置为红色</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E item)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.item = item;</span><br><span class="line">            <span class="keyword">this</span>.parent = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.left = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.right = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.isBlack = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置节点颜色为红色</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.isBlack = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置节点颜色为黑色</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBlack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.isBlack = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根节点</span></span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; root;</span><br><span class="line">    <span class="comment">// 比较函数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> E&gt; comparator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="辅助方法"><a href="#辅助方法" class="headerlink" title="辅助方法"></a>辅助方法</h3><ul>
<li><p>当前节点颜色是否为黑色</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isBlack</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">null</span> == node) || (node.isBlack);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>当前节点颜色是否为红色</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isRed</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !isBlack(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>当前子树中查找具有最小元素的节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;E&gt; <span class="title">getMinTree</span><span class="params">(Node&lt;E&gt; root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 一路向左即可。</span></span><br><span class="line">    Node&lt;E&gt; node = root;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">null</span> != node.left) &#123;</span><br><span class="line">        node = node.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>右旋</p>
<p>该操作就是 AVL 中的 <code>LL</code>，也是伸展树中的 <code>zig</code>。</p>
<p><img src="/2020/06/30/dataStructure/dataStructure-rbtree/image-20200630184952581.png" alt="图二：右旋"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rightRotate</span><span class="params">(Node&lt;E&gt; root)</span> </span>&#123;</span><br><span class="line">    Node&lt;E&gt; k1 = root;</span><br><span class="line">    Node&lt;E&gt; k2 = root.left;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首先调整k1左儿子指向及相应儿子的父节点指向。</span></span><br><span class="line">    k1.left = k2.right;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != k2.right) &#123;</span><br><span class="line">        k2.right.parent = k1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其次调整k2的父节点指向及相应父节点的儿子节点指向。</span></span><br><span class="line">    <span class="comment">// 如果k2.parent为空，表明k2为根结点，需重新指定根结点。</span></span><br><span class="line">    k2.parent = k1.parent;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != k1.parent) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k1 == k1.parent.left) &#123;</span><br><span class="line">            k1.parent.left = k2;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            k1.parent.right = k2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.root = k2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后调整k1的右儿子指向及相应儿子的父节点指向。</span></span><br><span class="line">    k2.right = k1;</span><br><span class="line">    k1.parent = k2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>左旋</p>
<p>该操作就是 AVL 中的 <code>RR</code>，也是伸展树中的 <code>zag</code>。</p>
<p><img src="/2020/06/30/dataStructure/dataStructure-rbtree/image-20200630185055765.png" alt="图三：左旋"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">leftRotate</span><span class="params">(Node&lt;E&gt; root)</span> </span>&#123;</span><br><span class="line">    Node&lt;E&gt; k1 = root;</span><br><span class="line">    Node&lt;E&gt; k2 = root.right;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首先调整k1右儿子指向及相应儿子的父节点指向。</span></span><br><span class="line">    k1.right = k2.left;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != k2.left) &#123;</span><br><span class="line">        k2.left.parent = k1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其次调整k2的父节点指向及相应父节点的儿子指向。</span></span><br><span class="line">    <span class="comment">// 如果k1.parent为空，表明k1为根结点，需重新指定根结点。</span></span><br><span class="line">    k2.parent = k1.parent;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != k1.parent) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k1 == k1.parent.left) &#123;</span><br><span class="line">            k1.parent.left = k2;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            k1.parent.right = k2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.root = k2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后调整k2右儿子及相应儿子的父节点指向。</span></span><br><span class="line">    k2.left = k1;</span><br><span class="line">    k1.parent = k2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>插入修正</p>
<p>向红黑树中插入元素时，可能会破坏红黑性质，因此需要对红黑树进行一定调整。</p>
<blockquote>
<p>当向红黑树中插入元素时，我们需要指定新建节点的颜色。如果指定为黑色，红黑性质五一定遭到破坏，故而需要进行调整；如果指定为红色，只有当其父节点的颜色同样为红色时，红黑性质四才会遭到破坏，此时需要进行调整。考虑到编码简洁性，我们指定新建节点的颜色为红色。</p>
</blockquote>
<p>插入修正涉及多种情景，我们在此一一详述 (假定此时新建节点已插入到合适位置。图例中 <code>C</code> 表示当前节点，<code>P</code> 表示父节点，<code>PP</code> 表示祖父节点，<code>U</code> 表示叔叔节点。)。</p>
<p><strong>插入情景1：</strong>红黑树为空</p>
<p>将当前节点指定为根节点，并将节点颜色置为黑色。</p>
<p><strong>插入情景2：</strong>当前节点的父节点颜色为黑色</p>
<p>无需做任何处理。</p>
<p><strong>插入情景3：</strong>当前节点的父节点颜色为红色</p>
<p>当前节点颜色与父节点颜色同为红色，违反红黑性质四，故而需要进行调整。由于父节点颜色为红色，根据红黑性质四可知祖父节点一定存在。考虑到祖父节点及叔叔节点颜色的不确定性，此情景又可进一步细分为如下子情景。</p>
<p><strong>插入情景3.1：</strong> 当前节点的父节点为祖父节点的左儿子</p>
<p><strong>插入情景3.1.1：</strong>叔叔节点存在且颜色为红色</p>
<p>为维持红黑性质，我们只需要将 <code>P</code> 和 <code>U</code> 置为黑色、<code>PP</code> 置为红色，同时重置节点 <code>PP</code> 为当前节点，递归处理当前节点即可。</p>
<p><img src="/2020/06/30/dataStructure/dataStructure-rbtree/image-20200630091414199.png" alt="图四：插入情景3.1.1"></p>
<p><strong>插入情景3.1.2：</strong>叔叔节点不存在或存在且颜色为黑色，并且当前节点为父节点的左儿子</p>
<p>这里有关叔叔节点的表述存在一定问题。由于祖父节点满足红黑性质，那么容易得知叔叔节点一定是空节点。此时为维持红黑性质，我们需要先将 <code>P</code> 置为黑色、<code>PP</code> 置为红色，然后右旋节点 <code>PP</code> 即可。</p>
<p><img src="/2020/06/30/dataStructure/dataStructure-rbtree/image-20200630095210331.png" alt="图五：插入情景3.1.2"></p>
<p><strong>插入情景3.1.3：</strong> 叔叔节点不存在或存在且颜色为黑色，并且当前节点为父节点的右儿子</p>
<p>这里有关叔叔节点的表述存在一定问题。由于祖父节点满足红黑性质，那么容易得知叔叔节点一定是空节点。此时为维持红黑性质，我们先左旋节点 <code>P</code> ，然后重置节点 <code>P</code> 为当前节点，最后使用 <em>插入情景3.1.2</em> 的处理方法即可。</p>
<p><img src="/2020/06/30/dataStructure/dataStructure-rbtree/image-20200630100051519.png" alt="图六：插入情景3.1.3"></p>
<p><strong>插入情景3.2：</strong> 当前节点的父节点为祖父节点的右儿子</p>
<p><strong>插入情景3.2.1：</strong> 叔叔节点存在且颜色为红色</p>
<p>为维持红黑性质，我们只需要将 <code>P</code> 和 <code>U</code> 置为黑色、<code>PP</code> 置为红色，同时重置节点 <code>PP</code> 为当前节点，递归处理 当前节点即可。</p>
<p><img src="/2020/06/30/dataStructure/dataStructure-rbtree/image-20200630100717135.png" alt="图七：插入情景3.2.1"></p>
<p><strong>插入情景3.2.2：</strong> 叔叔节点不存在或存在且颜色为黑色，并且当前节点为父节点的右儿子</p>
<p>这里有关叔叔节点的表述存在一定问题。由于祖父节点满足红黑性质，那么容易得知叔叔节点一定是空节点。此时为维持红黑性质，我们需要先将 <code>P</code> 置为黑色、<code>PP</code> 置为红色，然后左旋节点 <code>PP</code> 即可。</p>
<p><img src="/2020/06/30/dataStructure/dataStructure-rbtree/image-20200630101441786.png" alt="图八：插入情景3.2.2"></p>
<p><strong>插入情景3.2.3：</strong> 叔叔节点不存在或存在且颜色为黑色，并且当前节点为父节点的左儿子</p>
<p>这里有关叔叔节点的表述存在一定问题。由于祖父节点满足红黑性质，那么容易得知叔叔节点一定是空节点。此时为维持红黑性质，我们先右旋节点 <code>P</code> ，然后重置节点 <code>P</code> 为当前节点，最后使用 <em>插入情景3.2.2</em> 的处理方法即可。</p>
<p><img src="/2020/06/30/dataStructure/dataStructure-rbtree/image-20200630101818279.png" alt="图九：插入情景3.2.3"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 插入情景1,2已在它处加以处理，此函数仅处理插入情景3。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insertFixUp</span><span class="params">(Node&lt;E&gt; root)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// 如果当前节点的父节点存在，且节点颜色为红色，则需要调整。</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">null</span> != root.parent &amp;&amp; isRed(root.parent)) &#123;</span><br><span class="line">        <span class="comment">// 获取父节点和祖父节点引用。</span></span><br><span class="line">        Node&lt;E&gt; parent = root.parent;</span><br><span class="line">        Node&lt;E&gt; grandParent = parent.parent;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 父节点为祖父节点的左儿子。</span></span><br><span class="line">        <span class="keyword">if</span> (parent == grandParent.left) &#123;</span><br><span class="line">            Node&lt;E&gt; uncle = grandParent.right;</span><br><span class="line">            <span class="comment">// 插入情景3.1.1：叔叔节点存在且颜色为红色。</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != uncle &amp;&amp; isRed(uncle)) &#123;</span><br><span class="line">                parent.setBlack();</span><br><span class="line">                uncle.setBlack();</span><br><span class="line">                grandParent.setRed();</span><br><span class="line">                root = grandParent;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 插入情景3.1.3：叔叔节点不存在或存在且颜色为黑色，并且当前节点为父节点的右儿子。</span></span><br><span class="line">            <span class="keyword">if</span> (root == parent.right) &#123;</span><br><span class="line">                leftRotate(parent);</span><br><span class="line">                Node&lt;E&gt; tmp;</span><br><span class="line">                tmp = root;</span><br><span class="line">                root = parent;</span><br><span class="line">                parent = tmp;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 插入情景3.1.2：叔叔节点不存在或存在且颜色为黑色，并且当前节点为父节点的左儿子。</span></span><br><span class="line">            rightRotate(grandParent);</span><br><span class="line">            parent.setBlack();</span><br><span class="line">            grandParent.setRed();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 父节点为祖父节点的右儿子。</span></span><br><span class="line"></span><br><span class="line">            Node&lt;E&gt; uncle = grandParent.left;</span><br><span class="line">            <span class="comment">// 插入情景3.2.1： 叔叔节点存在且颜色为红色。</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != uncle &amp;&amp; isRed(uncle)) &#123;</span><br><span class="line">                parent.setBlack();</span><br><span class="line">                uncle.setBlack();</span><br><span class="line">                grandParent.setRed();</span><br><span class="line">                root = grandParent;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 插入情景3.2.3： 叔叔节点不存在或存在且颜色为黑色，并且当前节点为父节点的左儿子。</span></span><br><span class="line">            <span class="keyword">if</span> (root == parent.left) &#123;</span><br><span class="line">                rightRotate(parent);</span><br><span class="line">                Node&lt;E&gt; tmp;</span><br><span class="line">                tmp = root;</span><br><span class="line">                root = parent;</span><br><span class="line">                parent = tmp;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 插入情景3.2.2： 叔叔节点不存在或存在且颜色为黑色，并且当前节点为父节点的右儿子。</span></span><br><span class="line">            leftRotate(grandParent);</span><br><span class="line">            parent.setBlack();</span><br><span class="line">            grandParent.setRed();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上述调整可能导致根结点变为红色，在此需要调整。</span></span><br><span class="line">    <span class="keyword">this</span>.root.setBlack();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>删除子过程</p>
<p>将前者节点所在子树替换为后者节点所在子树，同时调整前者节点父节点的孩子节点指向。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">judgeParent</span><span class="params">(Node&lt;E&gt; former, Node&lt;E&gt; latter)</span> </span>&#123;</span><br><span class="line">    latter.parent = former.parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前者的父节点为空，表明其为根节点，故而需要调整root指向。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == former.parent) &#123;</span><br><span class="line">        <span class="keyword">this</span>.root = latter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调整前者父节点的孩子指向。</span></span><br><span class="line">    <span class="keyword">if</span> (former == former.parent.left) &#123;</span><br><span class="line">        former.parent.left = latter;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        former.parent.right = latter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>删除修正</p>
<p>如果待删除节点颜色为黑色，红黑性质五则会遭到破坏，此时需要对红黑树进行一定调整。</p>
<p>删除修正涉及多种情景，我们在此一一详述 (假定此时待删除节点已删除完成，我们需要对顶替待删除节点所在位置的那个节点进行调整操作。图例中 <code>C</code> 表示当前节点，即顶替待删除节点所在位置的那个节点，<code>P</code> 表示父节点，<code>B</code> 表示兄弟节点，<code>LB</code> 表示兄弟节点的左儿子，<code>RB</code> 表示兄弟节点的右儿子，节点颜色为灰色表示该节点颜色或为红色、或为黑色。)。</p>
<blockquote>
<ul>
<li>为保证删除节点后的红黑树满足红黑性质，我们暂且视当前节点额外具有一重黑色。故而下面图例中，我们直接将当前节点颜色置为黑色。</li>
<li>如果待删除节点颜色为黑色，那么根据红黑性质五容易得知：兄弟节点一定存在。</li>
</ul>
</blockquote>
<p><strong>删除情景1：</strong> 当前节点为父节点的左儿子</p>
<p><strong>删除情景1.1：</strong> 兄弟节点颜色为红色</p>
<p>当兄弟节点颜色为红色时，根据红黑性质可容易推知其他相关节点颜色。为维持红黑性质，我们需要先将 <code>P</code> 置为红色、<code>B</code> 置为黑色，然后左旋节点 <code>P</code>，最后使用 <em>删除情景1.2</em> 的处理方法即可。</p>
<p><img src="/2020/06/30/dataStructure/dataStructure-rbtree/image-20200630154921671.png" alt="图十：删除情景1.1"></p>
<p><strong>删除情景1.2：</strong> 兄弟节点颜色为黑色</p>
<p><strong>删除情景1.2.1：</strong> 兄弟节点的左右儿子节点颜色均为黑色</p>
<p>为维持红黑性质，我们需先将 <code>B</code> 置为红色，<code>C</code> 恢复为原本颜色，然后重置节点 <code>P</code> 为当前节点，最后递归处理当前节点即可。</p>
<p><img src="/2020/06/30/dataStructure/dataStructure-rbtree/image-20200630191723288.png" alt="图十一：删除情景1.2.1"></p>
<p><strong>删除情景1.2.2：</strong> 兄弟节点的左儿子颜色为红色，右儿子颜色为黑色</p>
<p>为维持红黑性质，我们需先将 <code>LB</code> 置为黑色、<code>B</code> 置为红色，然后右旋节点 <code>B</code>，最后使用 <em>删除情景1.2.3</em> 的处理方法即可。</p>
<p><img src="/2020/06/30/dataStructure/dataStructure-rbtree/image-20200630161437135.png" alt="图十二：删除情景1.2.2"></p>
<p><strong>删除情景1.2.3：</strong> 兄弟节点的左儿子颜色任意，右儿子颜色为红色</p>
<p>为维持红黑性质，我们需先将 <code>B</code> 置节点 <code>P</code> 原本的颜色、<code>P</code> 置为黑色、<code>RB</code> 置为黑色、<code>C</code> 恢复为原本颜色，然后左旋节点 <code>P</code> 即可。</p>
<p>此情景为删除修正中最为重要的情景，我们在此说明一下 “为什么如下转换是可行的? “。</p>
<p>通过为当前节点添加一重额外的黑色，未调整前的红黑树是满足红黑性质的，此时我们可得到如下等式：$hb(C) = hb(LB) + 1；hb(RB) = hb(LB)$。 通过一系列颜色调整，使得 <code>C</code> 所在子树的黑高减一、<code>RB</code> 所在子树的黑高加一，最终可得到如下等式：$hb(C) = hb(LB)；hb(RB) = hb(LB) + 1$。此时对于 <code>P</code> 和 <code>B</code> 而言，红黑性质五均得到满足，调整完成。</p>
<p><img src="/2020/06/30/dataStructure/dataStructure-rbtree/image-20200630164534109.png" alt="图十三：删除情景1.2.3"></p>
<p><strong>删除情景2：</strong> 当前节点为父节点的右儿子</p>
<p><strong>删除情景2.1：</strong> 兄弟节点颜色为红色</p>
<p>当兄弟节点颜色为红色时，根据红黑性质可容易推知其他相关节点颜色。为维持红黑性质，我们需要先将 <code>P</code> 置为红色、<code>B</code> 置为黑色，然后右旋节点 <code>P</code>，最后使用 <em>删除情景2.2</em> 的处理方法即可。</p>
<p><img src="/2020/06/30/dataStructure/dataStructure-rbtree/image-20200630171048818.png" alt="图十四：删除情景2.1"></p>
<p><strong>删除情景2.2：</strong> 兄弟节点颜色为黑色</p>
<p><strong>删除情景2.2.1：</strong> 兄弟节点的左右儿子节点颜色均为黑色</p>
<p>为维持红黑性质，我们需先将 <code>B</code> 置为红色，<code>C</code> 恢复为原本颜色，然后重置节点 <code>P</code> 为当前节点，最后递归处理当前节点即可。</p>
<p><img src="/2020/06/30/dataStructure/dataStructure-rbtree/image-20200630192222423.png" alt="图十五：删除情景2.2.1"></p>
<p><strong>删除情景2.2.2：</strong> 兄弟节点的左儿子颜色为黑色，右儿子颜色为红色</p>
<p>为维持红黑性质，我们需先将 <code>RB</code> 置为黑色、<code>B</code> 置为红色，然后左旋节点 <code>B</code>，最后使用 <em>删除情景2.2.3</em> 的处理方法即可。</p>
<p><img src="/2020/06/30/dataStructure/dataStructure-rbtree/image-20200630192420802.png" alt="图十六：删除情景2.2.2"></p>
<p><strong>删除情景2.2.3：</strong> 兄弟节点的左儿子为红色，右儿子颜色为任意颜色</p>
<p>为维持红黑性质，我们需先将 <code>B</code> 置节点 <code>P</code> 原本的颜色、<code>P</code> 置为黑色、<code>LB</code> 置为黑色、<code>C</code> 恢复为原本颜色，然后右旋节点 <code>P</code> 即可。</p>
<p>转换可行性解释与 <em>删除情景1.2.3</em> 类似。</p>
<p><img src="/2020/06/30/dataStructure/dataStructure-rbtree/image-20200630173050582.png" alt="图十七：删除情景2.2.3"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteFixUp</span><span class="params">(Node&lt;E&gt; root, Node&lt;E&gt; parent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调整结束条件：root不为红黑树根节点。</span></span><br><span class="line">    <span class="keyword">while</span> (root != <span class="keyword">this</span>.root) &#123;</span><br><span class="line">        <span class="comment">// root节点为父节点左儿子。</span></span><br><span class="line">        <span class="keyword">if</span> (root == parent.left) &#123;</span><br><span class="line">            <span class="comment">// 获取root节点的兄弟节点。</span></span><br><span class="line">            Node&lt;E&gt; brother = parent.right;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 删除情景1.1：兄弟节点颜色为红色。</span></span><br><span class="line">            <span class="keyword">if</span> (isRed(brother)) &#123;</span><br><span class="line">                leftRotate(parent);</span><br><span class="line">                parent.setRed();</span><br><span class="line">                brother.setBlack();</span><br><span class="line">                <span class="comment">// 更新root节点的兄弟节点。</span></span><br><span class="line">                brother = parent.right;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 删除情景1.2.1：兄弟节点的左右儿子节点颜色均为黑色。</span></span><br><span class="line">            <span class="keyword">if</span> (isBlack(brother.left) &amp;&amp; isBlack(brother.right)) &#123;</span><br><span class="line">                brother.setRed();</span><br><span class="line">                root = parent;</span><br><span class="line">                <span class="comment">// 更新root节点的父节点。</span></span><br><span class="line">                parent = root.parent;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isBlack(brother.right)) &#123;</span><br><span class="line">                <span class="comment">// 删除情景1.2.2：兄弟节点的左儿子颜色为红色，右儿子颜色为黑色。</span></span><br><span class="line">                rightRotate(brother);</span><br><span class="line">                brother.left.setBlack();</span><br><span class="line">                brother.setRed();</span><br><span class="line">                <span class="comment">// 更新root节点的兄弟节点。</span></span><br><span class="line">                brother = parent.right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 删除情景1.2.3：兄弟节点的左儿子颜色任意，右儿子颜色为红色。</span></span><br><span class="line">                brother.isBlack = parent.isBlack;</span><br><span class="line">                parent.setBlack();</span><br><span class="line">                brother.right.setBlack();</span><br><span class="line">                leftRotate(parent);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 此一调整可保证红黑树性质得以满足，直接退出即可。</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// root节点为父节点右儿子。</span></span><br><span class="line">            Node&lt;E&gt; brother = parent.left;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 删除情景2.1：兄弟节点颜色为红色。</span></span><br><span class="line">            <span class="keyword">if</span> (isRed(brother)) &#123;</span><br><span class="line">                rightRotate(parent);</span><br><span class="line">                parent.setRed();</span><br><span class="line">                brother.setBlack();</span><br><span class="line">                <span class="comment">// 更新root节点的兄弟节点。</span></span><br><span class="line">                brother = parent.left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 删除情景2.2.1：兄弟节点的左右儿子节点颜色均为黑色。</span></span><br><span class="line">            <span class="keyword">if</span> (isBlack(brother.left) &amp;&amp; isBlack(brother.right)) &#123;</span><br><span class="line">                brother.setRed();</span><br><span class="line">                root = parent;</span><br><span class="line">                <span class="comment">// 更新root节点的父节点。</span></span><br><span class="line">                parent = root.parent;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isBlack(brother.left)) &#123;</span><br><span class="line">                <span class="comment">// 删除情景2.2.2：兄弟节点的左儿子颜色为黑色，右儿子颜色为红色。</span></span><br><span class="line">                leftRotate(brother);</span><br><span class="line">                brother.right.setBlack();</span><br><span class="line">                brother.setRed();</span><br><span class="line">                <span class="comment">// 更新root节点的兄弟节点。</span></span><br><span class="line">                brother = parent.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 删除情景2.2.3：兄弟节点的左儿子为红色，右儿子颜色为任意颜色。</span></span><br><span class="line">                brother.isBlack = parent.isBlack;</span><br><span class="line">                parent.setBlack();</span><br><span class="line">                brother.left.setBlack();</span><br><span class="line">                rightRotate(parent);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 此一调整可保证红黑树性质得以满足，直接退出即可。</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != <span class="keyword">this</span>.root) &#123;</span><br><span class="line">        <span class="keyword">this</span>.root.setBlack();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>该函数需要注意一点：传参时需要传入待调整节点的父节点。其原因在于：待调整节点可能为空节点，空节点是无法直接找到其父节点的。</p>
</blockquote>
</li>
</ul>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RBTree</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="操纵"><a href="#操纵" class="headerlink" title="操纵"></a>操纵</h3><ul>
<li><p>红黑树中添加元素</p>
<p>添加元素过程与二叉查找树基本相同，只是在最后多了一个 “插入修正”。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E item)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 红黑树为空，直接创建该节点即可。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == <span class="keyword">this</span>.root) &#123;</span><br><span class="line">        <span class="keyword">this</span>.root = <span class="keyword">new</span> Node&lt;&gt;(item);</span><br><span class="line">        <span class="keyword">this</span>.root.isBlack = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向插入节点。</span></span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">this</span>.root;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 当前节点元素值大于待插入值，则应插入于左子树。</span></span><br><span class="line">        <span class="keyword">if</span> (comparator.compare(node.item, item) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == node.left) &#123;</span><br><span class="line">                node.left = <span class="keyword">new</span> Node&lt;&gt;(item);</span><br><span class="line">                node.left.parent = node;</span><br><span class="line">                node = node.left;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node = node.left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (comparator.compare(node.item, item) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 当前节点元素值等于待插入值，直接返回即可。</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 当前节点元素值小于待插入值，则应插入于右子树。</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == node.right) &#123;</span><br><span class="line">                node.right = <span class="keyword">new</span> Node&lt;&gt;(item);</span><br><span class="line">                node.right.parent = node;</span><br><span class="line">                node = node.right;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node = node.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入修正。</span></span><br><span class="line">    insertFixUp(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>红黑树中删除元素</p>
<p>删除元素过程同样与二叉查找树类似，只是额外多了两个步骤：记录待删除节点颜色以及 “删除修正”。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(E item)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 指向待删除节点。</span></span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">this</span>.root;</span><br><span class="line">    <span class="comment">// 指向待调整节点。</span></span><br><span class="line">    Node&lt;E&gt; judgeNode = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 指向待调整节点的父节点。</span></span><br><span class="line">    Node&lt;E&gt; judgeNodeParent = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 待删除节点是否为黑色。</span></span><br><span class="line">    <span class="keyword">boolean</span> isBlack = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">null</span> != node) &#123;</span><br><span class="line">        <span class="keyword">if</span> (comparator.compare(node.item, item) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (comparator.compare(node.item, item) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 红黑树为空或者不存在具有该元素的节点，直接返回即可。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == node) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    isBlack = node.isBlack;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 待删除节点的左右子树均不为空。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != node.left &amp;&amp; <span class="keyword">null</span> != node.right) &#123;</span><br><span class="line">        <span class="comment">// 获取后继节点。</span></span><br><span class="line">        Node&lt;E&gt; next = getMinTree(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将待删除节点调整为后继节点。</span></span><br><span class="line">        <span class="comment">// 这里有多种方式可以采取。例如直接交换关键字、直接交换这两个节点所有引用指向。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 直接交换二者关键字</span></span><br><span class="line">        E tmp;</span><br><span class="line">        tmp = next.item;</span><br><span class="line">        next.item = node.item;</span><br><span class="line">        node.item = tmp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新node指向及isBlack取值。</span></span><br><span class="line">        node = next;</span><br><span class="line">        isBlack = node.isBlack;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 待删除节点左子树不为空。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != node.left) &#123;</span><br><span class="line">        judgeNode = node.left;</span><br><span class="line">        judgeParent(node, judgeNode);</span><br><span class="line">        judgeNodeParent = judgeNode.parent;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">null</span> != node.right) &#123;</span><br><span class="line">        <span class="comment">// 待删除节点右子树为空。</span></span><br><span class="line">        judgeNode = node.right;</span><br><span class="line">        judgeParent(node, judgeNode);</span><br><span class="line">        judgeNodeParent = judgeNode.parent;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 左右子树均为空。</span></span><br><span class="line">        judgeNodeParent = node.parent;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == node.parent) &#123;</span><br><span class="line">            <span class="keyword">this</span>.root = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (node == node.parent.left) &#123;</span><br><span class="line">                node.parent.left = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node.parent.right = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除节点为黑节点，则需要进行调整。</span></span><br><span class="line">    <span class="keyword">if</span> (isBlack) &#123;</span><br><span class="line">        deleteFixUp(judgeNode, judgeNodeParent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2></li>
</ul>
<h3 id="自顶向下红黑树"><a href="#自顶向下红黑树" class="headerlink" title="自顶向下红黑树"></a>自顶向下红黑树</h3><p>上面所示代码为自底向上实现红黑树，另外还可自顶向下实现红黑树，此种做法的优点在于无需存储父节点信息。</p>
<ul>
<li><p>红黑树中添加元素</p>
<p>自底向上实现红黑树中，当叔叔节点颜色为红色时，需要向上递归处理；当叔叔节点颜色为黑色时，只需要处理当前节点、父节点和祖父节点。因此，为自顶向下实现红黑树，只需要使用一定规则保证 “当需要进行调整时叔叔节点颜色不可能为红色” 即可。</p>
<p>这一规则具体内容如图示：</p>
<p>如果当前节点的左右儿子节点颜色均为红色，那么便置当前节点颜色为红色，左右儿子节点颜色为黑色。</p>
<p><img src="/2020/06/30/dataStructure/dataStructure-rbtree/image-20200703103613118.png" alt="图十八：自顶向下插入调整"></p>
<p>自顶向下实现红黑树中添加元素具体步骤如下：</p>
<ol>
<li>初始化当前节点为 <code>this.root</code>、父节点为 <code>null</code>、祖父节点为 <code>null</code>。</li>
<li>如果当前节点左右儿子节点颜色均为红色，则采用上图加以调整。</li>
<li>如果当前节点父节点颜色亦为红色，则根据当前节点、父节点、祖父节点间关系进行调整。</li>
<li>如果当前节点父节点颜色为黑色，则直接跳转到 <strong>步骤 6</strong> 。</li>
<li>将当前节点元素值与待插入元素值进行对比，更新当前节点、父节点、祖父节点，跳转到 <strong>步骤 2</strong>。</li>
<li>设置根节点颜色为黑色。</li>
</ol>
</li>
<li><p>红黑树中删除元素</p>
<p>自底向上实现红黑树中，我们将删除元素转换为 “删除一个至少含有一个空儿子节点的节点”。当待删除节点的一个儿子节点为空、另一个儿子节点不为空时，我们还可取不空儿子节点所在子树中的最大值/最小值所在节点替换待删除节点，并指定该节点成为待删除节点。依此思路而行，最终待删除节点的左右儿子节点均为空节点。故而，我们便将删除元素进一步转换为 “删除一个两个儿子节点均为空节点的节点”。</p>
<p>如果待删除节点颜色为红色，那么直接删除即可；反之删除后需调整红黑性质。为自顶向下实现红黑树，只需要使用一定规则保证 “当前正在处理的节点颜色为红色” 即可。</p>
<p>假定某一轮调整已保证当前正在处理的节点颜色为红色，如果当前节点并非待删除节点，那么我们需要进一步向下探索，如此可得到如图情况：</p>
<p><img src="/2020/06/30/dataStructure/dataStructure-rbtree/image-20200703153638801.png" alt="图十九：自顶向下删除调整"></p>
<p>此时我们便需要使用一定规则将当前节点颜色调整为红色，这样便可进一步向下探索。最终我们将得到：待删除节点的左右儿子为空，且待删除节点颜色为红色，此时直接删除该节点即可。</p>
<blockquote>
<p>这里涉及的规则比较复杂，就不说了。</p>
</blockquote>
</li>
</ul>
<h3 id="优化红黑树"><a href="#优化红黑树" class="headerlink" title="优化红黑树"></a>优化红黑树</h3><p>插入、删除情景众多，使得红黑树实现代码非常复杂。通过对红黑树结构进一步施加限制，可以得到实现较为简单的简化版红黑树，这其中比较著名的有 BB树、AA树。在此我们仅简要介绍 AA 树。</p>
<p>AA 树对红黑树施以如下限制：一个节点最多只有一个红色儿子节点，且该红色儿子节点只能是该节点的右儿子节点。</p>
<p>如此限制结构，使得插入、删除情景各缩减为两种，大大降低了编程复杂性，具体调整就不在叙述了。</p>
<h3 id="扩张红黑树"><a href="#扩张红黑树" class="headerlink" title="扩张红黑树"></a>扩张红黑树</h3><p>“扩张红黑树” 指代改造红黑树节点结构以支持特定操作，同时保证红黑树原有各种操作可正常实现。这里介绍两种基于此而实现的数据结构——顺序统计树和区间树。</p>
<ul>
<li><p>顺序统计树</p>
<p>顺序统计树可在 $O(log^N)$ 时间内确定指定元素在整棵树中的排名、整棵树中指定排名对应的元素。</p>
<p>向红黑树节点结构中添加字段 <code>size</code> (其意义为：当前节点所在子树含有的节点个数)，即可得到顺序统计树的节点结构。</p>
<blockquote>
<p>实现二叉查找树之时，我顺带实现了顺序统计树，其实现代码参见 <a href="/2020/06/04/dataStructure/dataStructure-binarysearchtree/" title="数据结构-二叉查找树">数据结构-二叉查找树</a>。</p>
</blockquote>
</li>
<li><p>区间树</p>
<p>区间树是一种以区间为元素的数据结构，可在 $O(log^N)$ 时间内实现插入区间元素、删除区间元素、查询与指定区间重叠的区间元素等操作。</p>
<p>区间树的节点结构与红黑树节点结构有较大差别，故而在此列举其结构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">// 区间左端点(关键字)</span></span><br><span class="line">        <span class="keyword">int</span> low;</span><br><span class="line">        <span class="comment">// 区间右端点</span></span><br><span class="line">        <span class="keyword">int</span> high;</span><br><span class="line">        <span class="comment">// 当前子树中所有区间右端点的最大值</span></span><br><span class="line">        <span class="keyword">int</span> max;</span><br><span class="line">        <span class="comment">// 父节点</span></span><br><span class="line">        Node&lt;E&gt; parent;</span><br><span class="line">        <span class="comment">// 左儿子</span></span><br><span class="line">        Node&lt;E&gt; left;</span><br><span class="line">        <span class="comment">// 右儿子</span></span><br><span class="line">        Node&lt;E&gt; right;</span><br><span class="line">        <span class="comment">// 节点颜色</span></span><br><span class="line">        <span class="keyword">boolean</span> isBlack;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们使用区间左端点作为关键字参与排序，故而遍历区间树将得到：各区间按左端点的排列次序依次输出。</p>
</blockquote>
<p>插入区间元素与删除区间元素的操作与红黑树类似，故而不再叙述。我们在此详述 “查询与指定区间重叠的区间元素” 这一操作。</p>
<p>任意两个区间 $i$ 与 $i’$ 一定满足 <strong>区间三分律</strong>，即下面三条性质之一成立：</p>
<ol>
<li>$i$ 与 $i’$ 重叠 ( $i.low \leq i’.high \  且 \  i’.low \leq i.high$ )</li>
<li>$i$ 在 $i’$ 的左边 ( $i.high &lt; i’.low$ )</li>
<li>$i$ 在 $i’$ 的右边 ( $i.low &gt; i’.high$ )</li>
</ol>
<p>根据上面这个定理，可容易得到该操作的伪代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">intervalSearch(T, i)</span><br><span class="line">    x = T.root;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">null</span> != x &amp;&amp; i does not overlop x)</span><br><span class="line">        <span class="comment">// x.left.max &gt;= i.low 表明左子树与i重叠，则在该子树中一定可以找到一个区间与i重叠。</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != x.left &amp;&amp; x.left.max &gt;= i.low)</span><br><span class="line">            x = x.left;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            x = x.right;</span><br><span class="line">    <span class="keyword">return</span>; </span><br></pre></td></tr></table></figure>
<blockquote>
<p>该伪代码仅查询一个重叠区间元素，其时间复杂度为 $O(log^N)$ 。查找全部重叠区间元素也是可以的，但是时间复杂度就无法保证了。</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-伸展树</title>
    <url>/2020/06/21/dataStructure/dataStructure-splaytree/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>伸展树</strong> 是一种自调整的二叉查找树。它没有 AVL 那样严格的平衡条件，通过施以某些调整可使得树上各种操作的平均时间复杂度为 $O(log^N)$。</p>
<a id="more"></a>

<p>其结构图大致如下：</p>
<img src="/2020/06/21/dataStructure/dataStructure-splaytree/1561649132346.png" alt="图一：伸展树" style="zoom:50%;">

<p>我们知道：对于二叉查找树而言，每次操作最坏时间复杂度 $O(N)$ 并非不好，只要它相对不常发生就行。另外我们发现，如果某个节点被访问，那么不久后该节点将再次被访问。基于上述两个事实，伸展树在访问一个节点后，会将该节点旋转至根节点，这样做有两大目的：1. 一定程度上平衡整棵树。2. 降低再次访问该节点所需的时间。</p>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>伸展树无需保存高度信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SplayTree</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 节点结构</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">// 具体元素</span></span><br><span class="line">        E item;</span><br><span class="line">        <span class="comment">// 父节点</span></span><br><span class="line">        Node&lt;E&gt; parent;</span><br><span class="line">        <span class="comment">// 左儿子</span></span><br><span class="line">        Node&lt;E&gt; left;</span><br><span class="line">        <span class="comment">// 右儿子</span></span><br><span class="line">        Node&lt;E&gt; right;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E item)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.item = item;</span><br><span class="line">            <span class="keyword">this</span>.parent = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.left = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.right = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根节点</span></span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; root;</span><br><span class="line">    <span class="comment">// 比较函数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> E&gt; comparator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="辅助方法"><a href="#辅助方法" class="headerlink" title="辅助方法"></a>辅助方法</h3><p>伸展树中的伸展操作主要涉及六大调整，依次为 <code>zig</code>、<code>zag</code>、<code>zig-zig</code>、<code>zag-zag</code>、<code>zig-zag</code>、<code>zag-zig</code>。</p>
<ul>
<li><p>zig</p>
<p>通过 <code>zig</code> 调整使节点 K1 成为根节点。</p>
<p><code>zig</code> 调整与 AVL 中的 <code>LL</code> 基本相同，同为右旋。</p>
<p><img src="/2020/06/21/dataStructure/dataStructure-splaytree/image-20200620225903738.png" alt="图二：zig调整节点K1"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">zig</span><span class="params">(Node&lt;E&gt; root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 右旋要求当前节点为父节点的左儿子，不符合要求直接返回即可。</span></span><br><span class="line">    <span class="keyword">if</span> (root != root.parent.left) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node&lt;E&gt; parent = root.parent;</span><br><span class="line">    Node&lt;E&gt; grandParents = parent.parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首先调整父节点的左儿子指向及对应左儿子的父节点指向。</span></span><br><span class="line">    parent.left = root.right;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != root.right) &#123;</span><br><span class="line">        root.right.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其次调整当前节点的父节点指向及对应父节点的儿子指向。</span></span><br><span class="line">    root.parent = grandParents;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != grandParents) &#123;</span><br><span class="line">        <span class="keyword">if</span> (parent == grandParents.left) &#123;</span><br><span class="line">            grandParents.left = root;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            grandParents.right = root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后调整当前节点的右儿子指向及对应右儿子的父节点指向</span></span><br><span class="line">    root.right = parent;</span><br><span class="line">    parent.parent = root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>zag</p>
<p>通过 <code>zag</code> 调整使节点 K1 成为根节点。</p>
<p><code>zag</code> 调整与 AVL 中的 <code>RR</code> 基本相同，同为左旋。</p>
<p><img src="/2020/06/21/dataStructure/dataStructure-splaytree/image-20200620230148756.png" alt="图三：zag调整节点K1"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">zag</span><span class="params">(Node&lt;E&gt; root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 左旋要求root节点为父节点的右儿子，不符合要求直接返回即可。</span></span><br><span class="line">    <span class="keyword">if</span> (root != root.parent.right) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node&lt;E&gt; parent = root.parent;</span><br><span class="line">    Node&lt;E&gt; grandParents = parent.parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首先调整父节点的右儿子指向及对应右儿子的父节点指向。</span></span><br><span class="line">    parent.right = root.left;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != root.left) &#123;</span><br><span class="line">        root.left.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其次调整当前节点的父节点指向及对应父节点的儿子指向。</span></span><br><span class="line">    root.parent = grandParents;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != grandParents) &#123;</span><br><span class="line">        <span class="keyword">if</span> (parent == grandParents.left) &#123;</span><br><span class="line">            grandParents.left = root;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            grandParents.right = root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后调整当前节点的左儿子指向及对应左儿子的父节点指向。</span></span><br><span class="line">    root.left = parent;</span><br><span class="line">    parent.parent = root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>zig-zig</p>
<p>首先 <code>zig</code> 调整节点 K2，然后 <code>zig</code> 调整节点 K1，最终使得节点 K1 成为根节点。</p>
<p><img src="/2020/06/21/dataStructure/dataStructure-splaytree/image-20200620230611170.png" alt="图四：zig-zig调整节点K1"></p>
</li>
<li><p>zag-zag</p>
<p>首先 <code>zag</code> 调整节点 K2，然后 <code>zag</code> 调整节点 K1，最终使得节点 K1 成为根节点。</p>
<p><img src="/2020/06/21/dataStructure/dataStructure-splaytree/image-20200620230848539.png" alt="图五：zag-zag调整节点K1"></p>
</li>
<li><p>zig-zag</p>
<p>首先 <code>zig</code> 调整节点 K1，然后 <code>zag</code> 调整节点 K1，最终使得节点 K1 成为根节点。</p>
<p><img src="/2020/06/21/dataStructure/dataStructure-splaytree/image-20200620231018307.png" alt="图六：zig-zag调整节点K1"></p>
</li>
<li><p>zag-zig</p>
<p>首先 <code>zag</code> 调整节点 K1，然后 <code>zig</code> 调整节点 K1，最终使得节点 K1 成为根节点。</p>
<p><img src="/2020/06/21/dataStructure/dataStructure-splaytree/image-20200620231251686.png" alt="图六：zag-zig调整节点K1"></p>
</li>
<li><p>伸展操作</p>
<p>将节点 <code>root</code> 伸展到节点 <code>target</code> 的儿子节点处。</p>
<p>伸展操作需使用到上述六大调整，此处代码对此作了些优化。 另外，当传入 <code>target = null</code> 时，需自行调整 <code>root</code> 指向。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">splay</span><span class="params">(Node&lt;E&gt; root, Node&lt;E&gt; target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 节点为空，无需伸展。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == root) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (root.parent != target) &#123;</span><br><span class="line">        Node&lt;E&gt; parent = root.parent;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root == parent.left) &#123;</span><br><span class="line">            <span class="comment">// 表明当前节点为父节点的左儿子。</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 祖父节点存在且父节点为祖父节点的左儿子，那么需要进行zig-zig调整，这种需要先调整父节点才能调整子节点。</span></span><br><span class="line">            <span class="comment">// 如果父节点为祖父节点的右儿子，那么需要进行zig-zag调整，这种属于先调整当前节点随后调整父节点，与当前代码流程相同，故而可不用处理。</span></span><br><span class="line">            <span class="keyword">if</span> (parent.parent != target &amp;&amp; parent == parent.parent.left) &#123;</span><br><span class="line">                zig(parent);</span><br><span class="line">            &#125;</span><br><span class="line">            zig(root);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 表明当前节点为父节点的右儿子。</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 祖父节点存在且父节点为祖父节点的右儿子，那么需要进行zag-zag调整，这种需要先调整父节点才能调整子节点。</span></span><br><span class="line">            <span class="comment">// 如果父节点为祖父节点的左儿子，那么需要进行zag-zig调整。这种属于先调整当前节点随后调整父节点，与当前代码流程相同，故而可不用处理。</span></span><br><span class="line">            <span class="keyword">if</span> (parent.parent != target &amp;&amp; parent == parent.parent.right) &#123;</span><br><span class="line">                zag(parent);</span><br><span class="line">            &#125;</span><br><span class="line">            zag(root);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当前子树中查找具有最小元素的节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;E&gt; <span class="title">getMinTree</span><span class="params">(Node&lt;E&gt; root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node&lt;E&gt; parent = root.parent;</span><br><span class="line">    Node&lt;E&gt; node = root;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">null</span> != node.left) &#123;</span><br><span class="line">        node = node.left;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 访问该节点，就需要将该节点进行伸展。</span></span><br><span class="line">    splay(node, parent);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>当前子树中查找具有最大元素的节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;E&gt; <span class="title">getMaxTree</span><span class="params">(Node&lt;E&gt; root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node&lt;E&gt; parent = root.parent;</span><br><span class="line">    Node&lt;E&gt; node = root;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">null</span> != node.right) &#123;</span><br><span class="line">        node = node.right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问该节点，就需要将该节点进行伸展。</span></span><br><span class="line">    splay(node, parent);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SplayTree</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><ul>
<li><p>查询指定元素是否存在</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E item)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 伸展树为空，直接返回false即可。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == <span class="keyword">this</span>.root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">this</span>.root;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">null</span> != node) &#123;</span><br><span class="line">        <span class="keyword">if</span> (comparator.compare(node.item, item) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (comparator.compare(node.item, item) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != node) &#123;</span><br><span class="line">        <span class="comment">// 访问该节点，就需要将该节点进行伸展。</span></span><br><span class="line">        <span class="comment">// 伸展到null，需要调整 root 指向。</span></span><br><span class="line">        splay(node, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">this</span>.root = node;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>查询最小元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">E <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.root = getMinTree(<span class="keyword">this</span>.root);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.root.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>查询最大元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">E <span class="title">getMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.root = getMaxTree(<span class="keyword">this</span>.root);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.root.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="操纵"><a href="#操纵" class="headerlink" title="操纵"></a>操纵</h3></li>
<li><p>伸展树中添加元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E item)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 伸展树为空，直接创建该结点即可。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == <span class="keyword">this</span>.root) &#123;</span><br><span class="line">        <span class="keyword">this</span>.root = <span class="keyword">new</span> Node&lt;&gt;(item);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 伸展树不为空，向下查找并插入待插入值。</span></span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">this</span>.root;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 当前节点值大于待插入值，则应在左子树中查找。</span></span><br><span class="line">        <span class="keyword">if</span> (comparator.compare(node.item, item) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == node.left) &#123;</span><br><span class="line">                node.left = <span class="keyword">new</span> Node&lt;&gt;(item);</span><br><span class="line">                node.left.parent = node;</span><br><span class="line">                node = node.left;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node = node.left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (comparator.compare(node.item, item) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 当前节点值等于待插入值，直接返回即可。</span></span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 当前节点值小于待插入值，则应在右子树中查找。</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == node.right) &#123;</span><br><span class="line">                node.right = <span class="keyword">new</span> Node&lt;&gt;(item);</span><br><span class="line">                node.right.parent = node;</span><br><span class="line">                node = node.right;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node = node.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问该节点，就需要将该节点进行伸展。</span></span><br><span class="line">    <span class="comment">// 伸展到null，需要调整 root 指向。</span></span><br><span class="line">    splay(node, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">this</span>.root = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>伸展树中删除指定元素</p>
<p>删除操作采用了比较高明的技巧。具体删除操作步骤如下：</p>
<ol>
<li>查找该元素，如果存在则将其伸展至根节点，否则直接返回。</li>
<li>删除该节点后，将剩余左右两棵子树。如果一方为空，则指定另一方为根节点即可。</li>
<li>两方均不为空，找到左子树中具有最大元素的节点并将其旋转至根节点，那么可想而知：此时左子树的右儿子为空，直接将右子树置于此位置即可。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(E item)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 查找该元素，如果存在则会通过伸展将其置于根结点，否则直接返回即可。</span></span><br><span class="line">    <span class="keyword">if</span> (contains(item) == <span class="keyword">false</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 至少一方为空。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == <span class="keyword">this</span>.root.left &amp;&amp; <span class="keyword">null</span> == <span class="keyword">this</span>.root.right) &#123;</span><br><span class="line">        <span class="keyword">this</span>.root = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == <span class="keyword">this</span>.root.left) &#123;</span><br><span class="line">        <span class="keyword">this</span>.root = <span class="keyword">this</span>.root.right;</span><br><span class="line">        <span class="keyword">this</span>.root.parent = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == <span class="keyword">this</span>.root.right) &#123;</span><br><span class="line">        <span class="keyword">this</span>.root = <span class="keyword">this</span>.root.left;</span><br><span class="line">        <span class="keyword">this</span>.root.parent = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左右子树均不为空。</span></span><br><span class="line">    <span class="comment">// 获取左子树中最大节点，亦即当前根节点的前驱节点。</span></span><br><span class="line">    Node&lt;E&gt; pre = getMaxTree(<span class="keyword">this</span>.root.left);</span><br><span class="line">    pre.parent = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 置前驱节点的右儿子为当前根节点的右儿子。</span></span><br><span class="line">    pre.right = <span class="keyword">this</span>.root.right;</span><br><span class="line">    pre.right.parent = pre;</span><br><span class="line">    <span class="comment">// 调整root指向。</span></span><br><span class="line">    <span class="keyword">this</span>.root = pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>上面所示代码为自底向上实现伸展树，另外还可自顶向下实现伸展树。大致做法为：从根节点向叶子节点搜索过程中，依次构造三棵树：<code>L</code> 小于当前树中节点所构成的树，<code>X</code> 当前节点所在树，<code>R</code> 大于当前树中节点所构成的树。最后通过一定规则合并这三棵树，从而使得访问节点成为伸展树的根结点。</p>
<p>具体做法不再详述，该种方法相比于自底向上实现伸展树而言，优点就是无需存储父节点信息。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-斐波那契堆</title>
    <url>/2020/06/15/dataStructure/dataStructure-fibonacciheap/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>斐波那契堆</strong> 属于一种构建极为精妙的堆。它由二项队列改造而成，并将懒惰合并及左式堆的 <code>decreaseKey()</code> 实现方法融入其中，最终造就除删除操作外的所有操作的平均时间复杂度为 $O(1)$。</p>
<a id="more"></a>

<p>其结构图大致如下：</p>
<p><img src="/2020/06/15/dataStructure/dataStructure-fibonacciheap/image2.png" alt="图一：斐波那契堆"></p>
<p>斐波那契堆是具有堆序结构的有根树的集合，该集合中允许具有相同高度的有根树同时存在。该有根树是一棵具有一定限制的树，而正是该种限制，使得有根树中节点数量 $N$ 与根结点的孩子节点数量 $R$ 间具有如下关系： $R = O(log^N)$ ，该关系保证了斐波那契堆之上所有操作的平均时间复杂度。</p>
<blockquote>
<ul>
<li>懒惰合并及左式堆的 <code>decreaseKey()</code> 实现方法见之前文章。</li>
<li>斐波那契堆理论上具有良好的性能，但是由于其编程复杂性及时间复杂度的常数因子过大，使得其并不常用。</li>
</ul>
</blockquote>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>斐波那契堆中节点结构极其复杂，涉及四个节点引用，这也使得其编程较为复杂。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FibonacciHeap</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 节点结构</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">// 具体元素</span></span><br><span class="line">        E item;</span><br><span class="line">        <span class="comment">// 度(当前节点的孩子数目)</span></span><br><span class="line">        <span class="keyword">int</span> degree;</span><br><span class="line">        <span class="comment">// 自上次成为另一个节点的孩子以来，是否失去过孩子</span></span><br><span class="line">        <span class="comment">// 基于此字段对有根树施以限制。</span></span><br><span class="line">        <span class="keyword">boolean</span> mark;</span><br><span class="line">        <span class="comment">// 父亲节点</span></span><br><span class="line">        Node&lt;E&gt; parent;</span><br><span class="line">        <span class="comment">// 某一个孩子节点</span></span><br><span class="line">        Node&lt;E&gt; child;</span><br><span class="line">        <span class="comment">// 左兄弟</span></span><br><span class="line">        Node&lt;E&gt; left;</span><br><span class="line">        <span class="comment">// 右兄弟</span></span><br><span class="line">        Node&lt;E&gt; right;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E item)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.item = item;</span><br><span class="line">            <span class="keyword">this</span>.degree = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">this</span>.mark = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">this</span>.parent = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.child = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.left = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.right = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 指向斐波那契堆最小节点,用以访问整个斐波那契堆</span></span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; min;</span><br><span class="line">    <span class="comment">// 堆中节点个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> currentSize;</span><br><span class="line">    <span class="comment">// 比较函数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> E&gt; comparator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="辅助方法"><a href="#辅助方法" class="headerlink" title="辅助方法"></a>辅助方法</h3><ul>
<li><p>合并两个环形链表</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unionLinked</span><span class="params">(Node&lt;E&gt; e1, Node&lt;E&gt; e2)</span> </span>&#123;</span><br><span class="line">    e1.right.left = e2.left;</span><br><span class="line">    e2.left.right = e1.right;</span><br><span class="line">    e1.right = e2;</span><br><span class="line">    e2.left = e1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>从环形链表中剔除指定节点 (当前节点非环形链表中最后一个节点)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteLinkedNode</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">    node.left.right = node.right;</span><br><span class="line">    node.right.left = node.left;</span><br><span class="line">    node.left = <span class="keyword">null</span>;</span><br><span class="line">    node.right = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>向指定环形链表中添加指定节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addLinkedNode</span><span class="params">(Node&lt;E&gt; node, Node&lt;E&gt; root)</span> </span>&#123;</span><br><span class="line">    node.left = root.left;</span><br><span class="line">    node.right = root;</span><br><span class="line">    root.left = node;</span><br><span class="line">    node.left.right = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>链接两棵有根树，将根值小者作为根值大者的孩子，并返回最终结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;E&gt; <span class="title">linkTree</span><span class="params">(Node&lt;E&gt; e1, Node&lt;E&gt; e2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 保证e1为根值小者，e2为根值大者。</span></span><br><span class="line">    <span class="keyword">if</span> (comparator.compare(e1.item, e2.item) &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> linkTree(e2, e1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果e1孩子节点为空，则需调整以指向e2。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == e1.child) &#123;</span><br><span class="line">        e2.left = e2;</span><br><span class="line">        e2.right = e2;</span><br><span class="line">        e1.child = e2;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        addLinkedNode(e2, e1.child);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新其他信息</span></span><br><span class="line">    <span class="comment">// 按照上述mark定义，此处应当置为false。</span></span><br><span class="line">    e2.parent = e1;</span><br><span class="line">    e2.mark = <span class="keyword">false</span>;</span><br><span class="line">    e1.degree++;</span><br><span class="line">    <span class="keyword">return</span> e1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>根链表有根树合并</p>
<p>根链表指代 <code>min</code> 字段指向的那个环形链表。</p>
<p>该部分做法与懒惰二项队列合并相同高度的二项树做法类似。具体步骤如下：</p>
<ol>
<li>构建一个集合，用于存放含有不同度数的有根树。</li>
<li>每次从环形链表中取出一棵有根树，如果集合中存在相同度数的有根树则合并，否则直接将其置于集合中即可。</li>
<li>根据集合，构建出一个环形链表，将 <code>min</code> 字段指向最小节点即可。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 估计有根树的最大度数。</span></span><br><span class="line">    <span class="keyword">int</span> rootNum = (<span class="keyword">int</span>)Math.floor(Math.log(<span class="keyword">this</span>.currentSize) / Math.log(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化一个存放相同度数有根树集合。</span></span><br><span class="line">    Node&lt;E&gt;[] trees = <span class="keyword">new</span> Node[rootNum];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每次从根链表中提取一个节点，将其置于有根树集合中。</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        Node&lt;E&gt; node1 = <span class="keyword">this</span>.min.right;</span><br><span class="line">        <span class="keyword">if</span> (node1 == <span class="keyword">this</span>.min) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        deleteLinkedNode(node1);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> degree = node1.degree;</span><br><span class="line">        <span class="comment">// 如果链表集当前度数位置不为空，表明需进行合并。</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">null</span> != trees[degree]) &#123;</span><br><span class="line">            Node&lt;E&gt; node2 = trees[degree];</span><br><span class="line">            node1 = linkTree(node1, node2);</span><br><span class="line">            trees[degree] = <span class="keyword">null</span>;</span><br><span class="line">            degree++;</span><br><span class="line">        &#125;</span><br><span class="line">        trees[degree] = node1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将有根树集合中的树恢复为根链表，并更新min字段。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; trees.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == trees[i]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == <span class="keyword">this</span>.min) &#123;</span><br><span class="line">            <span class="keyword">this</span>.min = trees[i];</span><br><span class="line">            <span class="keyword">this</span>.min.left = <span class="keyword">this</span>.min;</span><br><span class="line">            <span class="keyword">this</span>.min.right = <span class="keyword">this</span>.min;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            addLinkedNode(trees[i], <span class="keyword">this</span>.min);</span><br><span class="line">            <span class="keyword">this</span>.min = comparator.compare(<span class="keyword">this</span>.min.item, trees[i].item) &gt; <span class="number">0</span> ? trees[i] : <span class="keyword">this</span>.min;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>相关定理证明得到：斐波那契堆中有根树的最大度数 $D$ 与堆中节点数量 $N$ 之间具有如下关系：$D \leq \lfloor log_{\phi}^N \rfloor, \phi = (1 + \sqrt{5}) / 2 \approx 1.618$。</p>
</blockquote>
</li>
<li><p>切除当前节点与父节点间关系，并将当前节点置于根链表之中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cut</span><span class="params">(Node&lt;E&gt; node, Node&lt;E&gt; parent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前节点为父节点唯一节点，则需置空父节点的孩子节点指向，否则将该节点从父节点的孩子节点所在环形链表中删除即可。</span></span><br><span class="line">    <span class="keyword">if</span> (node.right == node) &#123;</span><br><span class="line">        parent.child = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        deleteLinkedNode(node);</span><br><span class="line">    &#125;</span><br><span class="line">    parent.degree--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将当前节点置于根链表之中。</span></span><br><span class="line">    <span class="comment">// 按照上述mark定义，此处应当置为false。</span></span><br><span class="line">    addLinkedNode(node, <span class="keyword">this</span>.min);</span><br><span class="line">    node.parent = <span class="keyword">null</span>;</span><br><span class="line">    node.mark = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>级联切除</p>
<p>通过 <code>mark</code> 字段判断是否需要及时将当前节点置于根链表之中，以保证有根树中节点数量 $N$ 与根结点的孩子节点数量 $R$ 之间的关系。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cascadingCut</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">    Node&lt;E&gt; parent = node.parent;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != parent) &#123;</span><br><span class="line">        <span class="comment">// 如果当前节点为非根节点，且为第二次失去儿子节点，则应当将其与父节点断开，置于根链表之中。</span></span><br><span class="line">        <span class="keyword">if</span> (node.mark) &#123;</span><br><span class="line">            cut(node, parent);</span><br><span class="line">            cascadingCut(parent);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 那么这便是首次失去儿子节点，应当将mark置为true。</span></span><br><span class="line">            node.mark = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FibonacciHeap</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><ul>
<li><p>查询最小元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span> == <span class="keyword">this</span>.min ? <span class="keyword">null</span> : <span class="keyword">this</span>.min.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="操纵"><a href="#操纵" class="headerlink" title="操纵"></a>操纵</h3></li>
<li><p>斐波那契堆中添加元素</p>
<p>直接将节点置于根链表之中即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(E item)</span> </span>&#123;</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;&gt;(item);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == <span class="keyword">this</span>.min) &#123;</span><br><span class="line">        <span class="comment">// 将当前节点构成一个双向链表</span></span><br><span class="line">        node.left = node;</span><br><span class="line">        node.right = node;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置最小节点指向</span></span><br><span class="line">        <span class="keyword">this</span>.min = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 将当前节点插入到根链表之中</span></span><br><span class="line">        addLinkedNode(node, <span class="keyword">this</span>.min);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前节点比最小节点小，则需更新</span></span><br><span class="line">        <span class="keyword">this</span>.min = comparator.compare(<span class="keyword">this</span>.min.item, node.item) &lt; <span class="number">0</span> ? <span class="keyword">this</span>.min : node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.currentSize++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>斐波那契堆合并</p>
<p>直接将两者根链表合并即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(FibonacciHeap&lt;E&gt; fibonacciHeap)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 待合并堆为空，或者待合并堆就是当前堆，直接返回即可</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == fibonacciHeap.min || fibonacciHeap == <span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前堆为空，则直接将待合并堆赋值给当前堆即可</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == <span class="keyword">this</span>.min) &#123;</span><br><span class="line">        <span class="keyword">this</span>.min = fibonacciHeap.min;</span><br><span class="line">        <span class="keyword">this</span>.currentSize = fibonacciHeap.currentSize;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二者皆不为空，先合并根链表，然后更新最小节点</span></span><br><span class="line">    <span class="keyword">this</span>.min = unionLinked(<span class="keyword">this</span>.min, fibonacciHeap.min);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.min = comparator.compare(<span class="keyword">this</span>.min.item, fibonacciHeap.min.item) &gt; <span class="number">0</span> ? fibonacciHeap.min : <span class="keyword">this</span>.min;</span><br><span class="line">    <span class="keyword">this</span>.currentSize = <span class="keyword">this</span>.currentSize + fibonacciHeap.currentSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>斐波那契堆中指定节点降低元素值</p>
<p>具体实现与左式堆中  <code>decreaseKey()</code> 操作实现类似。如果指定节点降低元素值后当前有根树不满足堆序性质，则将当前节点所在子树置于根链表之中，同时调整当前有根树。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decreaseKey</span><span class="params">(Node&lt;E&gt; node, E item)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果待赋值大于当前节点值，直接返回即可。</span></span><br><span class="line">    <span class="keyword">if</span> (comparator.compare(node.item, item) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node.item = item;</span><br><span class="line"></span><br><span class="line">    Node&lt;E&gt; parent = node.parent;</span><br><span class="line">    <span class="comment">// 当前节点父节点不为空，表明非有根树的根结点。另外如果减值后值小于父节点值，则需要进行调整以保证堆序</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != parent &amp;&amp; comparator.compare(node.item, parent.item) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 将当前节点从父节点中清除，并置于根链表之中。</span></span><br><span class="line">        cut(node, parent);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 级联切除</span></span><br><span class="line">        cascadingCut(parent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 减值后的值小于最小节点值，则应当更新最小节点。</span></span><br><span class="line">    <span class="keyword">if</span> (comparator.compare(node.item, <span class="keyword">this</span>.min.item) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.min = node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>斐波那契堆中删除最小节点</p>
<p>删除最小节点后，可能根链表中有根树过多，此时需要进行一次集中合并。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">deleteMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前堆为空，直接返回空即可。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == <span class="keyword">this</span>.min) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node&lt;E&gt; deleteNode = <span class="keyword">this</span>.min;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 待删除节点存在孩子节点，则将其置于当前堆的根链表之中</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != deleteNode.child) &#123;</span><br><span class="line">        Node&lt;E&gt; tmp = deleteNode.child;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">null</span> != tmp) &#123;</span><br><span class="line">            tmp.parent = <span class="keyword">null</span>;</span><br><span class="line">            tmp = tmp.right == deleteNode.child ? <span class="keyword">null</span> : tmp.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.min = unionLinked(<span class="keyword">this</span>.min, deleteNode.child);</span><br><span class="line">        deleteNode.child = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从当前堆中移除该节点</span></span><br><span class="line">    <span class="keyword">if</span> (deleteNode.right == deleteNode) &#123;</span><br><span class="line">        <span class="comment">// 堆中仅有这一个节点，移除后置空最小节点</span></span><br><span class="line">        <span class="keyword">this</span>.min = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 这里更新最小节点，并指向待删除节点的右兄弟。此时最小节点指向不需要一定正确，后续会进行union操作。</span></span><br><span class="line">        <span class="keyword">this</span>.min = deleteNode.right;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从根链表中删除最小节点</span></span><br><span class="line">        deleteLinkedNode(deleteNode);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除最小节点使得根链表中节点过多，因此需要整理，顺便找到最小节点。</span></span><br><span class="line">        union();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.currentSize--;</span><br><span class="line">    <span class="keyword">return</span> deleteNode.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>斐波那契堆中删除指定节点</p>
<p>具体操作可通过上面两个操作加以实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">    decreaseKey(node, <span class="keyword">this</span>.min.item);</span><br><span class="line">    <span class="keyword">this</span>.min = node;</span><br><span class="line">    deleteMin();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-并查集</title>
    <url>/2020/06/07/dataStructure/dataStructure-unionfind/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>并查集</strong> 是一种基于双亲表示法表示的森林。它以一棵树表示一个集合，进而处理不相交集合的合并、查询问题。</p>
<a id="more"></a>

<p>其结构图大致如下：</p>
<p><img src="/2020/06/07/dataStructure/dataStructure-unionfind/v2-3bf6c1a6ecf87fa93f4dbab2012446c7_r.jpg" alt="图一：并查集"></p>
<p>针对并查集中的合并、查询操作有多种优化手段，我们在此提前介绍，并且仅展示优化后的代码。</p>
<ul>
<li><p>针对合并操作的优化</p>
<ul>
<li>按大小求并：总让含有较少元素的树成为含有较多元素的树的子树。</li>
<li>按高度求并：总让高度较低的树成为高度较高的树的子树。</li>
</ul>
</li>
<li><p>针对查询操作的优化</p>
<ul>
<li>路径压缩：将查找点到根结点的路径上所有结点的父节点直接指定为根结点。</li>
</ul>
</li>
<li><p>综合合并、查询优化</p>
<p>按大小求并与路径压缩二者可同时实现，而按高度求并与路径压缩并不能同时实现，原因在于：路径压缩会破坏树的高度。由于此时节点存储的高度信息实际上为预估高度，故而称此时的按高度求并为按秩求并。</p>
<p>实际中大多数并查集都是基于按秩求并与路径压缩实现的。</p>
</li>
</ul>
<blockquote>
<p>经优化后，并查集各种操作的平均时间复杂度为 $O(1)$，证明过程十分麻烦，故不赘述。</p>
</blockquote>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>如上所述，并查集基于双亲表示法实现，故而使用数组最为合适。另外，本文仅考虑位置间合并、查询操作，而不考虑元素间合并、查询操作，毕竟通过散列表可将后者转换为前者。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 节点结构</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 父节点</span></span><br><span class="line">        <span class="keyword">int</span> parent;</span><br><span class="line">        <span class="comment">// 秩(预估高度)</span></span><br><span class="line">        <span class="keyword">int</span> rank;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 节点集</span></span><br><span class="line">    <span class="keyword">private</span> Node[] nodes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>各个位置自成一棵树，并使用根结点位置标识这一棵树。另外根据当前节点的父节点是否就是它自己，即可判断当前节点是否为所在树的根节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    nodes = <span class="keyword">new</span> Node[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        nodes[i].parent = i;</span><br><span class="line">        nodes[i].rank = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 表明为根节点，返回标识</span></span><br><span class="line">    <span class="keyword">if</span> (index == <span class="keyword">this</span>.nodes[index].parent) &#123;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 路径压缩</span></span><br><span class="line">    <span class="keyword">int</span> root = find(<span class="keyword">this</span>.nodes[index].parent);</span><br><span class="line">    <span class="keyword">this</span>.nodes[index].parent = root;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> index1, <span class="keyword">int</span> index2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> root1 = find(index1);</span><br><span class="line">    <span class="keyword">int</span> root2 = find(index2);</span><br><span class="line">    <span class="comment">// 如果二者具有相同的树标识，表明二者是在同一棵树中，无需合并。</span></span><br><span class="line">    <span class="keyword">if</span> (root1 == root2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按秩求并。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.nodes[root1].rank &lt; <span class="keyword">this</span>.nodes[root2].rank) &#123;</span><br><span class="line">        <span class="keyword">this</span>.nodes[root1].parent = root2;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.nodes[root1].rank &lt; <span class="keyword">this</span>.nodes[root2].rank) &#123;</span><br><span class="line">        <span class="keyword">this</span>.nodes[root2].parent = root1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.nodes[root1].parent = root2;</span><br><span class="line">        <span class="keyword">this</span>.nodes[root1].rank++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-平衡二叉树</title>
    <url>/2020/06/05/dataStructure/dataStructure-avl/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>AVL (平衡二叉树)</strong> 是一种自平衡的二叉查找树。该平衡条件为：对于每个节点而言，左右子树的高度差不超过 1。</p>
<a id="more"></a>

<p>其结构图大致如下：</p>
<p><img src="/2020/06/05/dataStructure/dataStructure-avl/1115031-70d8f9c2f0dd35aa.png" alt="图一：平衡二叉树"></p>
<p>平衡二叉树所涉操作的代码实现与二叉查找树基本相同，但是由于插入、删除操作可能破坏平衡条件，故而这两个操作需要一定额外代码以恢复平衡。为精简篇幅，本文仅展示插入、删除操作的代码实现。</p>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AVL</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 节点结构</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">// 具体元素</span></span><br><span class="line">        E item;</span><br><span class="line">        <span class="comment">// 左儿子</span></span><br><span class="line">        Node&lt;E&gt; left;</span><br><span class="line">        <span class="comment">// 右儿子</span></span><br><span class="line">        Node&lt;E&gt; right;</span><br><span class="line">        <span class="comment">// 当前子树的高度</span></span><br><span class="line">        <span class="keyword">int</span> height;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E item, Node&lt;E&gt; left, Node&lt;E&gt; right, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.item = item;</span><br><span class="line">            <span class="keyword">this</span>.left = left;</span><br><span class="line">            <span class="keyword">this</span>.right = right;</span><br><span class="line">            <span class="keyword">this</span>.height = height;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 比较函数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> E&gt; comparator;</span><br><span class="line">    <span class="comment">// 根节点</span></span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="辅助方法"><a href="#辅助方法" class="headerlink" title="辅助方法"></a>辅助方法</h3><ul>
<li><p>获取节点高度</p>
<p>空节点高度指定为 -1，方便后面编码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span> == node ? -<span class="number">1</span> : node.height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>调整节点高度</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reHeight</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == node) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    node.height = Math.max(height(node.left), height(node.right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>当前子树中查找最小元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">getMinTree</span><span class="params">(Node&lt;E&gt; root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前子树为空，直接返回空节点即可。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == root.left) &#123;</span><br><span class="line">        <span class="comment">// 当前子树根节点的左儿子为空，表明这是最左节点，此一定为最小元素，故直接返回之。</span></span><br><span class="line">        <span class="keyword">return</span> root.item;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 当前子树根节点的左儿子不为空，则在左子树中查找最小元素。</span></span><br><span class="line">        <span class="keyword">return</span> getMinTree(root.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>当前子树中查找最大元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">getMaxTree</span><span class="params">(Node&lt;E&gt; root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前子树为空，直接返回空节点即可。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == root.right) &#123;</span><br><span class="line">        <span class="comment">// 当前子树根节点的右儿子为空，表明这是最右节点，此一定为最大元素，故直接返回之。</span></span><br><span class="line">        <span class="keyword">return</span> root.item;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 当前子树根节点的右儿子不为空，则在右子树中查找最大元素。</span></span><br><span class="line">        <span class="keyword">return</span> getMaxTree(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>调整操作</p>
<p>向树中插入元素时，从插入点到根节点的路径上的所有节点的平衡条件都有可能被破坏，因为只有它们的子树可能发生变化。</p>
<p>从插入点沿该路径上行到根节点的过程中，我们称第一个平衡条件被破坏的节点为 $\alpha$ 。实践证明：通过调整 $\alpha$， 不仅可使得 $\alpha$ 满足平衡条件，同时可保证该路径上的其他节点也都满足平衡条件。接下来我们将详细讲述如何调整？</p>
<p>由平衡二叉树定义可知，平衡条件被破坏意指 $\alpha$ 的左右子树高度差为 2。具体可分为两种情况，如图二所示 ( $K2$ 指代 $\alpha$，较高子树高度比较低子树高度大 2 )：</p>
<p><img src="/2020/06/05/dataStructure/dataStructure-avl/image-20200604211827699.png" alt="图二：平衡条件被破坏的两种情况"></p>
<p>依据上图无法实施调整，因此可进一步细化为下图 ( $K2$ 指代 $\alpha$，两个较低子树具有相同高度，较高子树高度比较低子树高度大 1 )：</p>
<p><img src="/2020/06/05/dataStructure/dataStructure-avl/image-20200604211850103.png" alt="图三：平衡条件被破坏的四种情况"></p>
<p>该图从左到右四种情况，我们依次称之为：对 $\alpha$ 的左儿子的左子树进行一次插入 (LL)、对 $\alpha$ 的左儿子的右子树进行一次插入 (LR)、对 $\alpha$ 的右儿子的左子树进行一次插入 (RL)、对 $\alpha$ 的右儿子的右子树进行一次插入 (RR)。</p>
<p>情况一、四可通过对树的一次 <em>单旋转</em> 而完成调整，情况二、三则需要通过稍微复杂的 <em>双旋转</em> 完成调整。</p>
<p><strong>单旋转：</strong></p>
<ul>
<li><p>LL</p>
<p>调整方法如下：</p>
<p><img src="/2020/06/05/dataStructure/dataStructure-avl/image-20200604212141073.png" alt="图四：LL调整"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;E&gt; <span class="title">LL</span><span class="params">(Node&lt;E&gt; root)</span> </span>&#123;</span><br><span class="line">    Node&lt;E&gt; k1 = root.left;</span><br><span class="line">    Node&lt;E&gt; k2 = root;</span><br><span class="line">    k2.left = k1.right;</span><br><span class="line">    k1.right = k2;</span><br><span class="line">        reHeight(k1);</span><br><span class="line">    reHeight(k2);</span><br><span class="line">        <span class="keyword">return</span> k1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>RR</p>
<p>调整方法如下：</p>
<p><img src="/2020/06/05/dataStructure/dataStructure-avl/image-20200604212425415.png" alt="图五：RR调整"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;E&gt; <span class="title">RR</span><span class="params">(Node&lt;E&gt; root)</span> </span>&#123;</span><br><span class="line">    Node&lt;E&gt; k1 = root.right;</span><br><span class="line">    Node&lt;E&gt; k2 = root;</span><br><span class="line">    k2.right = k1.left;</span><br><span class="line">    k1.left = k2;</span><br><span class="line">    reHeight(k1);</span><br><span class="line">    reHeight(k2);</span><br><span class="line">    <span class="keyword">return</span> k1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>双旋转：</strong></p>
<p>依据图三无法针对情况二、三进行调整，故而对情况二、三进一步细化：</p>
<p>  <img src="/2020/06/05/dataStructure/dataStructure-avl/image-20200604214811255.png" alt="图六：细化LR与RL"></p>
<ul>
<li><p>LR</p>
<p>调整方法如下：</p>
<p><img src="/2020/06/05/dataStructure/dataStructure-avl/image-20200605095818357.png" alt="图七：LR调整"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;E&gt; <span class="title">LR</span><span class="params">(Node&lt;E&gt; root)</span> </span>&#123;</span><br><span class="line">    root.left = RR(root.left);</span><br><span class="line">    root = LL(root);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>RL</p>
<p>调整方法如下：</p>
<p><img src="/2020/06/05/dataStructure/dataStructure-avl/image-20200605100627457.png" alt="图八：RL调整"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;E&gt; <span class="title">RL</span><span class="params">(Node&lt;E&gt; root)</span> </span>&#123;</span><br><span class="line">    root.right = LL(root.right);</span><br><span class="line">    root = RR(root);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>细化依据：平衡条件被破坏意指 $\alpha$ 的左右子树高度差为 2。那么高度较高的子树一定可以提取出一个儿子节点和一个孙子节点。</li>
<li>我们知道：插入元素最多可使得子树高度增加一。故而原先保持平衡条件的子树高度比平衡条件被破坏后的子树高度小一。另外观察四种情况的恢复平衡图，可以发现恢复平衡后子树高度比平衡条件被破坏后子树高度小一。综合二者可得到如下结论：原先保持平衡条件的子树高度与恢复平衡后子树高度相同。既然相同，从 $\alpha$ 上行到根节点的路径上的所有节点的平衡条件自然无需再做调整。</li>
</ul>
</blockquote>
</li>
</ul>
</li>
<li><p>当前子树中插入元素，并返回插入元素后的该子树</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;E&gt; <span class="title">addTree</span><span class="params">(Node&lt;E&gt; root, E item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == root) &#123;</span><br><span class="line">        <span class="comment">// 向空树中插入元素，直接返回该元素即可。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Node&lt;&gt;(item, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (comparator.compare(root.item, item) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 当前子树根节点值大于指定元素，表明应当插于左子树之中。</span></span><br><span class="line">        root.left = addTree(root.left, item);</span><br><span class="line">        <span class="comment">// 插入可能导致平衡条件被破坏，应当进行适当调整</span></span><br><span class="line">        <span class="keyword">if</span> (height(root.left) - height(root.right) == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (height(root.left.left) &gt; height(root.left.right)) &#123;</span><br><span class="line">                <span class="comment">// 左儿子的左子树高度高于左儿子的右子树，对应情况一。</span></span><br><span class="line">                root = LL(root);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 左儿子的左子树高度低于左儿子的右子树，对应情况二。</span></span><br><span class="line">                root = LR(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (comparator.compare(root.item, item) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 当前子树根节点值小于指定元素，表明应当插于右子树之中。</span></span><br><span class="line">        root.right = addTree(root.right, item);</span><br><span class="line">        <span class="comment">// 插入可能导致平衡条件被破坏，应当进行适当调整</span></span><br><span class="line">        <span class="keyword">if</span> (height(root.right) - height(root.left) == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (height(root.right.right) &gt; height(root.right.left)) &#123;</span><br><span class="line">                <span class="comment">// 右儿子的右子树高度高于右儿子的左子树，对应情况四。</span></span><br><span class="line">                root = RR(root);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 右儿子的右子树高度低于右儿子的左子树，对应情况三。</span></span><br><span class="line">                root = RL(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    reHeight(root);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>当前子树中删除指定元素，并返回删除指定元素后的该子树</p>
<p>删除策略与二叉查找树中采取的策略大致相同。另外，通过将删除操作等价于添加操作，实现借用上述四种情况实施调整以恢复平衡条件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;E&gt; <span class="title">deleteTree</span><span class="params">(Node&lt;E&gt; root, E item)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前子树根节点为空，直接返回空即可。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (comparator.compare(root.item, item) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 当前子树根节点值大于给定元素，则待删除元素一定位于左子树。</span></span><br><span class="line">        root.left = deleteTree(root.left, item);</span><br><span class="line">        <span class="comment">// 删除可能导致平衡条件被破坏，应当进行适当调整</span></span><br><span class="line">        <span class="comment">// 向当前子树的左子树删除一个元素等价于向当前子树的右子树中添加一个元素，因此失衡条件判断应当为当前子树的右子树高度比当前子树的左子树高度大2。</span></span><br><span class="line">        <span class="keyword">if</span> (height(root.right) - height(root.left) == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (height(root.right.right) &gt; height(root.right.left)) &#123;</span><br><span class="line">                <span class="comment">// 右儿子的右子树高度高于右儿子的左子树，对应情况四。</span></span><br><span class="line">                root = RR(root);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 右儿子的右子树高度低于右儿子的左子树，对应情况三。</span></span><br><span class="line">                root = RL(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (comparator.compare(root.item, item) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 当前子树根节点值小于给定元素，则待删除元素一定位于右子树。</span></span><br><span class="line">        root.right = deleteTree(root.right, item);</span><br><span class="line">        <span class="comment">// 删除可能导致平衡条件被破坏，应当进行适当调整</span></span><br><span class="line">        <span class="comment">// 向当前子树的右子树删除一个元素等价于向当前子树的左子树添加一个元素，因此失衡条件判断应当为当前子树的左子树高度比当前子树的右子树高度大2。</span></span><br><span class="line">        <span class="keyword">if</span> (height(root.left) - height(root.right) == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (height(root.left.left) &gt; height(root.left.right)) &#123;</span><br><span class="line">                <span class="comment">// 左儿子的左子树高度高于左儿子的右子树，对应情况一。</span></span><br><span class="line">                root = LL(root);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 左儿子的左子树高度低于左儿子的右子树，对应情况二。</span></span><br><span class="line">                root = LR(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 当前元素就是待删除元素</span></span><br><span class="line">        <span class="comment">// 左右儿子其中一者为空，直接将另一者所在子树作为当前子树，这种操作并不会使得平衡条件被破坏，因此无需调整。</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == root.left) &#123;</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">null</span> == root.right) &#123;</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 删除元素最多使得当前子树高度差增加一。这里采取从高度较高的子树中删除一个元素，即使使得高度差增加一，也不会使当前子树根节点的平衡条件被破坏。</span></span><br><span class="line">            <span class="comment">// 左右儿子节点均不为空。采取与二叉查找树删除操作类似做法，但是有所改进。</span></span><br><span class="line">            <span class="keyword">if</span> (height(root.left) &gt; height(root.right)) &#123;</span><br><span class="line">                <span class="comment">// 当前子树的左子树更高，则找到当前子树左子树的最大值，将其与当前元素交换后，删除当前子树左子树的最大值即可。</span></span><br><span class="line">                root.item = getMaxTree(root.left);</span><br><span class="line">                root.left = deleteTree(root.left, root.item);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 当前子树的右子树更高，则找到当前子树右子树的最小值，将其与当前元素交换后，删除当前子树右子树的最小值即可。</span></span><br><span class="line">                root.item = getMinTree(root.right);</span><br><span class="line">                root.right = deleteTree(root.right, root.item);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    reHeight(root);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AVL</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="操纵"><a href="#操纵" class="headerlink" title="操纵"></a>操纵</h3><ul>
<li><p>树中添加元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.root = addTree(<span class="keyword">this</span>.root, item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>树中删除指定元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(E item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.root = deleteTree(<span class="keyword">this</span>.root, item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-二叉查找树</title>
    <url>/2020/06/04/dataStructure/dataStructure-binarysearchtree/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>二叉查找树</strong> 是一种特殊的二叉树。对于二叉查找树中每个节点 $X$ 而言，它的左子树中各个节点的值均小于 $X$ 的值，它的右子树中各个节点的值均大于 $X$ 的值。中序遍历二叉查找树，将得到一个递增排序的序列。</p>
<a id="more"></a>

<p>其结构图大致如下：</p>
<p><img src="/2020/06/04/dataStructure/dataStructure-binarysearchtree/%E4%BA%8C%E5%8F%89%E6%A0%91%E8%A7%A3%E9%87%8A%E5%9B%BE.png" alt="图一：二叉查找树"></p>
<p>对于一棵含有 $N$ 个节点的二叉树而言，其平均深度为 $log^N$。二叉查找树的各种操作均基于深度实现，故而各种操作的平均时间复杂度为 $O(log^N)$。</p>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>为方便实现，规定树中元素各不相同。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 节点结构</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">// 具体元素</span></span><br><span class="line">        E item;</span><br><span class="line">        <span class="comment">// 左儿子</span></span><br><span class="line">        Node&lt;E&gt; left;</span><br><span class="line">        <span class="comment">// 右儿子</span></span><br><span class="line">        Node&lt;E&gt; right;</span><br><span class="line">        <span class="comment">// 元素计数器，当前子树中的元素个数</span></span><br><span class="line">        <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E item, Node&lt;E&gt; left, Node&lt;E&gt; right, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.item = item;</span><br><span class="line">            <span class="keyword">this</span>.left = left;</span><br><span class="line">            <span class="keyword">this</span>.right = right;</span><br><span class="line">            <span class="keyword">this</span>.size = size;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 比较函数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> E&gt; comparator;</span><br><span class="line">    <span class="comment">// 根节点</span></span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="辅助方法"><a href="#辅助方法" class="headerlink" title="辅助方法"></a>辅助方法</h3><p>树中各种操作往往都需要通过递归实现，二叉查找树的各种操作更是如此。</p>
<ul>
<li><p>获取节点的元素计数器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span> == node ? <span class="number">0</span> : node.size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>调整节点的元素计数器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reSize</span><span class="params">(Node&lt;E&gt; root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == root) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    root.size = size(root.left) + size(root.right) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>当前子树中查找指定元素是否存在</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Boolean <span class="title">containsTree</span><span class="params">(Node&lt;E&gt; root, E item)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果当前子树为空，直接返回false即可。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (comparator.compare(root.item, item) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 当前子树根节点值大于待查元素，表明待查元素应该位于左子树之中。</span></span><br><span class="line">        <span class="keyword">return</span> containsTree(root.left, item);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (comparator.compare(root.item, item) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 等于则直接返回true。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 小于表明待查元素应该位于右子树之中。</span></span><br><span class="line">        <span class="keyword">return</span> containsTree(root.right, item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>当前子树中插入元素，并返回插入元素后的该子树</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;E&gt; <span class="title">addTree</span><span class="params">(Node&lt;E&gt; root, E item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == root) &#123;</span><br><span class="line">        <span class="comment">// 向空树中插入元素，直接返回该节点即可。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Node&lt;&gt;(item, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (comparator.compare(root.item, item) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 当前子树根节点值大于待插入元素，表明应当插于左子树之中。</span></span><br><span class="line">        root.left = addTree(root.left, item);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (comparator.compare(root.item, item) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 当前子树根节点值小于待插入元素，表明应当插于右子树之中。</span></span><br><span class="line">        root.right = addTree(root.right, item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    reSize(root);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>当前子树中查找最小元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">getMinTree</span><span class="params">(Node&lt;E&gt; root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前子树为空，直接返回空节点即可。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == root.left) &#123;</span><br><span class="line">        <span class="comment">// 当前子树根节点的左儿子为空，表明这是最左节点，此一定为最小元素，故直接返回之。</span></span><br><span class="line">        <span class="keyword">return</span> root.item;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 当前子树根节点的左儿子不为空，则在左子树中查找最小元素。</span></span><br><span class="line">        <span class="keyword">return</span> getMinTree(root.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>当前子树中查找最大元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">getMaxTree</span><span class="params">(Node&lt;E&gt; root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前子树为空，直接返回空节点即可。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == root.right) &#123;</span><br><span class="line">        <span class="comment">// 当前子树根节点的右儿子为空，表明这是最右节点，此一定为最大元素，故直接返回之。</span></span><br><span class="line">        <span class="keyword">return</span> root.item;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 当前子树根节点的右儿子不为空，则在右子树中查找最大元素。</span></span><br><span class="line">        <span class="keyword">return</span> getMaxTree(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>当前子树中向下取整</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">getFloorTree</span><span class="params">(Node&lt;E&gt; root, E item)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前子树为空，直接返回空节点即可。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (comparator.compare(root.item, item) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 当前子树根节点值大于给定元素，则表明floor(item)一定位于左子树之中。</span></span><br><span class="line">        <span class="keyword">return</span> getFloorTree(root.left, item);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (comparator.compare(root.item, item) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 当前子树根节点值等于给定元素，直接返回即可。</span></span><br><span class="line">        <span class="keyword">return</span> root.item;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 当前子树根节点值小于给定元素，floor(item)可能就是当前元素，或者位于右子树之中。</span></span><br><span class="line">        E element = getFloorTree(root.right, item);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span> == element ? root.item : element;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>当前子树中向上取整</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">getCeilingTree</span><span class="params">(Node&lt;E&gt; root, E item)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前子树为空，直接返回空节点即可。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (comparator.compare(root.item, item) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 当前子树根节点值大于给定元素，ceiling(item)可能就是当前元素，或者位于左子树之中。</span></span><br><span class="line">        E element = getCeilingTree(root.left, item);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span> == element ? root.item : element;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (comparator.compare(root.item, item) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 当前子树根节点值等于给定元素，直接返回即可。</span></span><br><span class="line">        <span class="keyword">return</span> root.item;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 当前子树根节点值小于给定元素，ceiling(item)一定位于右子树之中。</span></span><br><span class="line">        <span class="keyword">return</span> getCeilingTree(root.right, item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>当前子树中查找第 $k$ 个元素 (k从0开始)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">selectTree</span><span class="params">(Node&lt;E&gt; root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 当前子树为空，直接返回空节点即可。</span></span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">null</span> == root) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">       <span class="keyword">int</span> leftNum = size(root.left);</span><br><span class="line">       <span class="keyword">if</span> (leftNum &gt; k) &#123;</span><br><span class="line">           <span class="comment">// 左子树元素个数大于k，则直接到左子树中查找即可。</span></span><br><span class="line">           <span class="keyword">return</span> selectTree(root.left, k);</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (leftNum == k) &#123;</span><br><span class="line">           <span class="comment">// 第leftNum个元素就是当前子树根节点</span></span><br><span class="line">           <span class="keyword">return</span> root.item;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// 左子树元素个数小于k，则应当到右子树中找寻第(k - leftNum - 1)个元素。</span></span><br><span class="line">           <span class="keyword">return</span> selectTree(root.right, k - leftNum - <span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当前子树中查看指定元素排名</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">rankTree</span><span class="params">(Node&lt;E&gt; root, E item)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根节点为空，表明找不到元素，应当返回一个无穷负数</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == root) &#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> leftNum = size(root.left);</span><br><span class="line">    <span class="keyword">if</span> (comparator.compare(root.item, item) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 当前子树根节点值大于指定元素，则表明指定元素应当位于左子树之中。</span></span><br><span class="line">        <span class="keyword">return</span> rankTree(root.left, item);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (comparator.compare(root.item, item) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 二者相等，表明找寻的就是该节点。而该节点排名就是leftNum。</span></span><br><span class="line">        <span class="keyword">return</span> leftNum;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 当前子树根节点值小于指定元素，应该在右子树中查找该元素。并且该元素排名应当为右子树中排名 + leftNum + 1。</span></span><br><span class="line">        <span class="keyword">return</span> leftNum + <span class="number">1</span> + rankTree(root.right, item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>当前子树中删除最小元素，并返回删除最小元素后的该子树</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;E&gt; <span class="title">deleteMinTree</span><span class="params">(Node&lt;E&gt; root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前子树为空，直接返回空节点即可。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == root.left) &#123;</span><br><span class="line">        <span class="comment">// 当前子树根节点的左儿子为空，表明这是最左节点。删除该节点后，直接以右子树作为当前子树即可。</span></span><br><span class="line">        root = root.right;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 当前子树根节点的左儿子不为空，则在左子树中删除最小值。</span></span><br><span class="line">        root.left = deleteMinTree(root.left);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    reSize(root);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>当前子树中删除最大元素，并返回删除最大元素后的该子树</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;E&gt; <span class="title">deleteMaxTree</span><span class="params">(Node&lt;E&gt; root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前子树为空，直接返回空节点即可。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == root.right) &#123;</span><br><span class="line">        <span class="comment">// 当前子树根节点的右儿子为空，表明这是最右节点。删除该节点后，直接以左子树作为当前子树即可。</span></span><br><span class="line">        root = root.left;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 当前子树根节点的右儿子不为空，则在右子树中删除最大值。</span></span><br><span class="line">        root.right = deleteMaxTree(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    reSize(root);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>当前子树中删除指定元素，并返回删除指定元素后的该子树</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;E&gt; <span class="title">deleteTree</span><span class="params">(Node&lt;E&gt; root, E item)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前子树为空，直接返回空即可。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (comparator.compare(root.item, item) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 当前子树根节点值大于给定元素，则待删除元素一定位于左子树。</span></span><br><span class="line">        root.left = deleteTree(root.left, item);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (comparator.compare(root.item, item) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 当前子树根节点值小于给定元素，则待删除元素一定位于右子树。</span></span><br><span class="line">        root.right = deleteTree(root.right, item);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 二者相等，表明当前子树根节点就是待删除节点。</span></span><br><span class="line">        <span class="comment">// 如果左右儿子有一者为空，则直接以另一者表示的子树作为当前子树即可。</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == root.right) &#123;</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">null</span> == root.left) &#123;</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 左右儿子均不为空。为保证删除节点后仍保持有序，将右子树中最小元素赋值给当前子树根节点，然后删除右子树中最小元素即可。</span></span><br><span class="line">            root.item = getMinTree(root.right);</span><br><span class="line">            root.right = deleteMinTree(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    reSize(root);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BinarySearchTree</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><ul>
<li><p>查询指定元素是否存在</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> containsTree(<span class="keyword">this</span>.root, item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>查询最小元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getMinTree(<span class="keyword">this</span>.root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>查询最大元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getMaxTree(<span class="keyword">this</span>.root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>向下取整(查找所有小于等于item中的最大元素)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getFloor</span><span class="params">(E item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getFloorTree(<span class="keyword">this</span>.root, item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>向上取整(查找所有大于等于item中的最小元素)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getCeiling</span><span class="params">(E item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getCeilingTree(<span class="keyword">this</span>.root, item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>查询第 $k$ 个元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">select</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> selectTree(<span class="keyword">this</span>.root, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>查看指定元素是第几个元素(即指定元素排名)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rank</span><span class="params">(E item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> rankTree(<span class="keyword">this</span>.root, item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="操纵"><a href="#操纵" class="headerlink" title="操纵"></a>操纵</h3></li>
<li><p>树中添加元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.root = addTree(<span class="keyword">this</span>.root, item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>树中删除最小元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.root = deleteMinTree(<span class="keyword">this</span>.root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>树中删除最大元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.root = deleteMaxTree(<span class="keyword">this</span>.root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>树中删除指定元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(E item)</span> </span>&#123;</span><br><span class="line">    deleteTree(<span class="keyword">this</span>.root, item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-二叉树</title>
    <url>/2020/06/03/dataStructure/dataStructure-binarytree/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>二叉树</strong> 是一种特殊的树，其中每个节点至多具有两个儿子节点。本文仅探讨 “树” 中最基本的操作——构建和遍历。</p>
<a id="more"></a>

<p>其结构图大致如下：</p>
<p><img src="/2020/06/03/dataStructure/dataStructure-binarytree/%E4%BA%8C%E5%8F%89%E6%A0%91%E8%A7%A3%E9%87%8A%E5%9B%BE.png" alt="图一：二叉树"></p>
<p>本文为 “树” 的第一篇文章，故而在此总结一下有关 “树” 的表示方法。</p>
<ul>
<li><p>双亲表示法</p>
<p>借用一组连续/离散空间来存储 “树” 中节点。在保存节点内容的同时，还保存一个指向双亲节点的指针元素。</p>
<p>应用举例：并查集。</p>
</li>
<li><p>孩子表示法</p>
<p>借用一组连续/离散空间来存储 “树” 中节点。在保存节点内容的同时，还保存若干指向孩子节点的的指针元素。</p>
<p>应用举例：二叉查找树。</p>
</li>
<li><p>孩子兄弟表示法</p>
<p>借用一组连续/离散空间来存储 “树” 中节点。在保存节点内容的同时，还保存有两个指针元素，其中一个指针指向第一个孩子节点，另一个指针指向兄弟节点。</p>
<p>应用举例：二项队列。</p>
</li>
</ul>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>本文使用孩子表示法以表示二叉树。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 节点结构</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">// 具体元素</span></span><br><span class="line">        E item;</span><br><span class="line">        <span class="comment">// 左儿子</span></span><br><span class="line">        Node&lt;E&gt; left;</span><br><span class="line">        <span class="comment">// 右儿子</span></span><br><span class="line">        Node&lt;E&gt; right;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E item, Node&lt;E&gt; left, Node&lt;E&gt; right)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.item = item;</span><br><span class="line">            <span class="keyword">this</span>.left = left;</span><br><span class="line">            <span class="keyword">this</span>.right = right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根节点</span></span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; root;</span><br><span class="line">    <span class="comment">// 索引(用于构建二叉树)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="辅助方法"><a href="#辅助方法" class="headerlink" title="辅助方法"></a>辅助方法</h3><ul>
<li><p>前序遍历构建二叉树</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;E&gt; <span class="title">treePreOrder</span><span class="params">(E[] arr)</span> </span>&#123;</span><br><span class="line">    E element = arr[<span class="keyword">this</span>.index++];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == element) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node&lt;E&gt; root = <span class="keyword">new</span> Node&lt;&gt;(element, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    root.left = treePreOrder(arr);</span><br><span class="line">    root.right = treePreOrder(arr);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>层序遍历构建二叉树</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;E&gt; <span class="title">treeLevelOrder</span><span class="params">(E[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    Node&lt;E&gt; root = <span class="keyword">new</span> Node&lt;&gt;(arr[index++], <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用双端队列模拟队列</span></span><br><span class="line">    ArrayDeque&lt;Node&lt;E&gt;&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    queue.addLast(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (queue.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        Node&lt;E&gt; tmp = queue.pollFirst();</span><br><span class="line">        E left = arr[index++];</span><br><span class="line">        E right = arr[index++];</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != left) &#123;</span><br><span class="line">            tmp.left = <span class="keyword">new</span> Node&lt;&gt;(left, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            queue.addLast(tmp.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != right) &#123;</span><br><span class="line">            tmp.right = <span class="keyword">new</span> Node&lt;&gt;(right, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            queue.addLast(tmp.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>前序遍历二叉树</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">traverseTreePreOrder</span><span class="params">(<span class="keyword">final</span> Node&lt;E&gt; root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == root) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.print(root.item + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    traverseTreePreOrder(root.left);</span><br><span class="line">    traverseTreePreOrder(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>中序遍历二叉树</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">traverseTreeInOrder</span><span class="params">(<span class="keyword">final</span> Node&lt;E&gt; root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == root) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    traverseTreeInOrder(root.left);</span><br><span class="line">    System.out.print(root.item + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    traverseTreeInOrder(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>后序遍历二叉树</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">traverseTreePostOrder</span><span class="params">(<span class="keyword">final</span> Node&lt;E&gt; root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == root) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    traverseTreePostOrder(root.left);</span><br><span class="line">    traverseTreePostOrder(root.right);</span><br><span class="line">    System.out.print(root.item + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3></li>
</ul>
<p>基于前序遍历、后序遍历和层序遍历的遍历结果，均可实现构建一棵二叉树。后序遍历顺序为 “左右根”，反向查看后序遍历的遍历结果，其遍历顺序便是 “根右左”，故而其与基于前序遍历的遍历结果构建一棵二叉树类似。</p>
<p>无法基于中序遍历构建一棵二叉树，原因在于：遍历过程中存在 “节点跳跃”。举例如下 (二者具有相同的中序遍历结果)：</p>
<p><img src="/2020/06/03/dataStructure/dataStructure-binarytree/20191003141457557.png" alt="图二：中序遍历构建二叉树冲突"></p>
<blockquote>
<p>实际使用中，基本上也不会以这种方式构建二叉树。通常都是基于插入操作构建二叉树的。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BinaryTree</span><span class="params">(E[] arr, <span class="keyword">int</span> option)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (option == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.root = treePreOrder(arr);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.root = treeLevelOrder(arr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>前中后序遍历的非递归版本都十分难写，但可喜的是，三者具有一种统一的写法，具体见代码。</p>
<ul>
<li><p>前序遍历 (递归)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">traversePreOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.print(<span class="string">&quot;前序遍历（递归）：&quot;</span>);</span><br><span class="line">    traverseTreePreOrder(<span class="keyword">this</span>.root);</span><br><span class="line">    System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>前序遍历 (非递归)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">traversePreOrderStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">this</span>.root;</span><br><span class="line">    <span class="comment">// 使用双端队列模拟栈</span></span><br><span class="line">    ArrayDeque&lt;Node&lt;E&gt;&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    System.out.print(<span class="string">&quot;前序遍历（非递归）：&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> ((<span class="keyword">null</span> != node) || (stack.size() &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">null</span> != node) &#123;</span><br><span class="line">            System.out.print(node.item + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            stack.addLast(node);</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stack.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            node = stack.pollLast();</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>中序遍历 (递归)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">traverseInOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.print(<span class="string">&quot;中序遍历（递归）：&quot;</span>);</span><br><span class="line">    traverseTreeInOrder(<span class="keyword">this</span>.root);</span><br><span class="line">    System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>中序遍历 (非递归)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">traverseInOrderStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">this</span>.root;</span><br><span class="line">    <span class="comment">// 使用双端队列模拟栈</span></span><br><span class="line">    ArrayDeque&lt;Node&lt;E&gt;&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    System.out.print(<span class="string">&quot;中序遍历（非递归）：&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> ((<span class="keyword">null</span> != node) || (stack.size() &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">null</span> != node) &#123;</span><br><span class="line">            stack.addLast(node);</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stack.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            node = stack.pollLast();</span><br><span class="line">            System.out.print(node.item + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>后序遍历 (递归)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">traversePostOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.print(<span class="string">&quot;后序遍历（递归）：&quot;</span>);</span><br><span class="line">    traverseTreePostOrder(<span class="keyword">this</span>.root);</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>后序遍历 (非递归)</p>
<p>后序遍历顺序为 “左右根”，故而只有当左子树和右子树遍历完成后，才可遍历根节点。后序遍历的非递归版本难点在于：判断当前栈顶元素的右子树是否已遍历完成？</p>
<p>可使用一个指针以解决该问题，其中该指针指向上一个遍历过的元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">traversePostOrderStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">this</span>.root;</span><br><span class="line">    <span class="comment">// 记录上一个遍历过的节点</span></span><br><span class="line">    Node&lt;E&gt; pre = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 使用双端队列模拟栈</span></span><br><span class="line">    ArrayDeque&lt;Node&lt;E&gt;&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    System.out.print(<span class="string">&quot;后序遍历（非递归）：&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> ((<span class="keyword">null</span> != node) || (stack.size() &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">null</span> != node) &#123;</span><br><span class="line">            stack.addLast(node);</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stack.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            node = stack.getLast();</span><br><span class="line">            <span class="comment">// 当前节点右子树为空或当前节点的右儿子为上一个遍历过的节点，表明右子树已遍历完成。此时即可遍历当前节点。</span></span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">null</span> == node.right) || (node.right == pre)) &#123;</span><br><span class="line">                System.out.print(node.item + <span class="string">&quot; &quot;</span>);</span><br><span class="line">                stack.pollLast();</span><br><span class="line">                pre = node;</span><br><span class="line">                node = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node = node.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>层序遍历</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">traverseLevelOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == <span class="keyword">this</span>.root) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用双端队列模拟队列</span></span><br><span class="line">    ArrayDeque&lt;Node&lt;E&gt;&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    queue.addLast(<span class="keyword">this</span>.root);</span><br><span class="line"></span><br><span class="line">    System.out.print(<span class="string">&quot;层序遍历：&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (queue.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        Node&lt;E&gt; tmp = queue.pollFirst();</span><br><span class="line">        System.out.print(tmp.item + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != tmp.left) &#123;</span><br><span class="line">            queue.addLast(tmp.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != tmp.right) &#123;</span><br><span class="line">            queue.addLast(tmp.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-散列表</title>
    <url>/2020/05/26/dataStructure/dataStructure-hashtable/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>散列表</strong> 是一种可实现以常数平均时间执行插入、删除、查询的数据结构。它基于散列函数将元素映射到固定空间中的某一位置。</p>
<a id="more"></a>

<p>其结构图大致如下：</p>
<p><img src="/2020/05/26/dataStructure/dataStructure-hashtable/v2-aa2188e188caa7010c3a7b362e766abf_720w.jpg" alt="图一：散列表"></p>
<p>散列表中有两大概念，在此先行解释。</p>
<ul>
<li><p>散列函数</p>
<p>顾名思义，它就是一个函数，形如 $hash(key)$。其中 $key$ 表示元素键值，$hash(key)$ 表示经散列函数计算得到的散列值。</p>
<p>散列函数的选择对于散列表性能具有重大影响。一个好的散列函数，可保证元素均匀分布于散列表之中。</p>
</li>
<li><p>冲突</p>
<p>散列表本质是将无穷元素映射到有穷空间之上。故而一定存在某两个元素键值不同，而具有相同的散列值，此种便称为冲突。</p>
</li>
</ul>
<p>为解决 “冲突发生时如何映射元素” 这一问题，不同的散列表实现给出了不同的策略。我们主要展示基于链地址法实现的散列表，其余实现方法在 <a href="##%E6%89%A9%E5%B1%95">扩展</a> 中简单介绍。</p>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>基于链地址法实现散列表，故而固定数组存储内容为一个链表。另外数组大小应为一个<strong>素数</strong>，这样做有助于元素均匀分布于散列表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashTable</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 默认表长</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_TABLE_SIZE = <span class="number">101</span>;</span><br><span class="line">    <span class="comment">// 基于链地址法的散列表</span></span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;E&gt;[] lls;</span><br><span class="line">    <span class="comment">// 元素数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> currentSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="辅助方法"><a href="#辅助方法" class="headerlink" title="辅助方法"></a>辅助方法</h3><ul>
<li><p>散列函数</p>
<p>借用 $Object.hashCode()$ 加以实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hashVal = e.hashCode() % <span class="keyword">this</span>.lls.length;</span><br><span class="line">    <span class="keyword">return</span> (hashVal + <span class="keyword">this</span>.lls.length) % <span class="keyword">this</span>.lls.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashTable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.lls = <span class="keyword">new</span> LinkedList[HashTable.DEFAULT_TABLE_SIZE];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.lls.length; i++) &#123;</span><br><span class="line">        <span class="keyword">this</span>.lls[i] = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><ul>
<li><p>查询元素是否存在</p>
<p>首先使用散列函数定位到链，然后在该链中查找该元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取待查询链</span></span><br><span class="line">    LinkedList&lt;E&gt; link = <span class="keyword">this</span>.lls[hash(e)];</span><br><span class="line">    <span class="keyword">return</span> link.indexOf(e) != -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="操纵"><a href="#操纵" class="headerlink" title="操纵"></a>操纵</h3></li>
<li><p>散列表中添加元素</p>
<p>首先使用散列函数定位到链，当该元素并不存在于散列表中才插入。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取待插入链</span></span><br><span class="line">    LinkedList&lt;E&gt; link = <span class="keyword">this</span>.lls[hash(e)];</span><br><span class="line">    <span class="keyword">if</span> (link.indexOf(e) == -<span class="number">1</span>) &#123;</span><br><span class="line">        link.addFirst(e);</span><br><span class="line">        <span class="keyword">this</span>.currentSize++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>散列表中删除元素</p>
<p>首先使用散列函数定位到链，当该元素存在与散列表中才删除。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取待删除元素所在链</span></span><br><span class="line">    LinkedList&lt;E&gt; link = <span class="keyword">this</span>.lls[hash(e)];</span><br><span class="line">    <span class="keyword">int</span> index = link.indexOf(e);</span><br><span class="line">    <span class="keyword">if</span> (index != -<span class="number">1</span>) &#123;</span><br><span class="line">        link.remove(index);</span><br><span class="line">        <span class="keyword">this</span>.currentSize--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2></li>
</ul>
<p>在此列举若干常用的散列表实现：</p>
<ul>
<li><p>基于开放定址法的实现</p>
<p>开放定址法下另有多种实现，分别为基于线性探测法的实现、基于平方探测法的实现和基于双散列的实现。</p>
<ul>
<li><p>基于线性探测法的实现</p>
<p>当发生冲突时，依次探测空间 $h_i(x) = (hash(x) + f(i)) \ %\  tableSize$，如果某个空间未使用，则将元素置于该空间之中，停止探测。</p>
<p>此方法的一大问题在于将会导致存在 “一次聚集” ，即空间成块使用。</p>
</li>
<li><p>基于平方探测法的实现</p>
<p>当发生冲突时，依次探测空间 $h_i(x) = (hash(x) + f(i^2)) \ %\  tableSize$，如果某个空间未使用，则将元素置于该空间之中，停止探测。</p>
<p>此方法可解决 “一次聚集”，但会导致 “二次聚集”。</p>
</li>
<li><p>基于双散列的实现</p>
<p>当发生冲突时，依次探测空间 $h_i(x) = (i \times hash_2(x)) \ %\  tableSize$，如果某个空间未使用，则将元素置于该空间之中，停止探测。</p>
<p>如果第二个散列函数选择的好，则散列表性能就好；否则就是灭顶之灾。</p>
</li>
</ul>
</li>
<li><p>再散列</p>
<p>如果散列表中存在元素过多，则创建一个具有原散列表两倍空间的新散列表，并基于新的散列函数将原散列表中元素映射到新散列表之中。此举的时间复杂度为 $O(N)$，由于不是经常发生此种情况，因此实际效果还行。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>散列表</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-二项队列</title>
    <url>/2020/05/25/dataStructure/dataStructure-binomialqueue/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>二项队列</strong> 属于一种构建极为精妙的堆。它不仅具有左式堆的优点（$O(log^N)$ 时间复杂度内实现堆合并），同时具有二叉堆的优点（$O(N)$ 时间复杂度内实现建堆）。</p>
<a id="more"></a>

<p>其结构图大致如下：</p>
<p><img src="/2020/05/25/dataStructure/dataStructure-binomialqueue/500px-Binomial_Trees.png" alt="图一：二项队列"></p>
<p>二项队列主要涉及一个概念和一个定理，在此先行解释。</p>
<ul>
<li><p>二项树 ($B_i$)</p>
<p>高度为 $i$ 的二项树 $B_i$ 构造规则如下：</p>
<ul>
<li>当 $i = 0$ 时，$B_i$ 为一棵单结点树。</li>
<li>当 $i &gt; 0$ 时，$B_i$ 通过将一棵二项树 $B_{i - 1}$ 附接到另一棵二项树 $B_{i - 1}$ 的根上而构成。</li>
</ul>
<p>仔细观察构造规则及上方结构图，我们可得到如下结论：</p>
<ul>
<li>二项树 $B_i$ 由一个带有儿子 $B_0,B_1,\dots,B_{i - 1}$ 的根组成。</li>
<li>二项树 $B_i$ 具有 $2^i$ 个结点。</li>
</ul>
<p>此时可以给出二项队列的具体定义：<strong>二项队列是具有堆序结构的二项树的集合，而且该集合中不存在具有相同高度的两棵二项树</strong>。</p>
</li>
<li><p>含有 $N$ 个结点的二项队列最多含有 $log^N$ 棵二项树。</p>
<p>此定理证明比较简单。</p>
<p>假定一个二项队列为 ${B_0,B_1,\dots,B_k}$，容易得知其含有 $2^0 + 2^1 + \dots + 2^k = 2^{k + 1} - 1$ 个结点。这句话反过来就是定理。</p>
<p>二项队列的操作都是基于二项树而言的，正是由于具有这样的性质，故而其操作的最坏时间复杂度为 $O(log^N)$。</p>
</li>
</ul>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>二项队列结构比较精妙，在此简单说明一下：</p>
<ul>
<li>二项树具有多个儿子结点，因此我们使用孩子兄弟表示法表示之。</li>
<li>为方便相同高度的二项树合并操作，我们逆向存放子二项树。例如：对于二项树 $B_i$ 而言，其根结点的兄弟结点为 $B_{i - 1}$，$B_{i - 1}$ 的兄弟结点为 $B_{i - 2}$，$\dots$ ，$B_{1}$ 的兄弟结点为 $B_{0}$。</li>
<li>我们采用数组从前往后依次存放相应高度的二项树，这样做的优点在于可以快速获取二项队列中的元素个数，同时方便编写二项队列合并操作的代码。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinomialQueue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 孩子兄弟表示法表示一颗二项树</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">// 具体元素</span></span><br><span class="line">        E item;</span><br><span class="line">        <span class="comment">// 孩子结点</span></span><br><span class="line">        Node&lt;E&gt; leftChild;</span><br><span class="line">        <span class="comment">// 兄弟结点</span></span><br><span class="line">        Node&lt;E&gt; nextSibling;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E item, Node&lt;E&gt; leftChild, Node&lt;E&gt; nextSibling)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.item = item;</span><br><span class="line">            <span class="keyword">this</span>.leftChild = leftChild;</span><br><span class="line">            <span class="keyword">this</span>.nextSibling = nextSibling;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 二项队列(使用数组保存二项树的根)</span></span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt;[] trees;</span><br><span class="line">    <span class="comment">// 元素个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> currentSize;</span><br><span class="line">    <span class="comment">// 比较函数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> E&gt; comparator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="辅助方法"><a href="#辅助方法" class="headerlink" title="辅助方法"></a>辅助方法</h3><ul>
<li><p>扩容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">expandTrees</span><span class="params">(<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    Node&lt;E&gt;[] newTrees = <span class="keyword">new</span> Node[length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.trees.length; i++) &#123;</span><br><span class="line">        newTrees[i] = <span class="keyword">this</span>.trees[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.trees = newTrees;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>获取最小元素下标</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findMinIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">    E min = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.trees.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == <span class="keyword">this</span>.trees[i]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == min) &#123;</span><br><span class="line">            min = <span class="keyword">this</span>.trees[i].item;</span><br><span class="line">            index = i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (comparator.compare(min, <span class="keyword">this</span>.trees[i].item) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(min + <span class="string">&quot; &quot;</span> + <span class="keyword">this</span>.trees[i].item);</span><br><span class="line">                min = <span class="keyword">this</span>.trees[i].item;</span><br><span class="line">                index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>合并高度相同的二项树</p>
<p>如上所述，二项树构造具有一定之规。另外二项队列中的二项树同时需要满足堆序性质。综合二者，二项队列中的二项树合成规则为：$B_i$ 通过将根值较小者/较大者的二项树 $B_{i - 1}$ 附接到另一棵二项树 $B_{i - 1}$ 的根上而构成。</p>
<p>此函数实现代码体现了 “逆向存放子二项树” 的好处。如果顺序存放子二项树，我们应当首先找到 <code>t1.leftChild</code> 的最后一个兄弟结点，然后将其兄弟结点的引用指向 <code>t2</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;E&gt; <span class="title">combineTrees</span><span class="params">(Node&lt;E&gt; t1, Node&lt;E&gt; t2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (comparator.compare(t1.item, t2.item) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> combineTrees(t2, t1);</span><br><span class="line">    &#125;</span><br><span class="line">    t2.nextSibling = t1.leftChild;</span><br><span class="line">    t1.leftChild = t2;</span><br><span class="line">    <span class="keyword">return</span> t1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3></li>
<li><p>空初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BinomialQueue</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.trees = <span class="keyword">new</span> Node[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>初始化携带一个元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BinomialQueue</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; comparator, E element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.trees = <span class="keyword">new</span> Node[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">this</span>.trees[<span class="number">0</span>] = <span class="keyword">new</span> Node&lt;&gt;(element, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">this</span>.currentSize = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3></li>
<li><p>查询容量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">capacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; trees.length) - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>查询最小值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = findMinIndex();</span><br><span class="line">    <span class="keyword">return</span> index == -<span class="number">1</span> ? <span class="keyword">null</span> : <span class="keyword">this</span>.trees[index].item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="操纵"><a href="#操纵" class="headerlink" title="操纵"></a>操纵</h3></li>
<li><p>合并两个二项队列</p>
<p>二项队列合并过程类似于数值相加。另外</p>
<p>举例如下：</p>
<p><img src="/2020/05/25/dataStructure/dataStructure-binomialqueue/20131109173216500.jpg" alt="图二：合并二项队列"></p>
<p>现需要将 $H1 = {B_1}$ 和 $H2 = {B_0,B_1,B_2}$ 合并为 $H3$ ，具体合并步骤如下：</p>
<ul>
<li> 对于 $H3$ 中的 $B_0$ 而言，$H1$ 没有而 $H2$ 有，则直接将 $H2$ 中的 $B_0$ 赋值给 $H3$ 的 $B_0$ 即可。</li>
<li> 对于 $H3$ 中的 $B_1$ 而言，$H1$ 和 $H2$ 均有，合并二者得到 “进位” $B_2$。再无多余 $B_1$，故而 $H3$ 的 $B_1$ 为 $null$。</li>
<li>对于 $H3$ 中的 $B_2$ 而言，$H1$ 没有而$H2$ 有，同时存在一个 “进位” $B_2$，合并二者得到 “进位” $B_3$。再无多余 $B_2$，故而 $H3$ 的 $B_2$ 为 $null$。</li>
<li>对于 $H3$ 中的 $B_3$ 而言，$H1$ 和 $H2$ 均无，但是存在一个 “进位” $B_3$，直接将进位$B_3$赋值给$H3$ 的 $B_3$ 即可。</li>
<li>$H1$ 和 $H2$ 无再合并之物，则合并结果为 $H3 = {B_0,B_2,B_3}$。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(BinomialQueue&lt;E&gt; binomialQueue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == binomialQueue) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.currentSize += binomialQueue.currentSize;</span><br><span class="line">    <span class="comment">//空间不足，需要扩容。这是一种扩容方式。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.currentSize &gt; capacity()) &#123;</span><br><span class="line">        <span class="keyword">int</span> maxLength = Math.max(<span class="keyword">this</span>.trees.length, binomialQueue.trees.length);</span><br><span class="line">        expandTrees(maxLength + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存上一次合并结果的“余数”</span></span><br><span class="line">    Node&lt;E&gt; carry = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.trees.length; i++) &#123;</span><br><span class="line">        Node&lt;E&gt; t1 = <span class="keyword">this</span>.trees[i];</span><br><span class="line">        Node&lt;E&gt; t2 = i &lt; binomialQueue.trees.length ? binomialQueue.trees[i] : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> whichCase = t1 == <span class="keyword">null</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">        whichCase += t2 == <span class="keyword">null</span> ? <span class="number">0</span> : <span class="number">2</span>;</span><br><span class="line">        whichCase += carry == <span class="keyword">null</span> ? <span class="number">0</span> : <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (whichCase) &#123;</span><br><span class="line">            <span class="comment">// 表明t2和carry均为null，无需操作</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 表明仅t2不为空，直接赋给this即可</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">this</span>.trees[i] = t2;</span><br><span class="line">                binomialQueue.trees[i] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 表明t1和t2均不为空，合并即可。</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                carry = combineTrees(t1, t2);</span><br><span class="line">                <span class="keyword">this</span>.trees[i] = binomialQueue.trees[i] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 表明仅carry不为空，直接赋给this即可</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                <span class="keyword">this</span>.trees[i] = carry;</span><br><span class="line">                carry = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 表明仅t1和carry不为空，合并即可</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                carry = combineTrees(t1, carry);</span><br><span class="line">                <span class="keyword">this</span>.trees[i] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 表明仅t2和carry不为空，合并即可</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                carry = combineTrees(t2, carry);</span><br><span class="line">                binomialQueue.trees[i] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 表明三者俱在</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">                carry = combineTrees(t2, carry);</span><br><span class="line">                binomialQueue.trees[i] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调整待合并堆相关参数</span></span><br><span class="line">    binomialQueue.currentSize = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>二项队列中添加元素</p>
<p>将待添加元素看做一个二项队列，合并二者即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(E element)</span> </span>&#123;</span><br><span class="line">    BinomialQueue&lt;E&gt; eBinomialQueue = <span class="keyword">new</span> BinomialQueue&lt;&gt;(<span class="keyword">this</span>.comparator, element);</span><br><span class="line">    merge(eBinomialQueue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处我们分析一下为什么可在 $O(N)$ 时间复杂度内实现建堆？也即为什么插入操作的平均时间复杂度为 $O(1)$ ？</p>
<p>通过上面的合并代码，可以发现合并两个二项队列所花费的时间依托于其上的二项树分布。</p>
<ul>
<li><p>如果将仅含一个元素的二项队列与一个含有偶数个元素的二项队列合并，仅需合并到 $B_0$ 即可，故而花费时间为 O(1)。</p>
</li>
<li><p>如果将仅含一个元素的二项队列与含有 $2^k - 1$ 个元素的二项队列合并，由于已有 $B_0,B_1,\dots, B_{k-1}$，所以需一直合并到 $B_k$，故而花费时间为 $O(k)$。</p>
</li>
</ul>
<p>上述两种情况属于运行时间的最好情况和最坏情况。最好情况的发生概率为 $1/2$，最坏情况的发生概率则极低。</p>
<p>假定总共执行插入操作 $N$ 次，可粗略得到：$N/2$ 次插入的运行时间为 $O(1)$，$N / 4$ 次插入的运行时间为 $O(2)$，$\dots$，$N/2^k$ 次插入的运行时间为 $O(k)$。</p>
<p>所有 $N$ 次插入的总运行时间为：$\sum_{i = 1}^k\frac{N \times i}{2^i} &lt; N \times \sum_{i = 1}^\infty\frac{i}{2^i} = 2N$。</p>
<p>故而一次插入操作的平均运行时间为 $2N / N = 2 = O(1)$，所以可在 $O(N)$ 时间复杂度内实现建堆 。</p>
</li>
<li><p>二项队列中删除最小元素</p>
<p>最小元素一定属于某个二项树的根结点。首先从当前二项队列中删除此二项树，然后使用该二项树的子二项树构建一个二项队列，合并此二者即可达到 “从二项队列中删除最小元素” 的目的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">deleteMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 为空则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.currentSize == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> index = findMinIndex();</span><br><span class="line">    E minElement = <span class="keyword">this</span>.trees[index].item;</span><br><span class="line">    Node&lt;E&gt; deletedTree = <span class="keyword">this</span>.trees[index].leftChild;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基于该二项队列的子二项树构建一个二项队列。</span></span><br><span class="line">    BinomialQueue eBinomialQueue = <span class="keyword">new</span> BinomialQueue(<span class="keyword">this</span>.comparator);</span><br><span class="line">    eBinomialQueue.expandTrees(index);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = index - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        eBinomialQueue.trees[i] = deletedTree;</span><br><span class="line">        deletedTree = deletedTree.nextSibling;</span><br><span class="line">        eBinomialQueue.trees[i].nextSibling = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    eBinomialQueue.currentSize += ((<span class="number">1</span> &lt;&lt; index) - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.trees[index] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.currentSize -= (<span class="number">1</span> &lt;&lt; index);</span><br><span class="line"></span><br><span class="line">    merge(eBinomialQueue);</span><br><span class="line">    <span class="keyword">return</span> minElement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2></li>
</ul>
<p>为进一步降低二项队列相关操作的时间复杂度，<em>懒惰二项队列</em> 应运而生，它通过支持懒惰合并使得合并操作的</p>
<p>平均时间复杂度为 $O(1)$，同时保证删除最小元素操作的平均时间复杂度仍为 $O(log^N)$。</p>
<p>由于支持懒惰合并，因此懒惰二项队列的具体定义如下：懒惰二项队列是具有堆序结构的二项树的集合，它允许集合中存在高度相同的两棵二项树。</p>
<p>懒惰合并仅涉及合并操作和删除最小元素操作，因此在此详述二者。</p>
<ul>
<li><p>合并操作</p>
<p>直接将高度相同的二项树放在一起即可。</p>
</li>
<li><p>删除最小元素操作</p>
<p>遍历所有二项树，找到最小元素将其删除。随后我们需要将懒惰二项队列转变为标准的二项队列，即通过合并二项树，使得集合中不存在高度相同的两棵二项树。</p>
</li>
</ul>
<blockquote>
<ol>
<li>合并操作和删除最小元素的平均时间复杂度证明过程极为复杂，这里省略。</li>
<li>为支持懒惰二项队列，将二项队列结构中的 <code>private Node&lt;E&gt;[] trees;</code> 修改为 <code>private LinkedList&lt;Node&lt;E&gt;&gt; trees</code> 即可得到懒惰二项队列结构。</li>
<li>通过合并操作和删除最小元素操作的具体内容，可以得知：懒惰合并指代只有当两个二项队列真正需要合并时 (即删除最小元素后) 才进行合并。</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-左式堆</title>
    <url>/2020/05/25/dataStructure/dataStructure-leftheap/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>左式堆</strong> 属于一种特殊的堆。除具有二叉堆所有功能外，它还可以在 $O(log^N)$ 时间复杂度内实现堆合并操作。</p>
<a id="more"></a>

<p>其结构图大致如下：</p>
<p><img src="/2020/05/25/dataStructure/dataStructure-leftheap/image-20200523111458539.png" alt="图一：左式堆"></p>
<p>左式堆主要涉及一个概念和一个定理，在此先行解释。</p>
<ul>
<li><p>零路径长 ($npl(x)$)</p>
<p>节点 $x$ 的零路径长 $npl(x)$  定义为：从 $x$ 到一个不具有两个儿子节点的最短路径的长。</p>
<p>如果节点 $x$ 具有 0 或 1 个儿子节点，那么 $npl(x) = 0$；如果该节点为空节点，则 $npl(null) = -1$。</p>
<p>根据如上定义，可以推知：任一节点的零路径长比它的各个儿子节点的零路径长的最小值大一。</p>
<p>此时可以给出左式堆的具体定义：<strong>左式堆是一棵具有堆序性质的二叉树，而且对于堆中任一节点而言，其左儿子节点的零路径长总是大于等于右儿子节点的零路径长。</strong></p>
</li>
<li><p>在右路径上有 $r$ 个节点的左式堆必然至少有 $2^r -1$ 个节点。</p>
<p>右路径：左式堆最右侧节点所形成的的路径。</p>
<p>使用数学归纳法加以证明。</p>
<p>如果 $i = 1$，左式堆具有 $1$ 个节点，符合定理。</p>
<p>假定 $i = r$ 符合定理。当 $i = r + 1$ 时，可知右子堆至少具有  $2^r - 1$ 个节点，为满足 “左儿子节点的零路径长总是大于等于右儿子节点的零路径长”，可知左子堆同样至少具有 $2^r - 1$ 个节点，再加上一个根节点，总的节点个数至少为 $(2^r - 1) * 2 + 1 = 2^{r + 1} - 1$，符合定理。故而证明完毕。</p>
<p>该定理没有什么用，我们主要使用它的推导定理：具有 $N$ 个节点的左式堆，其右路径最多含有 $log^{N + 1}$ 节点。</p>
<p><strong>由于右路径具有这样的性质，所以我们将对左式堆的所有操作都放到右路径上进行。这样也保证了复杂度为 $O(log^N)$。</strong></p>
</li>
</ul>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>左式堆中元素需可比较，为简化代码，我们直接在内部存储一个比较类，用于比较堆中元素。另外节点结构除保存元素外，还需保存 $npl$。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LeftHeap</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 节点结构</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">// 具体元素</span></span><br><span class="line">        E item;</span><br><span class="line">        <span class="comment">// 左儿子</span></span><br><span class="line">        Node&lt;E&gt; left;</span><br><span class="line">        <span class="comment">// 右儿子</span></span><br><span class="line">        Node&lt;E&gt; right;</span><br><span class="line">        <span class="comment">// 零路径长</span></span><br><span class="line">        <span class="keyword">int</span> npl;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E item, Node&lt;E&gt; left, Node&lt;E&gt; right, <span class="keyword">int</span> npl)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.item = item;</span><br><span class="line">            <span class="keyword">this</span>.left = left;</span><br><span class="line">            <span class="keyword">this</span>.right = right;</span><br><span class="line">            <span class="keyword">this</span>.npl = npl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 比较函数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> E&gt; comparator;</span><br><span class="line">    <span class="comment">// 根节点</span></span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="辅助方法"><a href="#辅助方法" class="headerlink" title="辅助方法"></a>辅助方法</h3><ul>
<li><p>$npl(x)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">npl</span><span class="params">(Node&lt;E&gt; e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span> == e ? -<span class="number">1</span> : e.npl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>合并</p>
<p>对链式结构的操作，基于递归实现往往比较简单。因此在此虽同时给出递归和迭代思路，但是仅给出递归代码。</p>
<ul>
<li><p>基于递归</p>
<ol>
<li>如果一方为空，则直接返回另一方。</li>
<li>比较两方根节点，<em>合并根节点较大者与根节点较小者的右子树</em>，并将其作为根节点较小者的右子树，做相关调整（包括：是否需交换左右子树以满足 “左儿子节点的零路径长总是大于等于右儿子节点的零路径长”、重新计算根节点的零路径长）使当前合并后的左式堆满足要求，然后返回之。</li>
</ol>
<p>举例：</p>
<p><img src="/2020/05/25/dataStructure/dataStructure-leftheap/merge_op.png" alt="图二：合并左式堆"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;E&gt; <span class="title">merge</span><span class="params">(Node&lt;E&gt; h1, Node&lt;E&gt; h2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 一方为空，则直接返回另一方</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == h1) &#123;</span><br><span class="line">        <span class="keyword">return</span> h2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == h2) &#123;</span><br><span class="line">        <span class="keyword">return</span> h1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二者皆不为空</span></span><br><span class="line">    <span class="comment">// 如果前者根值大于后者根值，需进行交换以保证h1引用根值较小者表示的左式堆。</span></span><br><span class="line">    <span class="keyword">if</span> (comparator.compare(h1.item, h2.item) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> merge(h2, h1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将根值较大者与根值较小者的右子堆合并，合并后的堆成为根值较小者的右子堆，最后调整npl值即可。</span></span><br><span class="line">    h1.right = merge(h1.right, h2);</span><br><span class="line">    <span class="keyword">if</span> (npl(h1.left) &lt; npl(h1.right)) &#123;</span><br><span class="line">        <span class="comment">// 交换两个节点</span></span><br><span class="line">        Node&lt;E&gt; tmp = h1.left;</span><br><span class="line">        h1.left = h1.right;</span><br><span class="line">        h1.right = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    h1.npl = npl(h1.right) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> h1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>基于迭代</p>
</li>
</ul>
<ol>
<li>按照大小关系合并两方的右路径以构建一颗新的树。</li>
<li>按照 “左右根” 顺序遍历整棵树，做相关调整（包括：是否需交换左右子树以满足 “左儿子节点的零路径长总是大于等于右儿子节点的零路径长”、重新计算根节点的零路径长），使得此树满足左式堆性质即可。</li>
</ol>
</li>
</ul>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LeftHeap</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><ul>
<li><p>查询最小值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == <span class="keyword">this</span>.root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.root.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="操纵"><a href="#操纵" class="headerlink" title="操纵"></a>操纵</h3></li>
<li><p>合并两个左式堆</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(LeftHeap&lt;E&gt; leftHeap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == leftHeap) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.root = merge(<span class="keyword">this</span>.root, leftHeap.root);</span><br><span class="line">    leftHeap.root = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>堆中添加元素</p>
<p>将待添加元素看做一个左式堆，然后合并两个左式堆即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(E element)</span> </span>&#123;</span><br><span class="line">    Node&lt;E&gt; eNode = <span class="keyword">new</span> Node&lt;&gt;(element, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">this</span>.root = merge(<span class="keyword">this</span>.root, eNode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>堆中删除最小元素</p>
<p>删除最小元素，直接合并两个左右子堆即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == <span class="keyword">this</span>.root) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.root = merge(<span class="keyword">this</span>.root.left, <span class="keyword">this</span>.root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>降低某个节点的元素值</p>
<p>这个操作只提思路，不做实现 (当前左式堆结构无法实现)。</p>
<p>在二叉堆 (小顶堆) 中，这一操作可通过上移至根节点实现，且时间复杂度为 $O(log^N)$。在左式堆中，如果采用相同的实现方法，由于并非所有节点到根节点的距离都是 $O(log^N)$，故而其时间复杂度一定大于 $O(log^N)$。</p>
<p>为保证此操作时间复杂度为 $O(log^N)$，左式堆应当采取另一种实现方法：将该节点与其父节点断开，将形成一个左式堆和一个堆 (可很容易恢复为左式堆)，然后合并二者即可。将堆恢复为左式堆及合并操作的时间复杂度均为 $O(log^N)$，故此操作的时间复杂度亦为 $O(log^N)$。 </p>
<p>将堆恢复为左式堆的时间复杂度为 $O(log^N)$，其原因在于：1. 只有父节点到根节点路径上的节点才有可能破坏左式堆性质，因此通过交换左右子树即可恢复性质。2. 由于最大右路径长为 $log^{N + 1}$，故而只需调整从父节点到根结点上的前 $log^{N + 1}$ 个节点即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decreaseKey</span><span class="params">(Node&lt;E&gt; e, E element)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2></li>
</ul>
<p><strong>斜堆</strong> 是左式堆的自调节形式，它与左式堆的关系类似于伸展树与 AVL 树间的关系。</p>
<p>斜堆本质上只是一个具有堆序的二叉树。相比于左式堆而言，它没有 “其左儿子节点的零路径长总是大于等于右儿子节点的零路径长” 这样的限制，故而关于节点的零路径长信息皆无需保留。也正因如此，斜堆的右路径可以无限长，故而单次操作时间复杂度为 $O(N)$。但是理论证明：<strong>对任意 $M$ 次连续操作，总的最坏情形运行时间为 $O(Mlog^N)$，故而平均时间复杂度为 $O(log^N)$。</strong></p>
<p>从左式堆实现中可以看到：其他操纵操纵都是基于合并操作实现的。斜堆亦是如此。故而在此简要介绍斜堆的合并操作。</p>
<p>在斜堆的合并操作中，除右路径最后一个节点外，左右子堆交换总是进行。借助上面合并代码，斜堆的合并代码列举如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;E&gt; <span class="title">merge</span><span class="params">(Node&lt;E&gt; h1, Node&lt;E&gt; h2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 一方为空，则直接返回另一方</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == h1) &#123;</span><br><span class="line">        <span class="keyword">return</span> h2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == h2) &#123;</span><br><span class="line">        <span class="keyword">return</span> h1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二者皆不为空</span></span><br><span class="line">    <span class="comment">// 如果前者根值大于后者根值，需进行交换以保证h1引用根值较小者表示的左式堆。</span></span><br><span class="line">    <span class="keyword">if</span> (comparator.compare(h1.item, h2.item) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        Node&lt;E&gt; tmp = h1;</span><br><span class="line">        h1 = h2;</span><br><span class="line">        h2 = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将根值较大者与根值较小者的右子堆合并，合并后的堆成为根值较小者的右子堆。</span></span><br><span class="line">    h1.right = merge(h1.right, h2);</span><br><span class="line">    <span class="comment">// 直接交换两个节点即可，因为h1.right为空情况已在2-8行代码中排除了。</span></span><br><span class="line">    Node&lt;E&gt; tmp = h1.left;</span><br><span class="line">    h1.left = h1.right;</span><br><span class="line">    h1.right = tmp;</span><br><span class="line">    <span class="keyword">return</span> h1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>








]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-二叉堆</title>
    <url>/2020/05/22/dataStructure/dataStructure-binaryheap/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>二叉堆</strong> 属于一种特殊的堆，其本质为一颗完全二叉树。</p>
<a id="more"></a>

<p>二叉堆分为两种——大顶堆和小顶堆。二者结构图大致如下：</p>
<p><img src="/2020/05/22/dataStructure/dataStructure-binaryheap/1024555-20161217182750011-675658660.png" alt="图一：二叉堆"></p>
<p>二叉堆本质上是一棵二叉树，通常应当采用链式存储结构加以实现。由于完全二叉树的性质，我们可以很方便地使用数组实现二叉堆。另外大顶堆与小顶堆原理相同，实现也差不多。故而，本文基于数组实现一个小顶堆。</p>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>堆中元素需可比较，为简化代码，我们直接在内部存储一个比较类，用于比较堆中元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryHeap</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 比较函数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> E&gt; comparator;</span><br><span class="line">    <span class="comment">// 基础数组(从下标1开始存储元素)</span></span><br><span class="line">    <span class="keyword">private</span> Object[] elementData;</span><br><span class="line">    <span class="comment">// 元素个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><blockquote>
<p>对堆进行操作后，需保持堆性质 (每个结点表示值总是大于/小于左右子结点表示值) 不发生变化。</p>
</blockquote>
<h3 id="辅助方法"><a href="#辅助方法" class="headerlink" title="辅助方法"></a>辅助方法</h3><p>堆具有两大基本操作——上移和下沉。</p>
<ul>
<li><p>上移</p>
<p>将指定位置结点上移时，将首先判断当前结点与父结点间大小关系。如果当前结点较小，则需将二者交换然后进一步判断父结点，反之表明已符合堆性质，直接退出即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 迭代写法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> length = <span class="keyword">this</span>.size;</span><br><span class="line">    <span class="keyword">final</span> Object element = <span class="keyword">this</span>.elementData[index];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = index / <span class="number">2</span>; i &gt; <span class="number">0</span>; i = i / <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (comparator.compare((E) <span class="keyword">this</span>.elementData[i], (E) element) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.elementData[index] = <span class="keyword">this</span>.elementData[i];</span><br><span class="line">            index = i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.elementData[index] = element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归写法</span></span><br><span class="line"><span class="comment">// 将element上移到堆中合适的位置，现已处理到index</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">upD</span><span class="params">(Object element, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index / <span class="number">2</span> &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData[index] = element;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = index / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (comparator.compare((E) <span class="keyword">this</span>.elementData[i], (E) element) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData[index] = <span class="keyword">this</span>.elementData[i];</span><br><span class="line">        index = i;</span><br><span class="line">        upD(element, index);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData[index] = element;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>下沉</p>
<p>将指定位置结点下沉时，将首先判断当前结点与左右子结点较小者间大小关系。如果当前结点较大，则需将二者交换然后进一步判断左右子结点较小者，反之表明已符合堆性质，直接退出即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 迭代写法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> length = <span class="keyword">this</span>.size;</span><br><span class="line">    <span class="keyword">final</span> Object element = <span class="keyword">this</span>.elementData[index];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = index * <span class="number">2</span>; i &lt;= length; i = i * <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 找寻左右儿子中小者</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; length &amp;&amp; comparator.compare((E) <span class="keyword">this</span>.elementData[i], (E) <span class="keyword">this</span>.elementData[i + <span class="number">1</span>]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            i = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (comparator.compare((E) <span class="keyword">this</span>.elementData[i], (E) element) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.elementData[index] = <span class="keyword">this</span>.elementData[i];</span><br><span class="line">            index = i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.elementData[index] = element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归写法</span></span><br><span class="line"><span class="comment">// 将element下沉到堆中合适的位置，现已处理到index</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">downD</span><span class="params">(Object element, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index * <span class="number">2</span> &gt; <span class="keyword">this</span>.size) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData[index] = element;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> i = index * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="keyword">this</span>.size &amp;&amp; comparator.compare((E) <span class="keyword">this</span>.elementData[i], (E) <span class="keyword">this</span>.elementData[i + <span class="number">1</span>]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            i = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (comparator.compare((E) <span class="keyword">this</span>.elementData[i], (E) element) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.elementData[index] = <span class="keyword">this</span>.elementData[i];</span><br><span class="line">            index = i;</span><br><span class="line">            downD(element, index);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.elementData[index] = element;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<blockquote>
<p>描述性内容写的是 “交换两个结点”；但是代码实现中略有不同。原因如下：假定执行一次上移共需迭代 $d$ 次。对于前者需执行 $3d$ 次赋值操作，而 后者则仅需要 $d + 1$ 次赋值。</p>
<p><strong>使用前者带来的负担是：运行效率略低；使用后者带来的负担则是：递归写法比较复杂。</strong></p>
</blockquote>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>堆初始化存在两种方式——自顶向下和自底向上。前者复杂度为 $O(Nlog^N)$，后者复杂度为 $O(N)$。</p>
<ul>
<li><p>自顶向下初始化</p>
<p>此种初始化方式比较简单，就是将每个元素依次插入到堆中即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BinaryHeap</span><span class="params">(E [] arr, Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> length = arr.length;</span><br><span class="line">    <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">    <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; length; i++) &#123;</span><br><span class="line">        insert(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>复杂度分析</p>
<p>容易知道，插入元素的时间复杂度为 $O(log^N)$ ，其中 $N$ 为当前堆中结点个数。</p>
<p>那么自顶向下初始化过程的时间复杂度便是：$\sum_{i = 1}^Nlog^i$，其中 $N$ 为最终堆中结点个数。</p>
<p>基于积分学知识，我们知道：$\int_{i - 1}^ilog^idi &lt; log^i &lt; \int_i^{i + 1}log^idi$，那么便有如下等式：</p>
<p>$$\sum_{i = 1}^N(\int_{i - 1}^ilog^idi) &lt; \sum_{i = 1}^Nlog^i &lt; \sum_{i = 1}^N\int_i^{i + 1}log^idi$$</p>
<p>$$\int_0^Nlog^idi &lt; \sum_{i = 1}^Nlog^i &lt; \int_1^{N + 1}log^idi$$</p>
<p>左右两端结果均为 $O(Nlog^N)$，故而 $\sum_{i = 1}^Nlog^i \approx O(Nlog^N)$。</p>
<p>所以，自顶向下初始化过程的时间复杂度为 $O(Nlog^N)$。 </p>
</li>
</ul>
</li>
<li><p>自底向上初始化</p>
<p>此种初始化方式比较巧妙，将非叶结点依次下沉即可得到一个堆。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BinaryHeap</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; comparator, E [] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> length = arr.length;</span><br><span class="line">    <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">    <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">this</span>.size = length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData[i + <span class="number">1</span>] = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = length / <span class="number">2</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        down(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>容易知道，下沉结点的时间复杂度为 $O(log^h)$，其中 $h$ 为当前结点的高度。</p>
<p>那么自底向上初始化过程的时间复杂度便是所有结点的高度之和，即 $S = \sum_{i = 0}^h2^i\times (h - i)$，其中 $h$ 为最终堆的高度。</p>
<p>使用错位相减法求解该式，可以得到 $S \approx O(2^h)$。高度为 $h$ 的完全二叉树，其结点个数 $N$ 满足等式 $2^h &lt; N &lt; 2^{h + 1}$，故而 $S \approx O(N)$。</p>
<p>所以，自底向上初始化过程的时间复杂度为 $O(N)$。 </p>
</li>
</ul>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><ul>
<li><p>查询最小值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size == <span class="number">0</span> ? <span class="keyword">null</span> : (E) <span class="keyword">this</span>.elementData[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="操纵"><a href="#操纵" class="headerlink" title="操纵"></a>操纵</h3></li>
<li><p>堆中添加元素</p>
<p>方法十分巧妙。将待添加元素置于堆末，然后上移该结点，即可实现将元素添加到堆中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(E element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData[++<span class="keyword">this</span>.size] = element;</span><br><span class="line">    up(<span class="keyword">this</span>.size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>堆中删除最小元素</p>
<p>方法十分巧妙。将堆头结点与堆末结点互换，此时删除堆末结点十分简单，然后下沉堆头结点，即可实现将最小元素从堆中删除。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">deleteMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.size &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    E element = (E) <span class="keyword">this</span>.elementData[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.size == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.size--;</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData[<span class="number">1</span>] = <span class="keyword">this</span>.elementData[<span class="keyword">this</span>.size--];</span><br><span class="line">        down(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-队列/栈</title>
    <url>/2020/05/21/dataStructure/dataStructure-arraydeque/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>队列</strong> 属于一种特殊的线性表/链表，它仅允许从一端插入元素、另一端删除元素。</p>
<p><strong>栈</strong> 属于一种特殊的线性表/链表，它仅允许在某一端插入、删除元素。</p>
<a id="more"></a>


<p>其结构图大致如下：</p>
<p><img src="/2020/05/21/dataStructure/dataStructure-arraydeque/images.png" alt="图一：队列/栈"></p>
<p>我们并不单独实现队列/栈，而是仅实现一个双端队列，它不仅具有队列功能、也具有栈功能。</p>
<p>双端队列实现方法有两种，一种基于循环数组，另一种基于链表。基于链表的已在 <a href="/2020/05/21/dataStructure/dataStructure-linkedlist/" title="数据结构-链表">数据结构-链表</a> 中给出，故而此处的双端队列基于循环数组实现。</p>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>在 Java 库中，<code>ArrayDeque</code> 类为双端队列的实现。在这种实现方法中，其中无法存储 <code>null</code> 值。</p>
<p>我们采用 Java库中类似方法，并在稍后代码中给出无法存储 <code>null</code> 值的原因。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayDeque</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 默认容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">16</span>;</span><br><span class="line">    <span class="comment">// 基础数组</span></span><br><span class="line">    <span class="keyword">private</span> Object[] elementData;</span><br><span class="line">    <span class="comment">// 队首(指向第一个元素的位置)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> head;</span><br><span class="line">    <span class="comment">// 队尾(指向最后一个元素的下一个位置)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="辅助方法"><a href="#辅助方法" class="headerlink" title="辅助方法"></a>辅助方法</h3><ul>
<li><p>单增($0 \leq i &lt; modulus$)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">inc</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> modulus)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((++i) &gt;= modulus) &#123;</span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>多增</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">inc</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> distance, <span class="keyword">int</span> modulus)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((i += distance) &gt;= modulus) &#123;</span><br><span class="line">        i -= modulus;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>单减($0 \leq i &lt; modulus$)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dec</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> modulus)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((--i) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        i = modulus - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>多减</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> modulus)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((i -= j) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        i += modulus;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>扩容</p>
<p>第 9 行代码可以看到，它借用 <code>null</code> 判断该双端队列为满状态还是空状态。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = <span class="keyword">this</span>.elementData.length;</span><br><span class="line">    Object[] elementData = <span class="keyword">new</span> Object[oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>)];</span><br><span class="line">    <span class="comment">// 将全部元素赋值过去</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; oldCapacity; i++) &#123;</span><br><span class="line">        elementData[i] = <span class="keyword">this</span>.elementData[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将原数组中右半部分元素移动到新数组中右半部分。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.tail &lt; <span class="keyword">this</span>.head || (<span class="keyword">this</span>.tail == <span class="keyword">this</span>.head &amp;&amp; <span class="keyword">null</span> !=<span class="keyword">this</span>.elementData[<span class="keyword">this</span>.head])) &#123;</span><br><span class="line">        <span class="keyword">int</span> spaceCapacity = oldCapacity &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="keyword">this</span>.head; i &lt; oldCapacity; i++) &#123;</span><br><span class="line">            elementData[i + spaceCapacity] = <span class="keyword">this</span>.elementData[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.head += spaceCapacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.elementData = elementData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>单增、多增、单减、多减四个函数意在封装下标移动时的取模操作。</p>
</blockquote>
</li>
</ul>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ul>
<li><p>空初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayDeque</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(ArrayDeque.DEFAULT_CAPACITY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>带参数初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayDeque</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        initialCapacity = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3></li>
<li><p>查询元素个数</p>
<p>我们无需变量存放元素个数信息，只需通过队首、队尾相减即可得到该信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sub(<span class="keyword">this</span>.tail, <span class="keyword">this</span>.head, <span class="keyword">this</span>.elementData.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>查询双端队列是否为空</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>查询队首</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ArrayDequeu中二者是有差别的。如果双端队列为空，前者返回一个异常，后者返回null。对此我做了简化。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) <span class="keyword">this</span>.elementData[<span class="keyword">this</span>.head];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peekFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getFirst();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>查询队尾</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ArrayDequeu中二者是有差别的。如果双端队列为空，前者返回一个异常，后者返回null。对此我做了简化。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) <span class="keyword">this</span>.elementData[dec(<span class="keyword">this</span>.tail, <span class="keyword">this</span>.elementData.length)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peekLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getLast();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="操纵"><a href="#操纵" class="headerlink" title="操纵"></a>操纵</h3></li>
<li><p>队首添加元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ArrayDequeu中二者是有差别的。如果双端队列为空，前者返回一个异常，后者返回null。对此我做了简化。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == e) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.elementData[<span class="keyword">this</span>.head = dec(<span class="keyword">this</span>.head,<span class="keyword">this</span>.elementData.length)] = e;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.head == <span class="keyword">this</span>.tail) &#123;</span><br><span class="line">        grow();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offerFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    addFirst(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>队尾添加元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ArrayDequeu中二者是有差别的。如果双端队列为空，前者返回一个异常，后者返回null。对此我做了简化。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == e) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.elementData[<span class="keyword">this</span>.tail] = e;</span><br><span class="line">    <span class="keyword">this</span>.tail = inc(<span class="keyword">this</span>.tail,<span class="keyword">this</span>.elementData.length);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.head == <span class="keyword">this</span>.tail) &#123;</span><br><span class="line">        grow();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offerLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    addLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>队首删除元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ArrayDequeu中二者是有差别的。如果双端队列为空，前者返回一个异常，后者返回null。对此我做了简化。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> E e = (E) <span class="keyword">this</span>.elementData[<span class="keyword">this</span>.head];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != e) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData[<span class="keyword">this</span>.head] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.head = inc(<span class="keyword">this</span>.head, <span class="keyword">this</span>.elementData.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> removeFirst();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>队尾删除元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ArrayDequeu中二者是有差别的。如果双端队列为空，前者返回一个异常，后者返回null。对此我做了简化。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> index = dec(<span class="keyword">this</span>.tail, <span class="keyword">this</span>.elementData.length);</span><br><span class="line">    <span class="keyword">final</span> E e = (E) <span class="keyword">this</span>.elementData[index];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != e) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData[index] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.tail = index;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> removeLast();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>清空双端队列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="keyword">this</span>.head; i != <span class="keyword">this</span>.tail; i = inc(i, <span class="keyword">this</span>.elementData.length)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData[i] = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.head = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.tail = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>对队列/栈中元素施加以单调性质便形成了一种新的数据结构——单调队列/单调栈。在单调队列/单调栈中，所有元素按序单调递增或单调递增。</p>
<p>该种数据结构用途不太广泛，仅能处理一种特定问题—— Next Greater Element。例如：给你一个数组，返回一个等长的数组，对应索引存储着下一个更大元素，如果没有更大的元素，就存 -1。如果输入为 <code> [2,1,2,4,3]</code> ，输出应当为 <code>[4,2,4,-1,-1]</code> 。基于单调栈，从后往前存储数组元素即可解决此问题。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>队列</tag>
        <tag>单调队列</tag>
        <tag>栈</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-链表</title>
    <url>/2020/05/21/dataStructure/dataStructure-linkedlist/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>链表</strong> 是采用链式存储结构表示和实现的线性表。本文仅探讨双向链表。</p>
<a id="more"></a>

<p>其结构图大致如下：</p>
<p><img src="/2020/05/21/dataStructure/dataStructure-linkedlist/shuanxianglianbiao.png" alt="图一：链表"></p>
<p>链表的优缺点：</p>
<ul>
<li>优点<ul>
<li>快速实现插入、删除元素。</li>
</ul>
</li>
<li>缺点<ul>
<li>需额外空间保存元素间逻辑关系。</li>
<li>查询效率低。</li>
</ul>
</li>
</ul>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>链表采用链式存储结构实现，故而需要首先定义结点结构。我们采用 Java 库相同的做法，将结点定义为链表类中的一个静态类。</p>
<p>另外依据 Java库中 <code>LinkedList</code> 类的定义，可以发现它同样实现了双端队列 <code>Deque</code>，在此我们也这样做。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 节点结构</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">// 具体元素</span></span><br><span class="line">        E item;</span><br><span class="line">        <span class="comment">// 前驱</span></span><br><span class="line">        Node&lt;E&gt; prev;</span><br><span class="line">        <span class="comment">// 后继</span></span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line"></span><br><span class="line">        Node(Node&lt;E&gt; prev, E item, Node&lt;E&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.prev = prev;</span><br><span class="line">            <span class="keyword">this</span>.item = item;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 头结点</span></span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; first;</span><br><span class="line">    <span class="comment">// 尾结点</span></span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; last;</span><br><span class="line">    <span class="comment">// 元素个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><blockquote>
<p>链表往往具有两种写法——一种具有标记结点，一种不具有标记结点。</p>
<p>使用前者，可无需考虑一些特殊情况，但是需要耗费一个结点的空间。</p>
<p>Java 库采用后者，故而我们亦采用后者。</p>
</blockquote>
<h3 id="辅助方法"><a href="#辅助方法" class="headerlink" title="辅助方法"></a>辅助方法</h3><ul>
<li><p>链接元素于首部</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; first = <span class="keyword">this</span>.first;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(<span class="keyword">null</span>, e, first);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == first) &#123;</span><br><span class="line">        <span class="keyword">this</span>.last = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        first.prev = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.first = newNode;</span><br><span class="line">    <span class="keyword">this</span>.size = <span class="keyword">this</span>.size + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>链接元素于尾部</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; last = <span class="keyword">this</span>.last;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(last, e, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == last) &#123;</span><br><span class="line">        <span class="keyword">this</span>.first = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        last.next = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.last = newNode;</span><br><span class="line">    <span class="keyword">this</span>.size = <span class="keyword">this</span>.size + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>链接元素于某结点之前(结点一定存在)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = succ.prev;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(prev, e, succ);</span><br><span class="line">    succ.prev = newNode;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == prev) &#123;</span><br><span class="line">        <span class="keyword">this</span>.first = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prev.next = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.size = <span class="keyword">this</span>.size + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>删除某元素(元素一定存在)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">    E element = x.item;</span><br><span class="line">    x.prev = <span class="keyword">null</span>;</span><br><span class="line">    x.item = <span class="keyword">null</span>;</span><br><span class="line">    x.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == prev) &#123;</span><br><span class="line">        <span class="keyword">this</span>.first = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prev.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.last = prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.size = <span class="keyword">this</span>.size - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>查找指定位置结点</p>
<p>查询指定位置结点，在此做一简单优化。如果位置位于链表前半部分，则顺序查找；否则逆向查找。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; (<span class="keyword">this</span>.size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = <span class="keyword">this</span>.first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">            x = x.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = <span class="keyword">this</span>.last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="keyword">this</span>.size - <span class="number">1</span>; i &gt; index; i--) &#123;</span><br><span class="line">            x = x.prev;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3></li>
<li><p>空初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3></li>
<li><p>查询元素个数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>查询链首</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Dequeu中二者是有差别的。如果链表为空，前者返回一个异常，后者返回null。对此我做了简化。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; e = <span class="keyword">this</span>.first;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> e.item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peekFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getFirst();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>查询链尾</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 同上</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; e = <span class="keyword">this</span>.last;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> e.item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peekLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getLast();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>查询指定位置元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="keyword">this</span>.size) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>查询元素位置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == o) &#123;</span><br><span class="line">        Node&lt;E&gt; x = <span class="keyword">this</span>.first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == x.item) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">            x = x.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = <span class="keyword">this</span>.first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.item.equals(o)) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">            x = x.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="操纵"><a href="#操纵" class="headerlink" title="操纵"></a>操纵</h3></li>
<li><p>链首添加元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Dequeu中二者是有差别的。如果因空间限制而添加失败，前者返回一个异常，后者返回false。对此我做了简化。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkFirst(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offerFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkFirst(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>链尾添加元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 同上</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offerLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>指定位置添加元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; <span class="keyword">this</span>.size) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (index == <span class="keyword">this</span>.size) &#123;</span><br><span class="line">        linkLast(element);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        linkBefore(element, node(index));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>链首删除元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Dequeu中二者是有差别的。如果链表为空，前者返回一个异常，后者返回null。对此我做了简化。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = <span class="keyword">this</span>.first;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == f) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> unlink(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> removeFirst();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>链尾删除元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 同上</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = <span class="keyword">this</span>.last;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == l) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> unlink(l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> removeLast();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>指定位置删除元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="keyword">this</span>.size) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>清空链表</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; x = <span class="keyword">this</span>.first; x != <span class="keyword">null</span>;) &#123;</span><br><span class="line">        Node&lt;E&gt; next = x.next;</span><br><span class="line">        x.prev = <span class="keyword">null</span>;</span><br><span class="line">        x.item = <span class="keyword">null</span>;</span><br><span class="line">        x.next = <span class="keyword">null</span>;</span><br><span class="line">        x = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.first = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.last = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>修改指定位置元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="keyword">this</span>.size) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node&lt;E&gt; x = node(index);</span><br><span class="line">    E oldElement = x.item;</span><br><span class="line">    x.item = element;</span><br><span class="line">    <span class="keyword">return</span> oldElement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>将 “分块思想” 应用于链表之中，便得到了一种新的数据结构—— <a href="/2020/07/13/dataStructure/dataStructure-blocklist/" title="块状链表">块状链表</a>。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-线性表</title>
    <url>/2020/05/20/dataStructure/dataStructure-arraylist/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>线性表</strong> 是具有线性结构特点、最简单、且最常用的一种数据结构。它是具有相同特性的数据元素组成的一个有限序列。</p>
<a id="more"></a>

<p>其结构图大致如下：</p>
<p><img src="/2020/05/20/dataStructure/dataStructure-arraylist/image-20200520201858696.png" alt="图一：线性表"></p>
<p>线性表的优缺点：</p>
<ul>
<li>优点<ol>
<li>随机存取。</li>
<li>无需额外空间保存元素间逻辑关系。</li>
</ol>
</li>
<li>缺点<ol>
<li>插入、删除需要移动大量元素。</li>
<li>可能存在存储空间“碎片“，即申请了但未使用的空间。</li>
</ol>
</li>
</ul>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>线性表需要先申请一定空间，然后再想其中存放元素，因此存在 <em>容量</em> 和 <em>元素个数</em> 两个概念。其中 <em>容量</em> 指的是当前线性表可容纳的元素个数；<em>元素个数</em> 指的是当前线性表已容纳的元素个数。由于 Java 数组本身就保存容量信息，因此在此无需存储它，仅需存储元素个数即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 默认容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 基础数组</span></span><br><span class="line">    <span class="keyword">private</span> Object[] elementData;</span><br><span class="line">    <span class="comment">// 元素个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="辅助方法"><a href="#辅助方法" class="headerlink" title="辅助方法"></a>辅助方法</h3><ul>
<li><p>扩容</p>
<p>每扩充一次，线性表容量增加一半。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Object[] grow() &#123;</span><br><span class="line">    Object[] newElementData = <span class="keyword">new</span> Object[<span class="keyword">this</span>.elementData.length + (<span class="keyword">this</span>.elementData.length &gt;&gt; <span class="number">1</span>)];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="keyword">this</span>.size; i++)</span><br><span class="line">        newElementData[i] = <span class="keyword">this</span>.elementData[i];</span><br><span class="line">    <span class="keyword">return</span> newElementData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3></li>
<li><p>空初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(ArrayList.DEFAULT_CAPACITY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>带参数初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        initialCapacity = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3></li>
<li><p>查询元素个数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>查询线性表是否为空</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size() == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>查询元素位置</p>
<p>如果存在则返回其下标，否则返回 -1。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == o)  &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == <span class="keyword">this</span>.elementData[i])</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(<span class="keyword">this</span>.elementData[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>查询指定位置内容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="keyword">this</span>.size) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (E)<span class="keyword">this</span>.elementData[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="操纵"><a href="#操纵" class="headerlink" title="操纵"></a>操纵</h3></li>
<li><p>指定位置添加元素</p>
<p>添加元素之前需要判断容量是否足够，不够则扩容。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; <span class="keyword">this</span>.size) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.elementData.length == <span class="keyword">this</span>.size) &#123;</span><br><span class="line">            <span class="keyword">this</span>.elementData = grow();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="keyword">this</span>.size; i &gt;= index; i--)</span><br><span class="line">            <span class="keyword">this</span>.elementData[i + <span class="number">1</span>] = <span class="keyword">this</span>.elementData[i];</span><br><span class="line">        <span class="keyword">this</span>.elementData[index] = element;</span><br><span class="line">        <span class="keyword">this</span>.size = <span class="keyword">this</span>.size + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>线性表末添加元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> add(size(),element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>删除指定位置元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= <span class="keyword">this</span>.size) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        E oldElement = (E) <span class="keyword">this</span>.elementData[index];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; <span class="keyword">this</span>.size; i++) &#123;</span><br><span class="line">            <span class="keyword">this</span>.elementData[i + <span class="number">1</span>] = <span class="keyword">this</span>.elementData[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.size = <span class="keyword">this</span>.size - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">this</span>.elementData[<span class="keyword">this</span>.size] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> oldElement;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>清空线性表</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.size; i++)</span><br><span class="line">        <span class="keyword">this</span>.elementData[i] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>修改指定位置元素</p>
<p>修改指定位置元素并返回旧元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="keyword">this</span>.size) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        E oldElement = (E)<span class="keyword">this</span>.elementData[index];</span><br><span class="line">        <span class="keyword">this</span>.elementData[index] = element;</span><br><span class="line">        <span class="keyword">return</span> oldElement;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>将 “分块思想” 应用于线性表之中，便得到了一种新的数据结构——块状数组。块状数组将首先对整个数组进行分块处理，所有针对数组的操作，将首先施加于分块之上，然后进一步施加于分块所在的块数组之上。</p>
<p>块状数组之上各种操作的时间复杂度均为 $O(\sqrt{N})$，其常用于区间求和、区间查询等问题。</p>
<p><img src="/2020/05/20/dataStructure/dataStructure-arraylist/v2-1655c12e302625448e5c09c6349258d7_720w.png" alt="图二：块状数组"></p>
<blockquote>
<p>块状数组代码实现比较灵活，故而在此简单介绍思想即可。</p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>线性表</tag>
      </tags>
  </entry>
</search>
