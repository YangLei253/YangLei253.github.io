<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>lab8 — 文件系统</title>
    <url>/2021/07/02/ucore/lab8/</url>
    <content><![CDATA[<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>设备驱动程序、文件系统、虚拟文件系统。</p>
<a id="more"></a>

<h2 id="改动点"><a href="#改动点" class="headerlink" title="改动点"></a>改动点</h2><p>相比于 <code>lab7</code> 源代码，<code>lab8</code> 主要做了如下改动：</p>
<ul>
<li><p><code>proc.h</code> 扩展 <code>struct proc_struct</code> 成员属性</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> &#123;</span></span><br><span class="line">    ... <span class="comment">// 同以往结构的属性</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">filesp</span>;</span>                <span class="comment">// 当前进程的文件集信息</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">pwd</span>;</span>      <span class="comment">// 当前进程所在工作目录的 inode</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">fd_array</span>;</span>  <span class="comment">// 打开文件表</span></span><br><span class="line">    <span class="keyword">int</span> files_count;        <span class="comment">// 共享此 files_struct 的进程个数</span></span><br><span class="line">    <span class="keyword">semaphore_t</span> files_sem;  <span class="comment">// 用于互斥访问 files_struct</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">        FD_NONE, FD_INIT, FD_OPENED, FD_CLOSED,</span><br><span class="line">    &#125; status;				<span class="comment">// 文件状态 (无效、初始态、打开态、关闭态)</span></span><br><span class="line">    <span class="keyword">bool</span> readable;			<span class="comment">// 可读</span></span><br><span class="line">    <span class="keyword">bool</span> writable;			<span class="comment">// 可写</span></span><br><span class="line">    <span class="keyword">int</span> fd;					<span class="comment">// 对应的文件描述符</span></span><br><span class="line">    <span class="keyword">off_t</span> pos;				<span class="comment">// 目前的访问位置</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">node</span>;</span>		<span class="comment">// 对应的 inode</span></span><br><span class="line">    <span class="keyword">int</span> open_count;			<span class="comment">// 此文件打开的次数 (此实验中，该字段似乎没什么用。然而，对于 Linux 系统而言，该字段是具有意义的：父子进程共享文件描述符，它们会对应至相同的文件表项，该表项的 open_count 取值会增加)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在 Linux 系统中，每个打开的文件对应三种数据结构：文件描述符表、打开文件表、<code>inode</code> 表，其中前一者为进程级数据结构，后两者为系统级数据结构。</p>
<p>在 <code>ucore</code> 中，每个打开的文件仅对应两种数据结构：打开文件表 (包含文件描述符表的信息)、<code>inode</code> 表，其中前者为进程级数据结构，后者为系统级数据结构。</p>
</blockquote>
</li>
<li><p><code>iobuf.[ch]</code> 提供数据读写的内核缓冲区</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iobuf</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *io_base;     </span><br><span class="line">    <span class="keyword">off_t</span> io_offset;   </span><br><span class="line">    <span class="keyword">size_t</span> io_len;     </span><br><span class="line">    <span class="keyword">size_t</span> io_resid;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p><code>dev.h</code> 规范设备抽象 (只要设备实现此结构所需内容，该系统便可应用此设备，用于屏蔽底层设备的不同)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> &#123;</span></span><br><span class="line">    <span class="keyword">size_t</span> d_blocks;</span><br><span class="line">    <span class="keyword">size_t</span> d_blocksize;</span><br><span class="line">    <span class="keyword">int</span> (*d_open)(struct device *dev, <span class="keyword">uint32_t</span> open_flags);</span><br><span class="line">    <span class="keyword">int</span> (*d_close)(struct device *dev);</span><br><span class="line">    <span class="keyword">int</span> (*d_io)(struct device *dev, struct iobuf *iob, <span class="keyword">bool</span> write);</span><br><span class="line">    <span class="keyword">int</span> (*d_ioctl)(struct device *dev, <span class="keyword">int</span> op, <span class="keyword">void</span> *data);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>值得一说的是，借助于上述内容，我们可以实现如下函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_ops</span> <span class="title">dev_node_ops</span> =</span> &#123;</span><br><span class="line">    .vop_magic                      = VOP_MAGIC,</span><br><span class="line">    .vop_open                       = dev_open,</span><br><span class="line">    .vop_close                      = dev_close,</span><br><span class="line">    .vop_read                       = dev_read,</span><br><span class="line">    .vop_write                      = dev_write,</span><br><span class="line">    .vop_fstat                      = dev_fstat,</span><br><span class="line">    .vop_ioctl                      = dev_ioctl,</span><br><span class="line">    .vop_gettype                    = dev_gettype,</span><br><span class="line">    .vop_tryseek                    = dev_tryseek,</span><br><span class="line">    .vop_lookup                     = dev_lookup,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p><code>inode.h</code> 规范 VFS 层级的 <code>inode</code> 结构</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> &#123;</span></span><br><span class="line">    <span class="comment">// inode 对应的实际类型所存放的信息 (若是设备，则存放设备信息；若是特定 FS，则存放其详细的 inode 信息)</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">device</span> __<span class="title">device_info</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sfs_inode</span> __<span class="title">sfs_inode_info</span>;</span></span><br><span class="line">    &#125; in_info;</span><br><span class="line">    <span class="comment">// inode 对应的实际类型 (特定设备、特定文件系统)</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">        inode_type_device_info = <span class="number">0x1234</span>,</span><br><span class="line">        inode_type_sfs_inode_info,</span><br><span class="line">    &#125; in_type;</span><br><span class="line">    <span class="comment">// 此 inode 的引用计数</span></span><br><span class="line">    <span class="keyword">int</span> ref_count;</span><br><span class="line">    <span class="comment">// 打开此 inode 的文件个数</span></span><br><span class="line">    <span class="keyword">int</span> open_count;</span><br><span class="line">    <span class="comment">// inode 对应的抽象文件系统</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fs</span> *<span class="title">in_fs</span>;</span></span><br><span class="line">    <span class="comment">// 抽象 inode 的操作集</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_ops</span> *<span class="title">in_ops</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// VFS 层级，针对 inode 操作的众多定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode_ops</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> vop_magic;</span><br><span class="line">    <span class="keyword">int</span> (*vop_open)(struct inode *node, <span class="keyword">uint32_t</span> open_flags);</span><br><span class="line">    <span class="keyword">int</span> (*vop_close)(struct inode *node);</span><br><span class="line">    <span class="keyword">int</span> (*vop_read)(struct inode *node, struct iobuf *iob);</span><br><span class="line">    <span class="keyword">int</span> (*vop_write)(struct inode *node, struct iobuf *iob);</span><br><span class="line">    <span class="keyword">int</span> (*vop_fstat)(struct inode *node, struct stat *stat);</span><br><span class="line">    <span class="keyword">int</span> (*vop_fsync)(struct inode *node);</span><br><span class="line">    <span class="keyword">int</span> (*vop_namefile)(struct inode *node, struct iobuf *iob);</span><br><span class="line">    <span class="keyword">int</span> (*vop_getdirentry)(struct inode *node, struct iobuf *iob);</span><br><span class="line">    <span class="keyword">int</span> (*vop_reclaim)(struct inode *node);</span><br><span class="line">    <span class="keyword">int</span> (*vop_gettype)(struct inode *node, <span class="keyword">uint32_t</span> *type_store);</span><br><span class="line">    <span class="keyword">int</span> (*vop_tryseek)(struct inode *node, <span class="keyword">off_t</span> pos);</span><br><span class="line">    <span class="keyword">int</span> (*vop_truncate)(struct inode *node, <span class="keyword">off_t</span> len);</span><br><span class="line">    <span class="keyword">int</span> (*vop_create)(struct inode *node, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">bool</span> excl, struct inode **node_store);</span><br><span class="line">    <span class="keyword">int</span> (*vop_lookup)(struct inode *node, <span class="keyword">char</span> *path, struct inode **node_store);</span><br><span class="line">    <span class="keyword">int</span> (*vop_ioctl)(struct inode *node, <span class="keyword">int</span> op, <span class="keyword">void</span> *data);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p><code>vfs.h</code> 规范 VFS 层级的 <code>fs</code> 结构</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fs</span> &#123;</span></span><br><span class="line">    <span class="comment">// 具体文件系统的信息 (此实验仅涉及 sfs)。</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sfs_fs</span> __<span class="title">sfs_info</span>;</span>                   </span><br><span class="line">    &#125; fs_info;                                      </span><br><span class="line">    <span class="comment">// fs 对应的实际文件系统类型</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">        fs_type_sfs_info,</span><br><span class="line">    &#125; fs_type;                                     </span><br><span class="line">    <span class="comment">// 针对 fs 的四大操作</span></span><br><span class="line">    <span class="keyword">int</span> (*fs_sync)(struct fs *fs);                 </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *(*<span class="title">fs_get_root</span>)(<span class="keyword">struct</span> <span class="title">fs</span> *<span class="title">fs</span>);</span>   </span><br><span class="line">    <span class="keyword">int</span> (*fs_unmount)(struct fs *fs);              </span><br><span class="line">    <span class="keyword">void</span> (*fs_cleanup)(struct fs *fs);          </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>vfs.h</code> 提供 VFS 层级的、针对文件，路径等内容的众多操作，它们进一步会调用 <code>inode_op-&gt;xxx</code> 完成具体功能。</p>
</blockquote>
</li>
<li><p><code>sysfile.[ch]</code> 提供关于文件系统调用的内核级封装</p>
<p>这部分提供的系统调用会进一步调用 VFS 层级的函数，从而实现相关功能。</p>
</li>
<li><p><code>vfsdev.c</code> 提供 <code>vfs_dev_t</code> 结构</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ucore 将设备也视为一种文件，因此也将其集成至 VFS。</span></span><br><span class="line"><span class="comment">// VFS 将设备表示为 vfs_dev_t，并将其串接为一个链表，以方便后续操作。</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="comment">// 设备名称</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *devname;</span><br><span class="line">    <span class="comment">// 设备对应的 inode 信息 (十分重要，借助于它，ucore 才能统一设备与文件系统的操作)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">devnode</span>;</span></span><br><span class="line">    <span class="comment">// 设备所挂载的文件系统</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fs</span> *<span class="title">fs</span>;</span></span><br><span class="line">    <span class="comment">// 设备是否可挂载</span></span><br><span class="line">    <span class="keyword">bool</span> mountable;</span><br><span class="line">    <span class="comment">// 链接只用</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> vdev_link;</span><br><span class="line">&#125; <span class="keyword">vfs_dev_t</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>sfs.h</code> 提供简易文件系统 SFS 的各种数据结构</p>
<p>下图为 SFS 的物理布局：</p>
<p><img src="/2021/07/02/ucore/lab8/image-20210702151848910.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sfs superblock 内容的具体结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sfs_super</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> magic;                                 <span class="comment">// 唯一标记 sfs </span></span><br><span class="line">    <span class="keyword">uint32_t</span> blocks;                                <span class="comment">// sfs 的总块数</span></span><br><span class="line">    <span class="keyword">uint32_t</span> unused_blocks;                         <span class="comment">// sfs 尚未使用的块数</span></span><br><span class="line">    <span class="keyword">char</span> info[SFS_MAX_INFO_LEN + <span class="number">1</span>];                <span class="comment">// sfs 简介信息</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sfs inode 内容的具体结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sfs_disk_inode</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> size;                                  <span class="comment">// 文件大小 (字节单位)</span></span><br><span class="line">    <span class="keyword">uint16_t</span> type;                                  <span class="comment">// 文件类型 (文件、目录、链接)</span></span><br><span class="line">    <span class="keyword">uint16_t</span> nlinks;                                <span class="comment">// 硬链接数目</span></span><br><span class="line">    <span class="keyword">uint32_t</span> blocks;                                <span class="comment">// 文件内容所占块数</span></span><br><span class="line">    <span class="keyword">uint32_t</span> direct[SFS_NDIRECT];                   <span class="comment">// 块索引的直接索引</span></span><br><span class="line">    <span class="keyword">uint32_t</span> indirect;                              <span class="comment">// 块索引的一级索引</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sfs 目录文件内部一项的具体结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sfs_disk_entry</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> ino;                                   <span class="comment">// 文件/目录的 inode 号</span></span><br><span class="line">    <span class="keyword">char</span> name[SFS_MAX_FNAME_LEN + <span class="number">1</span>];               <span class="comment">// 文件/目录的名称</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上述均为数据在硬盘中的组织形式，下述则是数据在内存中的组织形式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// sfs inode 内容的具体结构 (之所以区分硬盘和内存，一则额外信息需要保存，二则方便某些操作)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sfs_inode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sfs_disk_inode</span> *<span class="title">din</span>;</span>                     <span class="comment">// 硬盘 inode 的具体信息</span></span><br><span class="line">    <span class="keyword">uint32_t</span> ino;                                   <span class="comment">// inode 号</span></span><br><span class="line">    <span class="keyword">bool</span> dirty;                                     <span class="comment">// 此 inode 是否被修改</span></span><br><span class="line">    <span class="keyword">int</span> reclaim_count;                              <span class="comment">// 此 inode 待回收数，若其值为 0，需将其写回硬盘</span></span><br><span class="line">    <span class="keyword">semaphore_t</span> sem;                                <span class="comment">// 用于互斥访问 sfs_disk_inode</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> inode_link;                        <span class="comment">// 链接之用</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> hash_link;                         </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sfs 文件系统的具体结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sfs_fs</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sfs_super</span> <span class="title">super</span>;</span>                         <span class="comment">// superblock 信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span>                             <span class="comment">// 所挂载的设备</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bitmap</span> *<span class="title">freemap</span>;</span>                         <span class="comment">// freemap 表示的空闲块信息</span></span><br><span class="line">    <span class="keyword">bool</span> super_dirty;                               <span class="comment">// superblock/freemap 是否被修改</span></span><br><span class="line">    <span class="keyword">void</span> *sfs_buffer;                               <span class="comment">// 用于从硬盘获取非对齐块信息，以此作为缓冲，并复制给其他缓冲区</span></span><br><span class="line">    <span class="keyword">semaphore_t</span> fs_sem;                             <span class="comment">// 用于互斥访问 fs</span></span><br><span class="line">    <span class="keyword">semaphore_t</span> io_sem;                             <span class="comment">// 用于互斥访问 io </span></span><br><span class="line">    <span class="keyword">semaphore_t</span> mutex_sem;                          <span class="comment">/* semaphore for link/unlink and rename */</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> inode_list;                        <span class="comment">// sfs 所管部分 inode 的链表组织形式</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> *hash_list;                        <span class="comment">// sfs 所管部分 inode 的 hash 表组织形式</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p><code>sfs_inode.c</code> 提供 SFS 关于 <code>inode</code> 操作的实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意：这些操作最终要依托于挂载设备的 dev_node_ops 操作而实现。 </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_ops</span> <span class="title">sfs_node_dirops</span> =</span> &#123;</span><br><span class="line">    .vop_magic                      = VOP_MAGIC,</span><br><span class="line">    .vop_open                       = sfs_opendir,</span><br><span class="line">    .vop_close                      = sfs_close,</span><br><span class="line">    .vop_fstat                      = sfs_fstat,</span><br><span class="line">    .vop_fsync                      = sfs_fsync,</span><br><span class="line">    .vop_namefile                   = sfs_namefile,</span><br><span class="line">    .vop_getdirentry                = sfs_getdirentry,</span><br><span class="line">    .vop_reclaim                    = sfs_reclaim,</span><br><span class="line">    .vop_gettype                    = sfs_gettype,</span><br><span class="line">    .vop_lookup                     = sfs_lookup,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_ops</span> <span class="title">sfs_node_fileops</span> =</span> &#123;</span><br><span class="line">    .vop_magic                      = VOP_MAGIC,</span><br><span class="line">    .vop_open                       = sfs_openfile,</span><br><span class="line">    .vop_close                      = sfs_close,</span><br><span class="line">    .vop_read                       = sfs_read,</span><br><span class="line">    .vop_write                      = sfs_write,</span><br><span class="line">    .vop_fstat                      = sfs_fstat,</span><br><span class="line">    .vop_fsync                      = sfs_fsync,</span><br><span class="line">    .vop_reclaim                    = sfs_reclaim,</span><br><span class="line">    .vop_gettype                    = sfs_gettype,</span><br><span class="line">    .vop_tryseek                    = sfs_tryseek,</span><br><span class="line">    .vop_truncate                   = sfs_truncfile,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h2 id="练习零"><a href="#练习零" class="headerlink" title="练习零"></a>练习零</h2><p>该练习用于了解 <code>ucore</code> 文件系统的实现机制与运行流程。</p>
<h3 id="文件系统的实现机制"><a href="#文件系统的实现机制" class="headerlink" title="文件系统的实现机制"></a>文件系统的实现机制</h3><p><code>ucore</code> 文件系统的实现机制详见 <code>fs_init()</code> ，我们对其进行简要分析：</p>
<ul>
<li><p><code>vfs_init()</code> 初始化 VFS</p>
<p>VFS 主要记录两大数据：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设备信息</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">list_entry_t</span> vdev_list;    </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">semaphore_t</span> vdev_list_sem;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根目录的 inode 信息</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">bootfs_node</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">semaphore_t</span> bootfs_sem;</span><br></pre></td></tr></table></figure>
<p>因此，初始化上述变量即是 <code>vfs_init()</code> 的工作。</p>
</li>
<li><p><code>dev_init()</code> 初始化相关设备</p>
<p>此处设备指代 <code>stdin</code>、<code>stdout</code>、<code>disk0</code>，在此仅以 <code>stdin</code> 的初始化进行说明。</p>
<p><code>stdin</code> 初始化工作主要在于构建 <code>vfs_dev_t</code>，完成相关初始化，并将其加入至 <code>vdev_list</code>。</p>
<p> <code>vfs_dev_t</code> 的详细信息具体如下 (可以看到：各字段均已填充完毕)：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *devname; 				--&gt; <span class="string">&quot;stdin&quot;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">devnode</span>;</span>				--&gt; 下述的 <span class="class"><span class="keyword">struct</span> <span class="title">inode</span></span></span><br><span class="line"><span class="class">    <span class="keyword">struct</span> <span class="title">fs</span> *<span class="title">fs</span>;</span>						--&gt; <span class="literal">NULL</span></span><br><span class="line">    <span class="keyword">bool</span> mountable;						--&gt; <span class="literal">false</span> (设备不同，选项不同。对于 disk0，其选择即为 <span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">list_entry_t</span> vdev_link;</span><br><span class="line">&#125; <span class="keyword">vfs_dev_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">device</span> __<span class="title">device_info</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sfs_inode</span> __<span class="title">sfs_inode_info</span>;</span></span><br><span class="line">    &#125; in_info;							--&gt; 下述的 <span class="class"><span class="keyword">struct</span> <span class="title">device</span></span></span><br><span class="line"><span class="class">    <span class="title">enum</span> &#123;</span></span><br><span class="line">        inode_type_device_info = <span class="number">0x1234</span>,</span><br><span class="line">        inode_type_sfs_inode_info,</span><br><span class="line">    &#125; in_type;							--&gt; inode_type_device_info</span><br><span class="line">    <span class="keyword">int</span> ref_count;						--&gt; <span class="number">1</span></span><br><span class="line">    <span class="keyword">int</span> open_count;						--&gt; <span class="number">0</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fs</span> *<span class="title">in_fs</span>;</span>					--&gt; <span class="literal">NULL</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_ops</span> *<span class="title">in_ops</span>;</span>		--&gt; 上述的 dev_node_ops (重申一次，这些操作具体由 struct device 所定义的四个函数实现)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> &#123;</span></span><br><span class="line">    <span class="keyword">size_t</span> d_blocks;					--&gt; <span class="number">0</span></span><br><span class="line">    <span class="keyword">size_t</span> d_blocksize;					--&gt; <span class="number">1</span></span><br><span class="line">    <span class="keyword">int</span> (*d_open)(struct device *dev, <span class="keyword">uint32_t</span> open_flags);			--&gt; stdin_open</span><br><span class="line">    <span class="keyword">int</span> (*d_close)(struct device *dev);								--&gt; stdin_close</span><br><span class="line">    <span class="keyword">int</span> (*d_io)(struct device *dev, struct iobuf *iob, <span class="keyword">bool</span> write);	--&gt; stdin_io</span><br><span class="line">    <span class="keyword">int</span> (*d_ioctl)(struct device *dev, <span class="keyword">int</span> op, <span class="keyword">void</span> *data);			--&gt; stdin_ioctl</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p><code>sfs_init()</code> 初始化 sfs</p>
<p><code>sfs_init()</code> 的工作在于：挂载 sfs 至 <code>disk0</code>，并使用 <code>disk0</code> 硬盘信息初始化 <code>fs</code>。</p>
<p><code>fs</code> 的详细信息具体如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// disk0 所指代的 vfs_dev_t-&gt;fs = 下述 struct fs</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fs</span> &#123;</span></span><br><span class="line">    <span class="comment">// 具体文件系统的信息 (此实验仅涉及 sfs)。</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sfs_fs</span> __<span class="title">sfs_info</span>;</span>                   </span><br><span class="line">    &#125; fs_info;         					--&gt; 下述的 <span class="class"><span class="keyword">struct</span> <span class="title">sfs_fs</span>                             </span></span><br><span class="line"><span class="class">    // <span class="title">fs</span> 对应的实际文件系统类型</span></span><br><span class="line"><span class="class">    <span class="title">enum</span> &#123;</span></span><br><span class="line">        fs_type_sfs_info,</span><br><span class="line">    &#125; fs_type;                			--&gt; fs_type_sfs_info                     </span><br><span class="line">    <span class="comment">// 针对 fs 的四大操作</span></span><br><span class="line">    <span class="keyword">int</span> (*fs_sync)(struct fs *fs);      			--&gt; sfs_sync (此四者为 sfs 的具体实现)          </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *(*<span class="title">fs_get_root</span>)(<span class="keyword">struct</span> <span class="title">fs</span> *<span class="title">fs</span>);</span>   	--&gt; sfs_get_root</span><br><span class="line">    <span class="keyword">int</span> (*fs_unmount)(struct fs *fs);              	--&gt; sfs_unmount</span><br><span class="line">    <span class="keyword">void</span> (*fs_cleanup)(struct fs *fs);          	--&gt; sfs_cleanup</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sfs_fs</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sfs_super</span> <span class="title">super</span>;</span>             --&gt; disk0 硬盘所存的 superblock</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span>          		--&gt; disk0 所指代的 <span class="class"><span class="keyword">struct</span> <span class="title">device</span></span></span><br><span class="line"><span class="class">    <span class="keyword">struct</span> <span class="title">bitmap</span> *<span class="title">freemap</span>;</span>             --&gt; 新建 freemap，并使用 disk0 硬盘所存信息进行初始化</span><br><span class="line">    <span class="keyword">bool</span> super_dirty;                   --&gt; <span class="literal">false</span></span><br><span class="line">    <span class="keyword">void</span> *sfs_buffer;                   --&gt; 新建的缓冲区  </span><br><span class="line">    <span class="keyword">semaphore_t</span> fs_sem;                 --&gt; 初始化若干信号量</span><br><span class="line">    <span class="keyword">semaphore_t</span> io_sem;                             </span><br><span class="line">    <span class="keyword">semaphore_t</span> mutex_sem;                          </span><br><span class="line">    <span class="keyword">list_entry_t</span> inode_list;            --&gt; 初始化链表            </span><br><span class="line">    <span class="keyword">list_entry_t</span> *hash_list;            --&gt; 初始化 hash 表</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：第二个内核线程 <code>init</code> 的主体实现 <code>init_main()</code> 会设置 <code>disk0</code> 的根目录 <code>inode</code> 为<code>bootfs_node</code>。</p>
</blockquote>
</li>
</ul>
<p>至此，<code>ucore</code> 文件系统已然实现。</p>
<h3 id="文件系统的运行流程"><a href="#文件系统的运行流程" class="headerlink" title="文件系统的运行流程"></a>文件系统的运行流程</h3><p>使用若干文件操作说明 <code>ucore</code> 文件系统的运行流程：</p>
<ul>
<li><p><code>SYS_open</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 系统调用 SYS_open 陷入中断，经获取 path&#x2F;open_flags 参数后，调用 sysfile_open() 进行处理。</span><br><span class="line">2. sysfile_open() 进一步调用 file_open()，它首先从当前进程的文件集中分配 struct file，并调用 vfs_open() 进行处理。</span><br><span class="line">3. vfs_open() 进一步调用 vfs_lookup() 去寻找 path 对应文件的 inode。</span><br><span class="line">	1. vfs_lookup() 借助于 get_device() 获取 path 最初目录的 inode (对于路径 &quot;device:xxx&quot; 而言，即是 device 对应的 inode，它可通过遍历 vdev_list 找到；对于路径 &quot;&#x2F;xxx&quot; 而言，即是 &#x2F; 对应的 inode，它可通过访问 bootfs_node 得到；对于路径 &quot;xxx&quot;，即是工作目录对应的 inode&#96;，它可通过访问 pwd 得到)。</span><br><span class="line">	2. 随后，借助于 vop_lookup() 寻找该目录下对应文件的 inode (该目录的 inode 已知，则可直接调用其具体的 inode_ops)。</span><br><span class="line">4. 如果没有找到对应文件的 inode，而 open_flags 允许新建，则新建一个 inode (该目录是已知的，则其通过 inode_ops 调用的新建流程会自动设置,新建 inode 的 inode_ops 为该文件系统所允许的 inode_ops)，并完成相应的初始化工作。</span><br><span class="line">5. 使用上述得到的 inode 以及 open_flags 填充 struct file。</span><br><span class="line">6. 返回 file-&gt;fd 给用户进程。</span><br></pre></td></tr></table></figure></li>
<li><p><code>SYS_close</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 系统调用 SYS_close 陷入中断，经获取 fd 参数后，调用 sysfile_close() 进行处理。</span><br><span class="line">2. sysfile_close() 进一步调用 file_close()，它首先从当前进程的文件集中获取此 fd 对应的 struct file，并调用 fd_array_close() 进行处理。</span><br><span class="line">3. fd_array_close() 将 file-&gt;open_count 减一，如果此时为 0，则调用 fd_array_free() 进行清理。</span><br><span class="line">4. fd_array_free() 进一步调用 vfs_close()，它会依据 node-&gt;ref_count&#x2F;open_count 是否为 0，进一步调用 vop_close()&#x2F;vop_reclaim() 完成善后工作 (由于 inode 已知，同样可直接调用特定文件系统的 inode_ops )。</span><br></pre></td></tr></table></figure></li>
<li><p><code>SYS_read</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 系统调用 SYS_read 陷入中断，经获取 fd&#x2F;base&#x2F;len 参数后，调用 sysfile_read() 进行处理。</span><br><span class="line">2. sysfile_read() 执行若干预处理操作 (判断是否存在该 fd、分配内核缓冲区)，使用 file_read() 进行读取。</span><br><span class="line">3. file_read() 找到该 fd 对应的 struct file，经过权限是否允许的判断后，使用 vop_read() 读取相关内容至内核缓冲区。</span><br><span class="line">4. vop_read() 会基于 file-&gt; pos 找到相应的物理块，并进一步调用设备的 dev_node_ops 完成读取操作。</span><br><span class="line">5. 层层返回，将内核缓冲区的数据拷贝至用户空间 (可能由于待读取的数据很多，它会多次重复执行 3&#x2F;4&#x2F;5)。</span><br></pre></td></tr></table></figure></li>
<li><p><code>SYS_write</code></p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 系统调用 SYS_write 陷入中断，经获取 fd&#x2F;base&#x2F;len 参数后，调用 sysfile_write() 进行处理。</span><br><span class="line">2. sysfile_write() 执行若干预处理操作 (判断是否存在该 fd、分配内核缓冲区、)。</span><br><span class="line">3. 随后，sysfile_write() 拷贝用户空间数据至内核缓冲区，并使用 file_write() 进行写入。</span><br><span class="line">4. file_write() 找到该 fd 对应的 struct file，经过权限是否允许的判断后，使用 vop_write() 将内核缓冲区内容写入至相关设备。</span><br><span class="line">5. vop_write() 会基于 file-&gt; pos 找到相应的物理块，并进一步调用设备的 dev_node_ops 完成写入操作。</span><br><span class="line">&#x2F;&#x2F; 可能由于待写入的数据很多，它会多次重复执行 3&#x2F;4&#x2F;5。</span><br></pre></td></tr></table></figure>
<h2 id="练习一"><a href="#练习一" class="headerlink" title="练习一"></a>练习一</h2></li>
</ul>
<p>该练习用于实现文件读写的核心函数 <code>sfs_io_nolock()</code>。</p>
<p><code>sfs_io_nolock</code> 实现具体见源代码 (比较繁琐)：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sfs_io_nolock</span><span class="params">(struct sfs_fs *sfs, struct sfs_inode *<span class="built_in">sin</span>, <span class="keyword">void</span> *buf, <span class="keyword">off_t</span> offset, <span class="keyword">size_t</span> *alenp, <span class="keyword">bool</span> write)</span> </span>&#123;</span><br><span class="line">    ... <span class="comment">// 未修改处</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((blkoff = offset % SFS_BLKSIZE) != <span class="number">0</span>)  &#123;</span><br><span class="line">        <span class="comment">// 判断 endpos 和 offset 是否在同一块中?</span></span><br><span class="line">        <span class="comment">// 若为同一块 则 size 为 endpos - offset。</span></span><br><span class="line">        <span class="comment">// 若不为同一块 则 size 为 SFS_BLKSIZE - blkoff(偏移) 为 第一块要读的大小。</span></span><br><span class="line">        size = (nblks != <span class="number">0</span>) ? (SFS_BLKSIZE - blkoff) : (endpos - offset);</span><br><span class="line">        <span class="keyword">if</span> ((ret = sfs_bmap_load_nolock(sfs, <span class="built_in">sin</span>, blkno, &amp;ino)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((ret = sfs_buf_op(sfs, buf, size, ino, blkoff)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        alen += size;</span><br><span class="line">        <span class="keyword">if</span> (nblks == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        buf += size, blkno++; nblks--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中间对齐的情况。</span></span><br><span class="line">    size = SFS_BLKSIZE;</span><br><span class="line">    <span class="keyword">while</span> (nblks != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((ret = sfs_bmap_load_nolock(sfs, <span class="built_in">sin</span>, blkno, &amp;ino)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((ret = sfs_block_op(sfs, buf, ino, <span class="number">1</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        alen += size, buf += size, blkno++, nblks--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 末尾最后一块没对齐的情况。</span></span><br><span class="line">    <span class="keyword">if</span> ((size = endpos % SFS_BLKSIZE) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((ret = sfs_bmap_load_nolock(sfs, <span class="built_in">sin</span>, blkno, &amp;ino)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((ret = sfs_buf_op(sfs, buf, size, ino, <span class="number">0</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        alen += size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    *alenp = alen;</span><br><span class="line">    <span class="keyword">if</span> (offset + alen &gt; <span class="built_in">sin</span>-&gt;din-&gt;size) &#123;</span><br><span class="line">        <span class="built_in">sin</span>-&gt;din-&gt;size = offset + alen;</span><br><span class="line">        <span class="built_in">sin</span>-&gt;dirty = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如何实现 UNIX 的 PIPE 机制？</p>
<p>简单来说，PIPE 用于两个进程通信，前者输出放至管道，后者输入取自管道，输入输出并不同步。那么，两个进程应当对应不同的 <code>struct file</code>，但是对应相同的 <code>struct inode</code> (其对应的实际数据应当直接存放于内核之中)。</p>
<p>另外，对于每个进程而言，其 <code>fd_array[0,1,2]</code> 分别指代输入、输出、错误输出。因此，应当修改前者的输出 <code>fd_array[1]</code> 和后者的输入 <code>fd_array[0]</code> 为上述的 <code>struct file</code>。</p>
</blockquote>
<h2 id="练习二"><a href="#练习二" class="headerlink" title="练习二"></a>练习二</h2><p>该练习用于实现程序加载的核心函数 <code>load_icode()</code>。</p>
<p><code>load_icode()</code> 实现具体见源代码 (可类比 lab7 实现此函数)：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">load_icode</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> argc, <span class="keyword">char</span> **kargv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (current-&gt;mm != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;load_icode: current-&gt;mm must be empty.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ret = -E_NO_MEM;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span></span><br><span class="line">    <span class="keyword">if</span> ((mm = mm_create()) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> bad_mm;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (setup_pgdir(mm) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> bad_pgdir_cleanup_mm;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">page</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">elfhdr</span> __<span class="title">elf</span>, *<span class="title">elf</span> =</span> &amp;__elf;</span><br><span class="line">    <span class="keyword">if</span> ((ret = load_icode_read(fd, elf, <span class="keyword">sizeof</span>(struct elfhdr), <span class="number">0</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> bad_elf_cleanup_pgdir;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (elf-&gt;e_magic != ELF_MAGIC) &#123;</span><br><span class="line">        ret = -E_INVAL_ELF;</span><br><span class="line">        <span class="keyword">goto</span> bad_elf_cleanup_pgdir;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proghdr</span> __<span class="title">ph</span>, *<span class="title">ph</span> =</span> &amp;__ph;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> i;</span><br><span class="line">    <span class="keyword">uint32_t</span> vm_flags, perm;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; elf-&gt;e_phnum; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((ret = load_icode_read(fd, ph, <span class="keyword">sizeof</span>(struct proghdr), elf-&gt;e_phoff + <span class="keyword">sizeof</span>(struct proghdr) * i)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> bad_elf_cleanup_pgdir;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_type != ELF_PT_LOAD) &#123;</span><br><span class="line">            <span class="keyword">continue</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_filesz &gt; ph-&gt;p_memsz) &#123;</span><br><span class="line">            ret = -E_INVAL_ELF;</span><br><span class="line">            <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_filesz == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        vm_flags = <span class="number">0</span>, perm = PTE_U;</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_flags &amp; ELF_PF_X) vm_flags |= VM_EXEC;</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_flags &amp; ELF_PF_W) vm_flags |= VM_WRITE;</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_flags &amp; ELF_PF_R) vm_flags |= VM_READ;</span><br><span class="line">        <span class="keyword">if</span> (vm_flags &amp; VM_WRITE) perm |= PTE_W;</span><br><span class="line">        <span class="keyword">if</span> ((ret = mm_map(mm, ph-&gt;p_va, ph-&gt;p_memsz, vm_flags, <span class="literal">NULL</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">off_t</span> offset = ph-&gt;p_offset;</span><br><span class="line">        <span class="keyword">size_t</span> off, size;</span><br><span class="line">        <span class="keyword">uintptr_t</span> start = ph-&gt;p_va, end, la = ROUNDDOWN(start, PGSIZE);</span><br><span class="line"></span><br><span class="line">        ret = -E_NO_MEM;</span><br><span class="line"></span><br><span class="line">        end = ph-&gt;p_va + ph-&gt;p_filesz;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((page = pgdir_alloc_page(mm-&gt;pgdir, la, perm)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line">            &#125;</span><br><span class="line">            off = start - la, size = PGSIZE - off, la += PGSIZE;</span><br><span class="line">            <span class="keyword">if</span> (end &lt; la) &#123;</span><br><span class="line">                size -= la - end;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((ret = load_icode_read(fd, page2kva(page) + off, size, offset)) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line">            &#125;</span><br><span class="line">            start += size, offset += size;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        end = ph-&gt;p_va + ph-&gt;p_memsz;</span><br><span class="line">        <span class="keyword">if</span> (start &lt; la) &#123;</span><br><span class="line">            <span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">                <span class="keyword">continue</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            off = start + PGSIZE - la, size = PGSIZE - off;</span><br><span class="line">            <span class="keyword">if</span> (end &lt; la) &#123;</span><br><span class="line">                size -= la - end;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">memset</span>(page2kva(page) + off, <span class="number">0</span>, size);</span><br><span class="line">            start += size;</span><br><span class="line">            assert((end &lt; la &amp;&amp; start == end) || (end &gt;= la &amp;&amp; start == la));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((page = pgdir_alloc_page(mm-&gt;pgdir, la, perm)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line">            &#125;</span><br><span class="line">            off = start - la, size = PGSIZE - off, la += PGSIZE;</span><br><span class="line">            <span class="keyword">if</span> (end &lt; la) &#123;</span><br><span class="line">                size -= la - end;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">memset</span>(page2kva(page) + off, <span class="number">0</span>, size);</span><br><span class="line">            start += size;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    vm_flags = VM_READ | VM_WRITE | VM_STACK;</span><br><span class="line">    <span class="keyword">if</span> ((ret = mm_map(mm, USTACKTOP - USTACKSIZE, USTACKSIZE, vm_flags, <span class="literal">NULL</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line">    &#125;</span><br><span class="line">    assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP-PGSIZE , PTE_USER) != <span class="literal">NULL</span>);</span><br><span class="line">    assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP<span class="number">-2</span>*PGSIZE , PTE_USER) != <span class="literal">NULL</span>);</span><br><span class="line">    assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP<span class="number">-3</span>*PGSIZE , PTE_USER) != <span class="literal">NULL</span>);</span><br><span class="line">    assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP<span class="number">-4</span>*PGSIZE , PTE_USER) != <span class="literal">NULL</span>);</span><br><span class="line">    mm_count_inc(mm);</span><br><span class="line">    current-&gt;mm = mm;</span><br><span class="line">    current-&gt;cr3 = PADDR(mm-&gt;pgdir);</span><br><span class="line">    lcr3(PADDR(mm-&gt;pgdir));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 相比于 lab7 实现，该实现需要妥善放置 argc 和 kargv 至用户栈，因此需要一番计算，使得其尽量减少不必要存储消耗，且能保证 kargv[i] 能顺利索引到相应的字符串。</span></span><br><span class="line">    <span class="comment">// 先算出所有参数加起来的长度</span></span><br><span class="line">    <span class="keyword">uint32_t</span> total_len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc; ++i) &#123;</span><br><span class="line">        total_len += strnlen(kargv[i], EXEC_MAX_ARG_LEN) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 用户栈顶 减去所有参数加起来的长度 再 4字节对齐 找到 真正存放字符串参数的栈的位置</span></span><br><span class="line">    <span class="keyword">char</span> *arg_str = (USTACKTOP - total_len) &amp; <span class="number">0xfffffffc</span>;</span><br><span class="line">    <span class="comment">// 放字符串参数的栈的位置的下面 是存放指向字符串参数的指针</span></span><br><span class="line">    <span class="keyword">int32_t</span> *arg_ptr = (<span class="keyword">int32_t</span> *)arg_str - argc;</span><br><span class="line">    <span class="comment">// 指向字符串参数的指针下面 是参数的个数</span></span><br><span class="line">    <span class="keyword">int32_t</span> *stacktop = arg_ptr - <span class="number">1</span>;</span><br><span class="line">    *stacktop = argc;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc; ++i) &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> arg_len = strnlen(kargv[i], EXEC_MAX_ARG_LEN);</span><br><span class="line">        <span class="built_in">strncpy</span>(arg_str, kargv[i], arg_len);</span><br><span class="line">        *arg_ptr = arg_str;</span><br><span class="line">        arg_str += arg_len + <span class="number">1</span>;</span><br><span class="line">        ++arg_ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">tf</span> =</span> current-&gt;tf;</span><br><span class="line">    <span class="built_in">memset</span>(tf, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct trapframe));</span><br><span class="line"></span><br><span class="line">    tf-&gt;tf_cs = USER_CS;</span><br><span class="line">    tf-&gt;tf_ds = tf-&gt;tf_es = tf-&gt;tf_ss = USER_DS;</span><br><span class="line">    tf-&gt;tf_esp = stacktop;</span><br><span class="line">    tf-&gt;tf_eip = elf-&gt;e_entry;</span><br><span class="line">    tf-&gt;tf_eflags |= FL_IF;</span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">bad_cleanup_mmap:</span><br><span class="line">    exit_mmap(mm);</span><br><span class="line">bad_elf_cleanup_pgdir:</span><br><span class="line">    put_pgdir(mm);</span><br><span class="line">bad_pgdir_cleanup_mm:</span><br><span class="line">    mm_destroy(mm);</span><br><span class="line">bad_mm:</span><br><span class="line">    <span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ucore</category>
      </categories>
  </entry>
  <entry>
    <title>lab7 — 同步互斥</title>
    <url>/2021/06/29/ucore/lab7/</url>
    <content><![CDATA[<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>临界区、信号量、条件变量、管程。</p>
<a id="more"></a>

<h2 id="改动点"><a href="#改动点" class="headerlink" title="改动点"></a>改动点</h2><p>相比于 <code>lab6</code> 源代码，<code>lab7</code> 主要做了如下改动：</p>
<ul>
<li><code>sched.[ch]</code> 增加定时器机制，用以实现 <code>do_sleep()</code> 功能</li>
<li><code>wait.[ch]</code> 实现基于链表形式的等待队列</li>
<li><code>sem.[ch]</code> 实现信号量机制</li>
<li><code>monitor.[ch]</code> 实现基于管程的条件变量机制</li>
</ul>
<h2 id="练习零"><a href="#练习零" class="headerlink" title="练习零"></a>练习零</h2><p>该练习用于了解定时器机制的实现流程。</p>
<p>为实现此机制，首先需要使用相关数据结构以表征定时任务：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 表征定时任务</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> expires;       <span class="comment">// 任务的到期时间 (实际实现中，各定时任务按到期时间，由近至远串接至 timer_list。为简化定时更新操作，该字段含义变更为：当前定时任务距离前一个定时任务的时间间隔)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span>;</span>   <span class="comment">// 所涉的进程</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> timer_link;    <span class="comment">// 链接至 timer_list</span></span><br><span class="line">&#125; <span class="keyword">timer_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定时任务链表首部，用以串接各定时任务</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">list_entry_t</span> timer_list;</span><br></pre></td></tr></table></figure>
<p>各字段含义已经明确，<code>add_timer()/del_timer()</code> 的实现就比较简单，唯一需要注意的是：正确更新相关 <code>timer_t</code> 的 <code>expires</code> 字段。</p>
<p>接下来，便是如何动态感知定时任务是否到期，从而唤醒相关进程？</p>
<p>对于操作系统而言，它借助于时钟中断以感知时间变化，因此当时钟中断发生时，它会调用特定函数 (<code>ucore</code> 中的 <code>run_time_list()</code> ) 以动态感知定时任务，并且可能执行相关唤醒操作，最后，动态更新当前进程的时间片信息，从而判断是否需要切换调度。</p>
<blockquote>
<p>简单提一下，用户进程如何使用定时器？</p>
<p>简单流程：用户调用 <code>sleep(time)</code>  –&gt;  中断触发 <code>sys_sleep()</code>  –&gt;  间接调用 <code>do_sleep(time)</code>  –&gt;  <code>add_timer()</code>。</p>
</blockquote>
<h2 id="练习一"><a href="#练习一" class="headerlink" title="练习一"></a>练习一</h2><p>该练习用于了解信号量机制的实现流程。</p>
<blockquote>
<p>为实现互斥方法，总共存在三种方案：基于软件设计、基于硬件中断、基于硬件提供的原子操作。</p>
<p>在 <code>ucore</code> 中，使用最简单的 “基于硬件中断” 实现信号量机制。</p>
</blockquote>
<p>先行给出信号量机制实现的形式化描述 (信号量实现基本与此相同)：</p>
<img src="/2021/06/29/ucore/lab7/image-20210629110354732.png" width="50%;">

<p>对于信号量而言，它使用如下数据结构进行表征：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 信号量</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value; 					<span class="comment">// 共享资源的数目</span></span><br><span class="line">    <span class="keyword">wait_queue_t</span> wait_queue; 	<span class="comment">// 欲共享该资源的等待队列</span></span><br><span class="line">&#125; <span class="keyword">semaphore_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待队列</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> wait_head; 	<span class="comment">// 链首</span></span><br><span class="line">&#125; <span class="keyword">wait_queue_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待队列中的元素</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span>;</span> 	<span class="comment">// 所涉的进程</span></span><br><span class="line">    <span class="keyword">uint32_t</span> wakeup_flags;  	<span class="comment">// 该进程放置于等待队列中的原因 (例如：信号量、定时)</span></span><br><span class="line">    <span class="keyword">wait_queue_t</span> *wait_queue;	<span class="comment">// 所在的等待队列</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> wait_link;		<span class="comment">// 联结至 wait_head</span></span><br><span class="line">&#125; <span class="keyword">wait_t</span>;</span><br></pre></td></tr></table></figure>
<p>信号量对应的 <code>P()/V()</code> 操作，具体见源代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> __noinline <span class="keyword">void</span> __up(<span class="keyword">semaphore_t</span> *sem, <span class="keyword">uint32_t</span> wait_state) &#123;</span><br><span class="line">    <span class="keyword">bool</span> intr_flag;</span><br><span class="line">    <span class="comment">// local_intr_save 表示关中断，local_intr_restore 表示开中断。</span></span><br><span class="line">    <span class="comment">// 中断关闭，保证只有当前进程可以运行，从而保证这部分操作的原子性。</span></span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">wait_t</span> *wait;</span><br><span class="line">        <span class="comment">// 如果等待队列内部不存在等待进程，则资源数量加一，否则选择一个等待进程调度即可。</span></span><br><span class="line">        <span class="keyword">if</span> ((wait = wait_queue_first(&amp;(sem-&gt;wait_queue))) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            sem-&gt;value ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            assert(wait-&gt;proc-&gt;wait_state == wait_state);</span><br><span class="line">            wakeup_wait(&amp;(sem-&gt;wait_queue), wait, wait_state, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> __noinline <span class="keyword">uint32_t</span> __down(<span class="keyword">semaphore_t</span> *sem, <span class="keyword">uint32_t</span> wait_state) &#123;</span><br><span class="line">    <span class="keyword">bool</span> intr_flag;</span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    <span class="comment">// 如果仍存在资源可访问，则直接访问即可。</span></span><br><span class="line">    <span class="keyword">if</span> (sem-&gt;value &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        sem-&gt;value --;</span><br><span class="line">        local_intr_restore(intr_flag);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 表明已不存在资源可访问，则将当前进程放置于等待队列内部。</span></span><br><span class="line">    <span class="keyword">wait_t</span> __wait, *wait = &amp;__wait;</span><br><span class="line">    wait_current_set(&amp;(sem-&gt;wait_queue), wait, wait_state);</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调度其他进程运行。</span></span><br><span class="line">    schedule();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前进程再次运行，则表明其已获取资源。</span></span><br><span class="line">	...</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>虽然形式化与具体实现并不相同，但是两者是等价的。</p>
<p>两者的主要差别在于：在形式化中，<code>sem</code> 表征正在使用、预定使用共享资源后，共享资源的剩余数目；在具体实现中，<code>value</code> 表征正在使用共享资源后，共享资源的剩余数目 (此时，共享资源的剩余数目只可能大于等于零，而不可能小于零)。</p>
</blockquote>
<blockquote>
<p>如何为用户态进程提供信号量机制？</p>
<p>肯定需要使用系统调用。</p>
<p>当用户态进程使用创建信号量的系统调用时，OS 内部创建 <code>semaphore_t</code> 结构体，但是返回给用户态进程的标识则是另一个 (可能的情况，在 PCB 内部维护信号量数组，返回的是信号量在此数组的下标)。</p>
<p>当用户态进程使用 <code>up/down</code> 的系统调用时，OS 从当前进程的 PCB 找到相应的  <code>semaphore_t</code> 结构体，然后执行相关操作即可。</p>
</blockquote>
<h2 id="练习二"><a href="#练习二" class="headerlink" title="练习二"></a>练习二</h2><p>该练习用于了解基于管程的条件变量机制的实现流程。</p>
<blockquote>
<p>信号量可以实现互斥访问，也可实现进程间同步。因为基于信号量的进程间同步比较麻烦，而且容易出错误，因此出现了 <strong>条件变量</strong> (注意：条件变量仍是以信号量为基础)。</p>
<p>信号量和条件变量均是偏底层、用于互斥访问和进程间同步的方法，使用起来也是比较麻烦的。为进一步简化使用，更高层级的抽象形式 <strong>管程</strong> 便出现了。</p>
</blockquote>
<p>简而言之，<strong>管程</strong> 是一个黑盒，程序员往里扔的函数，它可确保在同一时刻，只有一个函数在执行 (亦因如此，确保其内部共享数据的互斥访问)。</p>
<blockquote>
<p>管程的实现方式分为多种，其主要区别在于：假定线程 A 因等待某条件而处于等待队列，线程 B 满足该条件后，线程 B 具有哪种行为？</p>
<ul>
<li><code>Mesa Semantics</code>：线程 B 执行 <code>cond_signal</code> ，因而线程 A 从等待队列移除，并放置于就绪队列，然后线程 B 继续执行。</li>
<li><code>Hanson Semantics</code>：线程 B 执行完成并退出的同时，执行 <code>cond_signal</code>，因而线程 A 从等待队列移除，并放置于就绪队列。</li>
<li><code>Hoare Semantics</code>：线程 B 执行 <code>cond_signal</code>，因而线程 A 从等待队列移除，并放置于就绪队列，然后立即阻塞线程 B，并等待线程 A 被执行。</li>
</ul>
<p>对于这三种方式，实际实现基于前两种 (因为可以减少一次上下文切换)，书本介绍基于后一种。</p>
<p>在 <code>ucore</code> 中，管程即是基于后一种实现的，由于需要保证 <code>cond_signal</code> 执行的同时，阻塞当前线程，因此其实现有些麻烦。</p>
<p>另外，管程属于更高层级的抽象形式，往往适用于 Java 等高级语言实现，这里实现一种基于 C 语言的、简化版的管程。</p>
</blockquote>
<p>管程基于信号量和条件变量而实现，信号量的实现前面已经谈及，在此给出条件变量实现的形式化描述 (条件变量实现基本与此大不相同)：</p>
<img src="/2021/06/29/ucore/lab7/image-20210629151705122.png" width="50%;">

<blockquote>
<p>根据此图，简单说明 <code>Mesa Semantics</code> 实现所存在的小缺陷。</p>
<p>线程 B 执行 <code>cond_signal</code> 后，它只是将线程 A 放置于就绪队列，此时即便调度至线程 A，由于其需要再次获取 <code>lock</code>，而此时 <code>lock</code> 仍归线程 B 所有，因此线程 A 仍无法运行，只能等待线程 B 执行完成并释放 <code>lock</code>，然后才能执行线程 A (如果调度线程 A 前调度了其他进程进入管程，有可能使得线程 A 的条件再次无法满足。因此，当线程 A 执行时，其需要循环判断条件是否满足)。</p>
</blockquote>
<p>对于管程而言，它使用如下数据结构进行表征：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 条件变量</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">condvar</span>&#123;</span></span><br><span class="line">    <span class="keyword">semaphore_t</span> sem;        <span class="comment">// 借助于信号量，间接使用等待队列 (最初设置信号量为 0)。</span></span><br><span class="line">    <span class="keyword">int</span> count;              <span class="comment">// 在此条件变量上等待的进程数量</span></span><br><span class="line">    <span class="keyword">monitor_t</span> * owner;      <span class="comment">// 所属的管程</span></span><br><span class="line">&#125; <span class="keyword">condvar_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 管程</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">monitor</span>&#123;</span></span><br><span class="line">    <span class="keyword">semaphore_t</span> mutex;      <span class="comment">// 互斥访问管程内部的数据结构，初始化为 1。</span></span><br><span class="line">    <span class="comment">// next_count 指代由于发出 cond_signal 而睡眠的进程数量，next 只是用于构建一个发出 cond_signal 而睡眠的进程的等待队列。此二者是实现 Hoare Semantics 的关键。</span></span><br><span class="line">    <span class="keyword">semaphore_t</span> next;      </span><br><span class="line">    <span class="keyword">int</span> next_count;         </span><br><span class="line">    <span class="keyword">condvar_t</span> *cv;          <span class="comment">// 管程内部的条件变量列表</span></span><br><span class="line">&#125; <span class="keyword">monitor_t</span>;</span><br></pre></td></tr></table></figure>
<p>首先给出初始化过程：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">monitor_init</span> <span class="params">(<span class="keyword">monitor_t</span> * mtp, <span class="keyword">size_t</span> num_cv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">// 初始值 next_count 自然为 0。</span></span><br><span class="line">    mtp-&gt;next_count = <span class="number">0</span>;</span><br><span class="line">    mtp-&gt;cv = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// mutex 置 1，表示当前管程尚无进程访问，next 只是用于构建等待队列，因此置 0。</span></span><br><span class="line">    sem_init(&amp;(mtp-&gt;mutex), <span class="number">1</span>); </span><br><span class="line">    sem_init(&amp;(mtp-&gt;next), <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 为条件变量分配空间，并依据字段含义进行初始化。</span></span><br><span class="line">    mtp-&gt;cv =(<span class="keyword">condvar_t</span> *) kmalloc(<span class="keyword">sizeof</span>(<span class="keyword">condvar_t</span>)*num_cv);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;num_cv; i++)&#123;</span><br><span class="line">        mtp-&gt;cv[i].count=<span class="number">0</span>;</span><br><span class="line">        sem_init(&amp;(mtp-&gt;cv[i].sem),<span class="number">0</span>);</span><br><span class="line">        mtp-&gt;cv[i].owner=mtp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来是条件变量的 <code>cond_wait()/cond_signal()</code>，具体见源代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cond_signal</span> <span class="params">(<span class="keyword">condvar_t</span> *cvp)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果当前条件变量上并不存在等待进程，则直接返回，否则执行如下操作。</span></span><br><span class="line">   <span class="keyword">if</span> (cvp-&gt;count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="keyword">monitor_t</span>* mon = cvp-&gt;owner;</span><br><span class="line">       mon-&gt;next_count++;</span><br><span class="line">       <span class="comment">// 唤醒当前条件变量所示等待队列上的一个。</span></span><br><span class="line">       up(&amp;(cvp-&gt;sem));</span><br><span class="line">       <span class="comment">// 将当前进程添加至 next 所示的等待队列上、使 next_count 加一，并选择调度其他进程。</span></span><br><span class="line">       down(&amp;(mon-&gt;next));</span><br><span class="line">       <span class="comment">// 再次执行时，当前进程唤醒，因而需要使next_count 减一。 </span></span><br><span class="line">       mon-&gt;next_count--;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cond_wait</span> <span class="params">(<span class="keyword">condvar_t</span> *cvp)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前条件变量上等待进程数加一。</span></span><br><span class="line">    cvp-&gt;count++;</span><br><span class="line">    <span class="keyword">monitor_t</span>* mon = cvp-&gt;owner;</span><br><span class="line">    <span class="comment">// 如果 next 所示的等待队列上存在进程，则唤醒其中的一个，否则唤醒管程等待队列上的一个。</span></span><br><span class="line">    <span class="keyword">if</span> (mon-&gt;next_count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        up(&amp;(mon-&gt;next));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        up(&amp;(mon-&gt;mutex));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将当前进程添加至等待队列，并选择调度其他进程。</span></span><br><span class="line">    down(&amp;(cvp-&gt;sem));</span><br><span class="line">    <span class="comment">// 再次执行时，表明条件已经满足，当前条件变量上等待进程数减一。</span></span><br><span class="line">    cvp-&gt;count--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，当编写管程内部函数时，其格式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">xxx</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    down(&amp;(mtp-&gt;mutex));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//--------the real body of function--------------</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(mtp-&gt;next_count&gt;<span class="number">0</span>)</span><br><span class="line">        up(&amp;(mtp-&gt;next));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        up(&amp;(mtp-&gt;mutex));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>似乎，高级语言内部实现管程是比较简单的。</p>
<p>对于一个普通的类而言，隐式添加成员变量 <code>mutex</code>、在各方法前后隐式添加获取和释放 <code>mutex</code> 的代码、向 <code>cond_wait()</code> 传递 <code>mutex</code> 即可(条件变量的设置和使用需要由用户编写，因为这部分涉及具体逻辑)。</p>
</blockquote>
<p>鉴于条件变量的两个操作难于理解，在此以一个例子进行说明。</p>
<p>所涉线程：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">线程 A:							线程 B:</span><br><span class="line">	...								...</span><br><span class="line">	cond_wait();					cond_signal();</span><br><span class="line">	...								...</span><br></pre></td></tr></table></figure>
<p>执行流程：</p>
<ol>
<li>线程 A 获取 <code>mutex</code>，从而开始执行。后续因等待某条件发生，因而执行 <code>cond_wait()</code>。</li>
<li><code>cond_wait()</code> 执行后，将线程 A 添加至该条件变量对应的等待队列中，并调度其他线程执行 (因为目前 next 所示的等待队列为空，因而执行 <code>up(&amp;(mon-&gt;mutex))</code>，从而释放 <code>mutex</code>)。</li>
<li>线程 B 获取 <code>mutex</code>，从而开始执行。后续满足某条件，因而执行 <code>cond_signal()</code>。</li>
<li><code>cond_signal()</code> 执行后，唤醒该条件变量对应的等待队列上的一个线程，将当前线程添加至 <code>next</code> 所示的等待队列上，并调度其他线程执行。</li>
<li>线程 A 继续执行其函数体，后续因为 <code>next_count &gt; 0</code> 唤醒 <code>next</code> 所示等待队列上的一个线程，然后完成执行。</li>
<li>线程 B 继续执行其函数体，后续因为 <code>next_count = 0</code>，释放 <code>mutex</code>，然后完成执行。</li>
</ol>
<p>针对上述流程，需要留意几点：</p>
<ol>
<li>线程 A 再次获取执行权限时，其并没有获取锁 <code>mutex</code>，而是继续使用线程 B 所获取的锁 <code>mutex</code>。因为线程 B 已经睡眠，因此这里不会发生互斥访问 。</li>
<li>线程 A 退出时，它所做的操作是唤醒线程 B，而非释放锁。释放锁的操作由最初获取锁的线程 B 自己释放。</li>
</ol>
<blockquote>
<p>综合说明 <code>Hoare Semantics</code> 实现中保证互斥访问的机制：</p>
<ol>
<li>线程间如果不存在条件变量的羁绊，则其依靠 <code>mutex</code> 实现互斥访问。</li>
<li>线程间如果存在条件变量的羁绊，执行 <code>cond_signal()</code> 的线程与执行 <code>cond_wait()</code> 的线程共享前者的锁，但是由于 <code>cond_signal()</code> 执行会阻塞一个、唤醒一个，故仍然保证互斥访问。</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>ucore</category>
      </categories>
  </entry>
  <entry>
    <title>lab6 — 调度器</title>
    <url>/2021/06/21/ucore/lab6/</url>
    <content><![CDATA[<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>进程调度算法。</p>
<a id="more"></a>

<h2 id="改动点"><a href="#改动点" class="headerlink" title="改动点"></a>改动点</h2><p>相比于 <code>lab5</code> 源代码，<code>lab6</code> 主要做了如下改动：</p>
<ul>
<li><p><code>proc.h</code> 扩展 <code>struct proc_struct</code> 成员属性</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> &#123;</span></span><br><span class="line">    ... <span class="comment">// 同以往结构的属性</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">run_queue</span> *<span class="title">rq</span>;</span>                       <span class="comment">// 该进程所在的 run_queue</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> run_link;                      <span class="comment">// 以链表形式链接各就绪进程</span></span><br><span class="line">    <span class="keyword">int</span> time_slice;                             <span class="comment">// 该进程所占用的 CPU 时间片</span></span><br><span class="line">    <span class="keyword">skew_heap_entry_t</span> lab6_run_pool;            <span class="comment">// FOR LAB6 ONLY: 以优先队列形式链接各就绪进程</span></span><br><span class="line">    <span class="comment">// 当前进程的 stride 和优先级属性。</span></span><br><span class="line">    <span class="keyword">uint32_t</span> lab6_stride;                       <span class="comment">// FOR LAB6 ONLY: 该进程对应的 stride 属性 (此二者用于 stride 调度算法)</span></span><br><span class="line">    <span class="keyword">uint32_t</span> lab6_priority;                     <span class="comment">// FOR LAB6 ONLY: 该进程对应的 priority 属性</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在 <code>alloc_proc()</code> 实现中，增加这些属性的初始化工作：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">list_init(&amp;(proc-&gt;run_link));</span><br><span class="line">proc-&gt;time_slice = <span class="number">0</span>;</span><br><span class="line">skew_heap_init(&amp;(proc-&gt;lab6_run_pool));</span><br><span class="line">proc-&gt;lab6_stride = <span class="number">0</span>;</span><br><span class="line">proc-&gt;lab6_priority = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>schedule.[ch]</code> 增加调度器框架信息</p>
<p><code>ucore</code> 调度器框架使用 <code>struct sched_class</code> 加以表示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> &#123;</span></span><br><span class="line">    <span class="comment">// 调度器名称</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="comment">// 初始化调度器</span></span><br><span class="line">    <span class="keyword">void</span> (*init)(struct run_queue *rq);</span><br><span class="line">    <span class="comment">// 进程入队</span></span><br><span class="line">    <span class="keyword">void</span> (*enqueue)(struct run_queue *rq, struct proc_struct *proc);</span><br><span class="line">    <span class="comment">// 进程出队</span></span><br><span class="line">    <span class="keyword">void</span> (*dequeue)(struct run_queue *rq, struct proc_struct *proc);</span><br><span class="line">    <span class="comment">// 选择待运行的进程</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *(*<span class="title">pick_next</span>)(<span class="keyword">struct</span> <span class="title">run_queue</span> *<span class="title">rq</span>);</span></span><br><span class="line">    <span class="comment">// 时钟触发的处理函数</span></span><br><span class="line">    <span class="keyword">void</span> (*proc_tick)(struct run_queue *rq, struct proc_struct *proc);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>ucore</code> 调度器具体使用 <code>struct run_queue</code> 进行处理：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">run_queue</span> &#123;</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> run_list;						<span class="comment">// 进程集合的链表形式    </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> proc_num;						<span class="comment">// 进程集合总数</span></span><br><span class="line">    <span class="keyword">int</span> max_time_slice;							<span class="comment">// 进程运行的最大时间片</span></span><br><span class="line">    <span class="keyword">skew_heap_entry_t</span> *lab6_run_pool;			<span class="comment">// For LAB6 ONLY: 进程集合的优先队列形式</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p><code>trap.c</code> 更新时钟中断的处理程序</p>
<p>每当发生时钟中断，调用 <code>ucore</code> 调度器的 <code>proc_tick()</code> 函数，从而使得调度器能够动态感知时间变化，并更新相关进程的某些调度属性信息。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> IRQ_OFFSET + IRQ_TIMER:</span><br><span class="line">        ticks++;</span><br><span class="line">        sched_class_proc_tick(current);</span><br></pre></td></tr></table></figure></li>
<li><p><code>default_sched.[ch]</code> 实现 Round-Robin 调度算法</p>
</li>
<li><p><code>sched.c</code> 更新 <code>wakeup_proc()</code> 操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wakeup_proc</span><span class="params">(struct proc_struct *proc)</span> </span>&#123;</span><br><span class="line">    assert(proc-&gt;state != PROC_ZOMBIE);</span><br><span class="line">    <span class="keyword">bool</span> intr_flag;</span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// proc 若未处于 RUNNABLE 状态，则置为此状态。</span></span><br><span class="line">        <span class="keyword">if</span> (proc-&gt;state != PROC_RUNNABLE) &#123;</span><br><span class="line">            proc-&gt;state = PROC_RUNNABLE;</span><br><span class="line">            proc-&gt;wait_state = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 若当前进程并非 proc，则将 proc 入队 (出现情况：当前进程创建子进程，子进程的 do_fork 最后一步会调用此函数，从而将其入队管理)。</span></span><br><span class="line">            <span class="keyword">if</span> (proc != current) &#123;</span><br><span class="line">                sched_class_enqueue(proc);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            warn(<span class="string">&quot;wakeup runnable process.\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>skew_heap.h</code> 提供斜堆的具体实现</p>
</li>
</ul>
<h2 id="练习一"><a href="#练习一" class="headerlink" title="练习一"></a>练习一</h2><p>该练习用于了解 Round-Robin 调度算法的具体实现。</p>
<p>Round-Robin 调度算法比较简单，直接查看源代码实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化 RR，只需初始化进程集合，并重置相关属性即可 (max_time_slice 属性由调用者自主设置)。</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RR_init</span><span class="params">(struct run_queue *rq)</span> </span>&#123;</span><br><span class="line">    list_init(&amp;(rq-&gt;run_list));</span><br><span class="line">    rq-&gt;proc_num = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入队。</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RR_enqueue</span><span class="params">(struct run_queue *rq, struct proc_struct *proc)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 放置当前进程于进程集合尾部。</span></span><br><span class="line">    list_add_before(&amp;(rq-&gt;run_list), &amp;(proc-&gt;run_link));</span><br><span class="line">    <span class="comment">// 如果其所剩时间片为 0，或不符合条件，则重置之。</span></span><br><span class="line">    <span class="keyword">if</span> (proc-&gt;time_slice == <span class="number">0</span> || proc-&gt;time_slice &gt; rq-&gt;max_time_slice) &#123;</span><br><span class="line">        proc-&gt;time_slice = rq-&gt;max_time_slice;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新其他属性。</span></span><br><span class="line">    proc-&gt;rq = rq;</span><br><span class="line">    rq-&gt;proc_num ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出队，进程集合中删除此进程，并初始化此进程的 run_link 即可。</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RR_dequeue</span><span class="params">(struct run_queue *rq, struct proc_struct *proc)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    list_del_init(&amp;(proc-&gt;run_link));</span><br><span class="line">    rq-&gt;proc_num --;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选择进程集合首部元素作为待运行的进程即可。</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct proc_struct * <span class="title">RR_pick_next</span><span class="params">(struct run_queue *rq)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">list_entry_t</span> *le = list_next(&amp;(rq-&gt;run_list));</span><br><span class="line">    <span class="keyword">if</span> (le != &amp;(rq-&gt;run_list)) &#123;</span><br><span class="line">        <span class="keyword">return</span> le2proc(le, run_link);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每次发生时钟中断，更新当前进程可用的时间片，如果可用时间片为 0，则设置 need_resched 以调度其他进程 (该字段在 trap() 的 if(!in_kernel) 内起作用)。</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RR_proc_tick</span><span class="params">(struct run_queue *rq, struct proc_struct *proc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (proc-&gt;time_slice &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        proc-&gt;time_slice --;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (proc-&gt;time_slice == <span class="number">0</span>) &#123;</span><br><span class="line">        proc-&gt;need_resched = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sched_class 的 RR 实现</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> <span class="title">default_sched_class</span> =</span> &#123;</span><br><span class="line">    .name = <span class="string">&quot;RR_scheduler&quot;</span>,</span><br><span class="line">    .init = RR_init,</span><br><span class="line">    .enqueue = RR_enqueue,</span><br><span class="line">    .dequeue = RR_dequeue,</span><br><span class="line">    .pick_next = RR_pick_next,</span><br><span class="line">    .proc_tick = RR_proc_tick,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="练习二"><a href="#练习二" class="headerlink" title="练习二"></a>练习二</h2><p>该练习用于实现 Stride 调度算法。</p>
<p>首先简单介绍 Stride 调度算法的基本思想：Stride 调用算法仍是基于时间片以调度进程，但是它每次选择进展最慢 (表征进程的 <code>struct proc_struct</code> 结构中，<code>stride</code> 表示当前进程的进展度，<code>BIG_STRIDE / priority</code> 表征当前进程被调度后的进展增加值) 的进程加以调度。</p>
<p>接下来，给出 Stride 调度算法的具体实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// BIG_STRIDE 取值具有一定原因，它可以保证即使 stride 取值溢出，仍可正确实现两个进程的 stride 比较操作，原理忽略。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIG_STRIDE    (((uint32_t)-1) / 2)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个进程的 stride 比较操作，用于构建斜堆。</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">proc_stride_comp_f</span><span class="params">(<span class="keyword">void</span> *a, <span class="keyword">void</span> *b)</span> </span>&#123;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">p</span> =</span> le2proc(a, lab6_run_pool);</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">q</span> =</span> le2proc(b, lab6_run_pool);</span><br><span class="line">     <span class="keyword">int32_t</span> c = p-&gt;lab6_stride - q-&gt;lab6_stride;</span><br><span class="line">     <span class="keyword">if</span> (c &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 Stride，只需初始化进程集合，并重置相关属性即可。</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">stride_init</span><span class="params">(struct run_queue *rq)</span> </span>&#123;</span><br><span class="line">     list_init(&amp;(rq-&gt;run_list)); <span class="comment">// 是否初始化进程集合的链表形式都可，因为不会用到。</span></span><br><span class="line">     rq-&gt;lab6_run_pool = <span class="literal">NULL</span>;</span><br><span class="line">     rq-&gt;proc_num = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入队，插入当前进程至斜堆，并更新相关属性。</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">stride_enqueue</span><span class="params">(struct run_queue *rq, struct proc_struct *proc)</span> </span>&#123;  </span><br><span class="line">     rq-&gt;lab6_run_pool = skew_heap_insert(rq-&gt;lab6_run_pool, &amp;(proc-&gt;lab6_run_pool), proc_stride_comp_f);</span><br><span class="line">     <span class="comment">// 如果尚未初始化 priority，则默认取值为 1。</span></span><br><span class="line">     <span class="keyword">if</span> (proc-&gt;lab6_priority == <span class="number">0</span>)</span><br><span class="line">     &#123;</span><br><span class="line">          proc-&gt;lab6_priority = <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">if</span> (proc-&gt;time_slice == <span class="number">0</span> || proc-&gt;time_slice &gt; rq-&gt;max_time_slice) &#123;</span><br><span class="line">           proc-&gt;time_slice = rq-&gt;max_time_slice;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">     proc-&gt;rq = rq;</span><br><span class="line">     rq-&gt;proc_num++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出队，斜堆删除特定进程。</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">stride_dequeue</span><span class="params">(struct run_queue *rq, struct proc_struct *proc)</span> </span>&#123;</span><br><span class="line">     rq-&gt;lab6_run_pool = skew_heap_remove(rq-&gt;lab6_run_pool, &amp;(proc-&gt;lab6_run_pool), proc_stride_comp_f);</span><br><span class="line">     rq-&gt;proc_num--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选择 stride 最小的进程作为待运行的进程，并更新其 stride 取值。</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct proc_struct * <span class="title">stride_pick_next</span><span class="params">(struct run_queue *rq)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (rq-&gt;lab6_run_pool != <span class="literal">NULL</span>)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span>* <span class="title">proc</span> =</span> le2proc(rq-&gt;lab6_run_pool, lab6_run_pool);</span><br><span class="line">          proc-&gt;lab6_stride += (BIG_STRIDE / proc-&gt;lab6_priority);</span><br><span class="line">          <span class="keyword">return</span> proc;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与 RR 所取操作相同。</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">stride_proc_tick</span><span class="params">(struct run_queue *rq, struct proc_struct *proc)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (proc-&gt;time_slice &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          proc-&gt;time_slice --;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (proc-&gt;time_slice == <span class="number">0</span>) &#123;</span><br><span class="line">          proc-&gt;need_resched = <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> <span class="title">default_sched_class</span> =</span> &#123;</span><br><span class="line">     .name = <span class="string">&quot;stride_scheduler&quot;</span>,</span><br><span class="line">     .init = stride_init,</span><br><span class="line">     .enqueue = stride_enqueue,</span><br><span class="line">     .dequeue = stride_dequeue,</span><br><span class="line">     .pick_next = stride_pick_next,</span><br><span class="line">     .proc_tick = stride_proc_tick,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ucore</category>
      </categories>
  </entry>
  <entry>
    <title>lab5 — 用户进程管理</title>
    <url>/2021/06/19/ucore/lab5/</url>
    <content><![CDATA[<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>进程、虚拟存储、中断机制、系统调用。</p>
<a id="more"></a>

<h2 id="改动点"><a href="#改动点" class="headerlink" title="改动点"></a>改动点</h2><p>相比于 <code>lab4</code> 源代码，<code>lab5</code> 主要做了如下改动：</p>
<ul>
<li><p><code>memlayout.h</code> 增加用户空间的图形表示和宏定义</p>
<p>宏定义 <code>USERTOP/USERBASE</code> 等指明用户虚拟地址空间范围，图形表示显示哪些用户空间属于合法空间。</p>
</li>
<li><p><code>pmm.[ch]</code> 添加若干与页表项、页面相关的拷贝函数</p>
</li>
<li><p><code>vmm.[ch]</code> 添加若干与 <code>mm/vma/pgdir</code> 相关的函数</p>
<p>值得注意的是： <code>struct mm_struct</code> 属性内容发生变化：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> mmap_list;        </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vma_struct</span> *<span class="title">mmap_cache</span>;</span> </span><br><span class="line">    <span class="keyword">pde_t</span> *pgdir;                  </span><br><span class="line">    <span class="keyword">int</span> map_count;                 </span><br><span class="line">    <span class="keyword">void</span> *sm_priv;                 </span><br><span class="line">    <span class="keyword">int</span> mm_count;                  <span class="comment">// 共享此 mm 的进程数量</span></span><br><span class="line">    <span class="keyword">lock_t</span> mm_lock;                <span class="comment">// 互斥锁, dup_map() 实现时使用，</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p><code>proc.h</code> 扩展 <code>proc_struct</code> 数据结构</p>
<p><code>proc_struct</code> 的扩展点具体如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> &#123;</span></span><br><span class="line">    ... <span class="comment">// 同以往结构的属性</span></span><br><span class="line">    <span class="keyword">int</span> exit_code;                              <span class="comment">// 当前进程的退出码，供父进程使用。</span></span><br><span class="line">    <span class="keyword">uint32_t</span> wait_state;                        <span class="comment">// 当前进程的等待状态，供子进程退出时调用。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">cptr</span>, *<span class="title">yptr</span>, *<span class="title">optr</span>;</span>     </span><br><span class="line">    <span class="comment">// 若干指针存放与其他进程间的关系(孩子进程指针(总是指向最新的子进程)、更年轻的(或称为前一个)兄弟进程指针、更年长的(或称为后一个)兄弟进程指针(后面两个指针构建兄弟进程的双向链表))</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p><code>proc.c</code> 增加若干与 <code>SYSCALL</code> 相关的实现函数</p>
</li>
</ul>
<blockquote>
<p>在 <code>ucore</code> 中，进程与线程采用同一套管理机制，它们间的区别可能仅在于：进程之间不共享地址空间，而线程间共享某进程的地址空间 (通过共享 <code>mm</code> 结构即可)，因此两个术语基本可以混用。</p>
</blockquote>
<h2 id="练习一"><a href="#练习一" class="headerlink" title="练习一"></a>练习一</h2><p>该练习用于了解 <code>do_exec()</code> 的具体实现。</p>
<p>在 lab4 中，我们已经知道：如何创建一个内核线程，并通过调度使得其正常执行。那么我们首先看一下 lab5 中所涉的内核线程：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// proc_init() -&gt; 构建 idleproc 和 initproc</span></span><br><span class="line">---</span><br><span class="line"><span class="keyword">int</span> pid = kernel_thread(init_main, <span class="literal">NULL</span>, <span class="number">0</span>); <span class="comment">// 此句构建 initproc，其执行 initmain 函数。</span></span><br><span class="line">---</span><br><span class="line">    </span><br><span class="line"><span class="comment">// initmain() -&gt; 构建 user_mainproc</span></span><br><span class="line">---</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">init_main</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> nr_free_pages_store = nr_free_pages();</span><br><span class="line">    <span class="keyword">size_t</span> kernel_allocated_store = kallocated();</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> pid = kernel_thread(user_main, <span class="literal">NULL</span>, <span class="number">0</span>); <span class="comment">// 此句构建 user_mainproc，属于第三个内核线程，它是 initproc 的子线程。</span></span><br><span class="line">    <span class="keyword">if</span> (pid &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;create user_main failed.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (do_wait(<span class="number">0</span>, <span class="literal">NULL</span>) == <span class="number">0</span>) &#123; <span class="comment">// 等待 user_mainproc 结束，并回收其剩余资源(此为后话)。</span></span><br><span class="line">        schedule();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">---</span><br><span class="line">    </span><br><span class="line"><span class="comment">// user_main</span></span><br><span class="line">---</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">user_main</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> TEST</span></span><br><span class="line">    KERNEL_EXECVE2(TEST, TESTSTART, TESTSIZE);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    KERNEL_EXECVE(<span class="built_in">exit</span>); <span class="comment">// 实际执行 sys_exec 系统调用，使用 do_exec() 重新配置当前进程的内存空间，并执行 exit 程序。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    panic(<span class="string">&quot;user_main execve failed.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>接下来，我们主要看看 <code>do_exec()</code> 的实现细节 (<code>do_exec</code> 等价于实际系统中的 <code>exec()</code> )：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_execve</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">size_t</span> len, <span class="keyword">unsigned</span> <span class="keyword">char</span> *binary, <span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> current-&gt;mm;</span><br><span class="line">    <span class="keyword">if</span> (!user_mem_check(mm, (<span class="keyword">uintptr_t</span>)name, len, <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (len &gt; PROC_NAME_LEN) &#123;</span><br><span class="line">        len = PROC_NAME_LEN;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> local_name[PROC_NAME_LEN + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(local_name, <span class="number">0</span>, <span class="keyword">sizeof</span>(local_name));</span><br><span class="line">    <span class="built_in">memcpy</span>(local_name, name, len);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空原有 mm。</span></span><br><span class="line">    <span class="keyword">if</span> (mm != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 首先切换页目录表，以防访问到不该访问的，使得访问异常。</span></span><br><span class="line">        lcr3(boot_cr3);</span><br><span class="line">        <span class="comment">// mm 共享数减一，如此此时为 0，则需要删除此 mm，具体包括 vma集合、页目录表和页表、实际物理空间、mm 结构。</span></span><br><span class="line">        <span class="keyword">if</span> (mm_count_dec(mm) == <span class="number">0</span>) &#123;</span><br><span class="line">            exit_mmap(mm);</span><br><span class="line">            put_pgdir(mm);</span><br><span class="line">            mm_destroy(mm);</span><br><span class="line">        &#125;</span><br><span class="line">        current-&gt;mm = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="comment">// load_icode 的主要工作包括：创建 mm、填充 mm 各属性、填充与代码段，数据段，栈相关的物理页、重新设置 tf，使得能够正确返回至用户空间，并开始执行相关代码。具体涉及 ELF 文件格式，可不细理。</span></span><br><span class="line">    <span class="keyword">if</span> ((ret = load_icode(binary, size)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> execve_exit;</span><br><span class="line">    &#125;</span><br><span class="line">    set_proc_name(current, local_name);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">execve_exit:</span><br><span class="line">    do_exit(ret);</span><br><span class="line">    panic(<span class="string">&quot;already exit: %e.\n&quot;</span>, ret);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// load_icode 涉及重置 tf 部分：</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">tf</span> =</span> current-&gt;tf;</span><br><span class="line"><span class="built_in">memset</span>(tf, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct trapframe));</span><br><span class="line"><span class="comment">// 更新 cs 等段寄存器值为用户态段。那么当执行中断返回时，系统便可基于此判断是否存在特权级切换，从而正确弹栈。</span></span><br><span class="line">tf-&gt;tf_cs = USER_CS;</span><br><span class="line">tf-&gt;tf_ds = tf-&gt;tf_es = tf-&gt;tf_ss = USER_DS;</span><br><span class="line">tf-&gt;tf_esp = USTACKTOP;</span><br><span class="line">tf-&gt;tf_eip = elf-&gt;e_entry;</span><br><span class="line">tf-&gt;tf_eflags = FL_IF;</span><br></pre></td></tr></table></figure>
<h2 id="练习二"><a href="#练习二" class="headerlink" title="练习二"></a>练习二</h2><p>该练习用于了解 <code>do_fork()-&gt;copy_mm()</code> 的具体实现。</p>
<p><code>copy_mm()</code> 具体指代复制当前进程的 <code>mm</code> 给新建 <code>proc</code> 的 <code>mm</code> 结构，具体实现细节直接看源代码即可，也没什么好说的。</p>
<h2 id="练习三"><a href="#练习三" class="headerlink" title="练习三"></a>练习三</h2><p>该练习用于理解各系统调用的实现机理。</p>
<p>首先看用户空间的系统调用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">syscall</span><span class="params">(<span class="keyword">int</span> num, ...)</span> </span>&#123;</span><br><span class="line">    va_list ap;</span><br><span class="line">    va_start(ap, num);</span><br><span class="line">    <span class="keyword">uint32_t</span> a[MAX_ARGS];</span><br><span class="line">    <span class="keyword">int</span> i, ret;</span><br><span class="line">    <span class="comment">// 获取相关参数</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_ARGS; i ++) &#123;</span><br><span class="line">        a[i] = va_arg(ap, <span class="keyword">uint32_t</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    va_end(ap);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实施中断，并将相关参数传给相关寄存器，它们会进一步放置于 tf 内部。</span></span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="string">&quot;int %1;&quot;</span></span></span></span><br><span class="line"><span class="function"><span class="params">        : <span class="string">&quot;=a&quot;</span> (ret)</span></span></span><br><span class="line"><span class="function"><span class="params">        : <span class="string">&quot;i&quot;</span> (T_SYSCALL),</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="string">&quot;a&quot;</span> (num),</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="string">&quot;d&quot;</span> (a[<span class="number">0</span>]),</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="string">&quot;c&quot;</span> (a[<span class="number">1</span>]),</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="string">&quot;b&quot;</span> (a[<span class="number">2</span>]),</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="string">&quot;D&quot;</span> (a[<span class="number">3</span>]),</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="string">&quot;S&quot;</span> (a[<span class="number">4</span>])</span></span></span><br><span class="line"><span class="function"><span class="params">        : <span class="string">&quot;cc&quot;</span>, <span class="string">&quot;memory&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如下为用户程序可调用的各种函数，它们统一使用 syscall 实现其功能。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_exit</span><span class="params">(<span class="keyword">int</span> error_code)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(SYS_exit, error_code);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_fork</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(SYS_fork);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_wait</span><span class="params">(<span class="keyword">int</span> pid, <span class="keyword">int</span> *store)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(SYS_wait, pid, store);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_yield</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(SYS_yield);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_kill</span><span class="params">(<span class="keyword">int</span> pid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(SYS_kill, pid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_getpid</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(SYS_getpid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_putc</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(SYS_putc, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_pgdir</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(SYS_pgdir);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，硬件得到 <code>T_SYSCALL</code> 中断号，并调用相关中断处理程序进行处理：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> T_SYSCALL:</span><br><span class="line">    syscall();</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>接下来，看看内核程序 <code>syscall()</code> 的具体实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sys_exit</span><span class="params">(<span class="keyword">uint32_t</span> arg[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> error_code = (<span class="keyword">int</span>)arg[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> do_exit(error_code);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sys_fork</span><span class="params">(<span class="keyword">uint32_t</span> arg[])</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">tf</span> =</span> current-&gt;tf;</span><br><span class="line">    <span class="keyword">uintptr_t</span> <span class="built_in">stack</span> = tf-&gt;tf_esp;</span><br><span class="line">    <span class="keyword">return</span> do_fork(<span class="number">0</span>, <span class="built_in">stack</span>, tf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sys_wait</span><span class="params">(<span class="keyword">uint32_t</span> arg[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pid = (<span class="keyword">int</span>)arg[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> *store = (<span class="keyword">int</span> *)arg[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> do_wait(pid, store);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sys_exec</span><span class="params">(<span class="keyword">uint32_t</span> arg[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name = (<span class="keyword">const</span> <span class="keyword">char</span> *)arg[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">size_t</span> len = (<span class="keyword">size_t</span>)arg[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *binary = (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)arg[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">size_t</span> size = (<span class="keyword">size_t</span>)arg[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">return</span> do_execve(name, len, binary, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sys_yield</span><span class="params">(<span class="keyword">uint32_t</span> arg[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> do_yield();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sys_kill</span><span class="params">(<span class="keyword">uint32_t</span> arg[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pid = (<span class="keyword">int</span>)arg[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> do_kill(pid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sys_getpid</span><span class="params">(<span class="keyword">uint32_t</span> arg[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> current-&gt;pid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sys_putc</span><span class="params">(<span class="keyword">uint32_t</span> arg[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = (<span class="keyword">int</span>)arg[<span class="number">0</span>];</span><br><span class="line">    cputchar(c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sys_pgdir</span><span class="params">(<span class="keyword">uint32_t</span> arg[])</span> </span>&#123;</span><br><span class="line">    print_pgdir();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上述函数为 SYS_xx 的具体实现，它们会获取相关参数，并调用相关 do_xxx 进行处理，最后返回。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">int</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="keyword">uint32_t</span> arg[])</span> </span>= &#123;</span><br><span class="line">    [SYS_exit]              sys_exit,</span><br><span class="line">    [SYS_fork]              sys_fork,</span><br><span class="line">    [SYS_wait]              sys_wait,</span><br><span class="line">    [SYS_exec]              sys_exec,</span><br><span class="line">    [SYS_yield]             sys_yield,</span><br><span class="line">    [SYS_kill]              sys_kill,</span><br><span class="line">    [SYS_getpid]            sys_getpid,</span><br><span class="line">    [SYS_putc]              sys_putc,</span><br><span class="line">    [SYS_pgdir]             sys_pgdir,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM_SYSCALLS        ((sizeof(syscalls)) / (sizeof(syscalls[0])))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">syscall</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">tf</span> =</span> current-&gt;tf;</span><br><span class="line">    <span class="keyword">uint32_t</span> arg[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">int</span> num = tf-&gt;tf_regs.reg_eax;</span><br><span class="line">    <span class="keyword">if</span> (num &gt;= <span class="number">0</span> &amp;&amp; num &lt; NUM_SYSCALLS) &#123;</span><br><span class="line">        <span class="keyword">if</span> (syscalls[num] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 从 tf 中获取相关参数，放置于 arg[] 内部，并调用相应的 SYS_xxx 进行处理。</span></span><br><span class="line">            arg[<span class="number">0</span>] = tf-&gt;tf_regs.reg_edx;</span><br><span class="line">            arg[<span class="number">1</span>] = tf-&gt;tf_regs.reg_ecx;</span><br><span class="line">            arg[<span class="number">2</span>] = tf-&gt;tf_regs.reg_ebx;</span><br><span class="line">            arg[<span class="number">3</span>] = tf-&gt;tf_regs.reg_edi;</span><br><span class="line">            arg[<span class="number">4</span>] = tf-&gt;tf_regs.reg_esi;</span><br><span class="line">            tf-&gt;tf_regs.reg_eax = syscalls[num](arg);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    print_trapframe(tf);</span><br><span class="line">    panic(<span class="string">&quot;undefined syscall %d, pid = %d, name = %s.\n&quot;</span>,</span><br><span class="line">            num, current-&gt;pid, current-&gt;name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于上述 <code>sys_xxx</code>，简要做如下分析：</p>
<ul>
<li><p><code>do_fork(0, stack, tf)</code></p>
<p>第一个参数为 0，表明其会完全复制当前进程的地址空间，第二三参数，表明其会完全复制当前进程的用户栈及中断帧。如此实现，含义与实际 <code>fork()</code> 相同。</p>
<p>由于之前早已说明 <code>do_fork()</code> 的实现细节，在此不再赘述。</p>
</li>
<li><p><code>do_execve(name, len, binary, size)</code></p>
<p>练习一已经说明其含义，在此不再赘述。</p>
</li>
<li><p><code>do_exit(error_code)</code></p>
<p><code>do_exit()</code> 用于回收该进程的内存资源，并设置 <code>PROC_ZOMBIE</code> 状态以等待父进程处理。如果当前进程存在子进程，需要将它们置为  <code>initproc</code> 的子进程。</p>
</li>
<li><p><code>do_wait(pid, store)</code></p>
<p><code>do_wait()</code> 用于等待子进程处于 <code>PROC_ZOMBIE</code> 状态，并回收其剩余资源 (指代内核栈、PCB)。</p>
<blockquote>
<p>某进程资源的回收工作具体分为两步：<code>do_exit()</code> 自主回收内存资源，<code>do_wait()</code> 由父进程回收内核资源。之所以如此实现，原因在于：进程回收内核资源，则其必定在使用内核栈，而内核资源包括内核栈，因此存在一个矛盾。另外，父进程可通过回收资源过程，获取其子进程的运行结果，然后动态施行相关操作。</p>
</blockquote>
</li>
<li><p><code>do_yield()</code></p>
<p><code>do_yield()</code> 用于释放 CPU，并让其调度处理其他进程。</p>
</li>
<li><p><code>do_kill(pid)</code></p>
<p><code>do_kill()</code> 用于设置特定进程的 <code>flags |= PF_EXITING;</code>。</p>
</li>
<li><p><code>sys_getpid/sys_putc/sys_pgdir</code></p>
<p>此三者都比较简单，没什么可说的。</p>
</li>
</ul>
<p>需要注意：<code>do_yield()</code> 和 <code>do_kill()</code> 功能实现的部分代码在函数内部，部分代码位于 <code>trap()</code> 内部，<code>trap()</code> 内部的实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trap</span><span class="params">(struct trapframe *tf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (current == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        trap_dispatch(tf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如此保存旧 tf，保证实现中断嵌套。</span></span><br><span class="line">        struct trapframe *otf = current-&gt;tf;</span><br><span class="line">        current-&gt;tf = tf;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">bool</span> in_kernel = trap_in_kernel(tf);</span><br><span class="line">    </span><br><span class="line">        trap_dispatch(tf);</span><br><span class="line">    </span><br><span class="line">        current-&gt;tf = otf;</span><br><span class="line">        <span class="keyword">if</span> (!in_kernel) &#123;</span><br><span class="line">            <span class="comment">// do_kill 发挥作用就比较慢，当特定进程再次进入中断后，才会让它触动回收。</span></span><br><span class="line">            <span class="comment">// 进程进入中断的方式主要存在两种：1. 系统调用 2. 时钟中断。</span></span><br><span class="line">            <span class="keyword">if</span> (current-&gt;flags &amp; PF_EXITING) &#123;</span><br><span class="line">                do_exit(-E_KILLED);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// do_yield 设置字段后，中断返回前即会重新调度。</span></span><br><span class="line">            <span class="keyword">if</span> (current-&gt;need_resched) &#123;</span><br><span class="line">                schedule();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="扩展练习一"><a href="#扩展练习一" class="headerlink" title="扩展练习一"></a>扩展练习一</h2><p>该练习用于实现 <code>Copy on Write(COW)</code> 机制。</p>
<p><code>COW</code> 机制实现比较复杂，并没有实现。在此简要说明其思想。</p>
<p>当执行 <code>do_fork(0, stack, tf) -&gt; copy_mm()</code> 时，复制 <code>vma</code> 集合、页目录表等内容，共享当前进程的物理页，并设置相关条目为只读 (而非原先的复制物理页)。</p>
<p>当新旧进程需要写共享物理页时，触发中断，执行 <code>do_pgfault()</code>。如果该页面为只读，且其共享数大于 1，则表明存在新旧进程在共享物理页，因此复制该物理页给当前进程，并设置相关条目为读写。 </p>
<h2 id="如何创建用户线程？"><a href="#如何创建用户线程？" class="headerlink" title="如何创建用户线程？"></a>如何创建用户线程？</h2><p>借助于 <code>do_fork()/do_execve()</code>，我们成功创建用户进程 (也可称作该进程对应的主线程)，它所对应的栈直接位于虚拟地址空间中的栈区。</p>
<blockquote>
<p>用户进程的栈大小默认为 8M。当栈所占实际空间小于 8M 时，它会因缺页中断而动态增长；当栈所占实际空间大于 8M 时，便会触发 <em>栈溢出</em>。</p>
</blockquote>
<p>对于用户线程而言，它们需要共享用户进程资源 (例如：地址空间、打开的文件列表)，而独占栈空间、寄存器组等资源。</p>
<p>经过上面的实现，共享进程资源比较简单，无非就是设置相关指针以指向相同结构体；独占寄存器组也比较简单，使用 <code>proc.context</code> 保存即可；唯一难点在于：如何独占栈空间的同时，实现共享该进程的地址空间？</p>
<p>Linux 系统的解决方案是这样的：创建用户线程之时，在当前地址空间的堆区直接分配栈空间，以此作为该线程的栈。</p>
<blockquote>
<p>用户线程的栈大小默认为 16K，最大为 2M。</p>
<p>注：Linux 的解决方案中，线程栈空间直接分配，它不会动态增长。</p>
</blockquote>
]]></content>
      <categories>
        <category>ucore</category>
      </categories>
  </entry>
  <entry>
    <title>lab4 — 内核线程管理</title>
    <url>/2021/06/16/ucore/lab4/</url>
    <content><![CDATA[<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>线程、状态转换。</p>
<a id="more"></a>

<h2 id="改动点"><a href="#改动点" class="headerlink" title="改动点"></a>改动点</h2><p>相比于 <code>lab3</code> 源代码，<code>lab4</code> 主要是添加代码 <code>process/*</code> 以实现进程/线程管理功能。</p>
<h2 id="练习一"><a href="#练习一" class="headerlink" title="练习一"></a>练习一</h2><p>此练习用于认识进程/线程控制块 PCB。</p>
<p>在 <code>ucore</code> 中，<code>struct proc_struct</code> 用于描述进程/线程：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">proc_state</span> <span class="title">state</span>;</span>                      <span class="comment">// 进程状态(创建、就绪、运行、阻塞、终止)</span></span><br><span class="line">    <span class="keyword">int</span> pid;                                    <span class="comment">// 进程 ID，唯一标识此进程。</span></span><br><span class="line">    <span class="keyword">int</span> runs;                                   <span class="comment">// 进程已运行时间(尚未用到)。</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> kstack;                           <span class="comment">// 进程的内核栈(每个进程/线程均有一个，用以当发生中断时保存相关信息)。</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">bool</span> need_resched;                 <span class="comment">// 该进程是否需要被重新调度。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">parent</span>;</span>                 <span class="comment">// 进程的父进程。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span>                       <span class="comment">// 进程对应的 mm。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>                     <span class="comment">// 进程对应的上下文信息(用于进程间切换以保存进程状态)。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">tf</span>;</span>                       <span class="comment">// 进程当前中断对应的 tf。</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> cr3;                              <span class="comment">// PDT 所在地址。</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;                             <span class="comment">// 进程标识信息(尚未用到)。</span></span><br><span class="line">    <span class="keyword">char</span> name[PROC_NAME_LEN + <span class="number">1</span>];               <span class="comment">// 进程名称</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> list_link;                      </span><br><span class="line">    <span class="keyword">list_entry_t</span> hash_link;                     <span class="comment">// PCB 相互链接对应的链表和 hash 表。</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进程状态的具体信息</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">proc_state</span> &#123;</span></span><br><span class="line">    PROC_UNINIT = <span class="number">0</span>,  <span class="comment">// 创建</span></span><br><span class="line">    PROC_SLEEPING,    <span class="comment">// 阻塞</span></span><br><span class="line">    PROC_RUNNABLE,    <span class="comment">// 就绪/运行</span></span><br><span class="line">    PROC_ZOMBIE,      <span class="comment">// 终止</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// context 还应保存各种段寄存器信息，但是此次 lab 为内核线程管理，这些寄存器取值固定，因此没有列出。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">context</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> eip;</span><br><span class="line">    <span class="keyword">uint32_t</span> esp;</span><br><span class="line">    <span class="keyword">uint32_t</span> ebx;</span><br><span class="line">    <span class="keyword">uint32_t</span> ecx;</span><br><span class="line">    <span class="keyword">uint32_t</span> edx;</span><br><span class="line">    <span class="keyword">uint32_t</span> esi;</span><br><span class="line">    <span class="keyword">uint32_t</span> edi;</span><br><span class="line">    <span class="keyword">uint32_t</span> ebp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>鉴于对于 PCB 的上述理解，我们应当在 <code>alloc_proc()</code> 中，如此初始化新建的 PCB： </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (proc != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">// 尚未分配进程所需的其他资源，进程状态当然处于 &quot;新建&quot;。</span></span><br><span class="line">    proc-&gt;state = PROC_UNINIT;</span><br><span class="line">    proc-&gt;pid = <span class="number">-1</span>;</span><br><span class="line">    proc-&gt;runs = <span class="number">0</span>;</span><br><span class="line">    proc-&gt;kstack = <span class="number">0</span>;</span><br><span class="line">    proc-&gt;need_resched = <span class="number">0</span>;</span><br><span class="line">    proc-&gt;parent = <span class="literal">NULL</span>;</span><br><span class="line">    proc-&gt;mm = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;proc-&gt;context, <span class="number">0</span> , <span class="keyword">sizeof</span>(struct context));</span><br><span class="line">    proc-&gt;tf = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 本 lab 所涉内核线程，其对应 PDT 均为 boot_cr3。</span></span><br><span class="line">    proc-&gt;cr3 = boot_cr3;</span><br><span class="line">    proc-&gt;flags = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;(proc-&gt;name), <span class="number">0</span>, PROC_NAME_LEN);</span><br><span class="line">    <span class="comment">// 对于其余信息，默认初始化为空即可。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="练习二"><a href="#练习二" class="headerlink" title="练习二"></a>练习二</h2><p>该练习用于实现 <code>do_fork()</code> 以为新建进程/线程分配资源 (其含义等价于实际系统中的 <code>fork()</code>)。</p>
<p>对于进程/线程而言，其所需资源包括 (就目前 lab 而言)：PCB、内核栈、内存资源。</p>
<p>在 <code>do_fork()</code> 函数内部，一一分配这些资源即可。具体源代码如下示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_fork</span><span class="params">(<span class="keyword">uint32_t</span> clone_flags, <span class="keyword">uintptr_t</span> <span class="built_in">stack</span>, struct trapframe *tf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = -E_NO_FREE_PROC;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (nr_process &gt;= MAX_PROCESS) &#123;</span><br><span class="line">        <span class="keyword">goto</span> fork_out;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = -E_NO_MEM;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配 PCB。</span></span><br><span class="line">    <span class="keyword">if</span> ((proc = alloc_proc()) == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> fork_out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指明当前进程为新建进程的父进程。</span></span><br><span class="line">    proc-&gt;parent = current;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配内核栈</span></span><br><span class="line">    <span class="keyword">if</span> (setup_kstack(proc) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_proc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配 mm (具体指代该进程对应程序的 vma 集、与物理页面对应的 PDT)。</span></span><br><span class="line">    <span class="keyword">if</span> (copy_mm(clone_flags, proc) != <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_kstack;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置中断栈帧内容以及新建进程的 context，容许进程切换的顺利进行。</span></span><br><span class="line">    copy_thread(proc, <span class="built_in">stack</span>, tf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置原子操作，添加此 PCB 至进程集合。</span></span><br><span class="line">    <span class="keyword">bool</span> intr_flag;</span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    &#123;</span><br><span class="line">        proc-&gt;pid = get_pid();</span><br><span class="line">        list_add(&amp;proc_list, &amp;(proc-&gt;list_link));</span><br><span class="line">        hash_proc(proc);</span><br><span class="line">        nr_process++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置此进程状态为 *就绪*。</span></span><br><span class="line">    wakeup_proc(proc);</span><br><span class="line"></span><br><span class="line">    ret = proc-&gt;pid;</span><br><span class="line">    </span><br><span class="line">fork_out:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">bad_fork_cleanup_kstack:</span><br><span class="line">    put_kstack(proc);</span><br><span class="line">bad_fork_cleanup_proc:</span><br><span class="line">    kfree(proc);</span><br><span class="line">    <span class="keyword">goto</span> fork_out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="练习三"><a href="#练习三" class="headerlink" title="练习三"></a>练习三</h2><p>该练习用于详细了解 <code>ucore</code> 内部如何实现进程切换。</p>
<p><code>do_fork()</code> 函数完成后，新建进程的各种资源已经分配完成，此时我们简单看看 PCB 的部分内容：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// struct trapframe *tf 属性的部分信息，其设置与 kernel_thread()/copy_thread() 相关。</span></span><br><span class="line">tf.tf_cs = KERNEL_CS;                            <span class="comment">// 各种段寄存器设置，表明其为内核进程。</span></span><br><span class="line">tf.tf_ds = tf.tf_es = tf.tf_ss = KERNEL_DS;</span><br><span class="line">tf.tf_regs.reg_ebx = (<span class="keyword">uint32_t</span>)fn;               <span class="comment">// ebx/edx 取值为新建进程运行的函数和相关参数，之所以设置此两寄存器，规定而已。</span></span><br><span class="line">tf.tf_regs.reg_edx = (<span class="keyword">uint32_t</span>)arg;</span><br><span class="line">tf.tf_eip = (<span class="keyword">uint32_t</span>)kernel_thread_entry;       <span class="comment">// 中断返回后的执行入口。</span></span><br><span class="line">tf.tf_regs.reg_eax = <span class="number">0</span>;</span><br><span class="line">tf.tf_esp = esp;</span><br><span class="line">tf.tf_eflags |= FL_IF;</span><br><span class="line"></span><br><span class="line"><span class="comment">// struct context context 属性的部分信息，其设置与 copy_thread() 相关。</span></span><br><span class="line">context.eip = (<span class="keyword">uintptr_t</span>)forkret;               <span class="comment">// 上下文切换的执行入口。</span></span><br><span class="line">context.esp = (<span class="keyword">uintptr_t</span>)(proc-&gt;tf);            <span class="comment">// 上下文切换的栈寄存器取值，其指向该进程内核栈的栈顶，其中存放 tf。</span></span><br></pre></td></tr></table></figure>
<p>接下来，我们看看，切换进程时具体执行的 <code>proc_run()</code> 函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">proc_run</span><span class="params">(struct proc_struct *proc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (proc != current) &#123;</span><br><span class="line">        <span class="keyword">bool</span> intr_flag;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">prev</span> =</span> current, *next = proc;</span><br><span class="line">        local_intr_save(intr_flag);</span><br><span class="line">        &#123;</span><br><span class="line">            current = proc;</span><br><span class="line">            <span class="comment">// 两者均为内核进程，而 tss-&gt;esp0 指代 CPL =0 时的内核栈顶，因此需要切换此值。</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 再次回顾 tss 的作用：用于保存当前进程的内核栈信息 (包括 ss0 和 esp0，ss0 指代栈段寄存器，esp0 指代栈顶)。</span></span><br><span class="line">            <span class="comment">// pizza 谈及：每次进程进入内核态，得到的内核栈都是空的。</span></span><br><span class="line">            <span class="comment">// 如果切换之时，进程处于用户态，那么完全可以使用此代码进行初始化。</span></span><br><span class="line">            <span class="comment">// 如果切换之时，进程处于内核态，context.esp 即是内核栈顶，tf.esp 为中断对应栈顶，这样来看，tss.esp0 初始化为任意值都是可以的。</span></span><br><span class="line">            <span class="comment">// 有意思的是：当用户态与内核态切换时，硬件自动加载和保存 tss.ss0 和 tss.esp0 至 ss 和 esp，因此这时候它们的值都是正确无误的。</span></span><br><span class="line">            <span class="comment">// 因此，这句代码是没有什么问题的。</span></span><br><span class="line">            load_esp0(next-&gt;kstack + KSTACKSIZE);</span><br><span class="line">            <span class="comment">// 加载新进程的 PDT。</span></span><br><span class="line">            lcr3(next-&gt;cr3);</span><br><span class="line">            <span class="comment">// 执行上下文切换</span></span><br><span class="line">            switch_to(&amp;(prev-&gt;context), &amp;(next-&gt;context));</span><br><span class="line">        &#125;</span><br><span class="line">        local_intr_restore(intr_flag);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进一步，追看 <code>switch_to()</code> 的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">switch_to:                      </span><br><span class="line">    # 保存原有进程的 context 信息。</span><br><span class="line">    movl 4(%esp), %eax          # eax points to from</span><br><span class="line">    # 指代将 switch_to 的返回地址 pop 作为原先进程的 context.eip </span><br><span class="line">    # (这里似乎有些不对，如果下次 to 进程切换至 from 进程，切换结果便是 proc_run 中 switch_to 的下一条指令，明显不符合所学内容)。</span><br><span class="line">    # 目前可能只是权宜之计，后续会有所改动。</span><br><span class="line">    popl 0(%eax)                </span><br><span class="line">    movl %esp, 4(%eax)          </span><br><span class="line">    movl %ebx, 8(%eax)          </span><br><span class="line">    movl %ecx, 12(%eax)        </span><br><span class="line">    movl %edx, 16(%eax)         </span><br><span class="line">    movl %esi, 20(%eax)      </span><br><span class="line">    movl %edi, 24(%eax)        </span><br><span class="line">    movl %ebp, 28(%eax)     </span><br><span class="line"></span><br><span class="line">    # 恢复新进程的 context 信息。</span><br><span class="line">    movl 4(%esp), %eax          </span><br><span class="line"></span><br><span class="line">    movl 28(%eax), %ebp        </span><br><span class="line">    movl 24(%eax), %edi         </span><br><span class="line">    movl 20(%eax), %esi        </span><br><span class="line">    movl 16(%eax), %edx         </span><br><span class="line">    movl 12(%eax), %ecx         </span><br><span class="line">    movl 8(%eax), %ebx          </span><br><span class="line">    movl 4(%eax), %esp          </span><br><span class="line"></span><br><span class="line">    # 设置函数的返回地址为 to 所指代的 eip (具体指代 forkret)，那么 switch_to 返回后，便会执行 forkret 函数。</span><br><span class="line">    pushl 0(%eax)              </span><br><span class="line"></span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>
<p>进一步，追看 <code>forkret() -&gt; forkrets()</code> 的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__trapret: </span><br><span class="line">    popal</span><br><span class="line"></span><br><span class="line">    popl %gs</span><br><span class="line">    popl %fs</span><br><span class="line">    popl %es</span><br><span class="line">    popl %ds</span><br><span class="line"></span><br><span class="line">    addl $0x8, %esp</span><br><span class="line">    iret</span><br><span class="line"></span><br><span class="line">.globl forkrets</span><br><span class="line">forkrets:</span><br><span class="line">    # 最初新进程的 esp 指向内核栈的栈顶，其中存放 tf。上下文切换完成后，凡是函数调用，消耗的都是新进程的 esp，因此其栈顶会发生变化。如此调整，以保证 esp 仍指向原先存放的 tf。</span><br><span class="line">    movl 4(%esp), %esp</span><br><span class="line">    # 此部分为中断处理的后半部分，弹出栈顶的一系列元素，返回执行中断前的指令，具体指代 tf.eip 所指。</span><br><span class="line">    # 对于新进程而言，其指代 kernel_thread_entry (它会调用 fn 和 arg，开始真正执行新进程的指令)。</span><br><span class="line">    jmp __trapret</span><br></pre></td></tr></table></figure>
<p>至此，完成分析 “进程切换” 的完整步骤。</p>
<blockquote>
<p>虽然本 lab 仅涉及内核线程的切换，但是其进程切换方式是比较特殊的：借助于中断实现。该种实现方式允许特权级切换，从而可以构建用户进程，从而为 lab5 打下基础。</p>
</blockquote>
]]></content>
      <categories>
        <category>ucore</category>
      </categories>
  </entry>
  <entry>
    <title>lab3 — 虚拟内存管理</title>
    <url>/2021/06/08/ucore/lab3/</url>
    <content><![CDATA[<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>虚拟存储、页面置换算法、中断机制。</p>
<a id="more"></a>

<h2 id="改动点"><a href="#改动点" class="headerlink" title="改动点"></a>改动点</h2><p>相比于 <code>lab2</code> 源代码，<code>lab3</code> 主要是添加部分代码以实现虚拟存储功能，仅见的改动点在于页描述结构 <code>page</code> 和 <code>alloc_pages</code> 函数的具体实现，两者源码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ref;                        </span><br><span class="line">    <span class="keyword">uint32_t</span> flags;                 </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> property;          </span><br><span class="line">    <span class="keyword">list_entry_t</span> page_link;         </span><br><span class="line">    <span class="keyword">list_entry_t</span> pra_page_link;     <span class="comment">// 链接属于同一程序的物理页面</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> pra_vaddr;            <span class="comment">// 指明此物理页面对应的虚拟地址</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">struct Page * <span class="title">alloc_pages</span><span class="params">(<span class="keyword">size_t</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">page</span>=</span><span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">bool</span> intr_flag;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">         local_intr_save(intr_flag);</span><br><span class="line">         &#123;</span><br><span class="line">              page = pmm_manager-&gt;alloc_pages(n);</span><br><span class="line">         &#125;</span><br><span class="line">         local_intr_restore(intr_flag);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 如果因空闲页不够而导致的内存分配失败，且此时已经开启 swap，则其会基于相关替换算法而自动换出某些页面，以满足分配要求(此处要求 n &gt; 1，表明只要请求页面大于 1，分配失败时不会尝试进行页面替换)。</span></span><br><span class="line">         <span class="keyword">if</span> (page != <span class="literal">NULL</span> || n &gt; <span class="number">1</span> || swap_init_ok == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">         </span><br><span class="line">         <span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">check_mm_struct</span>;</span></span><br><span class="line">         </span><br><span class="line">         swap_out(check_mm_struct, n, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="练习一"><a href="#练习一" class="headerlink" title="练习一"></a>练习一</h2><p>此练习用于了解页面替换算法 FIFO 的具体实现。</p>
<p>对于虚拟内存管理而言，另外涉及两大数据结构：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vma_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">vm_mm</span>;</span> <span class="comment">// 指向管理此 vma 的 mm</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> vm_start;      <span class="comment">// vma 的起始虚拟地址(包含)      </span></span><br><span class="line">    <span class="keyword">uintptr_t</span> vm_end;        <span class="comment">// vma 的终止虚拟地址(不包含)</span></span><br><span class="line">    <span class="keyword">uint32_t</span> vm_flags;       <span class="comment">// vma 权限标志信息(可读、可写、可执行)</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> list_link;  <span class="comment">// 用于将属于同一程序的 vma 链接起来</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> mmap_list;        <span class="comment">// 指向某程序的 vma 集</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vma_struct</span> *<span class="title">mmap_cache</span>;</span> <span class="comment">// 当前访问的 vma</span></span><br><span class="line">    <span class="keyword">pde_t</span> *pgdir;                  <span class="comment">// 该程序对应的页目录表</span></span><br><span class="line">    <span class="keyword">int</span> map_count;                 <span class="comment">// 指明某程序的 vma 总数</span></span><br><span class="line">    <span class="keyword">void</span> *sm_priv;                 <span class="comment">// swap manager(主要指代页面替换算法的具体实现) 的隐私信息。ucore 之中，使用 pra_list_head 进行填充</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>为实现 FIFO，我们需要使用 <code>list_entry_t pra_list_head</code> 所指链表来有序 (对于 FIFO 而言，指代页面被分配的时间) 保存某程序所分配的物理页面集 (集内页面使用 <code>Page.pra_page_link</code> 进行链接)。</p>
<p>当分配某程序物理页面后，需要将刚分配的页面放置于链首以显式更新 <code>pra_list_head</code> 链表；当需要选择待替换物理页面时，直接选择链尾页面即可。</p>
<blockquote>
<p>被替换的物理页面会被存放至 swap 分区内部 (此称为交换技术)。因为此时 PTE 表项无效，因此 <code>ucore</code> 使用此存放该页面所在位置的起始扇区编号。</p>
<p>因为 <code>ucore</code> 将物理页面线性映射至 swap 对应扇区，因此其交换技术的实现十分简单。而实际系统之中，这种映射实现是比较复杂的。</p>
</blockquote>
<p>基于 FIFO 实现思想及上述数据结构，很容易写出相关代码，故不再赘述。</p>
<h2 id="练习二"><a href="#练习二" class="headerlink" title="练习二"></a>练习二</h2><p>此练习用于了解并实现缺页中断的异常处理程序。</p>
<p>缺页中断的异常处理程序的具体调用流程如下：<code>__alltraps</code> –&gt; <code>trap</code> –&gt; <code>trap_dispatch</code>  –&gt;  <code>pgfault_handler</code>  –&gt;<code>do_pgfault</code>。这里直接基于 <code>do_pgfault</code> 的实现，说明如何处理缺页中断。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mm 指代当前运行程序的虚拟内存管理结构，error_code 指代硬件设置的异常码，addr 指代引发缺页中断的虚拟地址。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_pgfault</span><span class="params">(struct mm_struct *mm, <span class="keyword">uint32_t</span> error_code, <span class="keyword">uintptr_t</span> addr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = -E_INVAL;</span><br><span class="line">    <span class="comment">// 判断 addr 是否属于当前运行程序的合法地址。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vma_struct</span> *<span class="title">vma</span> =</span> find_vma(mm, addr);</span><br><span class="line"></span><br><span class="line">    pgfault_num++;</span><br><span class="line">    <span class="comment">// 如果该地址不合法，则直接返回即可。</span></span><br><span class="line">    <span class="keyword">if</span> (vma == <span class="literal">NULL</span> || vma-&gt;vm_start &gt; addr) &#123;</span><br><span class="line">        <span class="keyword">goto</span> failed;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 详细判断硬件设置的 error_code (其第 0 位指代中断是否由页面不存在而引起，第 1 位指代中断是否由写操作引起，第 2 位指代当前是否处于用户模式)，对于因权限不满足的情况，直接返回。</span></span><br><span class="line">    <span class="keyword">switch</span> (error_code &amp; <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: </span><br><span class="line">        <span class="keyword">if</span> (!(vma-&gt;vm_flags &amp; VM_WRITE)) &#123;</span><br><span class="line">            <span class="keyword">goto</span> failed;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: </span><br><span class="line">        <span class="keyword">goto</span> failed;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: </span><br><span class="line">        <span class="keyword">if</span> (!(vma-&gt;vm_flags &amp; (VM_READ | VM_EXEC))) &#123;</span><br><span class="line">            <span class="keyword">goto</span> failed;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下情形才能继续运行：1. 写某已存在的地址；2. 写未存在的地址，并且此地址可写；3. 读未存在的地址，并且此地址可读。</span></span><br><span class="line">    <span class="comment">// 对于情形 1，基本没有涉及，主要关注后两种情形。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取 vma 对应的访问权限</span></span><br><span class="line">    <span class="keyword">uint32_t</span> perm = PTE_U;</span><br><span class="line">    <span class="keyword">if</span> (vma-&gt;vm_flags &amp; VM_WRITE) &#123;</span><br><span class="line">        perm |= PTE_W;</span><br><span class="line">    &#125;</span><br><span class="line">    addr = ROUNDDOWN(addr, PGSIZE);</span><br><span class="line"></span><br><span class="line">    ret = -E_NO_MEM;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pte_t</span> *ptep=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 获取该虚拟地址对应的 pte 表项，若获取失败(可能因为空间不足，而分配页表失败)，则直接返回。</span></span><br><span class="line">    ptep = get_pte(mm-&gt;pgdir, addr, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (ptep == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> failed;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果其值为空，则只能直接分配页面(对于实际系统而言，直接分配肯定是不行的，因为当前页面可能存在数据)。</span></span><br><span class="line">    <span class="keyword">if</span> (*ptep == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 同样可能因为分配页面而失败，</span></span><br><span class="line">        <span class="keyword">if</span> (pgdir_alloc_page(mm-&gt;pgdir, addr, perm) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> failed;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 表明其存在于 swap 分区内部，需要进行获取(如果 swap manager 尚未初始化成功，则直接返回)。</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(swap_init_ok) &#123;</span><br><span class="line">            <span class="comment">// 获取 swap 内容至所分配的 page。</span></span><br><span class="line">            struct Page *page=<span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">if</span> ((ret = swap_in(mm, addr, &amp;page)) != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">goto</span> failed;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 构建页表映射，触发 FIFO 更新，设置 page 对应的 pra_vaddr。</span></span><br><span class="line">            page_insert(mm-&gt;pgdir, page, addr, perm);                        </span><br><span class="line">            swap_map_swappable(mm, addr, page, <span class="number">1</span>);</span><br><span class="line">            page-&gt;pra_vaddr = addr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">goto</span> failed;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line">failed:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="扩展练习一"><a href="#扩展练习一" class="headerlink" title="扩展练习一"></a>扩展练习一</h2><p>该练习用于了解并实现 <code>extended clock</code> 页面替换算法。</p>
<p>基于硬件实现以及现有数据结构，该算法比较容易实现。</p>
<p>当分配某程序物理页面后，需要将其放置于 <code>list_entry_t pra_list_head</code> 所示链表的尾部；程序访问过程中，硬件会自动设置 PTE 表项中的相关标志位 (所示页面是否发生修改，所示页面是否访问)；当需要选择待替换物理页面时，遍历链表，并动态更新 <code>pra_list_head</code> 指针以及相应页面对应页表项的标志位，如果某页面对应的标志位为 00 (即，自上次至此，尚未被访问，也尚未被修改)，则选择此页面进行替换。</p>
<h2 id="扩展练习二"><a href="#扩展练习二" class="headerlink" title="扩展练习二"></a>扩展练习二</h2><p>该练习用于了解并实现 <code>LRU</code> 页面替换算法。</p>
<blockquote>
<p>当某页面被访问后，似乎无法更新 LRU 所维护的页面链表。</p>
</blockquote>
]]></content>
      <categories>
        <category>ucore</category>
      </categories>
  </entry>
  <entry>
    <title>lab2 — 物理内存管理</title>
    <url>/2021/06/05/ucore/lab2/</url>
    <content><![CDATA[<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>分段机制、分页机制、物理内存管理机制、伙伴系统、slub 分配算法。</p>
<a id="more"></a>

<h2 id="改动点"><a href="#改动点" class="headerlink" title="改动点"></a>改动点</h2><p>相比于 <code>lab1</code> 源代码，<code>lab2</code> 主要做了如下改动：</p>
<ul>
<li><p><code>bootasm.S</code> 增加内存探测功能</p>
<p>借助于 BIOS 提供的 <code>int 0x15</code> 中断功能，探测当前机器的内存布局，并将其结果放置于 <code>0x8000</code> 处。</p>
<p>该结果以 <em>地址范围描述符</em>  结构体形式进行存放：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">e820map</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> nr_map;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">		<span class="keyword">long</span> <span class="keyword">long</span> addr; <span class="comment">// 基址</span></span><br><span class="line">		<span class="keyword">long</span> <span class="keyword">long</span> size; <span class="comment">// 大小</span></span><br><span class="line">		<span class="keyword">long</span> type; <span class="comment">// 类型</span></span><br><span class="line">	&#125; <span class="built_in">map</span>[E820MAX];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>kernel.ld</code> 重新设置入口点和加载位置</p>
<p>在 <code>lab1</code> 中，ucore 入口点直接为 <code>init.c</code>；而在 <code>lab2</code> 中，ucore 入口点为 <code>entry.S</code>，随后跳转至 <code>init.c</code>，原因在于：需要在 <code>entry.S</code> 中完成开启分页机制、加载基本页表等工作。</p>
<p>值得注意的是：虽然 <code>kernel.ld</code> 中加载位置为 <code>0xC0100000</code> ，但是 <code>bootmian.c</code> 却将其实际加载至 <code>0x100000</code>，从而形成一种不对等映射。</p>
</li>
<li><p>增加 <code>entry.S</code> 文件</p>
</li>
<li><p>修改 <code>pmm_init()</code> 函数</p>
<p>该函数为实现物理内存管理的关键函数，所有练习均基于此进行展开，其中主要完成如下工作：初始化物理内存管理器 <code>pmm_manager</code>、内核空间虚拟地址与物理地址的映射、有关页目录表和页表的各种操作。</p>
</li>
</ul>
<h2 id="练习一"><a href="#练习一" class="headerlink" title="练习一"></a>练习一</h2><p>此练习用于了解 <code>default_pmm.c</code> 代码所做的工作 (默认的物理内存管理：基于 First-Fit 的连续物理内存分配算法)。</p>
<p>对于物理内存管理而言，主要涉及两大数据结构：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 该结构用于管理空闲物理内存。</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> free_list;         <span class="comment">// 双向链表头部节点，该链表存放所有空闲内存块。</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> nr_free;           <span class="comment">// 该链表所含的空闲页总数(内存块可能包含多个空闲页)。</span></span><br><span class="line">&#125; <span class="keyword">free_area_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该结构用于描述某页信息。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ref;                        <span class="comment">// 指代当前页被映射至多少个虚拟页。</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;                 <span class="comment">// 指代当前页的状态信息。PG_reserved 表示当前页是否为保留页，PG_property 指代当前页是否空闲，仅内存块的第一个页设置此字段，内存块的其余页均设置为 0。</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> property;          <span class="comment">// 指代空闲内存块所包含的空闲页个数，仅空闲内存块的第一个空闲页设置此字段，其余空闲页均设置为 0。</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> page_link;         <span class="comment">// 双向链表节点。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>熟悉此两大数据结构各字段含义和 First-Fit 思想，很容易理解 <code>default_pmm.c</code> 所做的工作，在此不再赘述。</p>
<p>值得一说的是：<code>ucore</code> 如何初始化 <code>free_area_t</code>？</p>
<p>初始化工作具体分为两部分：</p>
<ul>
<li><p><code>init_pmm_manager()</code></p>
<p>初始化物理内存管理器为 <code>default_pmm_manager</code>，并调用该管理器的 <code>init()</code> 以初始化 <code>free_list</code> 和 <code>nr_free</code> 。</p>
</li>
<li><p><code>page_init()</code></p>
<p>基于内存探测结果，将空闲物理块放置于 <code>free_list</code> 中，以供管理器进行管理。</p>
<p>鉴于此函数比较重要，在此简单列举其实现源代码 (已忽略部分无关代码)：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">page_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 之前放置内存探测结构的位置便是 0x8000 + KERNBASE，如今获取它。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">e820map</span> *<span class="title">memmap</span> =</span> (struct e820map *)(<span class="number">0x8000</span> + KERNBASE);</span><br><span class="line">    <span class="comment">// maxpa 用于存放最大可用物理内存地址(注：ucore 设置可用物理空间最大为 KMEMSIZE，因此 maxpa 不可能超过此值，下面代码有设置)。</span></span><br><span class="line">    <span class="keyword">uint64_t</span> maxpa = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; memmap-&gt;nr_map; i ++) &#123;</span><br><span class="line">        <span class="keyword">uint64_t</span> begin = memmap-&gt;<span class="built_in">map</span>[i].addr, end = begin + memmap-&gt;<span class="built_in">map</span>[i].size;</span><br><span class="line">        <span class="comment">// 如果内存块类型为 E820_ARM 表明，其可供 OS 使用。</span></span><br><span class="line">        <span class="keyword">if</span> (memmap-&gt;<span class="built_in">map</span>[i].type == E820_ARM) &#123;</span><br><span class="line">            <span class="keyword">if</span> (maxpa &lt; end &amp;&amp; begin &lt; KMEMSIZE) &#123;</span><br><span class="line">                maxpa = end;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (maxpa &gt; KMEMSIZE) &#123;</span><br><span class="line">        maxpa = KMEMSIZE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// kernel.ld 中 .bss 数据段的结尾，基本也属于 OS 代码部分的结尾。</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">char</span> end[];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算所含页数，设置页描述数组 pages 的起始位置。</span></span><br><span class="line">    npage = maxpa / PGSIZE;</span><br><span class="line">    pages = (struct Page *)ROUNDUP((<span class="keyword">void</span> *)end, PGSIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 0~maxpa 部分的物理页，设为保留页。</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; npage; i ++) &#123;</span><br><span class="line">        SetPageReserved(pages + i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 页描述数组的结尾位置。</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> freemem = PADDR((<span class="keyword">uintptr_t</span>)pages + <span class="keyword">sizeof</span>(struct Page) * npage);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 page table 结尾 ~ maxpa 空间放置于空闲链表内(目前仅涉及内核空间，后续 ucore 实验可能涉及用户空间)。</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; memmap-&gt;nr_map; i ++) &#123;</span><br><span class="line">        <span class="keyword">uint64_t</span> begin = memmap-&gt;<span class="built_in">map</span>[i].addr, end = begin + memmap-&gt;<span class="built_in">map</span>[i].size;</span><br><span class="line">        <span class="keyword">if</span> (memmap-&gt;<span class="built_in">map</span>[i].type == E820_ARM) &#123;</span><br><span class="line">            <span class="keyword">if</span> (begin &lt; freemem) &#123;</span><br><span class="line">                begin = freemem;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (end &gt; KMEMSIZE) &#123;</span><br><span class="line">                end = KMEMSIZE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (begin &lt; end) &#123;</span><br><span class="line">                begin = ROUNDUP(begin, PGSIZE);</span><br><span class="line">                end = ROUNDDOWN(end, PGSIZE);</span><br><span class="line">                <span class="keyword">if</span> (begin &lt; end) &#123;</span><br><span class="line">                    init_memmap(pa2page(begin), (end - begin) / PGSIZE);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * QEMU 的物理内存探测结果布局：</span></span><br><span class="line"><span class="comment">    * e820map:</span></span><br><span class="line"><span class="comment">    * memory: 0009fc00, [00000000, 0009fbff], type = 1.</span></span><br><span class="line"><span class="comment">    * memory: 00000400, [0009fc00, 0009ffff], type = 2.</span></span><br><span class="line"><span class="comment">    * memory: 00010000, [000f0000, 000fffff], type = 2.</span></span><br><span class="line"><span class="comment">    * memory: 07ee0000, [00100000, 07fdffff], type = 1.</span></span><br><span class="line"><span class="comment">    * memory: 00020000, [07fe0000, 07ffffff], type = 2.</span></span><br><span class="line"><span class="comment">    * memory: 00040000, [fffc0000, ffffffff], type = 2.</span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    * 注：type 取值为 1，表示 OS 可用空间；type 取值为其他值，则 OS 不可用，仅供某些设备可用(具体不谈，知道即可)。</span></span><br><span class="line"><span class="comment">    * 按照上述代码以及探测结果可知，最大可用空间为 [0~07fdffff]，近似等于 [0~128M]。</span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    * entry.S 中，设置基本页表 KERNBASE + (0 ~ 4M) ~ (0 ~ 4M) 的映射关系。</span></span><br><span class="line"><span class="comment">    * 根据最开始的汇编代码可知：0~1M 已经供给 BIOS 和 BootLoader 使用，OS 使用的是 1~4M 空间。</span></span><br><span class="line"><span class="comment">    * 这里就存在一个问题，重新设置页表前，OS 真的不会超过 4M 吗，即所需页面不会超过 3 * 1024 / 4 = 768？</span></span><br><span class="line"><span class="comment">    * 简单分析一下：</span></span><br><span class="line"><span class="comment">    *     运行代码查看 end 取值，可以发现其值为 0xc011bf28，刨去 BIOS 和 BootLoader 所占空间，可知：OS 代码、数据部分所占 27 个页面。</span></span><br><span class="line"><span class="comment">    *     page table 所需页面计算：128M = 128 * 1024 / 4 (32768) 页面 = 每个页面大致容纳 4K/20=200 个 page 信息，因此总共需要约 163 个页面。</span></span><br><span class="line"><span class="comment">    *     由此可知，OS 是不会超过 4M 的。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="练习二"><a href="#练习二" class="headerlink" title="练习二"></a>练习二</h2><p>该练习用于了解页目录表、页表的使用，以及虚拟地址的转换流程。</p>
<p>对于 <code>ucore</code> 而言，如此划分 32 位的线性地址 (其中宏 <code>PDX/PTX/PGOFF/PPN</code> 分别用于获取线性地址的相应部分)：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// +--------10------+-------10-------+---------12----------+</span></span><br><span class="line"><span class="comment">// | Page Directory |   Page Table   | Offset within Page  |</span></span><br><span class="line"><span class="comment">// |      Index     |     Index      |                     |</span></span><br><span class="line"><span class="comment">// +----------------+----------------+---------------------+</span></span><br><span class="line"><span class="comment">//  \--- PDX(la) --/ \--- PTX(la) --/ \---- PGOFF(la) ----/</span></span><br><span class="line"><span class="comment">//  \----------- PPN(la) -----------/</span></span><br></pre></td></tr></table></figure>
<p>对于页目录表或者页表而言，其均 4KB 对齐，且表项均为 <code>int</code> 整数 (因为 4KB 对齐，那么页表或页的物理地址的低 12 位一定为 0，那么表项可使用这低 12 位存放权限信息，例如，当前页表或页可读、可写、是否存在)。</p>
<p><code>get_pte()</code> 函数的具体实现，详见源代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">pte_t</span> * <span class="title">get_pte</span><span class="params">(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">uintptr_t</span> la, <span class="keyword">bool</span> create)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 基于宏 PDX 及页目录表基址 pgdir，获取线性地址 la 所对应的页目录表条目。</span></span><br><span class="line">    <span class="keyword">pde_t</span> *pdep = pgdir + PDX(la);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断当前条目是否存在对应页表。</span></span><br><span class="line">    <span class="keyword">if</span> ( !(*pdep &amp; PTE_P))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 尝试分配一个物理页，以此作为页表。</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Page</span>* <span class="title">page</span> =</span> alloc_page();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分配失败或者无需新建，则直接返回。</span></span><br><span class="line">        <span class="keyword">if</span> (!create || page == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 需要使用此页表，设置引用数。基于 page2pa 获取该页对应的物理地址(页描述数组起始地址与 page 地址的差，表明其间存在多少个页描述结构，一个页描述结构对应 4KB 空间，那么很容易计算当前页所对应的物理地址)。</span></span><br><span class="line">        set_page_ref(page, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">uintptr_t</span> pa = page2pa(page);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 清空该页信息(pa 为物理地址，需要将其转换为虚拟地址，因为分段机制采用的是扁平模式，因此虚拟地址等价于线性地址。对于目前的内核而言，线性地址与物理地址间相差 0xC000000，因此很容易实现地址转换)。</span></span><br><span class="line">        <span class="built_in">memset</span>(KADDR(pa), <span class="number">0</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 建立页表与页目录间的对应关系，并设置相应权限。</span></span><br><span class="line">        *pdep = pa | PTE_P | PTE_W | PTE_U ;   </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回 la 对应的具体页表条目(因为页目录条目对应的是物理地址，同样需要将其转换为虚拟地址)。</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">pte_t</span> *)(KADDR(PDE_ADDR(*pdep))) + PTX(la);         </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：函数参数、指针操作，所涉及的地址均为虚拟地址，而非实际物理地址。</p>
<h2 id="练习三"><a href="#练习三" class="headerlink" title="练习三"></a>练习三</h2><p>该练习用于了解页目录表、页表的使用，以及虚拟地址的转换流程。</p>
<p><code>page_remove_pte()</code> 函数的具体实现，详见源代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">page_remove_pte(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">uintptr_t</span> la, <span class="keyword">pte_t</span> *ptep) &#123;</span><br><span class="line">	<span class="comment">// 判断当前页目录条目是否存在相应的页表，如果不存在则无需移除。</span></span><br><span class="line">    <span class="keyword">if</span> (*ptep &amp; PTE_P) &#123;</span><br><span class="line">        <span class="comment">// 获取相应页表对应的页描述结构</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">page</span> =</span> pte2page(*ptep);</span><br><span class="line">        <span class="comment">// 解除映射关系，自然需要引用数减一，如果引用数归零，则释放此页面。</span></span><br><span class="line">        <span class="keyword">if</span> (page_ref_dec(page) == <span class="number">0</span>) &#123;</span><br><span class="line">            free_page(page);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重置页目录条目，并清除 tlb 中有关此线性地址 la 的无效信息。</span></span><br><span class="line">        *ptep = <span class="number">0</span>;</span><br><span class="line">        tlb_invalidate(pgdir, la);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="扩展练习一"><a href="#扩展练习一" class="headerlink" title="扩展练习一"></a>扩展练习一</h2><p>该练习用于熟悉并简要实现伙伴系统 (Buddy System)。</p>
<p>虽然没有完成这个练习，但是在此简单说明其实现原理。</p>
<p>对于伙伴系统而言，首先预备两个数据结构：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设定总共存在 11 种不同大小的内存块，块大小分别为 2^0,...,2^10。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> buddy_block_size 11</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表集，将块大小为 2^i 的空闲块放置于 buddy_free_area[i] 之中。</span></span><br><span class="line"><span class="keyword">free_area_t</span> buddy_free_area[buddy_block_size]</span><br><span class="line"><span class="comment">// 位图，记录伙伴块的分配情况，如果伙伴块均分配或均未分配，则该值为 0，否则该值为 1。</span></span><br><span class="line"><span class="comment">// 该结构应当基于位实现，在此简化，使用 byte 代替。</span></span><br><span class="line">byte bitmap[buddy_block_size][]</span><br></pre></td></tr></table></figure>
<p>接下来，简要介绍主要操作：</p>
<ul>
<li><p><code>init(void)</code></p>
<p>与 <code>default_init(void)</code> 类似，初始化两个数据结构。</p>
</li>
<li><p><code>init_memmap(struct Page *base, size_t n)</code></p>
<p>对于伙伴系统而言，每个空闲链表只能存放块大小为 <code>2^i</code> 的块，因此需要将 <code>base</code> 拆分为合适的块，然后插入至相应的链表当中。</p>
</li>
<li><p><code>alloc_pages(size_t n)</code></p>
<p>首先寻找合适的 <code>N = 2^i</code>，使得 <code>N/2 &lt; n &lt;= N</code>；然后从 <code>buddy_free_area[i]</code>  开始，向上找到一个空闲块，如果该块大于 <code>N</code>，则需不断拆分，直至找到块大小刚好为 <code>N</code> 的空闲块 (拆分得到的其他块需放置到 <code>buddy_free_area</code> 合适的位置)，并设置 <code>bitmap[i][]</code> 相应位置。</p>
</li>
<li><p><code>free_pages(struct Page *base, size_t n)</code></p>
<p>假定 <code>n = 2^i</code>，首先搜索 <code>bitmap[i][]</code> 以判断伙伴块是否空闲，如果是则需合并两者，随后递归执行 <code>free_page(base, n &lt;&lt; 1)</code>，否则直接将其插入至 <code>buddy_free_area[i]</code> 即可，并设置 <code>bitmap[i][]</code> 相应位置。</p>
</li>
</ul>
<blockquote>
<p>伙伴系统的优点：较好地解决了外部碎片问题；适合大内存分配。</p>
<p>伙伴系统的缺点：性能开销偏大；如果所需内存偏小，则存在较严重的内部碎片。</p>
</blockquote>
<h2 id="扩展练习二"><a href="#扩展练习二" class="headerlink" title="扩展练习二"></a>扩展练习二</h2><p>该练习用于熟悉并简要实现 slub 分配机制。</p>
<p>该练习同样没有完成，同样在此说明其实现原理。</p>
<p>slub 分配机制的整体框架如图所示 (基于分离适配思想、缓存思想而实现)：</p>
<img src="/2021/06/05/ucore/lab2/image-20210604140812397.png" width="30%;">

<blockquote>
<p>分离适配思想：指代将空闲块划分为若干类别进行存放，当请求特定大小的空闲块时，从指代类别中进行分配。伙伴系统、slub 分类机制、堆动态分配，都是基于此分配空闲空间的。</p>
<p>缓存思想：slub 分配机制基于底层的伙伴系统而实现，该思想指代当分配块释放后，并不直接将其返回给底层分配系统，而是将其缓存起来，等待后续分配使用。</p>
</blockquote>
<p>在 slub 分配机制中，类别 (指代 <code>kmem_cache</code>) 划分为两类：通用型和专用型。前者所存放的空闲块大小依次为 8KB/16KB/…/8192KB (当所需块大小大于 8KB，则会直接使用伙伴系统进行分配)，后者所存放的空闲块大小根据指定数据结构进行设定 (<strong>此一点应当是 slub 的最大亮点</strong>)。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@VM-8-9-centos]<span class="comment"># cat /proc/slabinfo</span></span><br><span class="line">slabinfo - version: 2.1</span><br><span class="line"><span class="comment"># name            &lt;active_objs&gt; &lt;num_objs&gt; &lt;objsize&gt; &lt;objperslab&gt; &lt;pagesperslab&gt; : tunables &lt;limit&gt; &lt;batchcount&gt; &lt;sharedfactor&gt; : slabdata &lt;active_slabs&gt; &lt;num_slabs&gt; &lt;sharedavail&gt;</span></span><br><span class="line">...</span><br><span class="line">vm_area_struct     12392  13014    216   18    1 : tunables    0    0    0 : slabdata    723    723      0</span><br><span class="line">mm_struct            184    200   1600   20    8 : tunables    0    0    0 : slabdata     10     10      0</span><br><span class="line">shared_policy_node   5015   5015     48   85    1 : tunables    0    0    0 : slabdata     59     59      0</span><br><span class="line">numa_policy           15     15    264   15    1 : tunables    0    0    0 : slabdata      1      1      0</span><br><span class="line">radix_tree_node    15392  17234    584   14    2 : tunables    0    0    0 : slabdata   1231   1231      0</span><br><span class="line">idr_layer_cache      240    240   2112   15    8 : tunables    0    0    0 : slabdata     16     16      0</span><br><span class="line">kmalloc-8192          39     44   8192    4    8 : tunables    0    0    0 : slabdata     11     11      0</span><br><span class="line">kmalloc-4096         117    144   4096    8    8 : tunables    0    0    0 : slabdata     18     18      0</span><br><span class="line">kmalloc-2048         458    528   2048   16    8 : tunables    0    0    0 : slabdata     33     33      0</span><br><span class="line">kmalloc-1024        1399   1424   1024   16    4 : tunables    0    0    0 : slabdata     89     89      0</span><br><span class="line">kmalloc-512          763    800    512   16    2 : tunables    0    0    0 : slabdata     50     50      0</span><br><span class="line">kmalloc-256         3132   3376    256   16    1 : tunables    0    0    0 : slabdata    211    211      0</span><br><span class="line">kmalloc-192         2300   2352    192   21    1 : tunables    0    0    0 : slabdata    112    112      0</span><br><span class="line">kmalloc-128         1376   1376    128   32    1 : tunables    0    0    0 : slabdata     43     43      0</span><br><span class="line">kmalloc-96          1596   1596     96   42    1 : tunables    0    0    0 : slabdata     38     38      0</span><br><span class="line">kmalloc-64         16632  20800     64   64    1 : tunables    0    0    0 : slabdata    325    325      0</span><br><span class="line">kmalloc-32          1664   1664     32  128    1 : tunables    0    0    0 : slabdata     13     13      0</span><br><span class="line">kmalloc-16          4608   4608     16  256    1 : tunables    0    0    0 : slabdata     18     18      0</span><br><span class="line">kmalloc-8           4096   4096      8  512    1 : tunables    0    0    0 : slabdata      8      8      0</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>类别指向一系列 <code>slab</code>，其中每个 <code>slab</code> 是由若干连续页组建得到的 <code>object</code> 集 (<code>object</code> 或已分配，或未分配)，每次请求释放空间操作的主体对象便是 <code>object</code>。</p>
<blockquote>
<p>slab 管理空闲 <code>object</code> 的方式与堆动态内存分配管理空闲块的方式基本相同，都是在给定的空间内部利用空闲块存放相关链接信息。</p>
<p>伙伴系统管理空闲块的方式则与它们并不相同，则是在另外某个特定地方存放相关链接信息 (对于 ucore 而言，存放于 page Table 中各 page 数据结构的链表结构中)。</p>
</blockquote>
<p>slub 分配机制具体如何执行分配和释放 <code>object</code> 的操作，可详见 <a href="https://blog.csdn.net/lukuen/article/details/6935068">linux 内核 内存管理 slub算法</a>  。</p>
<blockquote>
<p>slub 分配机制的优点：有效解决小型内存分配问题、占用内存少。</p>
</blockquote>
<h2 id="地址映射的若干阶段"><a href="#地址映射的若干阶段" class="headerlink" title="地址映射的若干阶段"></a>地址映射的若干阶段</h2><p>在 <code>lab2</code> 中，最为复杂的，莫过于与分段机制和分页机制相关的若干地址映射阶段，在此简要介绍其实现过程。</p>
<ul>
<li><p>第一阶段</p>
<p><code>bootasm.S</code> 中开启分段机制，其所涉段表定义如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gdt:</span><br><span class="line">    SEG_NULLASM                                     <span class="comment"># null seg</span></span><br><span class="line">    SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)           <span class="comment"># code seg for bootloader and kernel</span></span><br><span class="line">    SEG_ASM(STA_W, 0x0, 0xffffffff)                 <span class="comment"># data seg for bootloader and kernel</span></span><br></pre></td></tr></table></figure>
<p>地址映射关系为：虚拟地址 == 线性地址 == 物理地址。</p>
</li>
<li><p>第二阶段</p>
<p><code>bootmain.c</code> 中加载 OS，由于编译的加载位置与实际的加载位置并不相同，因此存在一个隐性的地址映射关系 (实际并不存在)：虚拟地址 -  0xC0000000== 线性地址 == 物理地址。</p>
</li>
<li><p>第三阶段</p>
<p><code>entry.S</code> 中开启分页机制，其所涉页表如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.globl __boot_pgdir</span><br><span class="line">    # 映射虚拟地址 0 ~ 4M 至物理地址 0 ~ 4M(临时条目，跳转至 kern_init 前即会删除)。</span><br><span class="line">    .long REALLOC(__boot_pt1) + (PTE_P | PTE_U | PTE_W)</span><br><span class="line">    # 空白填充虚拟地址 4M ~ 0xC0000000 之间的页目录表项</span><br><span class="line">    .space (KERNBASE &gt;&gt; PGSHIFT &gt;&gt; 10 &lt;&lt; 2) - (. - __boot_pgdir) </span><br><span class="line">    # 映射虚拟地址 0xC0000000 + (0 ~ 4M) 至物理地址 0 ~ 4M。</span><br><span class="line">    .long REALLOC(__boot_pt1) + (PTE_P | PTE_U | PTE_W)</span><br><span class="line">    .space PGSIZE - (. - __boot_pgdir)</span><br></pre></td></tr></table></figure>
<p>地址映射关系为：虚拟地址 == 线性地址 == 物理地址  +  0xC0000000 (仅限 0 ~ 4M)。</p>
</li>
<li><p>第四阶段</p>
<p><code>pmm_init() -&gt; boot_map_segment()</code> 中重新设置页目录表和页表，从而得到如下地址映射关系：虚拟地址== 线性地址 == 物理地址  +  0xC0000000 (0~0x38000000，目前 <code>ucore</code> 所能访问的全部地址空间)。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>ucore</category>
      </categories>
  </entry>
  <entry>
    <title>lab1 — 系统软件启动过程</title>
    <url>/2021/05/27/ucore/lab1/</url>
    <content><![CDATA[<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p><code>make/gdb</code> 使用、磁盘 <code>MBR</code> 格式规范、BIOS 执行流程、bootloader 执行流程、<code>ELF</code> 文件格式、函数调用底层过程、中断处理流程。</p>
<a id="more"></a>

<h2 id="练习一"><a href="#练习一" class="headerlink" title="练习一"></a>练习一</h2><p>此练习用于了解编译 <code>ucore</code> 源代码为镜像文件 <code>ucore.img</code> 的整体流程。</p>
<blockquote>
<p>因为我不是很懂 <code>Makefile</code>，因此我会尽可能地避免介绍 <code>Makefile</code> 内部相关指令含义。</p>
</blockquote>
<p>在命令行目录 <code>labcodes_answer/lab1_result</code> 中，依次输入命令 <code>make clean,make &quot;V=&quot;</code>，即可得到详细的编译过程 (已删除若干冗余输出结果)：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 编译 .c 得到 .o 文件。着重说明几个重要参数：-ggdb 用于生成 gdb 调试信息、-nostdinc 不使用标准头文件、-Ixxx 使用指定位置 xxx 处的头文件。</span></span><br><span class="line">+ cc kern/init/init.c</span><br><span class="line">gcc -Ikern/init/ -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/<span class="built_in">trap</span>/ -Ikern/mm/ -c kern/init/init.c -o obj/kern/init/init.o</span><br><span class="line">+ cc kern/libs/stdio.c</span><br><span class="line">gcc -Ikern/libs/ -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/<span class="built_in">trap</span>/ -Ikern/mm/ -c kern/libs/stdio.c -o obj/kern/libs/stdio.o</span><br><span class="line">...</span><br><span class="line">gcc -Ilibs/ -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/  -c libs/printfmt.c -o obj/libs/printfmt.o</span><br><span class="line">+ ld bin/kernel</span><br><span class="line"><span class="comment"># 链接上述 .o 文件得到 kernel 可执行文件。着重说明几个重要参数：-m elf_i386 仿真 elf_i386 机器的链接器功能、-nostdlib 不使用标准库、-T xxx 使用特定链接脚本 xxx (其中主要指定各段的起始地址，设定代码段应当位于 0x100000 处) 进行链接。</span></span><br><span class="line">ld -m    elf_i386 -nostdlib -T tools/kernel.ld -o bin/kernel  obj/kern/init/init.o obj/kern/libs/stdio.o obj/kern/libs/readline.o obj/kern/debug/panic.o obj/kern/debug/kdebug.o obj/kern/debug/kmonitor.o obj/kern/driver/clock.o obj/kern/driver/console.o obj/kern/driver/picirq.o obj/kern/driver/intr.o obj/kern/<span class="built_in">trap</span>/trap.o obj/kern/<span class="built_in">trap</span>/vectors.o obj/kern/<span class="built_in">trap</span>/trapentry.o obj/kern/mm/pmm.o  obj/libs/string.o obj/libs/printfmt.o</span><br><span class="line"><span class="comment"># 编译 .S 或 .c 得到 .o。</span></span><br><span class="line">+ cc boot/bootasm.S</span><br><span class="line">gcc -Iboot/ -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Os -nostdinc -c boot/bootasm.S -o obj/boot/bootasm.o</span><br><span class="line">+ cc boot/bootmain.c</span><br><span class="line">gcc -Iboot/ -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Os -nostdinc -c boot/bootmain.c -o obj/boot/bootmain.o</span><br><span class="line"><span class="comment"># 编译得到 sign 可执行文件，其用于判断并规格化主引导扇区(如果满足容量限制的话)。</span></span><br><span class="line">+ cc tools/sign.c</span><br><span class="line">gcc -Itools/ -g -Wall -O2 -c tools/sign.c -o obj/sign/tools/sign.o</span><br><span class="line">gcc -g -Wall -O2 obj/sign/tools/sign.o -o bin/sign</span><br><span class="line"><span class="comment"># 链接 bootblock.o 和 bootasm 得到 bootblock 可执行文件。着重说明几个重要参数：-m elf_i386 仿真 elf_i386 机器的链接器功能、-nostdlib 不使用标准库、-N 指定代码段和数据段可读写、-e 指定入口点、-Ttext 指定代码段的起始地址</span></span><br><span class="line">+ ld bin/bootblock</span><br><span class="line">ld -m    elf_i386 -nostdlib -N -e start -Ttext 0x7C00 obj/boot/bootasm.o obj/boot/bootmain.o -o obj/bootblock.o</span><br><span class="line"><span class="comment"># 此两句输出结果表明，bootblock.out 所占容量为 500 bytes，并以此为基础，成功构建规格化的主引导扇区 (就是将 512 字节的最后两个字节设为 0x55AA，此两个字节的存在表明当前扇区为规格化的主引导扇区)。</span></span><br><span class="line"><span class="string">&#x27;obj/bootblock.out&#x27;</span> size: 500 bytes</span><br><span class="line">build 512 bytes boot sector: <span class="string">&#x27;bin/bootblock&#x27;</span> success!</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建空的 ucore.img 镜像文件，并将 bootblock 和 kernel 放置其中。</span></span><br><span class="line">dd <span class="keyword">if</span>=/dev/zero of=bin/ucore.img count=10000</span><br><span class="line">10000+0 records <span class="keyword">in</span></span><br><span class="line">10000+0 records out</span><br><span class="line">5120000 bytes (5.1 MB, 4.9 MiB) copied, 0.0307689 s, 166 MB/s</span><br><span class="line"><span class="comment"># 放置 bootblock 至 ucore.img 的第一个扇区</span></span><br><span class="line">dd <span class="keyword">if</span>=bin/bootblock of=bin/ucore.img conv=notrunc</span><br><span class="line">1+0 records <span class="keyword">in</span></span><br><span class="line">1+0 records out</span><br><span class="line">512 bytes copied, 0.000149858 s, 3.4 MB/s</span><br><span class="line"><span class="comment"># 放置 kernel 至 ucore.img 的第二个扇区。</span></span><br><span class="line">dd <span class="keyword">if</span>=bin/kernel of=bin/ucore.img seek=1 conv=notrunc</span><br><span class="line">146+1 records <span class="keyword">in</span></span><br><span class="line">146+1 records out</span><br><span class="line">74868 bytes (75 kB, 73 KiB) copied, 0.000415369 s, 180 MB/s</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可详见 <code>os_kernel_lab/labcodes_answer/lab1_result/tools/sign.c</code> 以查看其功能。</p>
<p><code>ucore</code> 源代码中的 <code>bootblock</code> 也是常说的 <code>bootloader</code>。</p>
<p><code>ucore</code> 的 <code>MBR</code> 十分简单，含 <code>bootloader</code> 而不含磁盘分区表信息。</p>
</blockquote>
<h2 id="练习二"><a href="#练习二" class="headerlink" title="练习二"></a>练习二</h2><p>此练习用于了解计算机启动至 <code>bootblock</code> 开始执行期间的指令执行顺序。</p>
<blockquote>
<p>对于 intel 以往机器而言，地址线 20 位 (物理寻址空间 2^20 = 1M)，而寄存器仅 16 位。为实现访问全部的地址空间，另设若干段寄存器 (例如 CS 表示代码段寄存器)，其中存放段基址。此时实际物理地址 = (段基址 &lt;&lt; 4 + IP)。鉴于此种地址访问方式直接访问物理地址，因此其称为 <strong>实模式</strong>。</p>
<p>为兼容以往机器，intel x86 机器启动后，首先进入 <strong>实模式</strong>，并寻址第一条指令 <code>CS:IP = 0xf000:0xfff0 =&gt; 0xffff0</code> 以执行 BIOS 指令。</p>
</blockquote>
<p>为了解此执行顺序，需要进行单步调试。</p>
<p>首先查看 <code>labcodes/lab1/Makefile</code> 中的 <code>debug</code> 部分指令： </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># $(QEMU) 执行 QEMU 模拟器、-S 启动 QEMU 而不启动 CPU，等待 monitor (其用于与 QEMU 通信，以执行暂停、运行模拟器等工作) 输入 &#x27;c&#x27; 后才启动 CPU 以进行模拟、-s 等待 gdb 远程连接、-D 指定日志存放位置、-monitor 重定向 monitor 至 stdio、 -hda 指定硬盘镜像文件</span></span><br><span class="line">$(V)$(TERMINAL) -e <span class="string">&quot;<span class="subst">$(QEMU)</span> -S -s -d in_asm -D <span class="subst">$(BINDIR)</span>/q.log -monitor stdio -hda $&lt; -serial null&quot;</span></span><br><span class="line">$(V)sleep 2</span><br><span class="line"><span class="comment"># 启动 gdb 调试，并使用 lab1init 进行初始化。</span></span><br><span class="line">$(V)$(TERMINAL) -e <span class="string">&quot;gdb -q -x tools/gdbinit&quot;</span></span><br></pre></td></tr></table></figure>
<p>其中 <code>gdbinit</code> 内容如下 (相较于源代码，此部分已经修改)：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 加载 kernel 的调试信息(暂时没用)</span></span><br><span class="line">file bin/kernel</span><br><span class="line"><span class="comment"># 设置当前所模拟机器的指令架构</span></span><br><span class="line"><span class="built_in">set</span> architecture i8086</span><br><span class="line"><span class="comment"># 远程连接 QEMU</span></span><br><span class="line">target remote :1234</span><br><span class="line"><span class="comment"># 根据上述的 debug 部分指令可知，此时仅启动 QEMU 而尚未启动 CPU，因此其位于 BIOS 尚未执行的状态。</span></span><br></pre></td></tr></table></figure>
<p>在命令行目录 <code>labcodes/lab1</code> 中，输入命令 <code>make debug</code>，开始进行调试。</p>
<p>查看 CS：IP 取值及此处指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># CS:IP 取值与上述相同。</span></span><br><span class="line">(gdb) p/x <span class="variable">$cs</span></span><br><span class="line"><span class="variable">$2</span> = 0xf000</span><br><span class="line">(gdb) p/x <span class="variable">$eip</span></span><br><span class="line"><span class="variable">$3</span> = 0xfff0</span><br><span class="line"><span class="comment"># 此处指令为一跳转指令，用于跳转至实际的 BIOS 指令 (如此设计，仍是兼容以往机器的缘故)。</span></span><br><span class="line">(gdb) x /i 0xffff0</span><br><span class="line">   0xffff0:     ljmp   <span class="variable">$0x3630</span>,<span class="variable">$0xf000e05b</span></span><br><span class="line"><span class="comment"># 大佬解释说，$0x3630 为 QEMU 版本问题，可以忽略。</span></span><br><span class="line"><span class="comment"># ljmp $0xf000e05b =&gt; 设置 CS:IP=0xf000:0xe05b，并跳转至此位置执行 BIOS 代码。</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>简要叙述 BIOS 功能：</p>
<ul>
<li>提供基本的输入输出功能 (例如，机器启动进入 BIOS 界面后，允许输入键盘信息并输出信息至显示屏)。</li>
<li>硬件自检 (检查与机器启动密切相关的硬件是否正常，如果不正常则直接启动失败，否则才允许继续启动)</li>
<li>加载 <code>bootloader</code> (BIOS 允许从指定磁盘启动，那么它便会加载指定磁盘的 0 号扇区，即 <code>MBR</code> ，至 <code>0x0:0x7C00</code> 处，并设置 <code>CS:IP</code> 为此值，从而执行 <code>bootloader</code> 指令)。</li>
</ul>
</blockquote>
<p>输入如下指令，以设置断点并运行机器至断点指令处。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) b *0x7c00</span><br><span class="line">(gdb) continue</span><br></pre></td></tr></table></figure>
<p>查看断点处指令，可得 (其与 <code>bootasm.S</code> 文件中 <code>start</code> 处指令相同，即执行的是此处指令，相关原因可见上述的 <code>make &quot;V=&quot;</code> 输出结果)：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(gdb) p/x <span class="variable">$pc</span></span><br><span class="line"><span class="variable">$4</span> = 0x7c00</span><br><span class="line">(gdb) x /5i <span class="variable">$pc</span></span><br><span class="line">=&gt; 0x7c00:      cli</span><br><span class="line">   0x7c01:      cld</span><br><span class="line">   0x7c02:      xor    %eax,%eax</span><br><span class="line">   0x7c04:      mov    %eax,%ds</span><br><span class="line">   0x7c06:      mov    %eax,%es</span><br></pre></td></tr></table></figure>
<h2 id="练习三"><a href="#练习三" class="headerlink" title="练习三"></a>练习三</h2><p>此练习用于了解 <code>bootasm.S</code> 代码所做的工作。</p>
<p><code>bootasm.S</code> 是 <code>bootloader</code> 的一部分，其主要完成三件事：1. 开启 A20；2. 初始化 GDT 表；3. 开启保护模式。</p>
<blockquote>
<p>对于 intel x86 机器而言，其地址线 32 位 (物理寻址空间 2^32 = 4G)，普通寄存器 32 位，段寄存器仍为 16 位 (兼容以往机器)。为访问全部的地址空间且基于分段提供保护功能，段寄存器此时存放 GPT 索引表位置及相关保护位，其中 GPT 表项存放段初始位置 (32 位)、段长、访问权限等信息，此时实际物理地址 = (段索引表示的段初始位置 + IP)。鉴于此种地址访问方式间接访问物理地址，因此其称为 <strong>保护模式</strong>。(在我看来，分段机制基本没用，不如使用分页机制，而且现今 intel 采用扁平模式已经略过分段机制了)</p>
</blockquote>
<p><code>bootasm.S</code> 的具体实现，详见源代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;asm.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注：Intel x86 中的段选择器，也称为段选择子。</span></span><br><span class="line"><span class="comment"># 段选择子仍存在一定规则，高 13 位表示其在 gdt 中的索引位，低 3 位为保护信息。</span></span><br><span class="line">.<span class="built_in">set</span> PROT_MODE_CSEG,        0x8                     <span class="comment"># kernel code segment selector</span></span><br><span class="line">.<span class="built_in">set</span> PROT_MODE_DSEG,        0x10                    <span class="comment"># kernel data segment selector</span></span><br><span class="line">.<span class="built_in">set</span> CR0_PE_ON,             0x1                     <span class="comment"># protected mode enable flag</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># start address should be 0:7c00, in real mode, the beginning address of the running bootloader</span></span><br><span class="line">.globl start</span><br><span class="line">start:</span><br><span class="line"></span><br><span class="line"><span class="comment"># bootloader 所做的第一件事：使能 A20 地址线，如此便可访问 4G 物理地址空间 (仍是兼容以往机器的缘故)。</span></span><br><span class="line"><span class="comment"># 使能 A20 地址线比较复杂，涉及较多底层硬件，简单来说：禁中断、等待 Input Buffer 为空、输入写命令、等待 Input Buffer 为空、输入置位命令。</span></span><br><span class="line">.code16                                             <span class="comment"># Assemble for 16-bit mode</span></span><br><span class="line">    <span class="comment"># 禁中断</span></span><br><span class="line">    cli                                             <span class="comment"># Disable interrupts</span></span><br><span class="line">    cld                                             <span class="comment"># String operations increment</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Set up the important data segment registers (DS, ES, SS).</span></span><br><span class="line">    xorw %ax, %ax                                   <span class="comment"># Segment number zero</span></span><br><span class="line">    movw %ax, %ds                                   <span class="comment"># -&gt; Data Segment</span></span><br><span class="line">    movw %ax, %es                                   <span class="comment"># -&gt; Extra Segment</span></span><br><span class="line">    movw %ax, %ss                                   <span class="comment"># -&gt; Stack Segment</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Enable A20:</span></span><br><span class="line">seta20.1:</span><br><span class="line">    inb <span class="variable">$0x64</span>, %al                                  <span class="comment"># Wait for not busy(8042 input buffer empty).</span></span><br><span class="line">    testb <span class="variable">$0x2</span>, %al</span><br><span class="line">    jnz seta20.1</span><br><span class="line"></span><br><span class="line">    movb <span class="variable">$0xd1</span>, %al                                 <span class="comment"># 0xd1 -&gt; port 0x64</span></span><br><span class="line">    outb %al, <span class="variable">$0x64</span>                                 <span class="comment"># 0xd1 means: write data to 8042&#x27;s P2 port</span></span><br><span class="line"></span><br><span class="line">seta20.2:</span><br><span class="line">    inb <span class="variable">$0x64</span>, %al                                  <span class="comment"># Wait for not busy(8042 input buffer empty).</span></span><br><span class="line">    testb <span class="variable">$0x2</span>, %al</span><br><span class="line">    jnz seta20.2</span><br><span class="line"></span><br><span class="line">    movb <span class="variable">$0xdf</span>, %al                                 <span class="comment"># 0xdf -&gt; port 0x60</span></span><br><span class="line">    outb %al, <span class="variable">$0x60</span>                                 <span class="comment"># 0xdf = 11011111, means set P2&#x27;s A20 bit(the 1 bit) to 1</span></span><br><span class="line"><span class="comment"># 至此，完成使能 A20 操作。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 加载 gdtdesc 所表示的值至 gdtr 寄存器。 </span></span><br><span class="line">    lgdt gdtdesc</span><br><span class="line">    <span class="comment"># cr0 控制寄存器的部分作用在于控制处理器的工作模式，通过设置相关位，以开启保护模式。</span></span><br><span class="line">    movl %cr0, %eax</span><br><span class="line">    orl <span class="variable">$CR0_PE_ON</span>, %eax</span><br><span class="line">    movl %eax, %cr0</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 跳转至 protcseg，执行相关指令 (因为目前基于分段机制，因此汇编码需要设置段选择子和段内偏移，注意：实模式和保护模式的段寄存器含义不同)。</span></span><br><span class="line">    ljmp <span class="variable">$PROT_MODE_CSEG</span>, <span class="variable">$protcseg</span></span><br><span class="line"></span><br><span class="line">.code32                                             <span class="comment"># Assemble for 32-bit mode</span></span><br><span class="line">protcseg:</span><br><span class="line">    <span class="comment"># 设置 cs 以外的段寄存器取值为 $PROT_MODE_DSEG，即均设置为数据段选择子的取值。</span></span><br><span class="line">    movw <span class="variable">$PROT_MODE_DSEG</span>, %ax                       <span class="comment"># Our data segment selector</span></span><br><span class="line">    movw %ax, %ds                                   <span class="comment"># -&gt; DS: Data Segment</span></span><br><span class="line">    movw %ax, %es                                   <span class="comment"># -&gt; ES: Extra Segment</span></span><br><span class="line">    movw %ax, %fs                                   <span class="comment"># -&gt; FS</span></span><br><span class="line">    movw %ax, %gs                                   <span class="comment"># -&gt; GS</span></span><br><span class="line">    movw %ax, %ss                                   <span class="comment"># -&gt; SS: Stack Segment</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如此设置各个段寄存器的值后 (这些值应当都不会再发生变化了)，编译器中的逻辑地址 =&gt; 隐式转换为同等的线性地址 =&gt; 再做它处。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置栈顶指针 esp 和 栈顶指针所示栈帧底部的指针 ebp (esp 指向栈空间底部，此时并不存在栈帧，因此 ebp 没有含义，将其设为 0，以此作为到达栈底的条件判断)，并调用 bootmain 函数 (因此栈空间为 0 ~ start/0x7c00)。</span></span><br><span class="line">    <span class="comment"># 注意：栈空间的使用是不会覆盖即将执行的其他指令的，原因有二：1. 上述已执行了众多指令，这部分指令空间是可以被直接覆盖的；2. bootmain 中函数调用所需的栈空间并不多，并且加载完 OS 后，便会跳转至 0x100000 处执行。</span></span><br><span class="line">    movl <span class="variable">$0x0</span>, %ebp</span><br><span class="line">    movl <span class="variable">$start</span>, %esp</span><br><span class="line">    <span class="comment"># 调用此函数，其为 bootloader 的另一部分，主要完成加载 OS 工作。</span></span><br><span class="line">    call bootmain</span><br><span class="line"></span><br><span class="line">    <span class="comment"># If bootmain returns (it shouldn&#x27;t), loop.</span></span><br><span class="line">spin:</span><br><span class="line">    jmp spin</span><br><span class="line"></span><br><span class="line"><span class="comment"># Bootstrap GDT</span></span><br><span class="line">.p2align 2                                          <span class="comment"># force 4 byte alignment</span></span><br><span class="line"><span class="comment"># 对于 gdt 中的段描述符而言，其含有 64 位，不同部位表示特定的含义，此处使用定义于 &lt;asm.h&gt; 中的宏填充表项 </span></span><br><span class="line"><span class="comment"># 对于 gdt 的段描述符组织结构而言，第一项应当为空，其余随便，在此处第二三项分别与代码段和数据段相关。</span></span><br><span class="line">gdt:</span><br><span class="line">    <span class="comment"># 全 0。</span></span><br><span class="line">    SEG_NULLASM                                     <span class="comment"># null seg</span></span><br><span class="line">    <span class="comment"># 代码段具有读、执行权限，段基址 = 0，段界限 = 4G，即扁平化处理，以隐藏分段机制。</span></span><br><span class="line">    SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)           <span class="comment"># code seg for bootloader and kernel</span></span><br><span class="line">    <span class="comment"># 数据段具有读、写执行权限，段基址 = 0，段界限 = 4G，即扁平化处理，以隐藏分段机制。</span></span><br><span class="line">    SEG_ASM(STA_W, 0x0, 0xffffffff)                 <span class="comment"># data seg for bootloader and kernel</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于 gptr 寄存器而言，其高 32 位为 gdt 所在地址 (对应 .long gdt)，低 16 位为段界限 (对应 .word 0x17)</span></span><br><span class="line">gdtdesc:</span><br><span class="line">    <span class="comment"># 根据 gdt 具体结构可知，其含有 3 个段，因此段界限为 3 * 8 - 1 = 23 = 0x17</span></span><br><span class="line">    .word 0x17                                      <span class="comment"># sizeof(gdt) - 1</span></span><br><span class="line">    .long gdt                                       <span class="comment"># address gdt</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于现有的操作系统而言，<code>Bootloader</code> 的实现代码往往很多，MBR 内部根本无法容纳全部的 <code>Bootloader</code>。因此，其实现往往是这样的：MBR 内部的 <code>Bootloader</code> 代码用于定位、加载、运行另外一处位置的代码，而该部分代码为 Boot Loader 的实际实现代码。该部分代码通常包含一些通用的文件系统驱动程序，从而保证可以加载 OS。</p>
</blockquote>
<h2 id="练习四"><a href="#练习四" class="headerlink" title="练习四"></a>练习四</h2><p>此练习用于了解 <code>bootmain.c</code> 代码所做的工作。</p>
<p><code>bootmain.c</code> 是 <code>bootloader</code> 的另一部分，其主要完成 OS 的加载。</p>
<p><code>bootmain.c</code> 的具体实现，详见源代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;defs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;x86.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;elf.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设定扇区大小、ELFHDR 加载位置</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SECTSIZE        512</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELFHDR          ((struct elfhdr *)0x10000)      <span class="comment">// scratch space</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果当前磁盘尚未准备好，则一直循环等待。</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">waitdisk</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> ((inb(<span class="number">0x1F7</span>) &amp; <span class="number">0xC0</span>) != <span class="number">0x40</span>)</span><br><span class="line">        <span class="comment">/* do nothing */</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 此处采用最常见的磁盘读取方式(等待磁盘准备好、发送读命令、等待磁盘准备好，读取数据)。</span></span><br><span class="line"><span class="comment">// 如何直接操纵磁盘以读取扇区的方式，属于硬件相关，简单了解即可。</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readsect</span><span class="params">(<span class="keyword">void</span> *dst, <span class="keyword">uint32_t</span> secno)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    waitdisk();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每次读取一个扇区</span></span><br><span class="line">    outb(<span class="number">0x1F2</span>, <span class="number">1</span>);                         </span><br><span class="line">    outb(<span class="number">0x1F3</span>, secno &amp; <span class="number">0xFF</span>);</span><br><span class="line">    outb(<span class="number">0x1F4</span>, (secno &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line">    outb(<span class="number">0x1F5</span>, (secno &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line">    outb(<span class="number">0x1F6</span>, ((secno &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xF</span>) | <span class="number">0xE0</span>);</span><br><span class="line">    outb(<span class="number">0x1F7</span>, <span class="number">0x20</span>);                      <span class="comment">// cmd 0x20 - read sectors</span></span><br><span class="line"></span><br><span class="line">    waitdisk();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取扇区内容至 dst</span></span><br><span class="line">    insl(<span class="number">0x1F0</span>, dst, SECTSIZE / <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 kernel offset 偏移处读取 count 字节至 va 处。</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readseg</span><span class="params">(<span class="keyword">uintptr_t</span> va, <span class="keyword">uint32_t</span> count, <span class="keyword">uint32_t</span> offset)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uintptr_t</span> end_va = va + count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 磁盘数据以扇区为单位，如果 offset 位于扇区内部，我们便需要重新设置 va，以保证 offset 偏移处的数据位于原先 va 处。</span></span><br><span class="line">    va -= offset % SECTSIZE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为 kernel 开始于扇区 1，因此此处需要加一，以计算所读数据的开始扇区。</span></span><br><span class="line">    <span class="keyword">uint32_t</span> secno = (offset / SECTSIZE) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依次循环，以读取扇区数据。</span></span><br><span class="line">    <span class="keyword">for</span> (; va &lt; end_va; va += SECTSIZE, secno ++) &#123;</span><br><span class="line">        readsect((<span class="keyword">void</span> *)va, secno);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bootmain</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 读取磁盘指定位置的数据(可以看到，总共需要读取 8 个扇区，可能是为确保 ELF 头部全部被读至内存)至 (uintptr_t)ELFHDR (0x10000)。</span></span><br><span class="line">    readseg((<span class="keyword">uintptr_t</span>)ELFHDR, SECTSIZE * <span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断该文件是否为 ELF 文件</span></span><br><span class="line">    <span class="keyword">if</span> (ELFHDR-&gt;e_magic != ELF_MAGIC) &#123;</span><br><span class="line">        <span class="keyword">goto</span> bad;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proghdr</span> *<span class="title">ph</span>, *<span class="title">eph</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 ELF 文件中的 program header 表 (其中存放程序执行直接相关的目标文件结构信息，用于定位各段)，随后加载各段至指定位置。</span></span><br><span class="line">    ph = (struct proghdr *)((<span class="keyword">uintptr_t</span>)ELFHDR + ELFHDR-&gt;e_phoff);</span><br><span class="line">    eph = ph + ELFHDR-&gt;e_phnum;</span><br><span class="line">    <span class="keyword">for</span> (; ph &lt; eph; ph ++) &#123;</span><br><span class="line">        <span class="comment">// 此处会将各段加载至相应的虚拟地址中，该虚拟地址由 kernel.ld 链接脚本设定。查看该文件，可知：代码段位于 0x100000 处。</span></span><br><span class="line">        readseg(ph-&gt;p_va &amp; <span class="number">0xFFFFFF</span>, ph-&gt;p_memsz, ph-&gt;p_offset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用入口函数，无需返回</span></span><br><span class="line">    ((<span class="keyword">void</span> (*)(<span class="keyword">void</span>))(ELFHDR-&gt;e_entry &amp; <span class="number">0xFFFFFF</span>))();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bad 这部分没什么用。</span></span><br><span class="line">bad:</span><br><span class="line">    outw(<span class="number">0x8A00</span>, <span class="number">0x8A00</span>);</span><br><span class="line">    outw(<span class="number">0x8A00</span>, <span class="number">0x8E00</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* do nothing */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="练习五"><a href="#练习五" class="headerlink" title="练习五"></a>练习五</h2><p>此练习需要了解函数调用过程的底层原理，并基于此实现 <code>print_stackframe()</code> 函数。</p>
<p>函数调用过程时栈的组织结构可简化为下图：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">+|  栈底方向        | 高位地址</span><br><span class="line"> |    ...          |</span><br><span class="line"> |    ...          |</span><br><span class="line"> |  参数3           |</span><br><span class="line"> |  参数2           |</span><br><span class="line"> |  参数1           |</span><br><span class="line"> |  返回地址         |</span><br><span class="line"> |  上一层[ebp]     | &lt;-------- [ebp]</span><br><span class="line"> |  局部变量        |  低位地址</span><br></pre></td></tr></table></figure>
<p>基于寄存器 <code>ebp</code> 取值，我们可以很容易地得到如下内容：当前函数的参数、父函数的返回地址、父函数的 <code>ebp</code> 取值。基于父函数的 <code>ebp</code> 取值，我们可以递归得到祖先函数的相关信息。</p>
<p>基于上述知识，可以很容易实现 <code>print_stackframe()</code> 函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_stackframe</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 此二者函数借助于汇编代码以获取寄存器 ebp/eip 取值。</span></span><br><span class="line">     <span class="keyword">uint32_t</span> ebp = read_ebp();</span><br><span class="line">     <span class="keyword">uint32_t</span> eip = read_eip();</span><br><span class="line">     <span class="comment">// 正如 bootasm.S 中看到的，最初 ebp 取值为 0，因此可借于此判断是否到达栈底。</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; ebp != <span class="number">0</span> &amp;&amp; i &lt; STACKFRAME_DEPTH; i++)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">uint32_t</span>* args = (<span class="keyword">uint32_t</span>*)(ebp + <span class="number">8</span>);</span><br><span class="line">         cprintf(<span class="string">&quot;ebp:0x%08x eip:0x%08x args:0x%08x 0x%08x 0x%08x 0x%08x&quot;</span>, ebp, eip, args[<span class="number">0</span>], args[<span class="number">1</span>], args[<span class="number">2</span>], args[<span class="number">3</span>]);</span><br><span class="line">         cprintf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">         <span class="comment">// 借助于调试信息以获取其所在函数的位置信息。</span></span><br><span class="line">         print_debuginfo(eip - <span class="number">1</span>);</span><br><span class="line">         <span class="comment">// 更新 eip 和 ebp。</span></span><br><span class="line">         eip = ((<span class="keyword">uint32_t</span>*)ebp)[<span class="number">1</span>];</span><br><span class="line">         ebp = ((<span class="keyword">uint32_t</span>*)ebp)[<span class="number">0</span>];</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="练习六"><a href="#练习六" class="headerlink" title="练习六"></a>练习六</h2><p>此练习需要了解中断向量表及中断处理流程，从而实现中断初始化函数 <code>idt_init()</code> 及 <code>trap_dispatch()</code> 中的时钟中断处理。</p>
<p>首先简单介绍 <code>labcodes/lab1/kern/init/init.c</code> 文件内 <code>kern_init()</code> 函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kern_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">char</span> edata[], end[];</span><br><span class="line">    <span class="built_in">memset</span>(edata, <span class="number">0</span>, end - edata);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化控制台 (硬件相关，暂时忽略)。</span></span><br><span class="line">    cons_init();               </span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *message = <span class="string">&quot;(THU.CST) os is loading ...&quot;</span>;</span><br><span class="line">    cprintf(<span class="string">&quot;%s\n\n&quot;</span>, message);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印 OS 相关信息。</span></span><br><span class="line">    print_kerninfo();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最终会调用 print_stackframe() 函数，可以忽略。</span></span><br><span class="line">    grade_backtrace();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化物理内存(重点关注)</span></span><br><span class="line">    pmm_init();                 </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化中断控制器(涉及硬件底层，可以忽略) </span></span><br><span class="line">    pic_init();  </span><br><span class="line">    <span class="comment">// 初始化中断描述符表(重点关注)</span></span><br><span class="line">    idt_init();                 </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化时钟 (硬件相关，暂时忽略)</span></span><br><span class="line">    clock_init();              </span><br><span class="line">    <span class="comment">// 使能中断</span></span><br><span class="line">    intr_enable();             </span><br><span class="line"></span><br><span class="line">    <span class="comment">// lab1 challenge</span></span><br><span class="line">    <span class="comment">// lab1_switch_test();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* do nothing */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>labcodes/lab1/kern/mm/pmm.c</code> 中查看 <code>pmm_init()</code> 的具体实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;defs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;x86.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mmu.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memlayout.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pmm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">taskstate</span> <span class="title">ts</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* *</span></span><br><span class="line"><span class="comment"> *  global segment number </span></span><br><span class="line"><span class="comment"> *  #define SEG_KTEXT   1</span></span><br><span class="line"><span class="comment"> *  #define SEG_KDATA   2</span></span><br><span class="line"><span class="comment"> *  #define SEG_UTEXT   3</span></span><br><span class="line"><span class="comment"> *  #define SEG_UDATA   4</span></span><br><span class="line"><span class="comment"> *  #define SEG_TSS     5</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *  global descrptor numbers </span></span><br><span class="line"><span class="comment"> *  #define GD_KTEXT    ((SEG_KTEXT) &lt;&lt; 3)      // kernel text</span></span><br><span class="line"><span class="comment"> *  #define GD_KDATA    ((SEG_KDATA) &lt;&lt; 3)      // kernel data</span></span><br><span class="line"><span class="comment"> *  #define GD_UTEXT    ((SEG_UTEXT) &lt;&lt; 3)      // user text</span></span><br><span class="line"><span class="comment"> *  #define GD_UDATA    ((SEG_UDATA) &lt;&lt; 3)      // user data</span></span><br><span class="line"><span class="comment"> *  #define GD_TSS      ((SEG_TSS) &lt;&lt; 3)        // task segment selector</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *  #define DPL_KERNEL  (0)</span></span><br><span class="line"><span class="comment"> *  #define DPL_USER    (3)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *  #define KERNEL_CS   ((GD_KTEXT) | DPL_KERNEL)</span></span><br><span class="line"><span class="comment"> *  #define KERNEL_DS   ((GD_KDATA) | DPL_KERNEL)</span></span><br><span class="line"><span class="comment"> *  #define USER_CS     ((GD_UTEXT) | DPL_USER)</span></span><br><span class="line"><span class="comment"> *  #define USER_DS     ((GD_UDATA) | DPL_USER)</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// GDT 中，内核段和用户段基本相同，均细分为代码段和数据段，均采用扁平模式，唯一不同点在于权限不同。</span></span><br><span class="line"><span class="comment">// TSS 是一种比较特殊的段，只要记住：其中的 SS0/ESP0 分别用于存放内核栈的栈段和 ESP 值。</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">segdesc</span> <span class="title">gdt</span>[] =</span> &#123;</span><br><span class="line">    SEG_NULL,</span><br><span class="line">    [SEG_KTEXT] = SEG(STA_X | STA_R, <span class="number">0x0</span>, <span class="number">0xFFFFFFFF</span>, DPL_KERNEL),</span><br><span class="line">    [SEG_KDATA] = SEG(STA_W, <span class="number">0x0</span>, <span class="number">0xFFFFFFFF</span>, DPL_KERNEL),</span><br><span class="line">    [SEG_UTEXT] = SEG(STA_X | STA_R, <span class="number">0x0</span>, <span class="number">0xFFFFFFFF</span>, DPL_USER),</span><br><span class="line">    [SEG_UDATA] = SEG(STA_W, <span class="number">0x0</span>, <span class="number">0xFFFFFFFF</span>, DPL_USER),</span><br><span class="line">    [SEG_TSS]    = SEG_NULL,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// gdtr 寄存器的具体结构。</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">pseudodesc</span> <span class="title">gdt_pd</span> =</span> &#123;</span><br><span class="line">    <span class="keyword">sizeof</span>(gdt) - <span class="number">1</span>, (<span class="keyword">uint32_t</span>)gdt</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">lgdt</span><span class="params">(struct pseudodesc *pd)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(<span class="string">&quot;lgdt (%0)&quot;</span> :: <span class="string">&quot;r&quot;</span> (pd))</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(<span class="string">&quot;movw %%ax, %%gs&quot;</span> :: <span class="string">&quot;a&quot;</span> (USER_DS))</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(<span class="string">&quot;movw %%ax, %%fs&quot;</span> :: <span class="string">&quot;a&quot;</span> (USER_DS))</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(<span class="string">&quot;movw %%ax, %%es&quot;</span> :: <span class="string">&quot;a&quot;</span> (KERNEL_DS))</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(<span class="string">&quot;movw %%ax, %%ds&quot;</span> :: <span class="string">&quot;a&quot;</span> (KERNEL_DS))</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(<span class="string">&quot;movw %%ax, %%ss&quot;</span> :: <span class="string">&quot;a&quot;</span> (KERNEL_DS))</span></span>;</span><br><span class="line">    <span class="comment">// reload cs</span></span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(<span class="string">&quot;ljmp %0, $1f\n 1:\n&quot;</span> :: <span class="string">&quot;i&quot;</span> (KERNEL_CS))</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* temporary kernel stack */</span></span><br><span class="line"><span class="keyword">uint8_t</span> stack0[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">gdt_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化 TSS 内部的 ss0/esp0。</span></span><br><span class="line">    ts.ts_esp0 = (<span class="keyword">uint32_t</span>)&amp;stack0 + <span class="keyword">sizeof</span>(stack0);</span><br><span class="line">    ts.ts_ss0 = KERNEL_DS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 GPT 中的 TSS 段描述符。</span></span><br><span class="line">    gdt[SEG_TSS] = SEG16(STS_T32A, (<span class="keyword">uint32_t</span>)&amp;ts, <span class="keyword">sizeof</span>(ts), DPL_KERNEL);</span><br><span class="line">    gdt[SEG_TSS].sd_s = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载 gdtr 和 tr 寄存器，并重新初始化各种段寄存器。</span></span><br><span class="line">    lgdt(&amp;gdt_pd);</span><br><span class="line">    ltr(GD_TSS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pmm_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 重新规划 GDT。</span></span><br><span class="line">    gdt_init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>labcodes/lab1/kern/trap/trap.c</code> 中查看 <code>idt_init()</code> 的具体实现 (相较于源代码，此部分已经修改)：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// idt 数组，即中断描述符表。</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">gatedesc</span> <span class="title">idt</span>[256] =</span> &#123;&#123;<span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// idtr 寄存器的具体结构。</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">pseudodesc</span> <span class="title">idt_pd</span> =</span> &#123;</span><br><span class="line">    <span class="keyword">sizeof</span>(idt) - <span class="number">1</span>, (<span class="keyword">uintptr_t</span>)idt</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">idt_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 该变量存放 vector.S 中各 vectori 函数的地址，这些函数为相应中断号对应的中断处理程序。</span></span><br><span class="line">     <span class="keyword">extern</span> <span class="keyword">uintptr_t</span> __vectors[];</span><br><span class="line">     <span class="comment">// 循环填充 idt 表。</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(idt) / <span class="keyword">sizeof</span>(struct gatedesc); i++)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="comment">// 对于 SETGATE 而言，其参数含义分别为：某个中断描述符、当前中断是否为 trap、对应中断处理程序的段选择子、所对应中断处理程序的段内偏移、使用该中断所需的权限等级</span></span><br><span class="line">         <span class="comment">// 就目前而言，对于大多数终端而言，其非 trap、段选择子为 GD_KTEXT/KERNEL_CS，段内偏移为 __vectors[i]、所需权限为 DPL_KERNEL。</span></span><br><span class="line">         SETGATE(idt[i], <span class="number">0</span>, GD_KTEXT, __vectors[i], DPL_KERNEL)</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">// T_SWITCH_TOK 比较特殊，它供用户使用，以切换至内核。</span></span><br><span class="line">     SETGATE(idt[T_SWITCH_TOK], <span class="number">1</span>, GD_KTEXT, __vectors[T_SWITCH_TOK], DPL_USER);</span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 加载 idt 寄存器。</span></span><br><span class="line">     lidt(&amp;idt_pd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单分析代码，我们可以得到中断处理流程：CPU 接收中断号 i –&gt; 调用 idt[i] 进行处理 –&gt; 调用 <code>__alltraps()</code> 进行处理 –&gt; 调用 <code>trap()</code> 进行处理 –&gt; 调用 <code>trap_dispatch()</code> 进行处理 –&gt;  依据中断号，执行相应功能，并返回。</p>
<p>在 <code>trap_dispatch()</code> 内部，针对时钟中断进行如下处理：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> IRQ_OFFSET + IRQ_TIMER:</span><br><span class="line">        ticks++;</span><br><span class="line">        <span class="keyword">if</span> (ticks % TICK_NUM == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            print_ticks();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于机器而言，部分硬件的中断号是固定的，部分硬件的中断号是动态分配的，此处的时钟中断号便是固定的。</p>
</blockquote>
<h2 id="扩展练习"><a href="#扩展练习" class="headerlink" title="扩展练习"></a>扩展练习</h2><p>该练习需要理解 intel 机器处理中断的具体流程，从而实现用户空间与内核空间的自主切换。</p>
<p>首先简要说明 intel 的硬件处理机制：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">- 每执行完一条指令，CPU 都会判断是否存在待处理的中断，如果存在，则先行获取中断号。</span><br><span class="line">- 如果中断号所示的中断描述符权限 DPL &gt;= CPL，则表明当前权限高于该中断的允许使用权限，故而可执行此次中断，否则为非法。</span><br><span class="line">- 如果中断号所示的段选择子的段描述符权限 DPL &lt; CPL, 则表明当前权限低于对应中断处理程序所需的权限，因此存在特权级转换。</span><br><span class="line">    - 如果存在特权级转换，则 CPU 会获取 TSS 中的 ss0/esp0，并将其设置给相应的寄存器，同时压入当前进程的 ss/esp 至内核栈。  +++++</span><br><span class="line">    - CPU 保存 cs/eip/eflags 等寄存器至内核栈。  +++++</span><br><span class="line">    - CPU 保存设置该中断号对应的中断处理程序的 cs/eip 至相应寄存器，从而开始执行中断处理程序。  +++++</span><br><span class="line">    - 中断处理程序首先保存 ds/es/fs/gs/各种通用寄存器至内核栈 (如果中断处理程序不会使用它们，则可不保存)，然后真正执行中断处理程序。  ----- </span><br><span class="line">    - 中断处理程序即将完成时，其会自动恢复上述保存的各种寄存器。  ----- </span><br><span class="line">- CPU 执行 iret 指令，内核栈中弹出 cs/eip/eflags 等寄存器。  +++++</span><br><span class="line">- 如果存在特权级转换，则 CPU 保存当前 ss/esp 至 TSS，然后从内核栈中弹出 ss/esp。  +++++ </span><br><span class="line"><span class="comment"># +++++ 表示由硬件自动完成，---- 表示由软件完成。</span></span><br></pre></td></tr></table></figure>
<p>其次，我们简单看看源代码与上述机制间的联系：</p>
<ul>
<li><p><code>__alltraps</code> 的具体实现</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.text</span><br><span class="line">.globl __alltraps</span><br><span class="line">__alltraps:</span><br><span class="line">    <span class="comment"># 压入相关段寄存器和通用寄存器值(实际上，这些寄存器也并非会用到，只是为保证能够在栈上构建 struct trapframe)</span></span><br><span class="line">    pushl %ds</span><br><span class="line">    pushl %es</span><br><span class="line">    pushl %fs</span><br><span class="line">    pushl %gs</span><br><span class="line">    pushal</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 根据上述硬件处理机制描述，硬件已经自动设置 ss/cs 等段寄存器了。 </span></span><br><span class="line">    <span class="comment"># 设置相应数据段寄存器。</span></span><br><span class="line">    movl <span class="variable">$GD_KDATA</span>, %eax</span><br><span class="line">    movw %ax, %ds</span><br><span class="line">    movw %ax, %es</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 压入 esp 值，等价于向 trap 传递参数。</span></span><br><span class="line">    pushl %esp</span><br><span class="line"></span><br><span class="line">    <span class="comment"># call trap(tf), where tf=%esp</span></span><br><span class="line">    call <span class="built_in">trap</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># pop the pushed stack pointer</span></span><br><span class="line">    popl %esp</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 相关操作处理完成后的恢复操作</span></span><br><span class="line">.globl __trapret</span><br><span class="line">__trapret:</span><br><span class="line">    popal</span><br><span class="line">    popl %gs</span><br><span class="line">    popl %fs</span><br><span class="line">    popl %es</span><br><span class="line">    popl %ds</span><br><span class="line"></span><br><span class="line">    <span class="comment"># get rid of the trap number and error code</span></span><br><span class="line">    addl <span class="variable">$0x8</span>, %esp</span><br><span class="line">    iret</span><br></pre></td></tr></table></figure></li>
<li><p><code>trap()</code> 的具体实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trap</span><span class="params">(struct trapframe *tf)</span> </span>&#123;</span><br><span class="line">    trap_dispatch(tf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>struct trapframe/pushregs</code> 的具体结构</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 观察 __alltraps 的压栈顺序，可以发现：此结构与其顺序相同。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pushregs</span> <span class="title">tf_regs</span>;</span></span><br><span class="line">    <span class="keyword">uint16_t</span> tf_gs;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_padding0;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_fs;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_padding1;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_es;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_padding2;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_ds;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_padding3;</span><br><span class="line">    <span class="keyword">uint32_t</span> tf_trapno;</span><br><span class="line">    <span class="comment">/* below here defined by x86 hardware */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> tf_err;</span><br><span class="line">    <span class="keyword">uintptr_t</span> tf_eip;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_cs;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_padding4;</span><br><span class="line">    <span class="keyword">uint32_t</span> tf_eflags;</span><br><span class="line">    <span class="comment">/* below here only when crossing rings, such as from user to kernel */</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> tf_esp;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_ss;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_padding5;</span><br><span class="line">&#125; __attribute__((packed));</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pushregs</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> reg_edi;</span><br><span class="line">    <span class="keyword">uint32_t</span> reg_esi;</span><br><span class="line">    <span class="keyword">uint32_t</span> reg_ebp;</span><br><span class="line">    <span class="keyword">uint32_t</span> reg_oesp;          <span class="comment">/* Useless */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> reg_ebx;</span><br><span class="line">    <span class="keyword">uint32_t</span> reg_edx;</span><br><span class="line">    <span class="keyword">uint32_t</span> reg_ecx;</span><br><span class="line">    <span class="keyword">uint32_t</span> reg_eax;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<p>接下来，我们准备实现该练习。</p>
<p>在 <code>labcodes/lab1/kern/init/init.c</code> 中，主函数调用 <code>lab1_switch_test()</code> 以测试功能实现。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lab1_switch_to_user</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 因为当前便是内核空间，因此调用中断不会引发特权级转换，而切换到用户空间需要弹出 ss/esp，故而需要预留 8 字节空间。</span></span><br><span class="line">    <span class="comment">// 因为需要切换至用户空间，直接调用相关中断即可。</span></span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	    <span class="string">&quot;sub $0x8, %%esp \n&quot;</span></span></span></span><br><span class="line"><span class="function"><span class="params">	    <span class="string">&quot;int %0 \n&quot;</span></span></span></span><br><span class="line"><span class="function"><span class="params">	    <span class="string">&quot;movl %%ebp, %%esp&quot;</span></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="comment">// 之所以需要这条代码，原因在于：由于当前函数均为汇编代码，编译得到的汇编代码少了 `movl %%ebp, %%esp` 这么一句，如果不显式补上这句，可能出问题。</span></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="comment">// 具体详见：https://piazza.com/class/i5j09fnsl7k5x0?cid=1468</span></span></span></span><br><span class="line"><span class="function"><span class="params">	    : </span></span></span><br><span class="line"><span class="function"><span class="params">	    : <span class="string">&quot;i&quot;</span>(T_SWITCH_TOU)</span></span></span><br><span class="line"><span class="function"><span class="params">	)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lab1_switch_to_kernel</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 因为需要切换至内核空间，直接调用相关中断即可。</span></span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	    <span class="string">&quot;int %0 \n&quot;</span></span></span></span><br><span class="line"><span class="function"><span class="params">	    <span class="string">&quot;movl %%ebp, %%esp \n&quot;</span></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="comment">// 之所以需要这条代码，原因同上。</span></span></span></span><br><span class="line"><span class="function"><span class="params">	    : </span></span></span><br><span class="line"><span class="function"><span class="params">	    : <span class="string">&quot;i&quot;</span>(T_SWITCH_TOK)</span></span></span><br><span class="line"><span class="function"><span class="params">	)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lab1_switch_test</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 基于汇编获取相关寄存器值，并将其显示于屏幕上。</span></span><br><span class="line">    lab1_print_cur_status();</span><br><span class="line">    cprintf(<span class="string">&quot;+++ switch to  user  mode +++\n&quot;</span>);</span><br><span class="line">    lab1_switch_to_user();</span><br><span class="line">    lab1_print_cur_status();</span><br><span class="line">    cprintf(<span class="string">&quot;+++ switch to kernel mode +++\n&quot;</span>);</span><br><span class="line">    lab1_switch_to_kernel();</span><br><span class="line">    lab1_print_cur_status();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>labcodes/lab1/kern/trap/trap.c</code> 中，实现 <code>T_SWITCH_TOU</code> 和 <code>T_SWITCH_TOK</code> 的中断处理：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> T_SWITCH_TOU:</span><br><span class="line">        <span class="comment">// 切换为用户空间，只需修改相关段寄存器即可。</span></span><br><span class="line">        tf-&gt;tf_cs = USER_CS;</span><br><span class="line">        tf-&gt;tf_ds = USER_DS;</span><br><span class="line">        tf-&gt;tf_es = USER_DS;</span><br><span class="line">        tf-&gt;tf_ss = USER_DS;</span><br><span class="line">        <span class="comment">// 需要开启 IO 权限，才能实现输出。</span></span><br><span class="line">        tf-&gt;tf_eflags |= FL_IOPL_MASK;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> T_SWITCH_TOK:</span><br><span class="line">        tf-&gt;tf_cs = KERNEL_CS;</span><br><span class="line">        tf-&gt;tf_ds = KERNEL_DS;</span><br><span class="line">        tf-&gt;tf_es = KERNEL_DS;</span><br><span class="line">        tf-&gt;tf_eflags &amp;= ~FL_IOPL_MASK;</span><br><span class="line">        <span class="comment">// 根据上述硬件处理机制，ss 设置由硬件自动实现。</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<h2 id="特权级"><a href="#特权级" class="headerlink" title="特权级"></a>特权级</h2><p>因为 intel 的特权级概念十分重要 (借助于此，可实现部分的保护机制)，因此在此简单介绍一番。</p>
<p>对于 intel 而言，特权级分为四个等级，使用 2 bit 进行表示，具体如图所示。实际之中，往往仅使用等级 0 (用于内核使用) 和等级 3 (用于用户使用)。</p>
<img src="/2021/05/27/ucore/lab1/u=1033402520,3603531046&fm=26&fmt=auto&gp=0.jpg" width="15%;">

<p>特权级具体表现在各种段寄存器、段描述符、门描述符之内，使用 <code>CPL/RPL/DPL</code> 进行表示，简要如图所示：</p>
<img src="/2021/05/27/ucore/lab1/image-20210527153029470.png" width="35%;">

<p>对于代码段/栈段选择子而言，其中  RPL 表示当前代码/进程所处的特权级，也称为 CPL；对于各种数据段选择子而言，其中 RPL 表示当前代码/进程访问该段内容时的请求权限，基于此可以提供更为细致的保护机制；对于各种描述符而言，其中 DPL 表示访问此部分内容所需的权限。</p>
<p>现在，基于上述知识，简单说明 intel 提供的保护机制。</p>
<ul>
<li>如果当前进程欲访问某数据段，则硬件判断 <code>Max(CPL,RPL) &lt;= 数据段的 DPL</code>，如果满足此等式，则允许执行此指令，否则存在权限冲突，直接报错。</li>
<li>如果当前进程欲访问某系统服务，则硬件判断 <code>CPL &lt;= 门描述符的 DPL</code>，如果满足此等式，则允许访问系统服务，否则表示不允许。另外，如果满足 <code>CPL &gt; 门描述符的段选择子对应的段描述符的 DPL</code> ，则表明存在特权级转换。</li>
</ul>
]]></content>
      <categories>
        <category>ucore</category>
      </categories>
  </entry>
  <entry>
    <title>虚拟内存</title>
    <url>/2021/04/28/sundry/virtual-memory/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p> 本文首先介绍虚拟内存的基本概念，随后依次介绍它的三大用途：缓存工具、内存保护、内存映射，最后介绍基于此的动态内存分配。</p>
<a id="more"></a>

<p>就计算机执行程序而言，其具有两种执行方式：物理寻址 (程序代码直接放入物理主存之中，并依照物理地址按序访问指令)、虚拟寻址 (程序代码以某种方式放入主存之中，借助于硬件翻译指令的虚拟地址，以实现按序访问指令)。</p>
<img src="/2021/04/28/sundry/virtual-memory/image-20210427204242148.png" width="50%;">

<p>早期计算机使用前种方式执行程序，而现有计算机均基于后种方式执行程序。</p>
<p>根据虚拟寻址的解释，可以知道：对于任意一条指令而言，其分别具有一个虚拟地址和一个物理地址。</p>
<p>将虚拟地址的集合称为虚拟地址空间，将物理地址的集合称为物理地址空间，那么虚拟寻址便是构建了两者间的映射关系，并以此执行程序。</p>
<h2 id="缓存工具"><a href="#缓存工具" class="headerlink" title="缓存工具"></a>缓存工具</h2><p>虚拟地址空间存在于磁盘 (因为目标文件位于磁盘)，而物理地址空间存在于主存。根据存储器金字塔结构，因为局部性原理，主存可作为磁盘的高速缓存；又因为程序通常存在局部性原理，那么物理地址空间也可作为虚拟地址空间的高速缓存。</p>
<p>计算机内部以页作为两者之间的传输单位，物理地址空间中的页称为物理页，虚拟地址空间中的页称为虚拟页。对于虚拟页而言，其具有如下分类：</p>
<ul>
<li>未分配页，即尚未被虚拟内存分配的页，这是由于其中并不包含代码或数据，因而无需存储。</li>
<li>缓存页，即已被缓存至物理主存的页。</li>
<li>未缓存页，即虚拟内存已分配而尚未被物理主存缓存的页。</li>
</ul>
<p>因为虚拟地址空间位于磁盘，而物理地址空间位于主存，两者之间不命中代价过大，因此两者之间的高速缓存 (即页表) 具有如下结构特征：</p>
<ul>
<li>页容量较大，通常为 4KB ~ 2MB。</li>
<li>基于全相联结构。</li>
<li>采用较为复杂的页面替换策略。</li>
<li>采用写回策略。</li>
</ul>
<p>页表的具体结构如下：</p>
<img src="/2021/04/28/sundry/virtual-memory/image-20210428101226079.png" width="40%;">

<p>另外，考虑到主存页表访问缓慢，因此计算机还提供高速缓存以缓存页表条目，称为 TLB (Translation Lookaside Buffer)，其结构为组相联：</p>
<img src="/2021/04/28/sundry/virtual-memory/image-20210428101645049.png" width="50%;">

<p>此时，计算机翻译虚拟地址为物理地址，并执行指令的流程如下：</p>
<ul>
<li>CPU 获取一个虚拟地址</li>
<li>MMU 尝试从 TLB 中获取该虚拟页的映射条目，若获得，则翻译得到物理地址并从高速缓存/主存中取得指令。</li>
<li>若无法获得，尝试从高速缓存/主存中获取该虚拟页的映射条目，若获得，则翻译得到物理地址并从高速缓存/主存中取得指令。</li>
<li>若无法获得，则表明该虚拟页并没有缓存于物理主存之中，则调用缺页中断处理程序，调取相关页至物理主存，随后即可获得该虚拟页的映射条目，然后翻译得到物理地址并从高速缓存/主存中取得指令。</li>
</ul>
<blockquote>
<p>注：页表条目可能存在于 TLB、高速缓存、主存页表之中。</p>
</blockquote>
<p>上面所谈页表均指代单张页表，然而如此组织会大大占用物理主存空间。为解决此问题，现有计算机往往实现多级页表以压缩页表大小：即拆分单张页表为多张页表，一级页表条目索引二级页表位置、二级页表条目索引三级页表位置、……、最后一级页表定位虚拟页与物理页映射，其示意结构与地址翻译过程如下示：</p>
<img src="/2021/04/28/sundry/virtual-memory/image-20210428104458975.png" width="50%;">

<p>实现多级页表具有如下优点：</p>
<ol>
<li>如果某些虚拟页从未被使用，则可无需分配相关页表，从而降低总体页表大小。</li>
<li>仅一级页表必须存入物理主存，其余页表或放入主存或放入交换空间，从而降低物理主存压力。</li>
</ol>
<h2 id="内存保护"><a href="#内存保护" class="headerlink" title="内存保护"></a>内存保护</h2><p>基于虚拟内存的内存保护机制实现于页表条目之上：首先为页表条目添加若干位信息 (例如，某位表示当前物理页是否可写，某位表示当前物理页是否能运行于内核模式之下)，随后载入虚拟页与物理页映射信息时设置相关位信息，最后在 MMU 翻译虚拟地址时查看位信息的约束条件以判断当前访问是否合法，从而实现内存保护。</p>
<h2 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h2><p>内存映射具体可细分为内存映射 IO 和内存映射文件，在此仅介绍内存映射文件。</p>
<p>内存映射文件指代将一个虚拟内存区域与一个磁盘对象关联起来，并以此文件内容初始化此虚拟内存区域。</p>
<p>针对内存映射文件而言，磁盘对象具有如下两种类别：</p>
<ul>
<li><p>普通文件</p>
<p>建立关联后，只有当 CPU 第一次访问该虚拟内存区域的虚拟地址时，系统才会基于缺页中断获取文件内容、选择合适的物理页进行映射，并以此内容填充物理页。</p>
<p><code>mmap(void *start, size_t length, xxxx,int fd, off_t offset)</code> 用于将文件描述符 fd 偏移 offset 处、长度为 length 的数据映射至虚拟内存 start 处、长度为 length 的空间。</p>
</li>
<li><p>匿名文件</p>
<p>匿名文件为内核创建的、内容全为二进制零的文件。<br>建立关联后，只有当 CPU 第一次访问该虚拟内存区域的虚拟地址时，系统才会换出一个物理页、将该物理页内容置为全零，并建立该物理页与虚拟页间的映射关系。</p>
<p><code>mmap(void *start, size_t length, xxxx,-1, off_t offset)</code> 用于将匿名文件映射至虚拟内存 start 处、长度为 length 的空间，实质就是向内核申请一块物理主存。</p>
</li>
</ul>
<p>根据映射对象的共享程度，又可细分为如下两种类别：</p>
<ul>
<li><p>共享映射</p>
<p>所映射的对象共享于多个进程，并且某进程的任何修改都会反映至各进程及磁盘。</p>
<img src="/2021/04/28/sundry/virtual-memory/image-20210428151606929.png" width="50%;">
</li>
<li><p>私有映射</p>
<p>所映射的对象虽可共享于多个进程，但是某进程的修改仅自己可见 (基于写时复制技术实现，即当进程欲修改私有对象时，系统会发现此为私有对象，便重新分配一个物理页至当前虚拟页，然后允许进程修改此物理页)。</p>
<img src="/2021/04/28/sundry/virtual-memory/image-20210428151735221.png" width="50%;">

</li>
</ul>
<p>可以看到：无论是共享映射，还是私有映射，都是在尽最大程度地利用物理主存。</p>
<blockquote>
<p>当 fork() 函数被当前进程调用时，内核会为新进程分配各种数据结构 (例如，PID)，然后创建当前进程虚拟内存相关数据结构的一个副本，以此实现当前进程与新进程私有映射虚拟内存。如此操作，造成的效果便是：当前进程与新进程具有相同的虚拟地址空间，但是两者仍不相干。</p>
<p>当 execve() 函数被当前进程调用时，内核会删除现有的虚拟内存，并基于私有映射以映射私有数据，基于共享映射以映射共享数据，最后重置 PC 寄存器。</p>
</blockquote>
<h2 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h2><p>动态内存分配指代动态分配虚拟地址空间中堆的内存给相应变量。</p>
<p>因为动态内存分配不仅涉及分配内存，同样涉及释放内存，因此如何有效管理堆内存，以保证堆尽可能小，同时提供完整功能，这便需要认真设计动态内存分配器。</p>
<p>动态内存分配器将对内存视为一组不同大小的块集合进行维护 (类似下图)，其中每个块要么已分配给某个变量，要么处于空闲状态。处于空闲状态的块等待被分配给进程使用；处于已分配状态的块保持分配状态，直至其被程序自身释放 (此种分配器称为显式分配器)，或被垃圾回收器释放 (此种分配器称为隐式分配器)。</p>
<img src="/2021/04/28/sundry/virtual-memory/image-20210428155744071.png" width="50%;">

<blockquote>
<p>注意：实际计算机内部往往具有块大小约束及块对齐要求。</p>
</blockquote>
<p>按照请求分配空闲块存在两种情况：1. 请求空间小于空闲块空间，且两者之差不足以构建一个空闲块，或者两者之差不满足块对齐要求，此时便存在内部空间浪费，此种称为 <em>内部碎片</em>。2. 请求空间小于等于所有空闲块空间之和，却大于任意单个空闲块空间，此时便存在外部空间浪费，此种称为 <em>外部碎片</em>。此两种情况会降低堆内存的利用效率，应当尽可能减少该种情况的发生。</p>
<h3 id="显式分配器"><a href="#显式分配器" class="headerlink" title="显式分配器"></a>显式分配器</h3><p>我们首先介绍最简单的块组织方式 —— 隐式空闲链表，随后介绍更为高效的块组织方式 —— 显式空闲链表、分离的空闲链表。</p>
<h4 id="隐式空闲链表"><a href="#隐式空闲链表" class="headerlink" title="隐式空闲链表"></a>隐式空闲链表</h4><p>对于隐式空闲链表而言，其中块具有如下结构 (块首存放块大小和分配信息)：</p>
<img src="/2021/04/28/sundry/virtual-memory/image-20210428161608027.png" width="50%;">

<blockquote>
<p>注：如果设定块 8 字节对齐，那么块大小一定是 8 的倍数，因此只需高 29 位表征块大小即可，其余 3 位用于存放其他信息。</p>
</blockquote>
<p>基于此种结构，我们很容易实现块的按序索引 (即当前块位置 + 块大小 = 下一块位置)，如此便构成隐式链表 (设定：如果某块大小为 0 且已分配，则表明其为隐式空闲链表的尾部。)：</p>
<img src="/2021/04/28/sundry/virtual-memory/image-20210428162426700.png" width="50%;">

<blockquote>
<p>注：实际实现之中，为满足对齐要求，堆开始处可能存放无用块。另外为简化后续的空闲块合并，往往存在隐式空闲链表的首部块。</p>
</blockquote>
<p>基于此结构，容易实现块分配 (即基于首次适配或最佳适配等放置规则选择合适块，然后设置该块为分配块即可，可能需要视对齐要求和块大小限制进行分割块)、块回收 (直接设置该块为未分配即可)。然而，对于块合并而言，其具有一点困难：容易合并当前空闲块与后继空闲块，而无法快速合并前驱空闲块。为解决此问题，通常修改块结构如下：</p>
<img src="/2021/04/28/sundry/virtual-memory/image-20210428163312426.png" width="35%;">

<h4 id="显式空闲链表"><a href="#显式空闲链表" class="headerlink" title="显式空闲链表"></a>显式空闲链表</h4><p>隐式空闲链表具有一个大缺点，即需搜索全部堆块以寻找合适块进行分配。为解决此问题，显式空闲链表通过在空闲块内添加指向前驱和后继的空闲块索引，从而实现只需搜索所有空闲块，即可寻找合适块进行分配。此时，块结构如下：</p>
<img src="/2021/04/28/sundry/virtual-memory/image-20210428165422684.png" width="50%;">

<p>基于此结构，容易实现块分配和块合并。而块分割或者块回收具有两种不同实现方式 (相比于后者而言，前者操作更快；然而，当采用首次适配进行块分配时，后者的内存利用率更高，且几近于最佳适配的内存利用率)：</p>
<ul>
<li><p>基于后进先出 (LIFO) 维护空闲链表</p>
<p>当块分割或块回收后，直接将空闲块放置于链表首部，如此可实现常数操作。</p>
</li>
<li><p>按照地址顺序维护空闲链表</p>
<p>当块分割或块回收后，按空闲链表查找位于此位置之前的那个空闲块，并将其放置于该空闲块之后，如此实现需要搜索所有空闲块。</p>
</li>
</ul>
<h4 id="分离的空闲链表"><a href="#分离的空闲链表" class="headerlink" title="分离的空闲链表"></a>分离的空闲链表</h4><p>显式空闲链表虽已改进块分配性能，然而它需要搜索全部空闲块。为进一步提高效率，分离的空闲链表被提出，它基于块大小将所有的空闲块分配至多个空闲链表，如此可将搜索范围缩至特定块大小范围的链表所含的空闲块。</p>
<p>当请求来临时，首先查找维护特定块大小范围的空闲链表，如果找到直接分配，否则查找比此特定块大小范围更高一级的空闲链表，找到直接分配，否则仍按此规则查找，直至不存在满足要求的空闲块，此时需要申请堆内存以构建满足要求的空闲块，然后分配即可。如果空闲块可分割的话，则将分割的空闲块放置相应的空闲链表即可。</p>
<blockquote>
<p>注：针对分离的空闲链表采用首次适配策略，其内存利用率近乎于针对整个堆的最佳适配策略的内存利用率。另外，C 语言的 malloc 函数即是基于此实现动态分配器的。</p>
</blockquote>
<h3 id="隐式分配器"><a href="#隐式分配器" class="headerlink" title="隐式分配器"></a>隐式分配器</h3><p>隐式分配器使用垃圾回收器自动回收堆存储过程中的不再使用的已分配块。此处简略说明垃圾回收器的基本原理。</p>
<p>垃圾回收器将内存视为一张有向可达图，其形式如图所示：</p>
<img src="/2021/04/28/sundry/virtual-memory/image-20210428181959714.png" width="50%;">

<p>图中节点分为两类：根节点 (存放于栈、寄存器或全局变量内)、堆节点 (存放于堆中，对应于已分配块)。每个根节点指向一个堆节点，堆节点内部又存有其他堆节点的指针。当存在一条从某任意根节点出发并到达堆节点 p 的有向路径，则称堆节点 p 可达，反之称为不可达。</p>
<p>垃圾回收器的工作便是基于某种形式维护有向可达图，并适时回收堆中不可达的堆节点。</p>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
  </entry>
  <entry>
    <title>处理器实现机制</title>
    <url>/2021/04/20/sundry/processor-implement/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文首先介绍处理器实现的底层基础，随后介绍单周期实现、流水线实现、乱序实现。</p>
<a id="more"></a>

<h2 id="底层基础"><a href="#底层基础" class="headerlink" title="底层基础"></a>底层基础</h2><p>对于处理器实现的底层基础而言，其由三部分组成：</p>
<ul>
<li><p>基于组合逻辑设计实现指令集</p>
<p>在数字逻辑设计中，我们可以借助于基本逻辑门 (逻辑与、逻辑或、逻辑非) 实现各种复杂操作，由此形成的电路主要分为两种：逻辑电路 (输出结果仅与输入相关)、时序电路 (输出结果不仅相关于输入，而且相关于电路当前状态)。</p>
<p>基于逻辑门实现的电路与高级语言中的逻辑操作并不相同，其具有如下特性：电路输出结果持续响应输入信息；当输入信息发生变化后，经过一段电路时延，电路的输出结果也会随之变化。</p>
<blockquote>
<p>注意：该特性使得时钟信号的存在十分有必要。</p>
</blockquote>
<p>对于处理器实现的底层基础而言，其便是借助于各种逻辑设计电路实现既定体系指令集中各指令的功能。</p>
</li>
<li><p>基于时钟信号控制逻辑执行</p>
<p>我们先以时序电路为例说明现有电路所存在的问题。</p>
<p>下图的时序电路用于实现数据累加，register2 依次输入 1,2…,9，combinational logic 为数据累加的具体实现，register1 暂存累加值，最终结果输出至 Z。</p>
<img src="/2021/04/20/sundry/processor-implement/image-20210420142400235.png" width="60%">

<p>假定初始情况下一切输入输出均为 0，随后，register2 开始输出 1，经过一段时延，register 1 得到输入 1。此时做一设想：register1 立刻输出 1 而 register2 慢半拍。因为 combinational logic 输入发生变化，因此 register1 得到输入 2。</p>
<p>可以看到：此时  register1 计算已然不正确。这正是由于电路时延带来的危害，使得逻辑计算变得混乱。</p>
<p>究其根源，可以发现：根本原因在于 register1 不适时地得到输入并将其输出。</p>
<p>为解决这一问题，可以借助于时钟信号控制。对于 register 而言，作如下规定：只有当时钟信号上升沿来临时，才可将数据写入至 register 之中，其余时间均不可写入。</p>
<img src="/2021/04/20/sundry/processor-implement/image-20210420145620872.png" width="60%;">
</li>
<li><p>基于存储设备实现数据存储</p>
<p>所有存储设备的使用规则与上面的 register 相同，均是时钟信号上升沿来临时才可写入信息。</p>
<p>在此，我们介绍两种常见的存储设备：寄存器文件 (图左)、内存 (图右)，其结构如图所示：</p>
<img src="/2021/04/20/sundry/processor-implement/image-20210420150200817.png" width="60%;">

<p>两者结构类似，我们以较为复杂的内存为例，作一简单说明。</p>
<p>当想要读取数据时，需自行设置 address/read，经过一段时延后，data out 即会输出待读取的数据信息；当想要写入数据时，需自行设置 address/data in/write，并且等待时钟信号上升沿来临时，数据才能写入至内存。</p>
</li>
</ul>
<h2 id="单周期实现"><a href="#单周期实现" class="headerlink" title="单周期实现"></a>单周期实现</h2><p>底层基础构建完毕后，我们开始实现最简单的处理器：单周期实现，即执行一条指令仅花费一个时钟周期。</p>
<p>为方便后续改进，在此将指令执行划分为如下阶段：</p>
<ul>
<li><p>取指 (Fetch)</p>
<p>该阶段依据 PC 寄存器的值从内存读取指令字节。</p>
</li>
<li><p>译码 (Decode)</p>
<p>该阶段分析读取的指令字节，并从寄存器文件获取该指令所需的寄存器数据。</p>
</li>
<li><p>执行 (Excute)</p>
<p>该阶段依据指令功能，执行相关逻辑单元，以得到执行结果。</p>
</li>
<li><p>访存 (Memory)</p>
<p>该阶段可从内存获取数据，也可将数据写入内存。</p>
</li>
<li><p>写回 (Write back)</p>
<p>该阶段可将相关数据写入寄存器文件，以更新相关寄存器。</p>
</li>
<li><p>更新 PC</p>
<p>该阶段更新 PC 寄存器的值为下一条指令的地址。</p>
</li>
</ul>
<p>单周期实现的结构如图所示：</p>
<img src="/2021/04/20/sundry/processor-implement/image-20210420152610647.png" width="18%;">

<p>对于单周期实现而言，它能够实现指令执行，然而具有如下缺点：</p>
<ol>
<li>因为需要将指令执行放置于一个时钟周期内，因此该时钟周期将会过长，这严重影响处理器单位时间内所能执行的指令数，从而使其处理性能低下。</li>
<li>在单个时钟周期内，指令执行的各阶段所涉硬件并不相同，从而出现某部分处于执行状态，而其他部分处于空闲状态。因此该种实现方式无法充分利用硬件。</li>
</ol>
<h2 id="流水线实现"><a href="#流水线实现" class="headerlink" title="流水线实现"></a>流水线实现</h2><p>流水线实现正是对单周期实现的改进，它可以做到进一步提升处理性能、充分利用硬件。</p>
<p>流水线实现的基本思想在于：划分指令执行为若干阶段，并借助于不相干的硬件部分处理各阶段。其结构如图所示：</p>
<img src="/2021/04/20/sundry/processor-implement/image-20210420154809357.png" width="20%;">

<p>相比于单周期实现而言，其具有如下改动：</p>
<ol>
<li>各阶段之间，借助于特殊寄存器暂存阶段执行结果，并以此作为下一阶段的输入信息。</li>
<li>一个时钟周期设定为各阶段执行所需时间的最大值。</li>
<li>融合取指和更新 PC 为同一阶段，如此便可实现连续取指。</li>
</ol>
<blockquote>
<p>更新 PC 实际操作比较麻烦。对于普通指令而言，只需执行 PC + 当前指令所占长度 即可；而对于指令 jxx (例如，jne)/ret 而言，需要借助于 <em>分支预测技术</em>  。</p>
<p>基于分支预测策略，分支预测技术可预测处理器即将执行哪个分支，从而更新 PC。最简单的分支预测策略即是：总是选择跳转、总是选择不跳转。</p>
</blockquote>
<p>此时，指令执行过程类似如下 (其间存在数据冒险)：</p>
<img src="/2021/04/20/sundry/processor-implement/image-20210420165222473.png" width="30%;">

<p>如此实现之后，其仍无法付诸实用。原因在于：虽然各阶段的执行硬件完全分离，但是指令之间却存在相关性。如此直接按序执行各阶段，而不施加相关操作，将会引发错误。</p>
<p>指令之间的相关性具体可细分为数据相关 (指代数据间读写相关) 和控制相关 (指代条件跳转引发的地址相关)，由此引发的错误称为数据冒险和控制冒险。</p>
<ul>
<li><p>数据冒险</p>
<p>指令间数据相关性具体表现为：RAR (读后读，即不同指令先后读取同一内容)、WAR (读后写，即某指令先写某内容，随后另一指令再读该内容)、RAW (写后读，即某指令先读某内容，随后另一指令再写该内容)、WAW (写后写，即不同指令先后写入同一内容)。</p>
<blockquote>
<p>扯远一点，真正能够造成数据冒险的数据相关性为 RAW、WAW、WAR。而且在这三者之中，RAW 为真依赖，WAW 和 WAR 则是假依赖 (因为可借助于寄存器重命名技术消除此类依赖)。</p>
<p>因为计算机仅暴露有限的寄存器给编译器，因此编译器会重复使用这些寄存器构建汇编代码。实际实现之中，计算机内部还有其他寄存器可用，通过寄存器关系映射 (即寄存器重命名) 可实现消除此类依赖，并借助于相关机制以保证顺序执行。简单地举例而言，对于具有 WAW 数据相关的汇编代码 <code>ADD r2，r1，r5; ADD r2，r3，r4; </code> 而言，使用寄存器重命名得到 <code>ADD P12，r1，r5; ADD P22，r3，r4;</code>，如此即可并行执行，两者执行完毕后，借助于一定机制可保证将正确数据写入寄存器 <code>r2</code> 之内。</p>
</blockquote>
<p>对于 RAR 而言，单纯读取同一内容不会造成数据冒险；对于 WAR 而言，读操作位于 D 而写操作位于 M/W，当前指令的读操作一定位于下一条指令的写操作之前执行，因此其不会造成数据冒险；对于 RAW 而言，写操作位于 M/W 而读操作位于 D，下一条指令的读操作可能早于当前指令的写操作，因此其可能造成数据冒险；对于 WAW 而言，写操作要么均位于 M，要么均位于 W，因此其不会造成数据冒险。</p>
<p>综上分析可知：对于流水线实现而言，RAW 可能引发数据冒险。</p>
<p>为避免数据冒险发生，只需保证先前指令写操作完成后，才可执行当前指令的读取操作。</p>
<p>为实现此目的，具有两种实现方式：暂停执行 (图上)、数据转发 (图下)，其实现示意如下：</p>
<img src="/2021/04/20/sundry/processor-implement/image-20210420170611397.png" width="30%;">

<p>暂停执行：如果当前指令译码阶段所需读取数据与其上指令写入相关，则等待其上指令写入完成后，再开始执行当前指令的译码阶段。</p>
<p>数据转发：如果当前指令译码阶段所需读取数据与其上指令写入相关，则借助于相关逻辑控制，直接将执行、访存、写回阶段的数据转发给当前指令的译码阶段，从而使得当前指令顺利进入下一阶段的执行。</p>
<p>需要注意的是：暂停执行可解决所有的数据冒险，但是效率低下；数据转发无法解决所有的数据冒险，但是效率高。</p>
<p>数据转发无法解决的数据冒险称为 加载/使用数据冒险，即指代当前指令从内存获取数据至寄存器，而下一条指令立刻使用该寄存器。</p>
<p>为解决此类冒险，可联合使用暂停执行和数据转发，其实现示意如下：</p>
<img src="/2021/04/20/sundry/processor-implement/image-20210420171913942.png" width="30%;">

<p>综上，对于一般数据冒险，流水线实现应当使用数据转发解决，对于加载/使用数据冒险，流水线实现使用 暂停执行 + 数据转发 解决，如此既可解决问题，又可提供高效率。</p>
</li>
<li><p>控制冒险</p>
<p>控制相关关注于条件跳转指令的执行，尤其是当分支预测错误后，应当如何解决以避免引发错误。</p>
<p>为解决控制冒险，计算机必须等待条件跳转指令执行完，确定分支后才能执行后续指令，因此其只能通过暂停执行加以解决，其实现示意如下：</p>
<img src="/2021/04/20/sundry/processor-implement/image-20210420173025927.png" width="30%;">

<p>该实现具有一个小优化：当执行条件跳转指令时，其仍根据分支预测结果加载相关指令，只是将其暂停至译码阶段。如果分支预测成功，则直接译码然后执行即可；否则清空后续指令，然后加载指令分支指令执行即可。</p>
</li>
</ul>
<p>通过为原有流水线实现添加冒险解决方案，如此便可付诸实用 (如果使用此时的流水线实现处理异常，其仍存在一些问题，但是并非主要内容，可以忽略)。</p>
<p>对于流水线实现而言，其性能瓶颈在于：如何平均划分指令执行各阶段，以使得一个时钟周期所需时间尽可能的小，从而提升处理器单位时间内所能执行的指令数。然而，由于指令执行的重头在于执行阶段，这使得各阶段实在无法实现平均划分，因此其他阶段都需要被迫等待，直至执行阶段完成。</p>
<h2 id="乱序实现"><a href="#乱序实现" class="headerlink" title="乱序实现"></a>乱序实现</h2><p>乱序实现可以解决上面所谈及的流水线实现缺点，而且它向前更进一步，可以实现指令级并行 (指代一次处理多条无关指令)。其结构如图所示：</p>
<img src="/2021/04/20/sundry/processor-implement/image-20210420191900949.png" width="30%;">

<p>相比于流水线实现而言，其主要变动在于：为执行阶段提供多种、多个算术单元，从而为实现指令级并行提供可能。</p>
<p>就具体实现而言，两者之间亦存在差别：流水线实现中指令顺序执行，乱序实现中指令乱序执行。</p>
<p>简要说明乱序实现的指令执行流程：</p>
<ol>
<li>指令控制单元 (ICU) 依次获取指令并对其译码，根据指令功能不同，将其发往不同的算术单元进行处理 (每个算术单元均有缓冲区存放指令)。</li>
<li>各算术单元接收指令后，如果该指令所需操作数已然获取，则待当前算术单元空闲时予以执行，随后发送执行结果至数据总线；反之，则监听数据总线以获取相关操作数。</li>
<li>各指令针对寄存器、内存所作的读写操作，也会基于一定机制实现更新相关内容。</li>
</ol>
<blockquote>
<p>乱序实现中，同样存在数据冒险和控制冒险，也自然具有相应机制加以解决，最为著名的便是：记分牌算法、Tomasulo 算法 (该算法便是借助于寄存器重命名技术解决 WAR 和 WAW 数据冒险的)。</p>
<p>需要注意的是：因为使用多个算术单元执行指令，因此乱序实现中的数据冒险涉及 RAW、WAW、WAR 三部分，而非仅仅 RAW。</p>
</blockquote>
<p>鉴于乱序实现具有指令级并行特点，可借助于循环展开和设置多个累积变量以加快程序运行。</p>
<p>举例而言 (左侧为普通循环，右侧为 循环展开 + 设置多个累积变量)：</p>
<img src="/2021/04/20/sundry/processor-implement/image-20210421084542255.png" width="30%;">

<p>为什么如此便可加快程序运行？原因有二：其一，各累积变量间计算互不相干，便可并行执行 (主因)；其二，减少循环次数，从而避免少许因控制冒险引发的性能损耗 (辅因)。</p>
<blockquote>
<p>程序运行性能相关于众多因素，如此单纯增加很多个累积变量，也有可能减缓程序运行，可能原因为：高速缓存内无法容纳全部指令代码，从而需要从内存获取，致使性能损耗。</p>
</blockquote>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>简单说明计算机为提升处理性能所做的相关工作：</p>
<ol>
<li>借助于硅半导体工艺的精进，提升芯片的工作频率，从而增强单位时间内所能处理的指令数。</li>
<li>通过构建新的分支预测技术与乱序执行技术，增强乱序执行效率。</li>
<li>通过添加新的集成专用单元和相关指令 (例如 SSE，可实现向量数据的快速计算)，增强处理器针对特定类型数据的处理能力。</li>
<li>借助于多核处理器 (即单个处理器内部存在多个性能较差的处理器核心)，通过这些核心并行工作，以此达到高效率的处理性能，从而达到横向扩展计算机处理性能的目录。</li>
</ol>
<blockquote>
<p>就目前现状而言：1. 芯片工作频率已无法迅速提升，因为那样会导致功耗过大，得不偿失。2. 目前所用技术已能达到比较好的性能，增强乱序执行效率的空间并不大。3. 这方面工作做了很多工作，也没有提升空间。</p>
<p>因为性能较差的处理器核心仍存在提升空间，且目前已具有相当可观的提升速度，因此，目前唯一出路在于：使用多核处理器以提升处理器性能。</p>
</blockquote>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
  </entry>
  <entry>
    <title>Linux 进程管理</title>
    <url>/2021/03/22/linux/linux7-process/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文介绍与进程、服务相关的若干知识。</p>
<a id="more"></a>

<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>如果学习过操作系统课程，我们知道：程序是一组代码集合，它存储于硬盘之中，而进程是程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位。</p>
<p>在 Linux 系统中，进程可简单表示为：PID (进程编号) + PPID (父进程编号) + 基于使用者所得到的权限 + 程序码。</p>
<p>我们最常使用的 bash 就是一个进程，其上输入各种指令便会引发一个 bash 子进程以执行此指令。这里就简单说明单一 bash 环境下的工作管理 (job control)：</p>
<ul>
<li>通过在指令尾部添加 <code>&amp;</code>，该指令便会于 bash 背景中执行，执行完成后，其结果会显示于 bash 页面之上。</li>
<li>向正在运行的指令程序输入 <code>ctrl + z</code>，该指令程序便会暂停执行，并位于 bash 背景之中。</li>
<li>借助于指令 <code>jobs</code>，可查看 bash 背景中各工作的状态信息。</li>
<li>借助于指令 <code>fg</code>，可将某指令程序拉至 bash 页面中执行。</li>
<li>借助于指令 <code>bg</code>，可将背景中某指令程序状态由暂停变更为运行中。</li>
<li>借助于指令 <code>kill</code>，可向背景中某指令程序发送特定 <code>signal</code>，以重启、删除此指令程序。</li>
</ul>
<p>需要注意的是，如果 bash 关闭，则 bash 背景中各种指令程序随即停止。若不想此场景发生，可使用指令 <code>nohup xxx &amp;</code>，如此该指令的执行便会位于系统背景之中，此时只有当 Linux 系统关闭，该指令程序才会停止。</p>
<p>接下来，我们简单谈谈 Linux 系统下的进程管理 (process control)：</p>
<ul>
<li><p><code>ps</code></p>
<p>该指令可查看个时间点各进程的运行情况。</p>
<p>通常只需知道两个选项即可：<code>ps -l</code> 用于查看 bash 之下的各进程运行情况，<code>ps aux</code> 用于查看系统之下的各进程运行情况。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">F S   UID     PID    PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD</span><br><span class="line">0 S  1000    1689    1688  0  80   0 -  5032 do_wai pts/0    00:00:00 bash</span><br><span class="line">0 R  1000    2101    1689  0  80   0 -  5228 -      pts/0    00:00:00 ps</span><br><span class="line">各字段含义如下：</span><br><span class="line">- F 表明此进程的权限类别，若为 4，则表示其为 root 权限。</span><br><span class="line">- S 表明此进程的运行状态，其取值通常有：R (运行中)、S (睡眠中，可被手动唤醒)、D (睡眠中，</span><br><span class="line">  不可被手动唤醒，通常处于 I/O 等待)、T (停止中)、Z (僵尸状态，进程已终止，但无法被移除)</span><br><span class="line">- UID/PID/PPID，含义十分明确，忽略。</span><br><span class="line">- 表明此进程的 CPU 使用率。</span><br><span class="line">- PRI/NI 共同指明该进程的运行优先级，PRI 取值越低，进程运行优先级越高。</span><br><span class="line">  PRI 动态变化且无法进行调整，由于 PRI 取值与 NI 相关，因此可动态调整它以间接调整 PRI。</span><br><span class="line">  借助于 nice 指令，在程序运行之初即指定 NI；借助于 renice，重新调整特定进程的 NI。</span><br><span class="line">- ADDR 指明该进程所依据的程序位于内存哪部分，不知道为什么显示为 <span class="string">&#x27;-&#x27;</span>。</span><br><span class="line">- SZ 指明该进程目录用掉多少内存。</span><br><span class="line">- WCHAN 仍是指明该进程是否处于运行状态。</span><br><span class="line">- TTY 指明使用者所使用的伪终端设备。</span><br><span class="line">- TIME 指明该进程实际使用 CPU 的时间。</span><br><span class="line">- CMD 指明触发此进程运行的指令。</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">root           1  0.0  0.1 168896 12052 ?        Ss   09:09   0:02 /sbin/init splash</span><br><span class="line">各字段含义如下：</span><br><span class="line">- USER 指明该进程的所属账号。</span><br><span class="line">- PID/%CPU/%MEM，含义十分明确，忽略。</span><br><span class="line">- VSZ 指明该进程用掉的虚拟内存量。</span><br><span class="line">- RSS 指明该进程占用的固定内存量。</span><br><span class="line">- TTY 含义同上。</span><br><span class="line">- STAT 指明该进程的运行状态，含义同 S。</span><br><span class="line">- START/TIME/MOMMAND，含义十分明确，忽略。 </span><br></pre></td></tr></table></figure>
<blockquote>
<p>通常情况下，当子进程运行完成后，父进程应当合理终止它。但是由于系统不稳定或者程序编写问题，会造成某些进程虽已运行完成，但是未被终止，这种进程便被称为 <code>zombie process</code> (即僵尸进程)，其状态便为 <code>Z</code>。</p>
</blockquote>
</li>
<li><p><code>top</code></p>
<p>该指令可动态持续侦测各进程的运行情况。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">top - 10:59:28 up  1:49,  2 users,  load average: 0.27, 0.30, 0.24</span><br><span class="line">Tasks: 247 total,   1 running, 245 sleeping,   1 stopped,   0 zombie</span><br><span class="line">%Cpu(s):  0.0 us,  1.5 sy,  0.0 ni, 98.5 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">MiB Mem :   7929.7 total,   6317.6 free,    409.2 used,   1202.9 buff/cache</span><br><span class="line">MiB Swap:   2048.0 total,   2048.0 free,      0.0 used.   7222.2 avail Mem</span><br><span class="line"></span><br><span class="line">PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND</span><br><span class="line">860 root      20   0 1120560  46824  26060 S   0.6   0.6   0:54.76 containerd</span><br><span class="line">top 指令输出结果比较多，我们一行一行介绍：</span><br><span class="line">第一行：</span><br><span class="line">10:59:28 指明当前时间；up  1:49 指明自开机至此的系统运行时间；2 users 指明系统使用者个数；</span><br><span class="line">load average: xxx 指明 1/5/15 分钟内的平均负载情况 (即系统平均需要运行几个进程)。</span><br><span class="line">第二行：</span><br><span class="line">各字段含义比较清晰，指明系统共计多少进程，多少处于运行状态，多少处于运行状态，...。</span><br><span class="line">第三行：</span><br><span class="line">该行从各个方面总体评估 CPU 的使用情况，即哪些方面占用了多少 CPU。</span><br><span class="line">us(user) 表示用户空间的 CPU 使用情况；sy(system) 表示系统空间的 CPU 使用情况；</span><br><span class="line">ni(niceness) 表示修改过优先级的进程的 CPU 使用情况；id(idle) 表示空闲 CPU 的使用情况； </span><br><span class="line">wa(<span class="built_in">wait</span>) 表示 I/O 等待的 CPU 使用情况；hi(hard interrupt) 表示硬中断的 CPU 使用情况；</span><br><span class="line">si(soft interrupt) 表示软中断的 CPU 使用情况； </span><br><span class="line">st(stole time) 表示分配给当前虚拟机的 CPU 时间中，被本机其他虚拟机所偷用的 CPU 使用情况。</span><br><span class="line">第四行：</span><br><span class="line">各字段含义比较清晰，指明系统的内存总量、空闲内存量、已用内存量和用作 buff 的内存量。</span><br><span class="line">第五行：</span><br><span class="line">与第四行各字段类似，只不过指的是内存交换空间的相关指标。</span><br><span class="line">第六行：</span><br><span class="line">PR 与上方的 PRI 同义；VIRT 指明该进程所用的内存总量，包括 Mem + Swap；</span><br><span class="line">RES 指明该进程真实使用的 Mem 之中的内存量；SHR 指明该进程所用的共享内存量；</span><br></pre></td></tr></table></figure>
<blockquote>
<p>默认情况下，指令 <code>top</code> 以 PID 排序侦测结果。若需按照内存使用率或 CPU 使用率进行排序，可在侦测页面中输入 <code>M</code> 或 <code>C</code>。</p>
</blockquote>
</li>
<li><p><code>pstree</code></p>
<p>该指令能够将各进程按照父子关系组织成为一棵树。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemd─┬─ModemManager───2*[&#123;ModemManager&#125;]</span><br><span class="line">        ├─ ***</span><br><span class="line">        ├─sshd───sshd───sshd───bash─┬─pstree</span><br><span class="line">        │                           └─vim</span><br><span class="line">        ├─ ***</span><br></pre></td></tr></table></figure>
<blockquote>
<p>从中可以看到进程 <code>systemd</code> 为所有进程的唯一父进程。</p>
</blockquote>
</li>
<li><p><code>kill/killall</code></p>
<p>该指令可向特定进程发送特定 <code>signal</code>，以启动、终止、重启该特定进程。</p>
<p>常见 <code>signal</code>：<code>SIGHUP</code> (启动被终止的进程)、<code>SIGKILL</code> (强制终止进程)、<code>SIGSTOP</code> (暂停进程)。</p>
</li>
</ul>
<p>最后简单介绍若干查看系统资源的指令：</p>
<ul>
<li><code>free</code>  –&gt;  查看系统内存使用情况。</li>
<li><code>uname</code>  –&gt;  查看系统与核心相关参数信息。</li>
<li><code>uptime</code>  –&gt;  查看系统启动时间与工作负载情况。</li>
<li><code>netstat</code>  –&gt;  查看网络与 port 使用的相关信息。</li>
<li><code>dmesg</code>  –&gt;  查看核心所产生的讯息。</li>
<li><code>vmstat</code>  –&gt;  动态侦测系统资源的使用情况。</li>
</ul>
<h2 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h2><p>服务，通常也称为 “daemons”，即一直处于运行状态的进程，它能向外界提供一种功能。</p>
<p>在此，我们介绍两种服务，一种与例行性工作调度相关，一种与日志记录相关。</p>
<p>在 Linux 系统中，存在两种例行性工作调度：突发型 (即某个特定时间点执行，它借助于 <code>atd</code> 服务而存在，使用指令 <code>at</code> 可定义此类任务)、循环型 (即定期执行，它借助于 <code>crond</code> 服务而存在，使用指令 <code>crontab</code> 可定义此类任务)。</p>
<blockquote>
<p>对于 <code>at</code> 和 <code>cron</code> 而言，分别存在 <code>xx.allow</code> 和 <code>xx.deny</code> 以限制所定义的任务是否可被执行，另外使用者所创建的任务分别被放置于 <code>/var/spool/at</code> 和 <code>/var/spool/cron</code> 之中。</p>
</blockquote>
<p>值得说一下的是：<code>crond</code> 服务通常也为系统所使用，在 <code>/etc/crontab</code> 配置文件中，其中定义了若干周期性执行 <code>/etc/cron.d/*</code> 中脚本 (其脚本功能可能是更新 locate 数据库，也可能是轮替日志文件) 的任务。</p>
<p>另外，考虑一种场景：假定某任务每周日晚上执行，但是某周六系统停电，电脑关机，自然该任务这周日不会执行。周一启动系统后，时间已经过期，<code>crond</code> 自然会等到本周日晚上才执行此任务，然而如果该任务比较重要的话，最好还是周一就执行一次。为解决这个问题，<code>anacron</code> 进程被启用，它会自动判断哪些任务逾期未执行，然后自动执行它们。</p>
<blockquote>
<p>十分有意思的是：<code>anacron</code> 由 <code>crond</code> 控制而周期执行，<code>anacron</code> 又会反过来判断各任务是否逾期未完成。</p>
</blockquote>
<p>在 Linux 系统中，日志记录主要分为两部分：一部分由 <code>systemd-journald</code> 提供，系统启动之初的各种日志信息均会由此记录；一部分由 <code>rsyslog</code> 提供，它会记录系统运行期间各进程的日志信息，普通程序也可基于相关规范将日志信息发与 <code>rsyslog</code> 以供其管理。</p>
<blockquote>
<p>各种日志文件通常均位于 <code>/var/log</code> 之中。</p>
<p>随着系统的运行，日志文件将会越来越大，那么就存在 <code>logrotate</code> 这一服务，它会基于 <code>/etc/logrotate.conf</code> 及 <code>/etc/logrotate.d/*</code> 中配置文件内容，按照特定方式轮替日志文件 (以某种格式备份当前所用日志文件，随后清空当前所用日志文件。另外，过早的日志文件可能会被自动清除)。</p>
</blockquote>
]]></content>
      <categories>
        <category>linux学习</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 账号管理</title>
    <url>/2021/03/20/linux/linux6-account/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>既然 Linux 系统可以提供多用户多任务环境，那么本文便介绍一下与用户账号相关的知识。</p>
<a id="more"></a>

<h2 id="详述"><a href="#详述" class="headerlink" title="详述"></a>详述</h2><p>在 Linux 系统中，与用户账号相关的文件主要涉及：<code>/etc/passwd</code>、<code>/etc/shadow</code> (记录 owner 信息)、<code>/etc/group</code>、<code>/etc/gshadow</code> (记录 group 信息)。</p>
<p>在 <code>/etc/passwd</code> 中，每一行表示一个 owner，举例并解释各字段如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yl:x:1001:1001::/home/yl:/bin/bash</span><br><span class="line">各字段以 <span class="string">&#x27;:&#x27;</span> 分割，共计 7 个。</span><br><span class="line">- 账号名称，用以用户记忆使用。</span><br><span class="line">- 账号密码，早期该位置放置密码，但是由于此文件各用户均可访问，从而容易造成密码被窃。现今账号密码</span><br><span class="line">  已放置于 /etc/shadow(仅特定账号和特定群组可访问) 之中，因此字段显示为 x。</span><br><span class="line">- UID，一对一映射账号名称，用以计算机使用。</span><br><span class="line">  在 Linux 系统中，UID=0 为系统管理员账号，UID=[1-999] 为系统账号，UID=[1000-] 为可登录账号。</span><br><span class="line">  UID=0 的账号具有特殊权限，其余账号均无特殊权限。</span><br><span class="line">- GID，一对一映射群组名称，用以计算机使用。</span><br><span class="line">- 使用者信息说明，用以介绍该账号的用途，基本没什么用。</span><br><span class="line">- 主文件夹，指明当前账号的家目录，其中存放当前账号的个人数据。</span><br><span class="line">- Shell，指明当前账号所使用的 SHELL 环境。</span><br></pre></td></tr></table></figure>
<p>在 <code>/etc/shadow</code> 中，每一行表示一个 owner 的密码信息，举例并解释各字段如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yl:Y6FFNSuN66W...:18694:0:99999:7:::</span><br><span class="line">各字段以 <span class="string">&#x27;:&#x27;</span> 分割，共计 9 个。</span><br><span class="line">- 账号名称，对应 /etc/passwd 中的账号名称。</span><br><span class="line">- 账号密码，通常取值为真实密码的 SHA-512。</span><br><span class="line">- 最近更动密码日期，取值为一整数，表示自 1970 年 1 月 1 日至今所经过的天数。</span><br><span class="line">- 密码不可被更动的天数，用以限制账号使用者频繁更动密码。</span><br><span class="line">- 密码需要重新更动的天数，用以保证密码的安全性。如果超过此天数限制，则账号 “过期”，</span><br><span class="line">  此时登录系统，则会被强制要求更动密码。</span><br><span class="line">- 密码需要重新更动前的警告天数，用以提醒账号使用者，需要及时更动密码。</span><br><span class="line">- 密码过期后的宽限天数，如果账号过期，且在宽限天数内未曾更动密码，则账号 “失效”。</span><br><span class="line">  账号失效，意味着该账号再也无法登录此系统。</span><br><span class="line">- 账号失效日期，取值为一整数，含义与 “最近更动密码日期” 相同，常为收费系统所使用。</span><br><span class="line">- 保留字段。</span><br></pre></td></tr></table></figure>
<p>借助于两个文件中各字段含义，简单说明三个使用操作：</p>
<ol>
<li>文件 <code>inode</code> 中实际存放的是 UID 和 GID。当使用 <code>ls -l</code> 进行查看文件时，系统会自动根据 <code>/etc/passwd</code> 和 <code>/etc/group</code> 找到 UID 和 GID 所对应的英文字符，从而将其显示出来。</li>
<li>当我们进行文件操作时，系统会提取特定文件的 UID 与 GID，并将其与使用者的 UID 与 GID 进行对比，如果满足权限，则进行操作，否则提示权限不足。</li>
<li>当使用者登录系统时，系统将会基于 <code>/etc/passwd</code> 和 <code>/etc/shadow</code> 核对使用者所输账号密码信息，如果两者不相符则退出，否则依据 <code>/etc/passwd</code> 中该账号的后两个字段，提供指定 SHELL 并切换至家目录 (其中涉及 SHELL 初始配置等操作)，以供使用者使用此系统。</li>
</ol>
<blockquote>
<p>在 <code>/etc/shadow</code> 的每行信息中，重点在于前两个字段，后面几个字段基本不使用。</p>
<p>指令 <code>passwd</code> 可用于修改账号密码，使用者可修改自身账号密码，root 用户可修改任意账号密码。如果使用者忘记自身密码，需借由 root 用户帮助而重置密码；如果 root 用户忘记密码，仍可基于某些方法 (例如，重新开机进入单人维护模式) 进入系统，从而重置密码。</p>
</blockquote>
<p>在 <code>/etc/group</code> 中，每一行表示一个 group，举例并解释各字段如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yl:x:1001:hhd,dms</span><br><span class="line">各字段以 <span class="string">&#x27;:&#x27;</span> 分割，共计 4 个。</span><br><span class="line">- 群组名称，用以用户记忆使用。</span><br><span class="line">- 群组密码，其含义与账号密码一致，供给 “群组管理员” 使用，现基本不使用此。</span><br><span class="line">- GID，一对一映射群组名称，用以计算机使用。</span><br><span class="line">- 群组所支持的账号名称集，即这些账号均属于此群组。</span><br></pre></td></tr></table></figure>
<p>在 <code>/etc/gshadow</code> 中，每一行表示一个 group 的密码信息，举例并解释各字段如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yl:!::hhd,dms</span><br><span class="line">各字段以 <span class="string">&#x27;:&#x27;</span> 分割，共计 4 个。</span><br><span class="line">- 群组名称，对应 /etc/group 中的群组名称。</span><br><span class="line">- 群组密码，现今基本不存在 “群组管理员”，因此其取值通常为 !。</span><br><span class="line">- 群组管理员对应账号，因为不存在 “群组管理员”，因此该字段为空。</span><br><span class="line">- 群组所支持的账号名称集，与 /etc/group 最后一个字段含义相同。</span><br></pre></td></tr></table></figure>
<p>对于群组而言，还存在些许概念值得一提：</p>
<ol>
<li>默认情况下，创建某个账号时，会自动创建一个同名群组，并将此账号添加至此同名群组之中，当然用户也可指定此账号添加至某特定群组之中。该账号所属群组即称为 <em>初始群组</em>，<code>/etc/passwd</code> 中 GID 所指代的便是初始群组。另外，在新版 Linux 系统的 <code>/etc/group</code> 和 <code>/etc/gshadow</code> 中，如果某群组为某账号的初始群组，则该群组的第四个字段中不再会包含此账号信息。</li>
<li>一个账号可添加至多个群组中，而在执行操作时所发挥作用的群组 (例如，查看文件时，依据哪个群组进行权限判断) 称为 <em>有效群组</em>。用户登录系统后，有效群组即为初始群组，可使用指令 <code>groups</code> 进行查看，随后可借由指令 <code>newgrp</code> 进行切换 (基于此指令切换有效群组后，使用者即会进入另一个 SHELL 环境中，若需退出，输入 <code>exit</code> 即可)。</li>
</ol>
<h2 id="所涉指令"><a href="#所涉指令" class="headerlink" title="所涉指令"></a>所涉指令</h2><p>系统管理员所能使用的指令有：</p>
<ul>
<li><code>useradd</code>  –&gt;  添加一个用户账号，与此相关的各种默认参数值见于 <code>/etc/default/useradd</code> 和 <code>/etc/login.defs</code>。</li>
<li><code>usermod</code>  –&gt;  修改用户账号相关信息。</li>
<li><code>userdel</code>  –&gt;  删除一个用户账号。</li>
<li><code>passwd</code>  –&gt;  为用户账号创建、修改、删除密码。</li>
<li><code>chage</code>  –&gt;  查看用户密码的详细信息，也可更新相关字段信息。</li>
<li><code>groupadd/groupmod/groupdel</code>  –&gt;  添加、修改、删除一个群组账号。</li>
<li><code>gpasswd</code>  –&gt;  创建一个群组管理员 (已基本不使用)。</li>
</ul>
<blockquote>
<p>使用者借用 <code>passwd</code> 更新自身密码时，首先需要输入当前密码，然后才能输入更新密码，且密码需满足一定安全规则；root 用户借用 <code>passwd</code> 设置密码时，直接输入更新密码即可。</p>
</blockquote>
<p>用户所能使用的指令有：</p>
<ul>
<li><code>id</code>  –&gt;  查询自身的 UID/GID 等信息。</li>
<li><code>finger</code>  –&gt;  查询自身账号信息。</li>
</ul>
]]></content>
      <categories>
        <category>linux学习</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 文件操作</title>
    <url>/2021/03/18/linux/linux5-fileoperation/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文介绍与文件操作相关的众多指令，这部分内容仅涉及指令功能说明，而不涉及具体用法。</p>
<a id="more"></a>

<p>如需了解详细用法，可借由命令 <code>command --help</code> \ <code>info command</code> \ <code>man command</code> 进行查看。</p>
<h2 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h2><ul>
<li><p><code>cd</code></p>
<p>该指令用于切换当前工作目录为指定目录。</p>
</li>
<li><p><code>pwd</code></p>
<p>该指令用于显示当前工作目录的具体路径信息。</p>
</li>
<li><p><code>mkdir</code></p>
<p>该指令可用于递归创建空目录。</p>
</li>
<li><p><code>rmdir</code></p>
<p>该指令仅用于递归删除空目录。</p>
</li>
</ul>
<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><ul>
<li><p><code>ls</code></p>
<p>该指令用于查看指定目录下各文件或目录的具体信息。</p>
</li>
<li><p><code>touch</code></p>
<p>该指令既可用于创建新文件，也可用于修改文件时间。</p>
<p>Linux 系统会记录与文件相关的多个时间参数，其中主要有 3 个时间参数：</p>
<ul>
<li><p><code>modification time (mtime)</code>：文件内容发生变动，触发更新此时间。</p>
</li>
<li><p><code>status time (ctime)</code>：文件状态 (例如，属性、权限、大小等) 发生变动，触发更新此时间。</p>
</li>
<li><p><code>access time (atime)</code>：文件内容被访问，触发更新此时间。</p>
</li>
</ul>
<blockquote>
<p>指令 <code>touch</code> 仅可设置修改 <code>mtime</code> 和 <code>atime</code>。</p>
</blockquote>
</li>
<li><p><code>cp</code></p>
<p>该指令用于复制指定内容至指定位置。</p>
<p><strong>默认情况下，指定内容与复制内容的属性和权限可能不同</strong>，因此需要额外注意此指令的操作结果。</p>
</li>
<li><p><code>mv</code></p>
<p>该指令既可用于指定文件名或目录名的修改，也可用于指定文件或目录的移动。</p>
</li>
<li><p><code>rm</code></p>
<p>该指令用于删除指定文件或目录。</p>
</li>
</ul>
<h2 id="文件查看"><a href="#文件查看" class="headerlink" title="文件查看"></a>文件查看</h2><ul>
<li><p><code>cat/tac</code></p>
<p>两个指令以行为单位，按序输出文件内容，不同点在于前者正序输出，而后者逆序输出。</p>
</li>
<li><p><code>nl</code></p>
<p>该指令以行为单位，按照正序输出文件内容，并为各行添加行号，其基本等价于 <code>cat -n</code>。</p>
</li>
<li><p><code>more/less</code></p>
<p>两个指令可实现翻页式查看文件内容，并支持文件内查找等功能。</p>
</li>
<li><p><code>head/tail</code></p>
<p>两个指令以行为单位，截取文件内容若干行作为输出结果，不同点在于前者从前往后截取，而后者从后往前截取。</p>
</li>
<li><p><code>od</code></p>
<p>上述指令均用于查看纯文本文件，该指令则用于查看非文本文件。</p>
</li>
<li><p><code>file</code></p>
<p>该指令用于判断特定文件的具体类型。</p>
</li>
</ul>
<h2 id="文件搜索"><a href="#文件搜索" class="headerlink" title="文件搜索"></a>文件搜索</h2><ul>
<li><p><code>which</code></p>
<p>该指令用于搜寻特定指令的二进制文件的具体位置。</p>
</li>
<li><p><code>whereis</code></p>
<p>该指令用于在若干特定目录内搜寻特定指令的二进制文件、源代码、使用手册的具体位置。</p>
</li>
<li><p><code>locate</code></p>
<p>该指令会基于 <code>/var/lib/mlocate</code> 数据库给出特定文件的搜寻结果。</p>
<p>默认情况下，Linux 系统会每天更新一次 <code>/var/lib/mlocate</code> 数据库，用户也可使用命令 <code>updatedb</code> 手动更新。更新数据库时，系统首先读取 <code>/etc/updatedb.conf</code> 配置文件 (其中可设定若干搜索限制)，然后在硬盘内部全局搜索以执行更新操作。</p>
<p>因为该指令基于数据库存储内容给出搜寻结果，因此它所能支持的功能比较有限。</p>
</li>
<li><p><code>find</code></p>
<p>该指令会直接搜索硬盘以给出特定文件的搜寻结果。</p>
<p>正因其直接搜索硬盘，<code>find</code> 的搜索速度会比较慢，但是却能支持众多强大功能，例如：搜索属于特定用户的文件、搜索具有特定权限的文件、搜索特定文件大小的文件。</p>
</li>
</ul>
<h2 id="文件处理"><a href="#文件处理" class="headerlink" title="文件处理"></a>文件处理</h2><ul>
<li><p><code>cut</code></p>
<p>该指令会以行为单位，截取行内若干字段。</p>
</li>
<li><p><code>grep</code></p>
<p>该指令同样以行为单位，搜寻并输出满足特定规则 (尤指正则表达式) 的行。</p>
</li>
<li><p><code>sort</code></p>
<p>该指令同样以行为单位，按照某种特定规则排序行数据，并将其输出。</p>
</li>
<li><p><code>uniq</code></p>
<p>该指令同样以行为单位，综合重复行信息为一行信息，并输出之。</p>
</li>
<li><p><code>wc</code></p>
<p>该指令用于统计特定文件中所含字符数、字数、行数信息。</p>
</li>
<li><p><code>tee</code></p>
<p>该指令用以将标准输入流所得内容同时输入至特定文件和标准输入流之中。</p>
</li>
<li><p><code>tr</code></p>
<p>该指令用于从特定文件中删除特定字符串，或将特定字符串替换为其他字符串。</p>
</li>
<li><p><code>col/expand</code></p>
<p>两个指令常用于替换 <code>tab</code> 键为若干空格键。</p>
</li>
<li><p><code>join</code></p>
<p>该指令同样以行为单位，按照某特定字段合并两个文件内容。</p>
</li>
<li><p><code>paste</code></p>
<p>较之 <code>join</code>，该指令的功能十分简单，它以行为单位，直接合并两个文件内容。</p>
</li>
<li><p><code>xargs</code></p>
<p>在 Linux 系统中，有些指令可以直接接收管道参数，而有些指令则不可用。该指令存在的价值便在于帮助部分指令接收管道参数。</p>
<p>其常见模式为：<code>xxx | xargs -n 2 command</code>，<code>xargs</code> 每次以两个管道参数作为 <code>command</code> 的实际参数，并执行此指令，直至管道参数使用完。</p>
</li>
<li><p><code>printf</code></p>
<p>该指令用于格式化输出指定类似，基本等价于 C 语言中的 <code>printf()</code> 函数。</p>
</li>
<li><p><code>sed</code></p>
<p>该指令功能比较强大，它可实现替换行数据、删除行数据、指定行的字符替换等。</p>
<p>其常见模式为：<code>xxx | sed &#39;a,bc&#39;</code>，<code>sed</code> 接收管线数据，并在管线数据的 <code>a-b</code> 行间执行 <code>c</code> 操作。</p>
</li>
<li><p><code>awk</code></p>
<p>该指令适用于以行为单位、行中字段为内容，进行数据处理。</p>
<p>其常见模式为：<code>awk &#39;BEGIN&#123;&#125; 条件1&#123;动作1&#125; 条件2&#123;动作2&#125; ... END&#123;&#125;&#39; fileName</code>，首先执行 <code>BEGIN</code> 中操作，随后依次从 <code>fileName</code> 中读取一行数据，并判断是否满足各条件，如果满足，则执行其中动作，否则便不执行任何动作，最后执行 <code>END</code> 中操作。</p>
</li>
<li><p><code>split</code></p>
<p>该指令用于将大文件切分为若干小文件。</p>
</li>
</ul>
<h2 id="文件对比"><a href="#文件对比" class="headerlink" title="文件对比"></a>文件对比</h2><ul>
<li><p><code>diff</code></p>
<p>该指令可用于对比两文件间的差异 (以行为单位)，同时可将此差异包装为一个 <code>patch</code> 文件(借助于参数 <code>-Naur</code>)。</p>
</li>
<li><p><code>cmp</code></p>
<p>该指令以字节为单位，进行两文件间的对比。</p>
</li>
<li><p><code>patch</code></p>
<p>该指令可基于 <code>patch</code> 文件更新旧文件或还原新文件。</p>
</li>
</ul>
<h2 id="文件打包-压缩"><a href="#文件打包-压缩" class="headerlink" title="文件打包/压缩"></a>文件打包/压缩</h2><p>文件打包与压缩操作往往会同时执行，因此这里仅介绍兼具打包与压缩功能的指令 <code>tar</code>。</p>
<p>在指令 <code>tar</code> 中，主要涉及三种压缩方式：gzip/bzip2/xz，三者的压缩性能依次递增，压缩时间亦是依次递增。</p>
<ul>
<li>打包压缩指令 <code>tar -c[z|j|J]vf tarName fileName</code>。</li>
<li>解包解压缩指令 <code>tar -x[z|j|J]vf tarName fileName</code>。</li>
</ul>
<blockquote>
<p>基于指令 <code>tar</code> 还可执行一些高级操作，例如：打包某目录的同时忽略特定类型文件、仅解压缩特定文件。</p>
</blockquote>
<h2 id="文件备份"><a href="#文件备份" class="headerlink" title="文件备份"></a>文件备份</h2><ul>
<li><p><code>tar</code></p>
<p>该指令可用于备份特定文件或特定目录为一个压缩包。</p>
</li>
<li><p><code>dd</code></p>
<p>该指令可从标准输入、设备、文件中读取数据，根据指定格式转换数据，并将其输出至文件、设备、标准输出。</p>
<p>如果忽略格式转换，该指令便可用于文件备份。</p>
</li>
<li><p><code>cpio</code></p>
<p>该指令可将指定数据备份至特定位置。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>linux学习</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 文件权限</title>
    <url>/2021/03/17/linux/linux4-permission/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Linux 系统的一大特色便在于其可以提供多用户多任务环境。鉴于各用户往往存在数据隐私保护需求，Linux 系统便提供了一套文件权限管理机制。本文介绍与文件权限管理相关的若干机制，具体包括 rwx 权限、隐藏权限、特殊权限、ACL。</p>
<a id="more"></a>

<h2 id="rwx-权限"><a href="#rwx-权限" class="headerlink" title="rwx 权限"></a>rwx 权限</h2><p>借助于命令 <code>ls -l</code>，我们可以查看当前目录下各文件的权限设置。举例而言：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-rwxrwxr-x            1               hhd    hhd    4096  2月 20 20:58   bin</span><br><span class="line"> 权限设置   链接至此inode的文件名数量  拥有者 所在群组  容量   最近修改时间  文件名</span><br></pre></td></tr></table></figure>
<p>对于第一栏信息，进一步可解析如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">   -               rwx                    rwx                 r-x</span><br><span class="line">文件属性  文件拥有者所具有的权限  文件所在群组所具有的权限  其他人所具有的权限</span><br></pre></td></tr></table></figure>
<p>对此我们做如下解释：</p>
<ul>
<li>对于某个文件访问者而言，其身份可能为 owner/group/other，这是 Linux 系统对用户身份的一种简单分类。类比于社会而言，owner 等价于自身，group 等价于家庭，other 等价于家庭以外的事物。</li>
<li>针对某种用户身份而言，一个文件可能具有的权限设置为 r、w、x。</li>
<li>对于一般文件而言，r 指代是否可读取其中内容，w 指代是否可向其中写入内容，x 指代是否可执行此文件。</li>
<li>因为目录文件内部存放目录内各文件或文件夹名与其 <code>inode</code> 对应编号信息，因此对于目录文件而言，r 指代是否可查看目录内容，w 指代是否可向其中增删文件或目录，x 指代是否可进入此目录。</li>
</ul>
<p>据此，我们可知：对于文件 <code>bin</code> 而言，其拥有者具有 <code>rwx</code> 权限，其所在群组成员具有 <code>rwx</code> 权限，其他人仅具有 <code>rx</code> 权限。</p>
<p>接下来，我们说明若干指令以修改各文件的属性或权限设置。</p>
<ul>
<li><p><code>chown</code></p>
<p>该指令用于设置文件拥有者和所在群组信息，具体用法为 <code>chown owner:group fileName</code>。</p>
</li>
<li><p><code>chgrp</code></p>
<p>该指令用于设置文件所在群组信息，具体用法为 <code>chgrp group fileName</code>。</p>
</li>
<li><p><code>chmod</code></p>
<p>该指令用于设置文件权限信息，其具体可细分为两种写法：其一，数字类型表示 rwx 权限，1 表示 x，2 表示 w，4 表示 r，那么 7 即表示 rwx。例如，<code>chmod 743 fileName</code>，即表示所设权限为 <code>rwxr---wx</code>，其中 <code>xxx</code> 为三个数字；其二，符号类型表示 rwx 权限，它直接借助于 r/w/x 以设置文件权限。例如，<code>chmod u=rw,go=r fileName</code>，即表示所设权限为 <code>rw-r--r--</code>。 </p>
</li>
</ul>
<blockquote>
<p>实践发现，似乎仅 root 用户可设置文件拥有者和所在群组属性，似乎仅文件拥有者和 root 用户可设置文件权限。</p>
</blockquote>
<p>在这部分最后，我们再谈一个问题：创建一个文件后，使用命令 <code>ls -l</code> 查看，会发现其具有默认权限，该默认权限由何决定？</p>
<p>指令 <code>umask</code> 可用于查看或设置新建文件的权限，因此该默认权限由此命令指定。 <code>umask</code> 用于查看默认权限，而 <code>umask xxxx</code> 用于设置默认权限 (第一个数字表示特殊权限的设置，下文有具体解释)。</p>
<h2 id="隐藏权限"><a href="#隐藏权限" class="headerlink" title="隐藏权限"></a>隐藏权限</h2><p>除最基本的 <code>rwx</code> 权限之外，在 Linux 系统的 ext2/3/4 文件系统之下，还可设置其他隐藏权限。</p>
<p>指令 <code>lsattr</code> 用于列举各文件所具有的隐藏权限，指令 <code>chattr</code> 用于设置各文件的隐藏权限。</p>
<p>在这些隐藏权限之中，我们重点关注两项：</p>
<ul>
<li><code>chattr +i fileName</code>，经此设置之后，该文件不能被删除、改名、设置链接、写入数据。</li>
<li><code>chattr +a fileName</code>，经此设置之后，只能向该文件中写入数据，而不能修改或删除其中数据。</li>
</ul>
<h2 id="特殊权限"><a href="#特殊权限" class="headerlink" title="特殊权限"></a>特殊权限</h2><p>在 Linux 系统中，存在三种特殊权限：<code>SUID</code>、<code>SGID</code>、<code>SBIT</code>，我们依次介绍之。</p>
<ul>
<li><p><code>SUID</code></p>
<p>该权限出现于文件拥有者的 <code>x</code> 权限之上，它具有如下使用限制和功能：</p>
<ol>
<li>该权限仅对于二进制程序有效。</li>
<li>使用者对于该程序需具有 <code>x</code> 执行权限。</li>
<li>程序执行过程中，使用者暂时具有程序拥有者的所有权限。</li>
</ol>
<p>换言之，如果使用者有权执行某程序，且此程序具有 <code>SUID</code> 权限，则程序执行时是以程序拥有者的身份执行的。</p>
<p>典型例子：<code>ls -l /usr/bin/passwd</code>。</p>
</li>
<li><p><code>SGID</code></p>
<p>该权限出现于文件所在群组的 <code>x</code> 权限之上，它具有如下使用限制和功能：</p>
<ol>
<li>该权限仅对二进制程序和目录有效。</li>
<li>如果该权限作用于二进制程序，且使用者对于该程序具有 <code>x</code> 执行权限，则程序执行过程中，使用者暂时具有该程序所在群组的群组身份。</li>
<li>如果该权限作用于目录，且使用者对于该目录具有 <code>wx</code> 权限，则使用者在此目录下的有效群组暂时变更为该程序所在群组。</li>
</ol>
<p>典型例子：<code>ls -l /usr/bin/locate</code>。</p>
</li>
<li><p><code>SBIT</code></p>
<p>该权限出现于其他人的 <code>x</code> 权限之上，它具有如下使用限制和功能：</p>
<ol>
<li>该权限仅对目录有效。</li>
<li>如果使用者对于该目录具有 <code>wx</code> 权限，则使用者在此目录下创建的文件，只能由使用者自己或 root 删除，即该目录下某文件的删除权利仅限于文件拥有者和 root 用户。</li>
</ol>
</li>
</ul>
<blockquote>
<p>如果某文件拥有 <code>SUID</code> 权限，则表明此文件拥有者同时具有 <code>x</code> 权限，同理可得 <code>SGID</code> 和 <code>SBIT</code>。</p>
<p>有效群组的相关介绍详见 <a href="/2021/03/20/linux/linux6-account/" title="Linux 账号管理">Linux 账号管理</a>。</p>
</blockquote>
<p>既然指令 <code>chmod</code> 用于设置文件权限，我们看看这个命令如何设置特殊权限。</p>
<p>与普通 <code>rwx</code> 权限类似，同样存在两种设置特殊权限的写法：其一，数字类型表示特殊权限，4 表示 <code>SUID</code>，2 表示 <code>SGID</code>，1 表示 <code>SBIT</code>，此时设置命令可表示为：<code>chmod 7xxx fileName</code>；其二，符号类型表示特殊权限，此时设置命令可表示为：<code>chmod ug+s,o+t fileName</code>。</p>
<h2 id="ACL"><a href="#ACL" class="headerlink" title="ACL"></a>ACL</h2><p>将使用者简单划分为 owner/group/other 三类，并在此基础上设置权限，该种权限管理机制终究是粗粒度的。要使用更加细粒度的权限管理，就需要引入额外机制。</p>
<p>ACL 全称为 Access Control List，它可以提供 Linux 系统传统权限机制之外的细部权限设置。另外，现有 Linux 系统也已默认支持 ACL。</p>
<p>ACL 可以达到如下程度的细粒度控制：</p>
<ul>
<li>对于某文件或目录而言，可设置特定用户的特定权限。</li>
<li>对于某文件或目录而言，可设置特定群组的特定权限。</li>
<li>对于某文件或目录而言，可设置该文件或目录上所能设置的最大权限 <code>mask</code>，即在该文件或目录下设置的各用户或群组的实际权限为其设置权限和 <code>mask</code> 相与的结果。 </li>
<li>对于某目录而言，可设置该目录下新建文件或目录的默认 ACL 权限。</li>
</ul>
<blockquote>
<p>命令 <code>getfacl</code> 和 <code>setfacl</code> 可用于查看或设置某文件或目录的 ACL 权限信息。</p>
<p>如果某文件或目录设置了 ACL 权限信息，则使用命令 <code>ls -l</code> 时，可以看到权限设置后部会多出 <code>+</code>，例如 <code>-rwxrw-r--+</code>。</p>
</blockquote>
]]></content>
      <categories>
        <category>linux学习</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 磁盘文件系统</title>
    <url>/2021/03/16/linux/linux3-filesystem/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文首先介绍 Linux 系统中最为常见的文件系统 ext2，随后介绍进阶文件系统 RAID 和 LVM。</p>
<a id="more"></a>

<p>磁盘分区完成后，还要经过格式化，系统才能使用此磁盘分区以存取数据。所谓格式化，即是在磁盘分区之上，构建一个文件系统。</p>
<p>Linux 系统所能识别的文件系统有 ext2 (Linux second extended file system)、xfs，Windows 系统所能识别的文件系统有 FAT (File Allocation Table)、NTFS (New Technology File System)。</p>
<blockquote>
<p>如果将格式化为 NTFS 的磁盘分区挂载于 Linux 系统，Linux 系统是无法识别并使用此磁盘分区的。 </p>
</blockquote>
<h2 id="ext2"><a href="#ext2" class="headerlink" title="ext2"></a>ext2</h2><p>Linux 系统所能识别的文件系统大体类似，我们在此介绍一种最为经典的文件系统 ext2。</p>
<p>在说明 ext2 结构之前，我们先介绍一下文件的存储形式。</p>
<p>对于一个文件而言，其主要分为两部分：实际存储内容和相关属性值 (例如，文件名、读写权限、修改时间等)。在 Linux 系统的文件系统之中，<code>block</code> 用于存储实际内容，<code>inode</code> 则用于存储相关属性值以及所对应的所有 <code>block</code> 编号。</p>
<p>当需要读取某文件的具体内容时，系统首先找到该文件对应的 <code>inode</code>，随后取出其中所有的 <code>block</code> 编号，最后提取各 <code>block</code> 内容以组合为该文件。其文件提取结构大致如下所示：</p>
<img src="/2021/03/16/linux/linux3-filesystem/image-20210315150044844.png" width="36%">

<blockquote>
<p>该种文件系统称为索引式文件系统，ext2 亦是此种文件系统。</p>
</blockquote>
<p>接下来我们谈及文件系统 ext2 的实际结构，其结构具体如下：</p>
<img src="/2021/03/16/linux/linux3-filesystem/image-20210315154436949.png" width="36%">

<p>对于一个磁盘分区而言，其先行被划分为一个 Boot Sector (用于存放开机管理程序) 和若干 Block Group。</p>
<blockquote>
<p>划分分区为众多 Block Group 的目的在于便于管理，同时也可促使同一文件的各部分内容集中存放，加快读取速度。</p>
</blockquote>
<p>对于一个 Block Group 而言，其进一步被划分为六部分：</p>
<ul>
<li><p>Superblock</p>
<p>它用于记录文件系统的整体信息，具体包括 <code>inode</code> 与 <code>block</code> 的总量、<code>inode</code> 与 <code>block</code> 的块大小、文件系统的创建时间、是否挂载等。</p>
<p>通常情况下，仅第一个 Block Group 具有此部分，其余 Block Group 均无此部分。为安全考虑，有时其他 Block Group 也会具有此部分，但是其内容仅为第一个 Block Group 此部分的备份。</p>
</li>
<li><p>档案系统描述</p>
<p>它用于记录当前 Block Group 所对应的开始和结束 Block 编号，以及 Block Group 内部六部分所对应的开始和结束 Block 编号。</p>
</li>
<li><p>区块对应表</p>
<p>基于 BitMap 数据结构，记录哪些 <code>block</code> 处于空闲状态。</p>
</li>
<li><p>inode 对应表</p>
<p>基于 BitMap 数据结构，记录哪些 <code>inode</code> 处于空闲状态。 </p>
</li>
<li><p>inode table</p>
<p>存放具体文件所对应的 <code>inode</code> 集。</p>
<p>因为 <code>inode</code> 之中存放该文件所对应的所有 <code>block</code> 编号，因此对于 ext2 文件系统而言，其所能存储的单个文件是有容量限制的。</p>
<p>为尽可能扩大单个文件的容量限制，ext2 文件系统采用如下方式存放 <code>block</code> 编号 (12 个直接记录、一个间接记录、一个双间接记录、一个三间接记录)：</p>
<img src="/2021/03/16/linux/linux3-filesystem/131130007318296.jpg" width="36%">
</li>
<li><p>block table</p>
<p>存放具体文件所对应的 <code>block</code> 集。</p>
</li>
</ul>
<p>介绍完 ext2 文件系统结构之后，我们再谈两个问题：</p>
<ol>
<li><p>如何查看 ext2 文件系统的结构参数信息？</p>
<p>Linux 系统提供指令 <code>dumpe2fs</code> 以查看 ext2 文件系统的结构参数信息。</p>
</li>
<li><p>ext2 文件系统是否存在数据不一致问题？</p>
<p>在 ext2 文件系统之中，读取操作不存在数据不一致问题，而写入操作可能引发数据不一致问题。</p>
<p>如果需要新增一个文件，文件系统将会产生如下行为：检查使用者对当前目录是否具有 <code>wx</code> 权限 –&gt;  根据 <code>inode bitmap</code> 找到空闲 <code>inode</code> 并写入属性信息  –&gt;  根据 <code>block bitmap</code> 找到空闲 <code>block</code> 并写入文件内容  –&gt;  更新 <code>inode/block bitmap</code> 与 Superblock。</p>
<p>假定前三步顺利完成，随后断电使得第四步没有完成，此时便存在数据不一致问题。</p>
<p>为解决此问题，最初做法：基于 Superblock 中的挂载位和状态位等信息判断是否需要强制检查数据不一致问题，如果需要，则比对整个文件系统中 <code>inode/block</code> 与 <code>bitmap</code>、Superblock 中的信息，以此判断是否存在数据不一致问题。</p>
<p>对于上述做法而言，它需要比对整个文件系统，故而十分耗时。为解决此问题，日志系统被应用至文件系统之中 —— 当需要写入文件至文件系统中时，首先向日志系统写入待操作信息，文件写入完成后，再次写入操作完成信息。此时，如果发生断电行为，再次开启系统后，只需检查日志系统即可判断是否存在数据不一致问题。</p>
</li>
</ol>
<blockquote>
<p>ext2 并不提供日志功能，而 ext3/4 可以提供日志功能。</p>
</blockquote>
<p>最后，我们说明若干与此相关的指令：</p>
<ul>
<li><p><code>df</code></p>
<p>该指令可列出各文件系统的整体磁盘使用情况。</p>
</li>
<li><p><code>du</code></p>
<p>该指令用于评估指定文件或目录所使用的磁盘空间大小。</p>
</li>
<li><p><code>ln</code></p>
<p>该指令用于文件间链接。</p>
<p>链接具体分为实体链接和符号链接。实体链接，即硬链接，链接文件与实际文件的文件名不同，但是两者所对应的 <code>inode</code> 相同；符号链接，即软链接，链接文件内部存放实际文件的具体路径，当查看链接文件时，系统会自动显示实际文件内容。</p>
<p>需要注意的是：实体链接仅限于单一文件系统，且仅能供文件使用；符号链接不仅可供文件使用，也可供目录使用，而且可跨越多个文件系统，因此符号链接使用更为广泛。</p>
</li>
</ul>
<h2 id="RAID"><a href="#RAID" class="headerlink" title="RAID"></a>RAID</h2><p>借助于软件或硬件设备，RAID (Redundant Arrays of Inexpensive Disks) 可将多个小容量磁盘整合成为一个大容量磁盘，而且该大容量磁盘不仅具有 <strong>存储功能</strong>，也具有 <strong>数据保护功能</strong>。</p>
<p>根据 RAID 等级不同，其所具有的数据保护功能亦有所不同。常见的 RAID 等级如下：</p>
<blockquote>
<p>在所有等级之下，RAID 均会先行设定 chunk 值，该值可理解为虚拟磁盘之上的扇区大小，它通常对应于物理磁盘之上的若干扇区。</p>
<p>RAID 具体实现技术及所涉算法比较复杂，故而不再做任何思虑。</p>
</blockquote>
<ul>
<li><p>RAID-0 (等量模式)</p>
<p>当写入文件之时，RAID 按照 chunk 大小切割文件，并将切割部分按序依次存入各磁盘之内，其结构大致如下：</p>
<img src="/2021/03/16/linux/linux3-filesystem/130px-RAID_0.svg.png">

<p>由于其中不含冗余信息，故而 RAID-0 不具有数据保护功能；但是它会将数据平均存于各磁盘之内，因此 RAID-0 具有最佳读写性能。</p>
</li>
<li><p>RAID-1 (映射模式)</p>
<p>当写入文件之时，RAID 按照 chunk 大小切割文件，并将文件内容分别写入各磁盘之中，其结构大致如下：</p>
<p><img src="/2021/03/16/linux/linux3-filesystem/130px-RAID_1.svg.png"></p>
<p>由于文件会被同时写入各磁盘之中，因此 RAID-1 具有最佳的数据保护功能；也正是如此，RAID-1 与普通单个磁盘的写性能相同，由于每个磁盘具有文件的全部数据，RAID-1 则可采用 RAID-0 类似的读取方式，使得 RAID-1 具有最佳的读性能。</p>
</li>
<li><p>RAID-5</p>
<p>RAID-5 属于 RAID-0 和 RAID-1 的折中方案，它借由奇偶校验信息以恢复数据。在该种 RAID 之中，即使一块磁盘发生损坏，所存储的数据信息也能得到恢复。</p>
<p>以下图结构为例：当写入数据之时，RAID 按照 chunk 大小切割文件，每次以 3 个 chunk 为一组，将它们及该 3 个 chunk 的奇偶校验结果随机放入各磁盘之中。</p>
<p><img src="/2021/03/16/linux/linux3-filesystem/220px-RAID_5.svg.png"></p>
<p>根据 RAID-5 的实现结构，可以看到：RAID-5 具有优于 RAID-0 的数据保护能力、近似等价于 RAID-0 的读写性能，且具有优于 RAID-1 的读写性能。</p>
</li>
<li><p>RAID-6</p>
<p>RAID-6 是对 RAID-5 的改进版本，它借由 2 块奇偶校验信息 (两者采用不同的奇偶校验算法) 以恢复数据。在该种 RAID 之中，它容许 2 块磁盘的损坏。</p>
<p><img src="/2021/03/16/linux/linux3-filesystem/270px-RAID_6.svg.png"></p>
<p>根据 RAID-6 的实现结构，可以看到：RAID-6 具有优于 RAID-5 的数据保护能力，近似等价于 RAID-5 的读写性能。</p>
</li>
<li><p>RAID-10</p>
<p>RAID-10 即是 RAID1+0，它将所有磁盘组合成为若干 RAID-1，再将这些 RAID-1 组合成为 RAID-0。</p>
<p><img src="/2021/03/16/linux/linux3-filesystem/220px-RAID_10.svg.png"></p>
<p>既然存在 RAID-10，一定会存在 RAID-01。</p>
<p><img src="/2021/03/16/linux/linux3-filesystem/220px-RAID_01.svg.png"></p>
<p>对于 RAID-10 和 RAID-01 而言，两者具有相同的读写性能，但是前者的数据保护功能强于后者的数据保护功能。</p>
<p>我们以例子说明关于数据保护功能的结论。对于 RAID-10 而言，假定 Disk0 损坏，则其余三个磁盘均可使用；而对于 RAID-01 而言，假定 Disk0 损坏，仅 Disk2 和 Disk3 可用。</p>
</li>
</ul>
<p>实际使用之中，较常使用的等级为 RAID 10 和 RAID 6。</p>
<p>根据网上资料，在此说明不常使用 RAID 5 的原因：由于磁盘存在不可恢复读取错误 (URE, unrecoverable read error)，当其中 1 块磁盘损坏后，RAID5 重建成功概率偏低，这使得数据丢失的风险增大。</p>
<blockquote>
<p>若干注意点：</p>
<p>依据实现方式不同，RAID 可进一步划分为硬件 RAID 和软件 RAID。</p>
<p>软件 RAID 依赖于软件 <code>mdadm</code> 而实现，具体借由指令 <code>mdadm</code> 实现创建、调整、删除、查询。</p>
<p>构建 RAID 之时，通常会向其中加入若干 Spare Disk，以实现某些硬盘损坏时自动重建 RAID。</p>
</blockquote>
<h2 id="LVM"><a href="#LVM" class="headerlink" title="LVM"></a>LVM</h2><p>LVM (Logical Volume Manager) 能够整合多个磁盘分区，使其看上去就像一个大磁盘，而且能够实现动态增加或移除分区到该磁盘之中，以此实现 <strong>动态调整文件系统容量的功能</strong>。</p>
<p>在 LVM 之中，存在如下若干概念：</p>
<ul>
<li><p>PV (Physical Volume)</p>
<p>它是 LVM 最底层的组成部分。</p>
<p>先借助于指令 <code>fdisk</code>  将磁盘分区或磁盘设备的 UUID 修改为 <code>8e</code> 码 (LVM 的识别码)，随后借助于指令 <code>pvcreate</code> 可将该磁盘分区或磁盘设备转换为 PV。</p>
</li>
<li><p>VG (Volume Group)</p>
<p>将若干 PV 整合在一起，得到的便是 VG，它就是 LVM 整合得到的大磁盘。</p>
</li>
<li><p>PE (Physical Extent)</p>
<p>PE 概念等价于实体磁盘的扇区，也等价于 RAID 的 chunk，它是 LVM 中数据存储的最小单位。</p>
</li>
<li><p>LV (Logical Volume)</p>
<p>在 LVM 中，VG 是整合得到的大磁盘。为使用该大磁盘，必定需要进行分区，VG 分区得到的便是 LV。</p>
</li>
</ul>
<p>根据上述概念，基本可以知道：LVM 首先抽象化 PV 得到 VG，随后在此基础之上，进行分区得到 LV，最后系统挂载 LV 进行使用。</p>
<p>VG、LV、PE 三者的关系可用下图加以表示：</p>
<img src="/2021/03/16/linux/linux3-filesystem/image-20210316155105037.png" width="36%">

<p>借助该图，LVM 能够实现动态调整文件系统容量的原因也可窥探一二。 LVM 的此项功能其实等价于能够实现动态调整 LV 和文件系统的容量，通过借用或退还 VG 中的 PE 可实现动态调整 LV 容量，而通过添加或减少 Block Group，同时修改部分配置信息即可实现动态调整文件系统容量。</p>
<p>在 LVM 之中，另有两个十分有趣的功能，分别为 “LVM thin Volume” 和 LV 磁盘快照，下面依次介绍之。</p>
<p>考虑这样一种情景：假定你需要 3 个 10G 的磁盘进行某些测试，而且这些磁盘的使用率都不会超过 10%，现如今你手边仅有一个 5G 的磁盘可用，那么能否借助于 5G 的磁盘仿真出 3 个 10G 的磁盘？“LVM thin Volume” 便可以做到这一点。</p>
<p>我们简单说明 “LVM thin Volume” 的实现原理：借助于 LVM 先行创建一个可以实支实付、用多少容量才分配实际写入多少容量的磁盘容量储存池 (thin pool)，然后使用此磁盘容量存储池即可生成若干个 “指定固定容量大小” 的 LV 设备，这样就可解决此情景问题。</p>
<blockquote>
<p>注意：基于磁盘容量存储池生成的 LV 设备的实际磁盘使用总量不能超过磁盘容量存储池的容量。</p>
</blockquote>
<p>考虑这样一种情景：假定需要保存磁盘某刻状态，并在将来某个时刻恢复到此状态，应当如何解决？使用 LV 磁盘快照即可。</p>
<p>我们简单说明 LV 磁盘快照的实现原理：LVM 内部预留一个区域用于快照，将其暂称为快照区，LV 中的所有区域暂称为系统区，快照区与系统区共享系统区内部 PE。假定某时刻启动一个快照，则快照区内部用于存储此快照信息。如果系统区中所有 PE 未发生任何变动，由于共享关系，快照区所看到的便是快照状态；如果系统区中某些 PE 发生变动，则 LV 会将修改前的此 PE 放置于快照区之中，由于共享关系，快照区所看到的便是快照区信息与系统区信息的叠加结果，其仍为快照状态。该原理可简单使用下图表示：</p>
<img src="/2021/03/16/linux/linux3-filesystem/image-20210316164306723.png" width="36%">

<blockquote>
<p>注意：快照区与系统区必须位于同一 VG。</p>
</blockquote>
<p>LV 磁盘快照与普通认知中的快照还是有些不同的。当为某 LV 创建磁盘快照后，该快照表现为一个设备，它可以同普通设备一般进行使用 (使用原理：如果操作结果使得系统区内数据发生变动，则其会将系统区内该 PE 存储到快照区之中)。既然如此，便会引申出一种骚操作：以 LV 为基础内容，创建快照设备，并以此作为联系测试之用，如此即可快速创建多个测试环境。</p>
]]></content>
      <categories>
        <category>linux学习</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 磁盘与分区</title>
    <url>/2021/03/15/linux/linux2-disk/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文介绍与磁盘分区相关的两种分区格式 —— MBR 和 GPT。</p>
<a id="more"></a>

<p>在介绍磁盘分区之前，简要说明各硬件设备在 Linux 系统中的表现形式以及分区的原因。</p>
<p>因为 Linux 的哲学思想为 “一切皆文件”，故而各硬件设备在 Linux 系统中的表现形式也为文件，其集中存放于 <code>/dev</code> 目录之下。例如：对于 STAT 接口的硬盘设备而言，其对应文件名称为 <code>/dev/sd[a-d]</code>，硬盘设备若存在分区，则分区对应的文件名称为 <code>/dev/sd[a-d][number]</code>。</p>
<p>使用分区的原因需要结合系统挂载来谈。系统挂载就是将某磁盘分区挂载至系统某目录之下，如此操作之后，该目录内容均会位于此磁盘分区之中，且目录内容不会影响其他磁盘分区中的数据。总结而言，磁盘分区具有如下优点：</p>
<ol>
<li>充分利用磁盘空间。如果将整颗大磁盘挂载于某小型目录之下，该磁盘空间将会大大浪费。</li>
<li>提升数据读取效率。将目录内容放置于磁盘分区之内，有助于集中放置数据，从而加快磁臂搜索。</li>
<li>保护分区数据安全。进行磁盘分区之后，如果系统需要重装，那么只会影响存放系统核心所在分区，其余分区数据不受任何影响。另外，分区数据读取越频繁，磁盘越容易出故障，因此进行磁盘分区之后，可将磁盘故障集中于某一区域，从而保证其余区域安全。</li>
</ol>
<blockquote>
<p>对于磁盘构成要素而言，指出几个简单概念：扇区 (存在两种规格，512 Byte 和 4 KB。为向下兼容，4 KB  扇区通常会进一步划分为 8 个 512 Byte 的逻辑扇区。因此下面叙述之中，扇区规格均为 512 Byte)、磁道、柱面、磁头、磁臂、主轴马达。</p>
<p>在整颗磁盘的所有扇区之中，1 号扇区十分重要，其中存放整颗磁盘的重要信息 (包括分区信息)。</p>
</blockquote>
<h2 id="MBR"><a href="#MBR" class="headerlink" title="MBR"></a>MBR</h2><p>对于 MBR 分区格式而言，1 号扇区之中存放三种信息：</p>
<ul>
<li>MBR：存放开机管理程序，即 Boot Loader，共计 446 Byte。</li>
<li>分区表：存放磁盘分区信息，共计 64 Byte。</li>
<li>记录签名：如果其中内容为 <code>0x55AA</code>，则表明该磁盘可作为启动之用，反之则不可，共计 2 Byte。</li>
</ul>
<p>在此三种信息之中，我们仅关注分区表中的内容。</p>
<p>鉴于每条分区信息需要 16 Byte 空间 (其中 4 Byte 存放起始扇区编号，4  Byte 存放终止扇区编号)，因此分区表内部仅能容纳 4 组分区 (称为<em>主分区</em>)。其分区结构大致如图所示：</p>
<img src="/2021/03/15/linux/linux2-disk/image-20210313111504839.png" width="36%">

<p>为进一步扩大所能容纳的分区数量，可将某一主分区转换为扩展分区，该分区可借助于内部的前几个扇区存储分区信息，以此进一步划分扩展分区，且划分得到的分区被命名为<em>逻辑分区</em>。</p>
<img src="/2021/03/15/linux/linux2-disk/image-20210313112622318.png" width="36%">

<blockquote>
<p>使用 MBR 分区格式划分磁盘时，通常做法为：三个主分区 + 一个扩展分区，扩展分区内部可自由划分逻辑分区。</p>
<p>实际之中，磁盘的第一个扇区和分区内的第一个扇区都会存放开机管理程序。也正是因为这个原因，才会存在多重开机，俗称 <em>多系统电脑</em>。</p>
</blockquote>
<p>对于 MBR 分区格式而言，它具有如下缺点：</p>
<ol>
<li>MBR 分区格式仅支持 2TB 以下的硬盘设备 (起始/终止扇区编号字段 4 字节，每个扇区存放 512 Byte，则 $2^{32} \times 512 Byte = 2^{41} Byte = 2 T$)，无法适应现今超大容量的硬盘设备。</li>
<li>虽扩展分区可使用内部的前几个扇区存储分区信息，但是分区数量仍有较大限制。</li>
</ol>
<h2 id="GPT"><a href="#GPT" class="headerlink" title="GPT"></a>GPT</h2><p>为克服 MBR 分区格式的上述缺点，GPT 分区格式被提出。</p>
<p>相比于 MBR 分区格式而言，它具有如下特点：</p>
<ol>
<li>第一个扇区前半部分同样存储开机管理程序，后半部分存储 GPT 分区格式的标识信息。</li>
<li>第 2 ~ 33 扇区存储分区表信息，与此同时，最后 33 个扇区备份此分区表信息 (解决缺点 2，最大支持 128 个分区)。</li>
<li>对于分区表而言，每个分区条目使用 128 Byte 存储，其中 8 Byte 存放起始扇区编号，8  Byte 存放终止扇区编号 (解决缺点 1，最大支持 8 ZB 的磁盘)。</li>
</ol>
<h2 id="所涉指令"><a href="#所涉指令" class="headerlink" title="所涉指令"></a>所涉指令</h2><p>指令 <code>fdisk</code> 用于设置 MBR 分区格式的磁盘分区，指令 <code>gdisk</code> 用于设置 GPT 分区格式的磁盘分区。</p>
<p>指令 <code>parted</code> 用于查看设备的分区信息。</p>
<p>指令 <code>lsblk</code> 用于查看特定块设备的若干信息。</p>
<p>指令 <code>blkid</code> 用于查看特定块设备的属性信息。</p>
]]></content>
      <categories>
        <category>linux学习</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 系统启动流程</title>
    <url>/2021/03/13/linux/linux1-boot/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Linux 系统启动流程十分复杂，这里仅做一简单说明，以供日后参考之用。</p>
<a id="more"></a>

<blockquote>
<p>为说明方便，我们作如下限定：磁盘采用 MBR 分区格式、Boot Loader 采用 GRUB2、linux 采用 <code>systemd</code> 启动方式。</p>
</blockquote>
<p>Linux 系统启动流程大致可分为如下步骤：</p>
<ol>
<li>BIOS 硬件自检与选择启动顺序</li>
<li>读取 MBR 并加载 Boot Loader </li>
<li>初始化内存盘及加载内核</li>
<li><code>systemd</code> 系统初始化</li>
</ol>
<h2 id="详述"><a href="#详述" class="headerlink" title="详述"></a>详述</h2><p>按下主机电源后，计算机主板开始上电并初始化相关固件，随后启动 CPU 并开始执行 BIOS 程序。</p>
<ol>
<li><p>BIOS 硬件自检与选择启动顺序</p>
<p>为保证系统能够稳定运行，BIOS 首先检查各硬件的基本功能是否正常 (此过程称为硬件自检，即 POST)。如果某些硬件出现问题，计算机主板会报以不同含义的蜂鸣声；反之，BIOS 程序会输出相关硬件信息至屏幕。</p>
<img src="/2021/03/13/linux/linux1-boot/bg2013021503.png" width="50%">

<p>硬件自检完成后，BIOS 将会执行硬件设备中 MBR 内的程序。由于计算机内部往往存在多个硬件设备，因此需要选择启动哪个硬件设备。默认情况下，BIOS 保存一个默认顺序，当然用户也可自行定义硬件设备的顺序。</p>
<img src="/2021/03/13/linux/linux1-boot/bg2013021504.jpg" width="50%">
</li>
<li><p>读取 MBR 并加载 Boot Loader </p>
<p>选定某硬件设备之后，BIOS 会加载 MBR 中的 Boot Loader 至内存，随后 CPU 开始执行其中指令。</p>
<blockquote>
<p>MBR 等概念详见 <a href="/2021/03/15/linux/linux2-disk/" title="Linux 磁盘与分区">Linux 磁盘与分区</a>。</p>
</blockquote>
<p>这里以 GRUB2 说明 Boot Loader 的工作详情。</p>
<p>如果你已知晓 MBR 等概念，那么就会知道：MBR 内部仅有 446 个字节用于存放 Boot Loader。由于 Boot Loader 包含较多功能，因此这点空间根本无法容纳其实现代码。</p>
<p>为容纳其实现代码，GRUB2 这样操作： MBR 内部的 Boot Loader 代码用于定位和加载另外一处位置的代码，而该部分代码为 Boot Loader 的实际实现代码。</p>
<p>在该实际实现代码所在空间内，其中还会存放一些通用的文件系统驱动程序。借助于这些驱动程序，Boot Loader 可加载 <code>/boot</code> 目录之中的 <code>initrd</code> 和 <code>vmlinuz</code> 文件 (<code>vmlinuz</code> 为 Linux 核心文件)。</p>
<blockquote>
<p>注意：<code>/boot</code> 目录所在的文件系统必须要为 GRUB2 所支持，否则无法存取这两个文件。</p>
</blockquote>
</li>
<li><p>初始化内存盘并加载内核</p>
<p>在此先行说明加载 <code>initrd</code> 文件的原因。</p>
<p>为方便开发商和核心功能开发者，Linux 核心允许动态载入核心模块 (它们位于 <code>/lib/modules</code> 目录之下)；并且实际之中，USB 等磁盘设备的驱动程序都是作为核心模块存在于 Linux 系统之中的 (如此可大大降低 Linux 核心的大小)。为使用这些核心模块所提供的功能，Linux 核心便需要挂载根目录，并载入核心模块。由于 Linux 核心内部并不存在相关磁盘设备的驱动程序，那么它就无法识别并挂载根目录。为解决这一问题，我们需要求助于 <code>initrd</code> 文件。</p>
<blockquote>
<p>如果 Linux 核心内部包含相关磁盘设备的驱动程序，则其无需使用 <code>initrd</code> 文件。</p>
</blockquote>
<p><code>initrd</code> 全称为 <code>Initial RAM Disk</code>。当该文件被加载至内存后，它会被解压缩并仿真成为一个小型根目录文件系统，且该系统之中内含与磁盘相关度较高的设备驱动程序。借助于这些驱动程序，便可为 Linux 核心挂载根目录。</p>
<p>Linux 核心成功挂载根目录后，它会执行一系列任务，包括测试并驱动周边设备、重新侦测硬件、释放小型根目录文件系统等，如此便成功构建硬件环境。</p>
</li>
<li><p><code>systemd</code> 系统初始化</p>
<p>构建完成硬件环境后，Linux 核心开始构建软件环境，它会调用第一支程序 <code>systemd</code>，并为其分配 PID = 1。</p>
<p>根据系统的配置文件，Linux 核心会执行指定的服务集 (见 <code>*.target</code> 文件，这些服务提供 Linux 的基础功能)，从而完成软件环境的建立。在此软件环境建立过程中，Linux 核心主要完成如下工作：挂载文件系统及相关的内存交换空间、载入核心模块、载入网络服务、载入图形化界面等。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>linux学习</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker Machine 介绍</title>
    <url>/2021/02/19/docker/docker6-machine/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在介绍 Docker Swarm 之前，先行介绍 Docker Machine —— 用于在本地平台或云平台之上快速安装 Docker 宿主机 (即带有 Docker Engine 的宿主机)，并使用 <code>docker-machine</code> 管理这些宿主机。</p>
<a id="more"></a>

<blockquote>
<p>官网显示：Docker Machine 属于被取代的产品。在此介绍它，希望能够快速构建 Docker 环境，从而为后续的 Docker Swarm 做铺垫。</p>
</blockquote>
<h2 id="Docker-Machine"><a href="#Docker-Machine" class="headerlink" title="Docker Machine"></a>Docker Machine</h2><p>Docker Machine 借助于命令 <code>docker-machine</code> 完成各种操作，具体包括：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Usage: docker-machine [OPTIONS] COMMAND [arg...]</span><br><span class="line"></span><br><span class="line">Create and manage machines running Docker.</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line"><span class="meta">  #</span><span class="bash"> 查看 docker-machine 所管理的全部宿主机</span></span><br><span class="line">  ls			List machines</span><br><span class="line"><span class="meta">  #</span><span class="bash"> 查看哪台宿主机处于活动状态(当前主机的环境变量 DOCKER_HOST 指向某个宿主机，则该宿主机处于活动状态)</span></span><br><span class="line">  active		Print which machine is active</span><br><span class="line"><span class="meta">  #</span><span class="bash"> 查看特定宿主机的 SSH 连接配置信息(主要包括 CA、Cert、key、IP+端口)</span></span><br><span class="line">  config		Print the connection config for machine</span><br><span class="line"><span class="meta">  #</span><span class="bash"> 查看特定宿主机的 IP 地址</span></span><br><span class="line">  ip			Get the IP address of a machine</span><br><span class="line"><span class="meta">  #</span><span class="bash"> 查看特定宿主机的详细信息</span></span><br><span class="line">  inspect		Inspect information about a machine</span><br><span class="line"><span class="meta">  #</span><span class="bash"> 查看特定宿主机的 URL</span></span><br><span class="line">  url			Get the URL of a machine</span><br><span class="line"><span class="meta">  #</span><span class="bash"> 查看特定宿主机的状态</span></span><br><span class="line">  status		Get the status of a machine</span><br><span class="line"><span class="meta">  #</span><span class="bash"> 显示相关命令用于设置 Docker Client 的指向(命令指向完成后，当前 Client 将指向特定宿主机)</span></span><br><span class="line">  env			Display the commands to set up the environment for the Docker client</span><br><span class="line">  </span><br><span class="line"><span class="meta">  #</span><span class="bash"> 创建一个 Docker 宿主机</span></span><br><span class="line">  create		Create a machine</span><br><span class="line"><span class="meta">  #</span><span class="bash"> 启动\停止\杀死\重启\移除一个宿主机</span></span><br><span class="line">  start			Start a machine</span><br><span class="line">  stop			Stop a machine</span><br><span class="line">  kill			Kill a machine</span><br><span class="line">  restart		Restart a machine</span><br><span class="line">  rm			Remove a machine</span><br><span class="line"><span class="meta">  #</span><span class="bash"> SSH 远程登录特定宿主机</span></span><br><span class="line">  ssh			Log into or run a command on a machine with SSH.</span><br><span class="line"><span class="meta">  #</span><span class="bash"> 宿主机之间拷贝文件</span></span><br><span class="line">  scp			Copy files between machines</span><br><span class="line"><span class="meta">  #</span><span class="bash"> 挂载目录至特定宿主机</span></span><br><span class="line">  mount			Mount or unmount a directory from a machine with SSHFS.</span><br><span class="line">  </span><br><span class="line"><span class="meta">  #</span><span class="bash"> 重置特定宿主机</span></span><br><span class="line">  provision		Re-provision existing machines</span><br><span class="line"><span class="meta">  #</span><span class="bash"> 为特定宿主机重新生成证书</span></span><br><span class="line">  regenerate-certs	Regenerate TLS Certificates for a machine</span><br><span class="line"><span class="meta">  #</span><span class="bash"> 升级特定宿主机的 Docker 版本</span></span><br><span class="line">  upgrade		Upgrade a machine to the latest version of Docker</span><br></pre></td></tr></table></figure>
<p>在此，我们着重介绍 <code>env</code> 和 <code>create</code> 命令。</p>
<ul>
<li><p><code>env</code></p>
<p>使用该命令后，将得到如下类似输出结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export DOCKER_TLS_VERIFY=&quot;1&quot;</span><br><span class="line">export DOCKER_HOST=&quot;tcp://192.168.99.100:2376&quot;</span><br><span class="line">export DOCKER_CERT_PATH=&quot;/home/hhd/.docker/machine/machines/1-machine&quot;</span><br><span class="line">export DOCKER_MACHINE_NAME=&quot;1-machine&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> Run this <span class="built_in">command</span> to configure your shell:</span> </span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">eval</span> $(docker-machine env 1-machine)</span></span><br></pre></td></tr></table></figure>
<p>当执行命令 <code>eval $(docker-machine env 1-machine)</code> 后，当前主机的 Docker Client 就会与 1-machine 中的 Docker Server 进行通信，也就是说，这条命令设置了当前主机的 Docker Client 的通信对象。</p>
<p>如果想切换当前主机的 Docker Client 的通信对象为本地 Docker Server，只需执行命令 <code>eval $(docker-machine env -u)</code> 即可。</p>
<p>另说一句，<code>docker context</code> 是专门用于配置、切换 Docker Client 指向的命令。</p>
</li>
<li><p><code>create</code></p>
<p>该命令用于创建一个 Docker 宿主机，因此其中必然涉及多种参数的配置。</p>
<p>我们在此仅说明若干重要参数：</p>
<p><code>--driver</code>  –&gt;  指定创建宿主机所用的驱动程序，常见为 virtualbox。</p>
<p><code>--virtualbox-hostonly-cidr</code>  –&gt;  指定宿主机的 IP 地址。</p>
<p><code>--virtualbox-memory</code>  –&gt;  指定宿主机的内存限制</p>
<p><code>--virtualbox-disk-size</code>  –&gt;  指定宿主机的磁盘限制</p>
</li>
</ul>
]]></content>
      <categories>
        <category>docker学习</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker Swarm 介绍</title>
    <url>/2021/02/19/docker/docker7-swarm/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2>]]></content>
      <categories>
        <category>docker学习</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么“贸易能使人人受益”？</title>
    <url>/2021/02/17/sundry/economics-trade/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文使用例子解释经济学原理中的第五大原理 ——“贸易能使人人受益”。</p>
<a id="more"></a>

<h2 id="详述"><a href="#详述" class="headerlink" title="详述"></a>详述</h2><p>为解释该原理，我们只需回答如下问题即可：</p>
<ol>
<li>在贸易之中，用户如何决定何种物品？</li>
<li>产品生产完后，如何保证贸易顺利完成？</li>
<li>相比于自给自足，贸易对于总产出有什么影响？</li>
</ol>
<p>在下面这个例子中，我们贯穿回答这三个问题。</p>
<p>假定存在两人 —— 张三和李四，它们均半天捕鱼、半天砍柴，以此过着自给自足的田园生活。两人生产情况如下：</p>
<p><img src="/2021/02/17/sundry/economics-trade/image-20210217125309543.png"></p>
<p>此时，张三每日产量为：5 斤柴 + 12.5 斤鱼，李四每日产量为：2.5 斤柴 + 25 斤鱼。</p>
<p>根据日产量可以看到，张三善于砍柴，而李四善于捕鱼，那么就可这样设想：张三整日砍柴而李四整日捕鱼，然后两人交换所得物品。</p>
<blockquote>
<p>这里使用另一种解释说明二人分工情况。</p>
<p><strong>比较优势</strong>：如果某人生产某产品的机会成本更小，则称其具有生产该产品的比较优势。</p>
<p>按照比较优势的定义，每个人都应当生产具有比较优势的产品。在该例子中，张三生产 1 斤柴的机会成本为 2.5 斤鱼，而李四生产 1 斤柴的机会成本为 10 斤鱼，故而张三具有生产柴的比较优势，因此张三应该专注于生产柴；同理可得李四应该专注于生产鱼。</p>
</blockquote>
<p>此时，张三每日产量为：10 斤柴，李四每日产量为：50 斤鱼。</p>
<p>为达到之前生产情况，张三愿意使用 5 斤柴兑换 12.5 斤鱼 (即 1 斤柴 = 2.5 斤鱼)，李四则愿意使用 25斤鱼兑换 2.5 斤柴 (即 1 斤柴 = 10 斤鱼)。可以看到：这里完全存在交换空间，因此贸易一定可以顺利完成。</p>
<p>假定双方各自交换产出的一般，则此时，张三每日产量为：5 斤柴 + 25 斤鱼，李四每日产量为：5 斤柴 + 25 斤鱼。</p>
<p>可以看到：贸易使得双方变得更好，而且使得总产出更多 (未实行贸易前，共计产出 7.5 斤柴 + 37.5 斤鱼，实行贸易后，共计产出 10 斤柴 + 50 斤鱼)。</p>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
  </entry>
  <entry>
    <title>经济学原理总结——宏观部分</title>
    <url>/2021/02/16/sundry/economics-principleMacro/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文为视频 <a href="https://www.bilibili.com/video/BV1bK4y1576z">经济学原理 (全77讲)</a> 的观后总结，以便后续查看、回忆经济学宏观部分相关知识。</p>
<a id="more"></a>

<p>首先给出贯穿整个经济学的十大原理，它们依次回答下列问题：人们如何做出决策 (前 4 个原理)、人们如何相互作用 (中 3 个原理)、整体经济如何运行 (后 3 个原理)：</p>
<ol>
<li>人们面临得失交换 (People face tradeoffs)。</li>
<li>某物的成本是为此所放弃的东西 (The cost of something is what you give up to get it)。</li>
<li>理性人思考边际量 (Rational people think at the margin)。</li>
<li>人们会对激励做出反应 (People respond to incentives)。</li>
<li>贸易能使人人受益 (Trade can make everyone better off)。</li>
<li>市场通常是组织经济活动的好方式 (Markets are usually a good way to organize economic activity)。</li>
<li>政府有时可以改进市场结果 (Governments can sometimes improve markets outcomes)。</li>
<li>一国的生活水平取决于它的生产 (The standard of living deponds on a country’s production)。</li>
<li>当政府发行过多货币时，物价上涨 (Prices rise when the government prints too much money)。</li>
<li>社会面临通货膨胀和失业之间的短期得失交换 (Society faces a short-run tradeoffs between inflation and unemployment)。</li>
</ol>
<h2 id="一国收入的衡量"><a href="#一国收入的衡量" class="headerlink" title="一国收入的衡量"></a>一国收入的衡量</h2><p>这一部分介绍若干指标以衡量一国的经济水平。</p>
<p><strong><em>国内生产总值 (Gross Domestic Product)</em></strong>：一定时期，一国范围内生产的所有最终物品和服务的总价值 (以市场价格评估)。</p>
<blockquote>
<p>此种 GDP 属于 <em>名义 GDP</em>，另有 <em>实际 GDP</em>，它以各种物品的某一不变价格评估。</p>
<p>假定以 2001 年商品价格为基准，计算 2001,2002 年的实际 GDP，记为 A,B。那么 B/A 一定程度上可以表征通货膨胀。</p>
</blockquote>
<p>借用循环流向图 (假定不存在进出口，不存在政府行为)，可知 GDP 等价于所有企业的增加值收益之和 (称为产业法)、所有家庭的支出之和 (称为支出法)、所有企业的工资租金支付与利润所得之和 (称为收入法)、所有家庭的收入之和 (称为收入法)。</p>
<blockquote>
<p>GDP 等价于所有企业的增加值收益之和，而非所有企业的收益之和，其原因在于：收益 = 增加值 + 原材料支出，如果计算所有企业的收益，由于原材料支出必定属于其他企业的收益，因此最终结果会存在重复计算部分企业收益的情况。</p>
</blockquote>
<img src="/2021/02/16/sundry/economics-principleMacro/nnpqmwhfsy.jpeg" width="50%">

<p>产业法、支出法、收入法是计算 GDP 的三种常见方法。由于企业增加值收益易于统计，因此该种方法最常使用。</p>
<p><strong><em>国内生产净值 (Net Domestic Product)</em></strong>：GDP - 固定资产的折旧损耗。</p>
<p><strong><em>国民生产总值 (Gross National Product)</em></strong>：一定时期、一国永久居民所获得的收入之和。</p>
<p>相比于 GDP 而言，其剔除外国人所获收入，加入本国人所获的国外收入。</p>
<p><strong><em>国民生产净值 (Net National Product)</em></strong>：GNP - 固定资产的折旧损耗。</p>
<p><strong><em>国民收入 (National Income)</em></strong>：等价于 NNP。</p>
<p><strong><em>通货膨胀 (Inflation)</em></strong>： 指代经济价格总水平上升的情况。</p>
<p><strong><em>消费者价格指数 (Consumer Price Index)</em></strong>：一个普通消费者购买的商品和服务的总费用。</p>
<p>该指数计算比较简单，首先确定需要统计哪些商品 (这些商品对普通消费者而言属于常见消费商品，依靠消费者调查得到)，随后得到现阶段各商品的价格和，最后以此结果除以某基准年的各商品价格和即可。</p>
<p><strong><em>通货膨胀率 (Inflation Rate)</em></strong>：衡量通货膨胀情况，其计算公式为 (当年 CPI - 上年 CPI) / 上年 CPI。</p>
<h2 id="生产与增长"><a href="#生产与增长" class="headerlink" title="生产与增长"></a>生产与增长</h2><p>根据原理 6 可知，生产决定一国的生活水平。为提高一国的生活水平，就需要研究生产的决定因素。</p>
<p><strong>生产率</strong>：一个工人在一小时的劳动时间内能够生产的物品和服务的数量。</p>
<p>生产要素 (指代用以生产物品和服务的投入) 直接决定生产率。就宏观经济而言，其具体指代：物质资本、人力资本、自然资源、技术知识。</p>
<p>更进一步，经济学提出 <em>生产函数</em>，它描述生产投入数量与生产产出数量之间的关系，即产出数量 = 可得到的生产技术 * F(劳动量，物质资本量，人力资本量，自然资源)。</p>
<p>鉴于生产函数所表征的关系，政府可执行以下政策以提高其生活水平：</p>
<ol>
<li><p>鼓励储蓄和投资 / 鼓励来自国外的投资 </p>
<p>如此操作，更多的资金才能流入公司。公司借此购置生产设备等要素，从而变相增大生产函数中的物质资本量，最终使得产出数量增大。</p>
</li>
<li><p>促进教育 / 促进健康</p>
<p>如此操作，才能提升个人素质，从而变相增大生产函数中的人力资本量，最终使得产出数量增大。</p>
</li>
<li><p>建立产权保障 / 促进研究开发</p>
<p>如此操作，可以促进技术革新，从而变相增大生产函数中的可得到的生产技术，最终使得产出数量增大。</p>
</li>
<li><p>控制人口增长 </p>
<p>如此操作，虽然会减少劳动量，但是会变相增大生产函数中的人力资本量，最终使得产出数量增大。</p>
</li>
<li><p>允许自由贸易 / 保持政治稳定</p>
<p>这些政策虽不直接影响生产要素，但是仍会间接产生其他积极影响 (例如，吸引国外投资)。</p>
</li>
</ol>
<h2 id="失业"><a href="#失业" class="headerlink" title="失业"></a>失业</h2><blockquote>
<p>失业同样会影响一国的生活水平，因为失业致使劳动量下降，从而使得生产函数中的产出数量减小。</p>
</blockquote>
<p>根据时间长短，失业可分为：短期失业 (或称周期性失业) 和长期失业 (或称自然失业)。</p>
<p>首先给出失业率的计算过程：</p>
<ol>
<li>随机选择若干家庭进行调查</li>
<li>基于调查结果，将所调查的成年人归纳为如下几类：就业者 (指代最近一段时间内从事有报酬工作的人)、失业者 (指代暂时没有工作、但是正在寻找工作的人)、非劳动力 (指代不属于前两类的成年人)。</li>
<li>计算如下指标：劳动力 = 就业者 + 失业者、失业率 = 失业者 / 劳动力、劳动力参工率 = 劳动力 / (劳动力 + 非劳动力)。</li>
</ol>
<p>接下来，给出一些原因以解释失业现象：</p>
<ul>
<li><p>摩擦性失业</p>
<p>具体指代因工人与工作相匹配的过程而引发的失业，也就是说：工人寻找合适工作是需要时间的。</p>
</li>
<li><p>结构性失业</p>
<p>具体指代因实际工资高于均衡工资，致使劳动力供给数量超出需求数量而引发的失业。使得该种现象发生的可能原因有：最低工资限制、工会要求提供员工福利、公司以高薪养员工。</p>
</li>
</ul>
<h2 id="货币与通货膨胀"><a href="#货币与通货膨胀" class="headerlink" title="货币与通货膨胀"></a>货币与通货膨胀</h2><p>这部分首先介绍货币，随后介绍中央人民银行与商业银行的作用，最后说明通货膨胀的原因。</p>
<p>根据政治所知，货币就是商品交换中的一般等价物。</p>
<p>现实生活中，货币分为两种：<strong>商品货币</strong> (以具有内在价值的商品作为货币，例如：金银)、<strong>法定/信用货币</strong> (因政府法令而被使用的货币，例如：硬币、纸币)。</p>
<blockquote>
<p> 下面这部分内容所述货币均为法定/信用货币。</p>
</blockquote>
<p><strong>货币供给</strong>：经济中可得的货币数量。</p>
<p>众所周知，商业银行主要存在两项业务：存取款 (用户可存入货币至该银行中，也可从中取出已存入的货币)、借贷 (将部分用户存入的货币借与其他用户)。</p>
<p>首先定义概念 <em>准备金</em>：银行吸收但没有贷出的存款。我们以例子说明结论：“<strong>假定商业银行仅实施存取款业务，那么银行一定不会影响货币供给；然而假定商业银行既实施存取款业务，也实施借贷业务，那么银行就会影响货币供给</strong>”。</p>
<p>第一种情况所对应的结论显而易见，我们仅说明第二种情况。假定 A 向商业银行中存入 100 元，随后商业银行向 B 借贷 90 元，那么此时经济中可得的货币数量就应当为 100 + 90 = 190 (注意：A 仍可随时取出 100 元，商业银行存在一定制度保证这件事)，这样就增加了货币供给。</p>
<blockquote>
<p>实际之中，为保证用户可以顺利存取，商业银行会被规定准备金率，准备金以外的存款可用于贷款。</p>
<p>假定用户向商业银行 A 存入 1 元，A 向其他用户借贷，其他用户又存入其他商业银行，商业银行再次借贷，…。如此行事，因为商业银行的借贷行为，最初的 1 元就会被扩充为若干元。经济学中，使用 <em>货币乘数</em> 描述这一行为。</p>
<p>货币乘数：相对于每 1 美元的央行发行货币，商业银行系统所创造的货币数量。该值等于 1 / 准备金率。</p>
</blockquote>
<p>为防止商业银行乱来以及保证国计民生，中央人民银行被建立，其负责两项重要职能：监管银行体系、调节经济中的货币数量。</p>
<p>中央人民银行调整经济中的货币数量主要通过两种方式：</p>
<ol>
<li>通过发放或收购债券，直接调整经济中的货币数量。</li>
<li>通过调整存款利率、准备金利率、向银行发放贷款等行为，影响商业银行的借贷业务，从而间接调整货币供给数量，以调整经济中的货币数量。</li>
</ol>
<blockquote>
<p>如果中央人民银行没有足够货币收购债券或者向银行发放贷款，它就可能会印钞。</p>
</blockquote>
<p><strong>通货膨胀</strong>：指代总体价格水平上升的情况，也可理解为货币价值降低。</p>
<p>经济学存在一个结论：货币供给增多，导致通货膨胀。</p>
<p>我们同样使用供需理论说明这个结论。</p>
<p>货币需求就是市场中所需的货币数量，它由使用者决定，如果货币价值低，则所需数量多，反之则所需数量少；货币供给就是市场中的供给数量，它由中央人民银行决定，短期来看，供给数量不会发生变动。</p>
<p>假定其他条件不变，中央人民银行向每个人发放货币以增大货币供给量 (现实之中，并不会采取这种方式，这里只是方便解释)，那么每个人手中就会有更多的货币，它们就有更多的消费需求。由于商品数量不发生变化，从而引发供小于求，这必将导致商品价格上升。</p>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
  </entry>
  <entry>
    <title>Docker Compose 介绍</title>
    <url>/2021/02/14/docker/docker5-compose/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>到目前为止，我们可以很方便地运行一个容器。如果需要运行由多个容器组成的应用，直接使用 <code>docker run</code> 命令就会显得十分繁琐。为此，Docker 提供 <code>docker compose</code> 命令行工具以简化多容器应用运行流程。</p>
<a id="more"></a>

<p><code>docker compose</code> 的使用方式十分简单，分三步即可：定义 Dockerfile 文件、定义 docker-compose.yml 文件、使用 <code>docker-compose</code> 命令运行。</p>
<p>Dockerfile 文件已介绍于 <a href="/2021/02/08/docker/docker4-dockerfile/" title="Dockerfile 文件介绍">Dockerfile 文件介绍</a> 之中，这篇文章主要介绍 docker-compose.yml 文件和 <code>docker-compse</code> 命令。</p>
<h2 id="compose-文件"><a href="#compose-文件" class="headerlink" title="compose 文件"></a>compose 文件</h2><p>在 <code>docker compose</code> 之中，两个概念需要先行解释：</p>
<ul>
<li>服务 (service)：运行相同镜像的若干容器实例，例如：redis 服务、mysql 服务。</li>
<li>项目 (project)：由一组关联服务组成的完整业务单元。</li>
</ul>
<p>docker-compose.yml 文件就是一个项目，其中定义着该项目的具体组织结构。</p>
<p>docker-compose.yml 的典型结构如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指明 compose 文件版本号</span></span><br><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.9&quot;</span></span><br><span class="line"><span class="comment"># 定义该项目所涉的各种服务</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">	<span class="string">...</span></span><br><span class="line">	</span><br><span class="line"><span class="comment"># 定义项目所涉及的数据卷</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">	<span class="string">...</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义项目所涉及的网络</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">	<span class="string">...</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义项目所涉及的配置信息</span></span><br><span class="line"><span class="attr">configs:</span></span><br><span class="line">	<span class="string">...</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义项目所涉及的秘密信息</span></span><br><span class="line"><span class="attr">secrets:</span></span><br><span class="line">	<span class="string">...</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>按照目前理解，<code>configs</code> 和 <code>secrets</code> 与 <code>bind mount</code> 没什么区别，就是再次封装而已。</p>
</blockquote>
<p>接下来，我们将一一详述各部分。</p>
<h3 id="services"><a href="#services" class="headerlink" title="services"></a>services</h3><p>services 部分的典型结构如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">	<span class="comment"># 某单个服务</span></span><br><span class="line">	<span class="comment"># webapp 为服务名</span></span><br><span class="line">	<span class="attr">webapp:</span></span><br><span class="line">		<span class="comment"># 服务所对应镜像的若干配置信息</span></span><br><span class="line">		<span class="attr">build:</span></span><br><span class="line">			<span class="comment"># 指明该镜像的来源，其值为 Dockerfile 所在目录的路径或者为注册服务器上的仓库名</span></span><br><span class="line">			<span class="attr">context:</span> <span class="string">./dir</span></span><br><span class="line">			<span class="comment"># 若 context 内容为前者，则此处指明 Dockerfile 文件名，默认为 Dockerfile</span></span><br><span class="line">			<span class="attr">dockerfile:</span> <span class="string">Dockerfile-alternate</span></span><br><span class="line">			<span class="comment"># 对应 Dockerfile 中基于 ARG 指令定义的变量，这里为赋初值。</span></span><br><span class="line">			<span class="attr">args:</span></span><br><span class="line">				<span class="attr">buildno:</span> <span class="number">1</span></span><br><span class="line">			<span class="comment"># 指明基于 Dockerfile 制作镜像时的缓存来源</span></span><br><span class="line">			<span class="attr">cache_from:</span></span><br><span class="line">				<span class="bullet">-</span> <span class="string">alpine:latest</span></span><br><span class="line">			<span class="comment"># 向镜像中添加元数据，与 Dockerfile 中 LABEL 指令作用相同，</span></span><br><span class="line">			<span class="attr">labels:</span></span><br><span class="line">				<span class="bullet">-</span> <span class="string">&quot;com.example.name&quot;</span><span class="string">:&quot;hhd&quot;</span></span><br><span class="line">			<span class="comment"># 设置容器实例运行时所处的网络</span></span><br><span class="line">			<span class="attr">network:</span> <span class="string">host</span></span><br><span class="line">			<span class="comment"># 设置容器实例运行时，目录 /dev/shm 大小</span></span><br><span class="line">			<span class="attr">shm_size:</span> <span class="string">&#x27;2gb&#x27;</span></span><br><span class="line">			<span class="comment"># 当 Dockerfile 采用 multi-stage 时，设置指定 stage，使得 Dockerfile 的构建过程停止于此 stage</span></span><br><span class="line">			<span class="attr">target:</span> <span class="string">prod</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment"># 与 build 连用，命名根据 Dockerfile 构建得到的镜像，否则会默认生成镜像名和标签</span></span><br><span class="line">		<span class="comment"># 如果单独使用 image，其表示所使用的镜像来源</span></span><br><span class="line">		<span class="attr">image:</span> <span class="string">webapp:tag</span></span><br><span class="line">			</span><br><span class="line">		<span class="comment"># 添加或移除容器实例功能(基本不使用)</span></span><br><span class="line">		<span class="attr">cap_add:</span></span><br><span class="line">			<span class="bullet">-</span> <span class="string">ALL</span></span><br><span class="line">		<span class="attr">cap_drop:</span></span><br><span class="line">			<span class="bullet">-</span> <span class="string">NET_ADMIN</span></span><br><span class="line">		<span class="comment"># 为容器实例指定父cgroup</span></span><br><span class="line">		<span class="attr">cgroup_parent:</span> <span class="string">m-executor-abcd</span></span><br><span class="line">		<span class="comment"># 设置 PID(与操作系统相关，暂时忽略)</span></span><br><span class="line">		<span class="attr">pid:</span> <span class="string">&#x27;host&#x27;</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment"># 授予当前服务对相关配置的访问权限(配置需已定义于 configs 之中)</span></span><br><span class="line">		<span class="comment"># 短语法形式</span></span><br><span class="line">		<span class="attr">configs:</span></span><br><span class="line">			<span class="bullet">-</span> <span class="string">my_config</span></span><br><span class="line">		<span class="comment"># 长语法形式(分别指明源配置、容器实例中的目标位置，默认为 /&lt;source&gt;、用户id、组id、配置的访问权限)</span></span><br><span class="line">		<span class="attr">configs:</span></span><br><span class="line">			<span class="bullet">-</span> <span class="attr">source:</span> <span class="string">my_config</span></span><br><span class="line">			  <span class="attr">target:</span> <span class="string">/usr_config</span></span><br><span class="line">			  <span class="attr">uid:</span></span><br><span class="line">			  <span class="attr">gid:</span></span><br><span class="line">			  <span class="attr">mode:</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment"># 授予当前服务对相关秘密的访问权限(配置需已定义于 secrets 之中)</span></span><br><span class="line">		<span class="comment"># 短语法形式</span></span><br><span class="line">		<span class="attr">secrets:</span></span><br><span class="line">			<span class="bullet">-</span> <span class="string">my_secret</span></span><br><span class="line">		<span class="comment"># 长语法形式(分别指明源配置、容器实例中的目标位置，默认为 /run/secrets/&lt;source&gt;、用户id、组id、配置的访问权限)</span></span><br><span class="line">		<span class="attr">configs:</span></span><br><span class="line">			<span class="bullet">-</span> <span class="attr">source:</span> <span class="string">my_secret</span></span><br><span class="line">			  <span class="attr">target:</span> <span class="string">/usr_secret</span></span><br><span class="line">			  <span class="attr">uid:</span></span><br><span class="line">			  <span class="attr">gid:</span></span><br><span class="line">			  <span class="attr">mode:</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment"># 设置服务对应的容器实例名称</span></span><br><span class="line">		<span class="attr">container_name:</span> <span class="string">my_web_container</span></span><br><span class="line">		<span class="comment"># 设置设备映射列表</span></span><br><span class="line">		<span class="attr">devices:</span></span><br><span class="line">			<span class="bullet">-</span> <span class="string">&#x27;/dev/ttyUSB0:/dev/ttyUSB0&#x27;</span></span><br><span class="line">		<span class="comment"># 自定义 DNS 服务列表</span></span><br><span class="line">		<span class="attr">dns:</span></span><br><span class="line">			<span class="bullet">-</span> <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span></span><br><span class="line">		<span class="comment"># 自定义 DNS 搜索域</span></span><br><span class="line">		<span class="attr">dns_search:</span></span><br><span class="line">			<span class="bullet">-</span> <span class="string">example.com</span></span><br><span class="line">		<span class="comment"># 覆盖 ENTRYPOINT 指令所实施的默认操作</span></span><br><span class="line">		<span class="attr">entrypoint:</span> [<span class="string">&#x27;php&#x27;</span>,<span class="string">&#x27;-d&#x27;</span>]</span><br><span class="line">		<span class="comment"># 覆盖 CMD 指令所实施的默认操作</span></span><br><span class="line">		<span class="attr">command:</span> <span class="string">echo</span> <span class="string">&quot;hello&quot;</span></span><br><span class="line">        <span class="comment"># 从文件中添加容器实例的环境变量</span></span><br><span class="line">        <span class="attr">env_file:</span></span><br><span class="line">        	<span class="bullet">-</span> <span class="string">./common_env</span></span><br><span class="line">        <span class="comment"># 直接添加环境变量</span></span><br><span class="line">        <span class="attr">environment:</span></span><br><span class="line">        	<span class="bullet">-</span> <span class="string">SHOW=true</span></span><br><span class="line">        <span class="comment"># 公布服务所对应镜像的内部端口</span></span><br><span class="line">        <span class="attr">expose:</span></span><br><span class="line">        	<span class="bullet">-</span> <span class="string">&#x27;8000&#x27;</span></span><br><span class="line">        <span class="comment"># 配置端口映射信息</span></span><br><span class="line">        <span class="comment"># 短语法形式(两种形式，一种主机端口:容器端口,另一种容器端口)</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        	<span class="bullet">-</span> <span class="string">&#x27;3251:80&#x27;</span></span><br><span class="line">        <span class="comment"># 长语法形式(具体包括容器端口、主机端口、所用协议、..)</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        	<span class="bullet">-</span> <span class="attr">target:</span> <span class="number">80</span></span><br><span class="line">        	  <span class="attr">published:</span> <span class="number">3251</span></span><br><span class="line">        	  <span class="attr">protocol:</span> <span class="string">tcp</span></span><br><span class="line">        	  <span class="attr">mode:</span> <span class="string">host</span>   </span><br><span class="line">        <span class="comment"># 指明当前容器链接至哪些容器，与 docker run 命令的 --link 参数作用一样</span></span><br><span class="line">        <span class="attr">links:</span> </span><br><span class="line">        <span class="comment"># 指明当前容器链接至哪些外部容器，与 docker run 命令的 --link 参数作用一样</span></span><br><span class="line">        <span class="attr">external_links:</span></span><br><span class="line">        	<span class="comment"># (链接容器名：定义的别名)</span></span><br><span class="line">        	<span class="bullet">-</span> <span class="string">project_db_1:mysql</span></span><br><span class="line">		<span class="comment"># 添加主机名映射信息，与 docker run 命令的 --add-host 参数作用一样</span></span><br><span class="line">		<span class="attr">extra_hosts:</span></span><br><span class="line">			<span class="bullet">-</span> <span class="string">&quot;somehost:165.254.2.2&quot;</span></span><br><span class="line">		<span class="comment"># 配置健康检查操作，与 HEALTHCHECK 指令作用相同。</span></span><br><span class="line">		<span class="attr">healthcheck:</span></span><br><span class="line">		<span class="comment"># 容器实例内部是否运行一个初始化程序(这里涉及操作系统知识，暂时忽略)</span></span><br><span class="line">		<span class="attr">init:</span> <span class="literal">true</span></span><br><span class="line">		<span class="comment"># 指定容器实例采用的隔离技术</span></span><br><span class="line">		<span class="attr">isolation:</span> <span class="string">default</span></span><br><span class="line">		<span class="comment"># 向容器实例中添加元数据</span></span><br><span class="line">		<span class="attr">labels:</span></span><br><span class="line">			<span class="bullet">-</span> <span class="string">&quot;com.example.name&quot;</span><span class="string">:&quot;hhd&quot;</span></span><br><span class="line">		<span class="comment"># 配置服务的日志记录信息(包括日志驱动程序、日志记录地址等信息)</span></span><br><span class="line">		<span class="attr">logging:</span></span><br><span class="line">			<span class="attr">driver:</span> <span class="string">syslog</span></span><br><span class="line">			<span class="attr">options:</span></span><br><span class="line">				<span class="attr">syslog-address:</span> <span class="string">&quot;xxxx&quot;</span></span><br><span class="line">		<span class="comment"># 设置容器实例运行时的网络模式</span></span><br><span class="line">		<span class="attr">network_mode:</span> <span class="string">&#x27;bridge&#x27;</span></span><br><span class="line">		<span class="comment"># 设置容器实例运行时的网络(需已定义于 networks 之中)</span></span><br><span class="line">		<span class="attr">networks:</span></span><br><span class="line">			<span class="bullet">-</span> <span class="string">host</span></span><br><span class="line">				<span class="comment"># 设置当前服务在此网络中的主机别名，以供同一网络内的其他服务调用</span></span><br><span class="line">				<span class="attr">aliases:</span></span><br><span class="line">					<span class="bullet">-</span> <span class="string">aliase1</span></span><br><span class="line">				<span class="comment"># 设置当前服务在此网络中的 IP 地址</span></span><br><span class="line">				<span class="attr">ipv4_address:</span> <span class="number">172.16</span><span class="number">.238</span><span class="number">.10</span></span><br><span class="line">        		<span class="attr">ipv6_address:</span> <span class="number">2001</span><span class="string">:3984:3989::10</span></span><br><span class="line">        <span class="comment"># 为当前服务分配若干profile。默认情况下，执行 docker-compose 命令将启动文件中定义的所有服务</span></span><br><span class="line">        <span class="comment"># 使用 profile 后，如果执行 docker-compose 命令时没有携带参数 `--profile frontend`，则该服务不会被启动</span></span><br><span class="line">        <span class="attr">profile:</span></span><br><span class="line">        	<span class="bullet">-</span> <span class="string">frontend</span></span><br><span class="line">        <span class="comment"># 设置容器实例的重启策略(共有 no\always\no-failure\unless-stopped 四种)</span></span><br><span class="line">        <span class="attr">restart:</span> <span class="literal">no</span></span><br><span class="line">        <span class="comment"># 使用 docker stop 命令停止容器时，它首先发送 SIGTERM 信号至容器，等待一段时间后，再发送 SIGKILL 信号停止容器</span></span><br><span class="line">        <span class="comment"># 该字段便是设置这段时间具体有多长</span></span><br><span class="line">        <span class="attr">stop_grace_period:</span> <span class="string">1s</span></span><br><span class="line">        <span class="comment"># 设置停止容器的信号</span></span><br><span class="line">        <span class="attr">stop_sigal:</span> <span class="string">SIGUSR1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 挂载 tmpfs</span></span><br><span class="line">        <span class="attr">tmpfs:</span></span><br><span class="line">        	<span class="bullet">-</span> <span class="string">/app</span></span><br><span class="line">        <span class="comment"># 数据卷挂载(若希望重用某个命名数据卷，其必须定义于顶层结构的volumes 之中)</span></span><br><span class="line">        <span class="comment"># 短语法(数据卷名称/路径名:容器路径名:mode)</span></span><br><span class="line">        <span class="attr">volumes:</span></span><br><span class="line">        	<span class="bullet">-</span> <span class="string">./cache:/user:ro</span></span><br><span class="line">        <span class="comment"># 长语法(具体包括挂载类型、数据卷名称或路径名、容器路径名、是否只读等)</span></span><br><span class="line">        <span class="attr">volumes:</span></span><br><span class="line">        	<span class="bullet">-</span> <span class="attr">type:</span> <span class="string">volume</span></span><br><span class="line">        	  <span class="attr">source:</span> <span class="string">./cache</span></span><br><span class="line">        	  <span class="attr">target:</span> <span class="string">/user</span></span><br><span class="line">        	  <span class="attr">read_only:</span>	</span><br><span class="line">		</span><br><span class="line">        <span class="comment"># 配置托管服务账号的凭据规范(仅用于 windows 环境，因此忽略)</span></span><br><span class="line">        <span class="attr">credential_spec:</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 指明当前服务的依赖服务(docker 会按照此依赖顺序按序启动服务)</span></span><br><span class="line">        <span class="attr">depends_on:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">redis</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">db</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 与服务运行与部署的相关配置信息(当服务部署于 swarm 时，这些配置信息才会生效，因此忽略)</span></span><br><span class="line">        <span class="attr">deploy:</span></span><br><span class="line">		</span><br><span class="line">        <span class="comment"># 还有一些参数，可以暂时忽略</span></span><br><span class="line">			</span><br><span class="line">	<span class="comment"># 其他服务(与上类似，故而省略)</span></span><br></pre></td></tr></table></figure>
<h3 id="volumes"><a href="#volumes" class="headerlink" title="volumes"></a>volumes</h3><p>若希望重用某个命名数据卷，其必须定义于顶层结构的 volumes 之中。</p>
<p>volumes 部分的典型结构如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">volumes:</span></span><br><span class="line">	<span class="comment"># 定义一个命名数据卷，其余配置采用默认值</span></span><br><span class="line">	<span class="attr">my-volume:</span></span><br><span class="line">	<span class="comment"># 定义另一个命名数据卷，其余配置采用自定义形式</span></span><br><span class="line">    <span class="attr">other-volume:</span></span><br><span class="line">    	<span class="comment"># 配置当前数据卷所用的驱动程序</span></span><br><span class="line">    	<span class="attr">driver:</span> <span class="string">foobar</span></span><br><span class="line">    	<span class="comment"># 以键值对形式向驱动程序传递参数</span></span><br><span class="line">    	<span class="attr">driver-opt:</span></span><br><span class="line">    		<span class="attr">type:</span> <span class="string">&quot;nfs&quot;</span></span><br><span class="line">    	<span class="comment"># 取值为 true，表明已存在此数据卷，则 compose 会查找此数据卷并挂载之；反之 compose 会尝试创建并使用之</span></span><br><span class="line">    	<span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    	<span class="comment"># 为数据卷自定义一个名称</span></span><br><span class="line">    	<span class="attr">name:</span> <span class="string">my-app-volume</span></span><br></pre></td></tr></table></figure>
<h3 id="networks"><a href="#networks" class="headerlink" title="networks"></a>networks</h3><p>networks 部分的典型结构如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">networks:</span></span><br><span class="line">	<span class="comment"># 定义一个网络</span></span><br><span class="line">	<span class="attr">my-network:</span></span><br><span class="line">		<span class="comment"># 指明该网络所用驱动程序</span></span><br><span class="line">		<span class="attr">driver:</span> <span class="string">bridge</span></span><br><span class="line">        <span class="comment"># 以键值对形式向驱动程序传递参数</span></span><br><span class="line">		<span class="attr">driver-opt:</span></span><br><span class="line">			<span class="attr">foo:</span> <span class="string">&quot;bar&quot;</span></span><br><span class="line">		<span class="comment"># 当 driver=overlay 时，此字段才有用</span></span><br><span class="line">		<span class="comment"># 取值为 true，则单个容器和服务均可连接至网络；反之仅服务可连接至网络</span></span><br><span class="line">		<span class="attr">attachable:</span> <span class="literal">true</span></span><br><span class="line">		<span class="comment"># 设置 IP地址管理(IPAM) 的若干配置，包括所用驱动程序，所处网段</span></span><br><span class="line">		<span class="attr">ipam:</span></span><br><span class="line">			<span class="attr">driver:</span> <span class="string">default</span></span><br><span class="line">			<span class="attr">config:</span></span><br><span class="line">				<span class="bullet">-</span> <span class="attr">subnet:</span> <span class="string">&quot;192.168.0.0/16&quot;</span></span><br><span class="line">		<span class="comment"># 取值为 true，表明已存在此网络，则 compose 会直接使用此外部网络；反之 compose 会尝试创建并使用之</span></span><br><span class="line">		<span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">		<span class="comment"># 为网络自定义一个名称</span></span><br><span class="line">    	<span class="attr">name:</span> <span class="string">my-app-network</span></span><br></pre></td></tr></table></figure>
<h3 id="configs-secrets"><a href="#configs-secrets" class="headerlink" title="configs/secrets"></a>configs/secrets</h3><p>configs 与 secrets 的结构一致，其典型结构如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">configs/secrets:</span></span><br><span class="line">	<span class="comment"># 定义一个 config/secret 名称</span></span><br><span class="line">	<span class="attr">my_config:</span></span><br><span class="line">		<span class="comment"># 该 config/secret 对应的文件路径</span></span><br><span class="line">		<span class="attr">file:</span> <span class="string">xxx</span></span><br><span class="line">		<span class="comment"># 取值为 true，表明已存在此 config/secret，则 compose 会直接使用此；反之 compose 会尝试创建并使用之</span></span><br><span class="line">		<span class="attr">external:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h2 id="compose-命令"><a href="#compose-命令" class="headerlink" title="compose 命令"></a>compose 命令</h2><p><code>docker-compose</code> 命令完成与 Compose 相关的众多操作。在此，简单列举若干：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Sub Commands:</span><br><span class="line">  <span class="comment"># 构建指定服务对应的镜像，其等价于 docker build </span></span><br><span class="line">  build              Build or rebuild services</span><br><span class="line">  <span class="comment"># 上传或下拉指定服务所对应的镜像，其等价于 docker pull/push</span></span><br><span class="line">  pull               Pull service images</span><br><span class="line">  push               Push service images </span><br><span class="line">  <span class="comment"># 构建指定服务对应的容器实例，其等价于 docker create </span></span><br><span class="line">  create             Create services</span><br><span class="line">  <span class="comment"># 运行指定服务，其等价于调用 docker run </span></span><br><span class="line">  run                Run a one-off <span class="built_in">command</span></span><br><span class="line">  <span class="comment"># 依次完成构建镜像、数据卷、网络,创建容器实例,运行等操作，从而启动整个项目</span></span><br><span class="line">  up                 Create and start containers</span><br><span class="line">  <span class="comment"># 与 up 命令相对，删除 up 命令所创建的一切</span></span><br><span class="line">  down               Stop and remove containers, networks, images, and volumes</span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 在指定服务的容器实例中执行指定命令，其等价于 docker exec</span></span><br><span class="line">  <span class="built_in">exec</span>               Execute a <span class="built_in">command</span> <span class="keyword">in</span> a running container</span><br><span class="line">  <span class="comment"># 设置某服务的容器实例数量</span></span><br><span class="line">  scale              Set number of containers <span class="keyword">for</span> a service</span><br><span class="line">  <span class="comment"># 杀死/暂停/取消暂停/启动/停止/重启 特定服务的容器实例，其等价于 docker ...</span></span><br><span class="line">  <span class="built_in">kill</span>               Kill containers</span><br><span class="line">  pause              Pause services</span><br><span class="line">  unpause            Unpause services</span><br><span class="line">  start              Start services</span><br><span class="line">  stop               Stop services</span><br><span class="line">  restart            Restart services</span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 验证、查看指定的 compose 文件</span></span><br><span class="line">  config             Validate and view the Compose file</span><br><span class="line">  <span class="comment"># 以 JSON 格式输出某服务的容器实例中的事件信息</span></span><br><span class="line">  events             Receive real time events from containers</span><br><span class="line">  <span class="comment"># 显示特定服务的日志输出</span></span><br><span class="line">  logs               View output from containers</span><br><span class="line">  <span class="comment"># 查看指定服务的容器实例的端口映射信息</span></span><br><span class="line">  port               Print the public port <span class="keyword">for</span> a port binding</span><br><span class="line">  <span class="comment"># 罗列所涉容器</span></span><br><span class="line">  ps                 List containers</span><br><span class="line">  <span class="comment"># 显示服务的进程信息</span></span><br><span class="line">  top                Display the running processes</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 移除指定服务的已停止运行的容器实例</span></span><br><span class="line">  rm                 Remove stopped containers</span><br></pre></td></tr></table></figure>
<p>可以看到 <code>docker-compose</code> 命令与 <code>docker</code> 命令基本一致，前者为后者的再次封装。</p>
<p>当在 shell 窗口输入 <code>docker-compose up</code> 命令后，客户端会将 docker-compose.yml 以及上下文环境 (主要指代 Dockerfile 的上下文环境) 发送至守护进程，守护进程依次自动完成如下事件以启动整个项目：创建数据卷和网络、依据 Dockerfile 构建镜像、按照依赖关系创建容器并将其加入相应网络。</p>
]]></content>
      <categories>
        <category>docker学习</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>经济学原理总结——微观部分</title>
    <url>/2021/02/09/sundry/economics-principleMicro/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文为视频 <a href="https://www.bilibili.com/video/BV1bK4y1576z">经济学原理 (全77讲)</a> 的观后总结，以便后续查看、回忆经济学微观部分相关知识。</p>
<a id="more"></a>

<p>首先给出贯穿整个经济学的十大原理，它们依次回答下列问题：人们如何做出决策 (前 4 个原理)、人们如何相互作用 (中 3 个原理)、整体经济如何运行 (后 3 个原理)：</p>
<ol>
<li>人们面临得失交换 (People face tradeoffs)。</li>
<li>某物的成本是为此所放弃的东西 (The cost of something is what you give up to get it)。</li>
<li>理性人思考边际量 (Rational people think at the margin)。</li>
<li>人们会对激励做出反应 (People respond to incentives)。</li>
<li>贸易能使人人受益 (Trade can make everyone better off)。</li>
<li>市场通常是组织经济活动的好方式 (Markets are usually a good way to organize economic activity)。</li>
<li>政府有时可以改进市场结果 (Governments can sometimes improve markets outcomes)。</li>
<li>一国的生活水平取决于它的生产 (The standard of living deponds on a country’s production)。</li>
<li>当政府发行过多货币时，物价上涨 (Prices rise when the government prints too much money)。</li>
<li>社会面临通货膨胀和失业之间的短期得失交换 (Society faces a short-run tradeoffs between inflation and unemployment)。</li>
</ol>
<h2 id="供给和需求"><a href="#供给和需求" class="headerlink" title="供给和需求"></a>供给和需求</h2><p>在一个市场之中，针对某个商品，往往存在众多买者和卖者，买者决定需求，卖者决定供给，买卖双方共同决定市场结果 (指代商品的实际价格和实际流通数量)。</p>
<p>在这一部分，我们仅考虑 <em>完全竞争市场</em>。在该种市场类型之中，存在众多买者和卖者，它们均为价格接受者 (即个人无法单独影响商品价格)。与之对应的市场类型为 <em>不完全竞争市场</em>，具体可细分为垄断市场、寡头市场、垄断竞争市场。</p>
<p>为描述供给和需求的关系，我们依次给出需求模型、供给模型、供求均衡模型。</p>
<h3 id="需求模型"><a href="#需求模型" class="headerlink" title="需求模型"></a>需求模型</h3><p>需求模型用于描述需求与价格间的关系 (需求定律：其他条件不变，价格上升导致需求下降)，它可使用下图加以表示 (需求曲线具体何种走势我们不关系，在此仅列出大致趋势)：</p>
<img src="/2021/02/09/sundry/economics-principleMicro/image-20210125123821968.png" width="35%">

<p>影响需求的因素很多，大致包括：市场价格、消费者收入、替代品或互补品等相关商品的价格、个人嗜好。观察上图，我们可以直观看到市场价格与需求的关系。为描述其他非市场价格因素与需求间的关系，我们可直接通过左右移动该曲线做到 (左图表示其他非市场价格因素有助于需求时，市场价格与需求的关系，右图表示其他非市场价格因素有害于需求时，市场价格与需求的关系)：</p>
<img src="/2021/02/09/sundry/economics-principleMicro/image-20210125130140621.png" width="65%">

<h3 id="供给模型"><a href="#供给模型" class="headerlink" title="供给模型"></a>供给模型</h3><p>供给模型用于描述供给与价格间的关系 (供给定律：其他条件不变，价格上升导致供给增加)，它可使用下图加以表示 (供给曲线具体何种走势我们不关系，在此仅列出大致趋势)：</p>
<img src="/2021/02/09/sundry/economics-principleMicro/image-20210125133115385.png" width="35%">

<p>影响供给的因素很多，大致包括：市场价格、原材料价格、技术。观察上图，我们可以直观看到市场价格与供给的关系。为描述其他非市场价格因素与供给间的关系，我们可直接通过左右移动该曲线做到 (左图表示其他非市场价格因素有助于供给时，市场价格与供给的关系，右图表示其他非市场价格因素有害于供给时，市场价格与供给的关系)：</p>
<img src="/2021/02/09/sundry/economics-principleMicro/image-20210125133630225.png" width="65%">

<h3 id="供求均衡模型"><a href="#供求均衡模型" class="headerlink" title="供求均衡模型"></a>供求均衡模型</h3><p>供求均衡模型用于描述需求、供给与价格间的关系 (供求定律：在竞争市场上，价格调整使得供给与需求平衡)，它可通过叠加需求模型和供给模型的图示得到：</p>
<img src="/2021/02/09/sundry/economics-principleMicro/image-20210125134336737.png" width="35%">

<p>上图之中，两条曲线的交叉点称为均衡点，此时市场供给和市场需求一致，市场价格 (也称为均衡价格) 为所有人接受。</p>
<p>理想情况下，无论市场初始情况如何，通过价格的动态调整，市场最终将达到均衡点所处状态。</p>
<h3 id="弹性"><a href="#弹性" class="headerlink" title="弹性"></a>弹性</h3><p>弹性用于衡量买者或卖者对市场环境变化做出反应的程度。在此，我们仅关注 <em>需求/供给的价格弹性</em>：给定 1% 的价格变化，需求/供给变化的百分比，它可近似理解为价格-需求/供给图例中曲线的斜率。</p>
<p>依据价格弹性的不同，可划分得到缺乏弹性的需求/供给 (即价格变化仅会引发较小的需求/价格变化，常见商品有衣物、盐)、富于弹性的需求/供给 (即价格变化将会引发较大的需求/价格变化，常见商品有首饰、数码产品)。</p>
<p>考虑总收益 = 价格 * 需求 (总收益对应于阴影面积)，那么对于缺乏弹性的商品而言，价格上升可导致总收益上升；对于富于弹性的商品而言，价格上升将导致总收益下降。</p>
<img src="/2021/02/09/sundry/economics-principleMicro/image-20210125142547795.png" width="35%">

<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>依据上面知识，我们分析问题 “禁毒增加还是减少与毒品相关的犯罪？”。</p>
<p>假定未采取任何措施情况下，毒品价格-需求/供给图如下示：</p>
<img src="/2021/02/09/sundry/economics-principleMicro/image-20210125134336737.png" width="35%">

<p>容易知道，禁毒操作有害于供给且不会影响需求，此时毒品价格-需求/供给图如下示：</p>
<img src="/2021/02/09/sundry/economics-principleMicro/image-20210125150405076.png" width="35%">

<p>根据上图可知：当市场达到均衡状态时，禁毒操作将使得毒品价格上升。毒品属于缺乏弹性的商品，即毒品价格上升比例低于毒品供给/需求比例，于是可这样理解禁毒操作的效果：毒品价格上升一点点，但是毒品供给/需求基本没有发生变化。因此吸毒者将耗费更多资金用于购买毒品，为获取更多资金，吸毒者很有可能从事不法活动，这将可能增加与毒品相关的犯罪。</p>
<p>接下来我们分析问题 “禁毒教育增加还是减少与毒品相关的犯罪？”</p>
<p>容易知道：禁毒教育有害于需求而不会影响供给，此时毒品价格-需求/供给图如下示：</p>
<img src="/2021/02/09/sundry/economics-principleMicro/image-20210125151728119.png" width="35%">

<p>根据上图可知：当市场达到均衡状态时，禁毒教育将使毒品价格下降、需求/供给减少。这些效果使得购买毒品所耗费资金减少，从而可能降低与毒品相关的犯罪。</p>
<h2 id="市场与政府政策"><a href="#市场与政府政策" class="headerlink" title="市场与政府政策"></a>市场与政府政策</h2><p>由买卖双方共同决定的市场价格可能并不公平，政府便会实行价格管控以维护公平原则。这一行为虽是好心，但实际结果往往事与愿违。</p>
<p>价格管控分为两个方面：价格上限和价格下限。这一部分内容便是借由供求均衡模型分析相关管控行为的影响。</p>
<h3 id="价格上限"><a href="#价格上限" class="headerlink" title="价格上限"></a>价格上限</h3><p>政府实行价格上限管控存在两种可能情况：</p>
<ul>
<li>价格上限高于均衡价格，价格上限管控无作用。</li>
<li>价格上限低于均衡价格，价格上限管控起作用。</li>
</ul>
<p>鉴于第一种可能情况并不会对现有市场产生影响，因此我们在此仅考虑第二种可能情况的影响。</p>
<blockquote>
<p>注意：市场是不断变化地，突发事件可能导致两者情况相互转换。例如：假定冰淇淋市场目前处于第一种可能情况，天气突然炎热且国家上调电费费率，此时需求增大而供给减少，重新达到均衡状态的冰淇淋市场就有可能处于第二种可能情况。</p>
</blockquote>
<p>对于第二种可能情况，其价格-需求/供给图如下示：</p>
<img src="/2021/02/09/sundry/economics-principleMicro/image-20210127120435736.png" width="35%">

<p>从中可以看到：价格上限管控导致需求大于供给，从而引发短缺。</p>
<p>我们知道市场价格由供给和需求共同决定。现如今政府管控价格上限，那么必将引发供给和需求的变动，从而使得由新供给和新需求共同决定的市场价格小于或等于价格上限。</p>
<p>在此，我们说明政府管控价格上限的一个典型例子——房租价格上限。</p>
<p>政府管控房租价格上限旨在让普通人也能住得起房，此为好心。</p>
<p>接下来分析一下此价格管控对市场的影响。从短期来看，租房市场供给不会发生变动，价格管控将引发一定程度的短缺，但是更多人可以相对便宜的价格住得起房，与政府初衷一致。从长期来看，租赁者一定会觉得亏，或减少修缮房屋费用，或改造房屋以为他用，这使得租房市场供给急剧减少，价格管控将引发严重短缺，这使得仅有少部分人住得起房，其余人不得不流落街头，与政府初衷不一致。更为严重的是，租赁者无心修缮房屋，房屋逐渐破旧，市区显现萧条、破败之态，无益于市区发展。</p>
<h3 id="价格下限"><a href="#价格下限" class="headerlink" title="价格下限"></a>价格下限</h3><p>政府实行价格下限管控存在两种可能情况：</p>
<ul>
<li>价格下限低于均衡价格，价格下限管控无作用。</li>
<li>价格下限高于均衡价格，价格下限管控起作用。</li>
</ul>
<p>鉴于第一种可能情况并不会对现有市场产生影响，因此我们在此仅考虑第二种可能情况的影响。</p>
<blockquote>
<p>市场是不断变化地，突发事件可能导致两者情况相互转换。</p>
</blockquote>
<p>对于第二种可能情况，其价格-需求/供给图如下示：</p>
<img src="/2021/02/09/sundry/economics-principleMicro/image-20210127125343686.png" width="35%">

<p>从中可以看到：价格下限管控导致需求小于供给，从而引发过剩。</p>
<p>我们知道市场价格由供给和需求共同决定。现如今政府管控价格下限，那么必将引发供给和需求的变动，从而使得由新供给和新需求共同决定的市场价格刚好等于或大于价格下限。</p>
<p>在此，我们说明政府管控价格下限的一个典型例子——最低工资。</p>
<p>政府管控最低工资旨在保障民生，此为好心。</p>
<p>接下来分析一下此价格管控对市场的影响。价格管控引发过剩，即劳动力供给大于需求，这将致使低能力的劳动力失业，与政府初衷不一致。</p>
<h3 id="税收"><a href="#税收" class="headerlink" title="税收"></a>税收</h3><p>此节介绍一个非常有意思的知识点——税收，我们使用使用冰淇淋市场说明此知识点。</p>
<p>假定未征税前的价格-需求/供给图如下示 (冰淇淋单价为 3.0，市场供需为 100)：</p>
<img src="/2021/02/09/sundry/economics-principleMicro/image-20210127133625740.png" width="35%">

<p>如果仅向买方征收 0.5 的税，则其有害于需求，此时价格-需求/供给图如下示 (冰淇淋单价为 2.8，买方实际支付价格为 3.3，市场供需为 90)：</p>
<img src="/2021/02/09/sundry/economics-principleMicro/image-20210127134215286.png" width="35%">

<blockquote>
<p>这里需要说明一个问题：征税后的市场均衡价格为什么是 2.8？这里给出一种可能的解释：如果向买方征税，按照最初的均衡价格，买方的支付意愿应当为 2.5。这个价格卖方肯定是不同意的，一定会要求适当增价，因此征税后的市场均衡价格应当介于 2.5 和 3.0 之间。</p>
</blockquote>
<p>上图表明两个问题：1. 税收由买房和卖方共同负担 2. 税收抑制需求。</p>
<p>如果仅向卖方征收 0.5 的税，则其有害于供给，此时价格-需求/供给图如下示 (冰淇淋单价为 3.3，卖方实际收益为 2.8，市场供需为 90)：</p>
<img src="/2021/02/09/sundry/economics-principleMicro/image-20210127140852516.png" width="35%">

<blockquote>
<p>这里需要说明一个问题：征税后的市场均衡价格为什么是 3.3？这里给出一种可能的解释：如果向卖方征税，按照最初的均衡价格，卖方的要价意愿应当为 3.5。这个价格买方肯定是不同意的，一定会要求适当减价，因此征税后的市场均衡价格应当介于 3.0 和 3.5 之间。</p>
</blockquote>
<p>上图同样表明两个问题：1. 税收由买房和卖方共同负担 2. 税收抑制需求。</p>
<p>综合这两个“如果”，可以得到结论：<strong>无论向哪方征税，最终税收均由两方共同承担，且税收抑制需求和供给</strong>。</p>
<p>接下来探寻另一个问题：买方与卖方之间，哪一方承担更多部分的税收？</p>
<p>观察仅向买方征税的价格-需求/供给图或者仅向卖方征税的价格-需求/供给图，对比征税前后的均衡状态，可以发现：市场价格、供给、需求均下降，且供给下降量与需求下降量相同。按照弹性概念 (即价格变动 1 %，供给/需求变动的百分比) 可知，供给方 (即卖方) 和需求方 (即买方) 都会适度让利，以此作为最终税收。因为供给下降量与需求下降量相同，那么我们可以得到如下结论：<strong>如果供给的价格弹性高于需求的价格弹性，则买方承当更多部分的税收；如果供给的价格弹性低于需求的价格弹性，则买方承担更多部分的税收</strong>。</p>
<h2 id="市场效率"><a href="#市场效率" class="headerlink" title="市场效率"></a>市场效率</h2><p>这一部分内容借助于若干概念以说明原理 6，即市场通常是组织经济活动的好方式。</p>
<p>首先给出如下概念：</p>
<ul>
<li>消费者剩余：消费者的支付意愿减去消费者的实际支付价格，用于衡量消费者的收益 (非实际意义上的收益)。</li>
<li>生产者剩余：生产者的实际收入价格减去生产者的生产成本，用于衡量生产者的收益。</li>
<li>总剩余：消费者剩余 + 生产者剩余 = 消费者的支付意愿 - 消费者的实际支付价格 + 生产者的实际收入价格 - 生产者的生产成本 = 消费者的支付意愿 - 生产者的生产成本</li>
</ul>
<p>对应于价格-需求/供给图，我们可以做如下解释：</p>
<ul>
<li>对于需求曲线上某一点，它表示商品价格为此点时，所有消费者愿意购买商品的总数量。</li>
<li>对于供给曲线上某一点，它表示商品价格为此点时，所有生产者愿意提供商品的总数量。</li>
<li>需求曲线以下、指定价格以上所围面积即是消费者剩余 (蓝色面积)。</li>
<li>供给曲线以上、指定价格以下所围面积即是生产者剩余 (黄色面积)。</li>
</ul>
<img src="/2021/02/09/sundry/economics-principleMicro/image-20210127203201429.png" width="35%">

<p>当资源配置使得总剩余最大化，此时市场最为高效，也称此时达到 <em>市场效率</em>。</p>
<p>根据价格-需求/供给图，不难发现：当市场达到均衡状态后，以均衡价格为界，令愿以此价格购买商品的消费者为实际消费者，愿以此价格提供商品的生产者为实际生产者，此种资源配置情况下总剩余最大化。</p>
<p>不难发现：这种使得总剩余最大化的资源配置情况是自动形成的，它无需外界干预。消费者一旦发现其支付意愿高于均衡价格，其自动成为实际消费者，生产者一旦发现其生产成本低于均衡价格，其自动成为实际生产者。市场便是借助于 <strong>价格</strong> 这一隐形工具实现自主、高效地配置资源 (之所以称价格为隐形的，原因在于总剩余定义中的消费者剩余和生产者剩余涉及价格，而总剩余计算无关价格)。</p>
<p>至此，完成原理 “市场通常是组织经济活动的好方式” 的相关说明。</p>
<blockquote>
<p>此原理成立存在两个假设条件：其一，市场是完全竞争的，不存在市场势力 (即垄断或寡头)；其二，市场结果仅与买卖双方相关，不涉及外部性，例如污染问题。</p>
<p>现实问题无法满足此二者假设条件，可能导致 <em>市场失灵</em>，即市场无法自主、高效地配置资源。</p>
</blockquote>
<h2 id="外部性"><a href="#外部性" class="headerlink" title="外部性"></a>外部性</h2><p>当市场结果影响到市场中买卖双方以外的其他地方，所产生的的副作用即为 <em>外部性</em>。根据影响效果好坏，可细分为正外部性 (例如，技术溢出) 和负外部性 (例如，污染问题)。</p>
<p>我们以技术溢出为例，说明正外部性对市场的影响。</p>
<p>首先给出基本的价格-需求/供给图 (从某个角度讲，供给曲线上的点可理解为私人成本)：</p>
<img src="/2021/02/09/sundry/economics-principleMicro/image-20210125134336737.png" width="35%">

<p>由于技术溢出对社会其他方面产生正向激励，因此商品的社会成本低于私人成本，因此其实际的价格-需求/供给图如下：</p>
<img src="/2021/02/09/sundry/economics-principleMicro/image-20210204131341112.png" width="35%">

<p>可以看到：理论均衡点位于实际均衡点的右侧，即本应生产更多商品，而实际生产较少，从而造成市场资源配置效率低。</p>
<p>为解决此问题，通常存在两种做法：1. 强制生产更多商品；2. 通过政府补贴方式将外部性因素内部化。</p>
<p>我们以铝生产为例，说明负外部性对市场的影响。</p>
<p>首先给出基本的价格-需求/供给图 (从某个角度讲，供给曲线上的点可理解为私人成本)：</p>
<img src="/2021/02/09/sundry/economics-principleMicro/image-20210125134336737.png" width="35%">

<p>由于铝生产过程产生废水，污染环境，因此商品的社会成本高于私人成本，因此其实际的价格-需求/供给图如下：</p>
<img src="/2021/02/09/sundry/economics-principleMicro/image-20210204132254013.png" width="35%">

<p>可以看到：理论均衡点位于实际均衡点左侧，即本应生产较少商品，而实际生产较多，从而造成市场资源配置效率低。</p>
<p>为解决此问题，通常存在两种做法：1. 强制生产较少商品；2. 通过征收税负方式将外部性因素内部化。</p>
<p>上面两个例子中，均是通过外部力量解决外部问题，而 <strong>科斯定理</strong> 指出可以通过私人方式解决外部性问题：如果产权 (指代对资源和财产使用、占有、支配的权利) 得到明确界定，且当事双方能够无成本地就资源配置进行谈判协商，则私人市场总能解决外部性问题，并有效分配资源。</p>
<p>我们以铝生产为例，说明这个定理。</p>
<p>铝生产过程中产生的废水将污染环境 (具体限定为部分区域土地，其为若干户所拥有)。土地收到污染，则户主会就此与厂家进行谈判协商，以确定赔偿金额。如此协商结果，便是变相增加私人成本，达到通过外部力量解决问题的类似效果。</p>
<blockquote>
<p>现实之中，大部分外部性问题无法依靠私人方式解决的原因在于：1. 产权界定不清楚；2. 谈判协商成本太高。</p>
<p>知识产权就是产权的一种，它的存在就是为了解决部分外部性问题。</p>
</blockquote>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
  </entry>
  <entry>
    <title>Dockerfile 文件介绍</title>
    <url>/2021/02/08/docker/docker4-dockerfile/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>Dockerfile</strong> 是一个文本文件，其中包含若干指令，用以层级构建 docker image。 </p>
<a id="more"></a>

<p>为方便介绍 Dockerfile 有关内容，需要简单说明 <code>image</code> 和 <code>container</code> 的底层原理。</p>
<p><code>image</code> 实际是一个层级只读文件，其结构大致如图所示：</p>
<img src="/2021/02/08/docker/docker4-dockerfile/462718f3cd35608c20481b33b09db020.jpg" width="25%">

<p><code>container</code> 可理解为镜像之上添加一个可读写层。容器之中所执行的任何操作 (例如，添加内容、修改 <code>image</code> 内容) 都会保存至该可读写层。</p>
<p>此时我们看一下 <code>docker commit</code> 操作，基于此操作构建得到的镜像等价于运行此容器所使用的镜像 + 该可读写层。这基本是 Dockerfile 构建镜像的原理，即以基本镜像为基础，生成容器并运行它，执行相关操作，<code>docker commit</code> 得到中间镜像，随后以此中间镜像为基础，再次执行类似步骤，最终得到目标镜像。</p>
<h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><p>此节介绍 dockerfile 之中所涉及的各种内容。</p>
<p>需要注意两点：</p>
<ol>
<li><strong>Dockerfile 生成器将自上而下、逐行执行 Dockerfile 文件中的指令</strong>。</li>
<li><strong>Dockerfile 中每条构建指令的执行结果都会成为目标镜像中的一层</strong>。</li>
</ol>
<h3 id="解析器指令"><a href="#解析器指令" class="headerlink" title="解析器指令"></a>解析器指令</h3><p>解析器指令为 Dockerfile 的可选内容，它会影响 Dockerfile 文件中后续指令的执行方式。</p>
<p>其具体格式为 <code># directive=value</code>，且特定的 <code>directive</code> 仅能出现一次。Dockerfile 支持的解析器指令具体如下：</p>
<ul>
<li><p>syntax  –&gt;  <code># syntax [remote image reference]</code></p>
<p>syntax 指令用于指定构建当前 Dockerfile 文件所使用的 Dockerfile 生成器位置。</p>
<p>例如：<code># syntax=docker/dockerfile:1.0.0</code>，指定 Dockerfile 生成器位置为远端仓库的 docker/dockerfile:1.0.0。</p>
</li>
<li><p>escape  –&gt;  <code># escape \</code></p>
<p>escape 指令用于指定 Dockerfile 文件中的转义字符，默认转义字符为 <code>\</code>。</p>
<p>例如：<code># escape |</code>，指定转义字符为 <code>|</code>。 </p>
</li>
</ul>
<blockquote>
<p>如果注释、空行、生成指令均已按序执行完成，则后续出现的解析器指令将被自动认定为注释。因此，为保证解析器指令正确执行，最好将其置于 Dockerfile 文件顶部。</p>
<p>解析器指令的执行结果不会成为目标镜像的一层，也不会出现在构建输出结果之中。</p>
</blockquote>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>除解析器指令外，凡是以 <code>#</code> 开头的行均为注释行。</p>
<blockquote>
<p>执行 Dockerfile 前，会自动移除其中注释。因此，当分行书写一条指令时，其中穿插注释并不会影响指令执行效果。</p>
</blockquote>
<h3 id="dockerignore-文件"><a href="#dockerignore-文件" class="headerlink" title=".dockerignore 文件"></a>.dockerignore 文件</h3><p>该文件类似于 <code>.gitignore</code> 文件，用于排除使用 Dockerfile 构建镜像过程中所涉及的特定文件或文件夹。</p>
<h3 id="构建指令"><a href="#构建指令" class="headerlink" title="构建指令"></a>构建指令</h3><p>构建指令为 Dockerfile 的主体内容，它定义了镜像的具体构建过程。</p>
<p>构建指令一般格式为 <code>INSTRUCTION arguments</code> ，其中 <code>INSTRUCTION</code> 指明具体指令，<code>arguments</code> 为所涉参数。Dockerfile 支持的构建指令具体如下：</p>
<ul>
<li><p>FROM  –&gt;  <code>FROM [--platform=&lt;platform&gt;] &lt;image&gt;[:&lt;tag&gt;] [AS &lt;name&gt;]</code></p>
<p>FROM 指令用于指明目标镜像所使用的基础镜像。</p>
<p>例如：<code>FROM  --platform=linux/amd64 centos:lastest AS CS</code>，以 centos:lastest 为基础镜像，并将此构建阶段命名为 CS，同时指定构建平台为 linux/amd64 架构 (默认为本机所处的构建平台)。</p>
<p>除解析器指令、注释、ARG 指令外，FROM 指令应当为 Dockerfile 文件自上而下的第一条指令，其标志 <code>build stage</code> 的开始。</p>
</li>
<li><p>RUN  –&gt;  <code>RUN &lt;command&gt; &lt;param1&gt;</code> / <code>RUN [&#39;executable&#39;,&#39;param1&#39;]</code></p>
<p>RUN 指令用于生成目标镜像的一层，该层为基于当前最新中间镜像得到的容器的可读写层。</p>
<p>例如：<code>RUN &#39;echo $HOME&#39;</code>，基于当前最新中间容器得到的镜像中执行 <code>echo $HOME</code> shell 命令，并以可读写层作为目标镜像的一层。</p>
</li>
<li><p>ADD  –&gt;  <code>ADD [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt; </code></p>
<p>ADD 指令用于将 <code>src</code> 所指代的文件、文件夹或远程文件 URL 添加至当前最新中间镜像的文件系统之中。</p>
<p>例如：<code>ADD test.txt /usr/</code>，将上下文中的 <code>test.txt</code> 文件添加至文件系统的 <code>/usr/</code> 处。</p>
</li>
<li><p>COPY  –&gt;  <code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;</code></p>
<p>COPY 指令用于将 <code>src</code> 所指代的文件或文件夹添加至当前最新中间镜像的文件系统之中。</p>
<p>COPY 指令存在可选参数 <code>--from=&lt;name&gt;</code>，其可用于在 <code>multi-stage</code> 之中重置当前指令所使用的 <code>stage context</code>。</p>
</li>
<li><p>ENTRYPOINT  –&gt;  <code>ENTRYPOINT &lt;command&gt; &lt;param1&gt;</code> / <code>ENTRYPOINT [&#39;executable&#39;,&#39;param1&#39;]</code></p>
<p>ENTRYPOINT 指令用于配置容器启动时<strong>自动执行的命令</strong>。</p>
<p>它具有两种使用方式：shell 形式 (<code>ENTRYPOINT &lt;command&gt; &lt;param1&gt;</code>) 和 exec 形式 (<code>ENTRYPOINT [&#39;executable&#39;,&#39;param1&#39;]</code>)，前者会首先调用 shell 窗口，随后在其中执行命令，后者则直接执行命令。</p>
<p>如果 Dockerfile 中存在多条 ENTRYPONT 指令，则最后一个 ENTRYPOINT 指令会生效。另外，如果不希望默认执行 ENTRYPOINT 所指代的命令，可在运行容器时使用参数 <code>--entrypoint</code> 重新设置。</p>
<p>例如：<code>ENTRYPOINT [&#39;/bin/echo&#39;,&#39;hello&#39;]</code>，容器启动后，它会自动执行命令 <code>/bin/echo &#39;hello&#39;</code>。</p>
</li>
<li><p>CMD –&gt;  <code>CMD &lt;command&gt; &lt;param1&gt;</code> / <code>CMD [&#39;executable&#39;,&#39;param1&#39;]</code> / <code>CMD [&#39;param1&#39;]</code></p>
<p>CMD 指令用于配置容器启动时<strong>自动执行的默认命令</strong>。</p>
<p>它具有三种用法，前两种用法与 ENTRYPOINT 相同，在此仅说明第三种用法，即 <code>CMD [&#39;param1&#39;]</code>。它需要与 ENTRYPOINT 指令联合使用，并以 <code>param1</code> 作为 ENTRYPOINT 指令所执行命令的参数。 </p>
<p>如果 Dockerfile 中存在多条 CMD 指令，则最后一个 CMD 指令会生效。另外，如果用户运行待执行容器时指定相关参数，则其会覆盖 CMD 指令。</p>
<p>鉴于 ENTRYPOINT 与 CMD 指令十分相似，在此联合二者举例。</p>
<p>假定 Dockerfile 含有如下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ENTRYPOINT <span class="built_in">echo</span> </span><br><span class="line">CMD [<span class="string">&#x27;hello&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>当运行容器时，如果具体命令为 <code>docker run centos</code>，则容器启动后自动执行 <code>echo &quot;hello&quot;</code>；如果具体命令为 <code>docker run centos &quot;world&quot;</code>，则容器启动后自动执行 <code>echo &quot;world&quot;</code>；如果具体命令为 <code>docker run --entrypoint=&#39;touch&#39; centos</code>，则容器启动后自动执行 <code>touch &quot;hello&quot;</code>。</p>
</li>
<li><p>EXPOSE  –&gt;  <code>EXPOSE &lt;port&gt;</code></p>
<p>EXPOSE 指令用于指明目标镜像向外发布的端口，它类似于一个介于发布镜像者与运行容器者之间的端口文档说明。</p>
<p>例如：<code>EXPOSE 80/udp</code>，向外暴露面向 UDP 的 80 端口。</p>
</li>
<li><p>VOLUME  –&gt;  <code>VOLUME [mountpoint]</code></p>
<p>VOLUME 指令用于创建一个挂载点。</p>
<p>当运行容器时，如果没有显式挂载此挂载点，则其会默认创建匿名卷挂载此挂载点。</p>
<p>例如：<code>VOLUME &#39;/lib/bin&#39;</code>。</p>
</li>
<li><p>USER  –&gt;  <code>USER &lt;user&gt;:[group]</code></p>
<p>USER 指令用于设置 UID 和 GID 以供容器运行时使用。</p>
</li>
<li><p>WORKDIR  –&gt;  <code>WORKDIR &lt;path&gt;</code></p>
<p>WORKDIR 指令用于设置容器运行的工作目录。</p>
<p>例如：<code>WORKDIR /bin</code>，设置容器的 <code>/bin</code> 目录为工作目录。</p>
</li>
<li><p>LABEL  –&gt;  <code>LABEL &lt;key&gt;=&lt;value&gt;</code></p>
<p>LABEL 指令用于为目标镜像添加元数据。</p>
<p>例如：<code>LABEL version=&quot;1.0&quot;</code>。</p>
</li>
<li><p>MAINTAINER  –&gt;  <code>MAINTAINER &lt;name&gt;</code></p>
<p>MAINTAINER 指令用于指明维护者信息，也可使用 <code>LABEL maintainer=&lt;name&gt;</code> 达到同样效果。</p>
<p>例如：<code>MAINTAINER &quot;Stivin&quot;</code></p>
</li>
<li><p>ENV  –&gt;  <code>ENV &lt;key&gt;=&lt;value&gt;</code></p>
<p>ENV 指令用于设置运行于容器时的环境变量 (将持久化于容器之内)，其可应用于 Dockerfile 文件中的后续指令中。</p>
<p>例如：<code>ENV &#39;PATH&#39;=&#39;/bin/lib&#39;</code>，设置环境变量 <code>PATH</code> 为 <code>/bin/lib</code>。</p>
</li>
<li><p>ARG –&gt;  <code>ARG &lt;name&gt;[=&lt;value&gt;]</code></p>
<p>ARG 指令用于设置 Dockerfile 文件中所使用到的变量 (不会存在于容器之内)。所定义的变量从其定义位置开始生效，在此位置之前引用将得到空字符串。</p>
</li>
<li><p>ONBUILD  –&gt;  <code>ONBUILD xxx </code></p>
<p>ONBUILD 指令用于为目标镜像添加触发器 (本质就是若干指令)。如果目标镜像作为其他 Dockerfile 文件中的基础镜像，则 Dockerfile 生成器执行完 <code>FROM xxx</code> 后，这些触发器会自动执行。</p>
<p>例如：<code>ONBUILD ADD . /app/src</code>。</p>
</li>
<li><p>STOPSIGNAL   –&gt;  <code>STOPSIGNAL &lt;signal&gt;</code></p>
<p>STOPSIGNAL 指令用于设置用以容器退出的信号。</p>
<p>例如：<code>STOPSIGNAL SIGKILL</code>。</p>
</li>
<li><p>HEALTHCHECK  –&gt;  <code>HEALTHCHECK [option] CMD command</code> / <code>HEALTHCHECK none</code></p>
<p>HEALTHCHECK  指令用于设置执行容器健康检查时应当做的操作。</p>
<p>HEALTHCHECK 指令的两种形式中，<code>HEALTHCHECK [option] CMD command</code> 用于设置具体执行哪些操作，<code>HEALTHCHECK none</code> 表示禁止继承自基础镜像的任何健康检查操作。</p>
<p>例如：<code>HEALTHCHECK --interval=5m --timeout=3s CMD curl -f http://localhost/ || exit 1</code>。</p>
</li>
<li><p>SHELL –&gt;  <code>SHELL  [&#39;exectuable&#39;,&#39;paramters]</code></p>
<p>SHELL 指令用于重写默认 shell 。</p>
</li>
</ul>
<h3 id="multi-stage"><a href="#multi-stage" class="headerlink" title="multi-stage"></a>multi-stage</h3><p>利用上面所学的各种指令，我们可以很容易地编写一个构建特定目标镜像的 Dockerfile 文件。但是，编写 Dockerfile 文件的难点在于如何保证目标镜像大小尽可能地小。这其中存在众多技巧，在此介绍一种常见技巧。</p>
<p>考虑一种常见场景：项目开发过程中，往往存在两个环境——应用开发环境和应用部署环境。当项目开发完成后，就需要将其放到应用部署环境之中。</p>
<p>就目前所知，我们应该会构建两个 Dockerfile 文件：第一个 Dockerfile 文件用于构建开发环境，并拷贝项目代码至镜像中，运行得到二进制程序后，将其拷贝至本地；第二个 Dockerfile 文件用于构建部署环境，并将先前得到的二进制程序放置其中。</p>
<p>这种过程比较复杂，而且会产生中间镜像 (即根据第一个 Dockerfile 所产生的目标镜像)，十分繁琐。</p>
<p>如果借助于 <code>multi-stage</code>，我们只需构建一个 Dockerfile 文件，即可达到同样的效果。</p>
<p>在该种情况下，Dockerfile 文件中会存在两个 <code>stage</code> (每个 <code>stage</code> 以 <code>FROM</code> 指令标识开始，以下一个 <code>FROM</code> 指令标识结束)，第一个 <code>stage</code> 用于构建开发环境，并拷贝项目代码至镜像中，运行得到二进制程序即可，第二个 <code>stage</code> 构建部署环境，并借助于 COPY 指令的 <code>--from</code> 参数将第一个 <code>stage</code> 中的二进制程序放置其中。</p>
<blockquote>
<p>使用 Dockerfile 生成器构建 <code>multi-stage</code> 相关的 Dockerfile 文件时，其会保存各 <code>stage</code> 的运行结果以供其他 <code>stage</code> 使用，但是仅最后一个 <code>stage</code> 的运行结果会保存于目标镜像之中。</p>
</blockquote>
<h2 id="Docker-build"><a href="#Docker-build" class="headerlink" title="Docker build"></a>Docker build</h2><p>命令 <code>Docker build</code> 用于根据 Dockerfile 文件构建目标镜像。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Usage:  docker build [OPTIONS] PATH | URL | -</span><br><span class="line"></span><br><span class="line">Build an image from a Dockerfile</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">      --add-host list           Add a custom host-to-IP mapping (host:ip)</span><br><span class="line">      --build-arg list          Set build-time variables</span><br><span class="line">      --cache-from strings      Images to consider as cache sources</span><br><span class="line">  -f, --file string             Name of the Dockerfile (Default is <span class="string">&#x27;PATH/Dockerfile&#x27;</span>)</span><br><span class="line">      --no-cache                Do not use cache when building the image</span><br><span class="line">  -t, --tag list                Name and optionally a tag <span class="keyword">in</span> the <span class="string">&#x27;name:tag&#x27;</span> format</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<p>当在 shell 窗口输入此命令后，客户端会将 Dockerfile 以及上下文环境 (指代运行此命令的当前目录的全部内容，如果其中文件符合 <code>.dockerignore</code>，则其会被忽略) 发送至守护进程，守护进程验证 Dockerfile 语法无误后，使用 Dockerfile 生成器依次执行 Dockerfile 文件中指令，以逐步构建目标镜像。</p>
<p>目标镜像构建过程往往是比较缓慢的。为解决此问题，Docker 借助于缓存机制以加快构建过程。</p>
<p>该缓存机制可简单分解为如下三条规则 (这里暂不考虑解析器指令)：</p>
<ol>
<li>如果指令文本未曾发生变动，则可直接重用先前构建的缓存结果。</li>
<li>对于 COPY、ADD 指令而言，如果所涉文件和指令文本均未曾发生变动，则可直接重用先前构建的缓存结果。</li>
<li>如果当前指令构建的层无法使用缓存结果，则其后续指令构建的层亦不能使用缓存结果。</li>
</ol>
<blockquote>
<p>因为存在缓存机制，编写高效 Dockerfile 的技巧之一便是：将不变部分尽可能写于 Dockerfile 文件前部。 </p>
</blockquote>
<p>举例而言，假定初始 Dockerfile 如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FROM python:3.7-slim-buster</span><br><span class="line">COPY . .</span><br><span class="line">RUN pip install --quiet -r requirements.txt</span><br><span class="line">ENTRYPOINT [<span class="string">&quot;python&quot;</span>, <span class="string">&quot;server.py&quot;</span>]</span><br></pre></td></tr></table></figure>
<p>使用命令 <code>docker build</code> 构建目标镜像，可得到如下运行结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Sending build context to Docker daemon   5.12kB</span><br><span class="line">Step 1/4 : FROM python:3.7-slim-buster</span><br><span class="line"> ---&gt; f96c28b7013f</span><br><span class="line">Step 2/4 : COPY . .</span><br><span class="line"> ---&gt; eff791eb839d</span><br><span class="line">Step 3/4 : RUN pip install --quiet -r requirements.txt</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 591f97f47b6e</span><br><span class="line">Removing intermediate container 591f97f47b6e</span><br><span class="line"> ---&gt; 02c7cf5a3d9a</span><br><span class="line">Step 4/4 : ENTRYPOINT [<span class="string">&quot;python&quot;</span>, <span class="string">&quot;server.py&quot;</span>]</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> e3cf483c3381</span><br><span class="line">Removing intermediate container e3cf483c3381</span><br><span class="line"> ---&gt; 598b0340cc90</span><br><span class="line">Successfully built 598b0340cc90</span><br><span class="line">Successfully tagged example1:latest</span><br></pre></td></tr></table></figure>
<p> 不修改 Dockerfile，再次执行命令 <code>docker build</code>，可得到如下运行结果 (step2-4 均使用缓存结果)：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Sending build context to Docker daemon   5.12kB</span><br><span class="line">Step 1/4 : FROM python:3.7-slim-buster</span><br><span class="line"> ---&gt; f96c28b7013f</span><br><span class="line">Step 2/4 : COPY . .</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; eff791eb839d</span><br><span class="line">Step 3/4 : RUN pip install --quiet -r requirements.txt</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 02c7cf5a3d9a</span><br><span class="line">Step 4/4 : ENTRYPOINT [<span class="string">&quot;python&quot;</span>, <span class="string">&quot;server.py&quot;</span>]</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 598b0340cc90</span><br><span class="line">Successfully built 598b0340cc90</span><br><span class="line">Successfully tagged example1:latest</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>docker学习</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>docker 数据卷和网络</title>
    <url>/2021/01/30/docker/docker3-volumeAndNetwork/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文介绍 Docker 中与数据持久化相关的 <code>volume</code> 和与通信相关的 <code>network</code>。</p>
<a id="more"></a>

<h2 id="volume-数据卷"><a href="#volume-数据卷" class="headerlink" title="volume (数据卷)"></a>volume (数据卷)</h2><p>默认情况下，容器一旦被移除，其中包含的数据也会自动消失。为避免这种情况，需要用到数据持久化技术。</p>
<p>Docker 提供宿主机与容器之间共享文件，从而将数据持久化于宿主机。其具体分为两种方式 —— <code>volumes</code> 和 <code>bind mounts</code>。另外，对于 Linux 而言，Docker 提供 <code>tmpfs mount</code> ，它将数据直接保存于宿主机内存之中，而非容器之中。</p>
<h3 id="volumes"><a href="#volumes" class="headerlink" title="volumes"></a>volumes</h3><p><code>volumes</code> 由 Docker 创建并管理，且其中数据仅能由 Docker 进程操纵，其位于由 Docker 所管理的宿主机文件系统部分 (对于 Linux 而言，具体位于 <code>/var/lib/docker/volumes/</code>)。</p>
<p>Docker 提供 <code>docker volume</code> 命令管理 <code>volumes</code>，该命令的详细信息具体如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Usage:  docker volume COMMAND</span><br><span class="line"></span><br><span class="line">Manage volumes</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">  create      Create a volume</span><br><span class="line">  inspect     Display detailed information on one or more volumes</span><br><span class="line">  ls          List volumes</span><br><span class="line">  prune       Remove all unused <span class="built_in">local</span> volumes</span><br><span class="line">  rm          Remove one or more volumes</span><br></pre></td></tr></table></figure>
<p>为持久化容器数据，我们可在启动容器时使用 <code>-v</code> 或 <code>--mount</code> 参数将特定 <code>volumes</code> 挂载于容器的特定目录。举例如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 挂载volumeName数据卷至centos的/var/lib目录，且指定数据卷为只读模式。</span><br><span class="line">docker run -v volumeName:/var/lib:ro centos</span><br><span class="line">docker run --mount <span class="string">&#x27;type=volume,src=volumeName,dst=/var/lib,readonly&#x27;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>-v</code> 与 <code>--mount</code> 的区别在于：前者混杂多种使用情况，后者使用键值对形式将这些情况区分开来。建议使用 <code>--mount</code> 挂载数据卷。</p>
</blockquote>
<p>有关 <code>volumns</code> 的使用，作如下几点说明：</p>
<ol>
<li><code>volumes</code> 具体细分为 <code>Named volumes</code> 和 <code>Anonymous volumes</code>，前者由用户分配数据卷名称，后者由 Docker 分配数据卷名称。命令 <code>docker run -v volumeName:/var/lib:ro centos</code> 使用的是 <code>Named volumes</code>，命令 <code>docker run -v /var/lib:ro centos</code> 使用的是 <code>Anonymous volumes</code>。</li>
<li>如果容器目录不存在，则自动创建；如果数据卷不存在，则自动创建。</li>
<li><strong>如果将空数据卷挂载至容器非空目录，则容器目录内容会首先被自动复制至数据卷，然后该容器挂载并使用数据卷。</strong></li>
<li>启动容器时，可使用 <code>--volumes-from</code> 参数以挂载特定容器中的数据卷，从而实现两容器数据卷内容共享。</li>
</ol>
<h3 id="bind-mounts"><a href="#bind-mounts" class="headerlink" title="bind mounts"></a>bind mounts</h3><p><code>bind mounts</code> 由用户创建并管理，其中数据可为任何进程操纵，其所在位置由用户自主决定。</p>
<p>为持久化容器数据，我们可在启动容器时使用 <code>-v</code> 或 <code>--mount</code> 参数将宿主机指定目录与容器特定目录绑定挂载。举例如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 绑定挂载宿主机/usr/lib目录与centos的/var/lib目录，且指定为只读模式。</span><br><span class="line">docker run -v /usr/lib:/var/lib:ro centos</span><br><span class="line">docker run --mount <span class="string">&#x27;type=bind,src=/usr/lib,dst=/var/lib,readonly&#x27;</span></span><br></pre></td></tr></table></figure>
<p>有关 <code>bind mounts</code> 的使用，作如下几点说明：</p>
<ol>
<li>如果容器目录或文件不存在，则自动创建；如果宿主机目录或文件不存在，此时分为两种情况：若使用 <code>-v</code> 参数，则总是创建相应的目录，若使用 <code>--mount</code> 参数，则不会创建相应目录或文件，并提示报错。</li>
<li>对于 <code>bind mounts</code> 而言，其不存在 “容器目录内容自动复制至数据卷” 的类似情况，而是容器直接挂载并使用宿主机目录或文件。</li>
</ol>
<blockquote>
<p>有关绑定传播 (bind propagation) 的知识官方文档讲的很模糊，自己没有看懂。另外，官网文档中言及 “Bind propagation is an advanced topic and many users never need to configure it.”，所以可以省略这部分内容。</p>
</blockquote>
<h3 id="tmpfs-mounts"><a href="#tmpfs-mounts" class="headerlink" title="tmpfs mounts"></a>tmpfs mounts</h3><p>如果容器运行所产生的数据为无关数据，处理此数据的一种绝佳方法是使用 <code>tmpfs mounts</code>，如此操作后，这些数据便位于宿主机内存之中，从而减小容器大小。当容器停止运行后，这些数据会自动消失。</p>
<blockquote>
<p><code>tmpfs mounts</code> 仅限于 Linux 使用。</p>
<p><code>tmpfs mounts</code> 无法挂载于多个容器，而 <code>volumes</code> 和 <code>bind mounts</code> 可以。</p>
</blockquote>
<p>为使用 <code>tmpfs mounts</code>，我们可在启动容器时使用 <code>--tmpfs</code> 或 <code>--mount</code> 参数挂载容器特定目录至宿主机内存。举例如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 挂载centos的/var/lib目录至宿主机内存</span><br><span class="line">docker run --tmpfs /var/lib centos</span><br><span class="line">docker run --mount <span class="string">&#x27;type=tmpfs,dst=/var/lib&#x27;</span> centos</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>--tmpfs</code> 与 <code>--mount</code> 的区别在于：前者不允许配置 <code>tmpfs</code> 相关选项 (具体指代 <code>tmpfs-size</code> 和 <code>tmpfs-mode</code>)，且不能被用于 <code>swarm service</code>。</p>
</blockquote>
<h2 id="network-网络"><a href="#network-网络" class="headerlink" title="network (网络)"></a>network (网络)</h2><p>容器间相互通信，依赖于 Docker 强大的网络功能。</p>
<p>Docker 网络架构由三部分组成：Container Network Model (CNM)、Libnetwork、驱动程序，其中 CNM 为网络设计标准，它规定了 Docker 网络架构的基本组成要素；Libnetwork 为 CNM 的具体实现；驱动程序提供不同的网络拓扑实现。</p>
<h3 id="CNM"><a href="#CNM" class="headerlink" title="CNM"></a>CNM</h3><p>CNM 规定了三个基本组成要素：沙盒 (Sandbox)、终端 (Endpoint)、网络 (Network)，其中沙盒是一个独立的网络栈，包括以太网接口、端口、路由表、DNS配置等内容；终端指代虚拟网络接口，负责将沙盒连接至网络；网络为 802.1d 网桥的软件实现。三者连接关系如图所示：</p>
<img src="/2021/01/30/docker/docker3-volumeAndNetwork/image-20210207134013720.png" width="30%">

<h3 id="驱动程序"><a href="#驱动程序" class="headerlink" title="驱动程序"></a>驱动程序</h3><p>Docker 内置若干驱动程序，包括 bridge、overlay、host、macvlan、none，我们在此一一介绍。</p>
<ul>
<li><p>bridge</p>
<p>bridge network  仅适用于单机 (single docker daemon host) 使用，借助于链路层软件设备——网桥，实现在所负责网段之内转发流量。</p>
<p>Docker 内置一个默认 bridge network。容器启动时，如果未使用 <code>--network</code> 参数指定网络，则其存在于默认 bridge network。当然，用户也可自定义 bridge network。</p>
<p>自定义 bridge network 与默认 bridge network 的区别：</p>
<ol>
<li>前者提供容器之间的 DNS 解析，而后者不提供。在默认 bridge network 之中，容器间通信只能基于 IP 地址 (一种取巧方式是使用 <code>--link</code>，随后使用容器名通信。其实际是在容器的 hosts 文件下添加一条 IP 地址与容器名的映射，因此其本质仍是基于 IP 地址进行通信)。而在自定义 bridge network 之中，容器间可基于 IP 地址、容器名、网络别名实施通信。</li>
<li>前者可以提供更好的隔离性能。未使用 <code>--network</code> 指定网络的容器均归于默认 bridge network，这使得其中包含各种应用，鱼龙混杂，无法提供较好的隔离。</li>
<li>对于前者而言，容器可随时连接或断开连接；对于后者而言，如果希望断开连接，需要停止容器并以合适的网络选项重新启动它。</li>
<li>对于后者而言，基于 <code>--link</code> 参数启动的容器与 link 对象容器共享相同的环境变量。</li>
</ol>
</li>
<li><p>overlay</p>
<p>overlay network 适用于多机 (multiple docker daemon host) 间构建分布式网络，借助于 VXLAN 隧道技术，实现分布式网络内转发流量。</p>
<p>当初始化 swarm 或添加 Docker host 至现有 swarm 时，两个网络被自动创建：ingress，一个默认 overlay network；docker_gwbridge，一个桥接网络，允许容器访问外网。</p>
</li>
<li><p>host</p>
<p>如果某个容器使用 host network，则其与宿主机共享相同的网络栈 (例如，IP 地址、端口)。</p>
</li>
<li><p>macvlan</p>
<p>….</p>
</li>
<li><p>none</p>
<p>如果不希望容器使用网络功能，则可指定 <code>--network</code> 参数为 <code>none</code>。</p>
</li>
</ul>
<blockquote>
<p>这里涉及太多的网络知识，不懂。</p>
</blockquote>
]]></content>
      <categories>
        <category>docker学习</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>docker 基本操作</title>
    <url>/2021/01/14/docker/docker2-baseOperation/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在介绍 Docker 的基本操作之前，我们先行简单介绍一下 <code>Docker Engine</code>。</p>
<a id="more"></a>

<p><code>Docker Engine</code> 是一个 <em>客户端/服务器</em> 应用，具有如下重要组件：</p>
<ul>
<li>一个服务器，它是一种长期运行的程序，也称为守护进程 (daemon process)。</li>
<li>一套 REST API，实现与守护进程的通信。</li>
<li>一套命令行接口 (Command Line Interface)，可实现客户端与服务器的通信。</li>
</ul>
<img src="https://docs.docker.com/engine/images/engine-components-flow.png" width="35%">

<blockquote>
<p>借助于脚本或 CLI 命令，CLI 间接使用 REST API 以实现与服务器的交互 (这种间接关系也可从上图直观看到)。</p>
</blockquote>
<p>日常应用之中，我们主要使用 CLI 命令。因此，在本文之中，我们简单介绍 <code>image</code>、<code>container</code>、<code>registry</code> (<code>Docker</code> 的三大组成部分) 的相关操作。</p>
<blockquote>
<p>两种方式可查看具体 CLI 命令：其一，网站 <a href="https://docs.docker.com/reference/">https://docs.docker.com/reference/</a> ；其二，bash 窗口下使用命令 <code>docker xxx --help</code>。</p>
</blockquote>
<h2 id="image-镜像"><a href="#image-镜像" class="headerlink" title="image (镜像)"></a>image (镜像)</h2><p><code>image</code> 是一个只读文件，基于此可创建 <code>container</code>。为方便理解，可将其视为程序代码；同样地，<code>container</code> 可视为程序代码运行后对应的进程。</p>
<p><code>image</code> 对应的 CLI 命令可使用 <code>docker image --help</code> 进行查看：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Usage:  docker image COMMAND</span><br><span class="line"></span><br><span class="line">Manage images</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">  build       Build an image from a Dockerfile</span><br><span class="line">  history     Show the history of an image</span><br><span class="line">  import      Import the contents from a tarball to create a filesystem image</span><br><span class="line">  inspect     Display detailed information on one or more images</span><br><span class="line">  load        Load an image from a tar archive or STDIN</span><br><span class="line">  ls          List images</span><br><span class="line">  prune       Remove unused images</span><br><span class="line">  pull        Pull an image or a repository from a registry</span><br><span class="line">  push        Push an image or a repository to a registry</span><br><span class="line">  rm          Remove one or more images</span><br><span class="line">  save        Save one or more images to a tar archive (streamed to STDOUT by default)</span><br><span class="line">  tag         Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE</span><br></pre></td></tr></table></figure>
<p>根据命令功能将它们分门别类，并简要介绍如下：</p>
<ul>
<li><p>构建相关</p>
<p><code>build</code>  –&gt;  根据 Dockerfile 配置文件，构建一个 <code>image</code>。</p>
<p><code>import</code>  –&gt;  根据归档文件内容，创建一个 <code>image</code> (<code>export</code> 后续会介绍)。</p>
<p><code>load</code>  –&gt;  根据归档文件或标准输入流内容，创建一个 <code>image</code>。</p>
<p><code>save</code>  –&gt;  保存一个或多个 <code>image</code> 至标准输出流或归档文件。</p>
<p><code>pull</code>  –&gt;  从 <code>registry</code> 处拉取一个 <code>image</code> (<code>registry</code> 后续会介绍)。</p>
<p><code>push</code>  –&gt;  上传一个 <code>image</code> 至 <code>registry</code>。</p>
<blockquote>
<p><code>save/load</code> 互为一组命令，保存 <code>image</code> 至归档文件，然后加载归档文件为 <code>image</code>，其中归档文件不仅保有 <code>image</code> 的具体内容，也保有 <code>image</code> 的各种元数据、历史记录。<code>import/export</code> 互为一组命令，导出容器至归档文件，然后导入归档文件为 <code>image</code>，其中归档文件仅保存容器状态 (类似于虚拟机快照)，而不保存任何额外信息。因此，相较于基于 <code>export</code> 得到的归档文件，基于 <code>save</code> 得到的归档文件所占容量往往偏大。</p>
</blockquote>
</li>
<li><p>查看相关</p>
<p><code>ls</code>  –&gt;  列举所有 <code>image</code> 。</p>
<p><code>inspect</code>  –&gt;  显示一个或多个 <code>image</code> 的详细信息。</p>
<p><code>history</code>  –&gt;  显示一个 <code>image</code> 的历史操作记录。</p>
</li>
<li><p>修改相关</p>
<p><code>tag</code>  –&gt;  为指定 <code>image</code> 创建一个标签。</p>
</li>
<li><p>删除相关</p>
<p><code>rm</code>  –&gt;  删除一个或多个 <code>image</code>。</p>
<p><code>prune</code>   –&gt;  删除无用的 <code>image</code> (默认指代 dangling image)。</p>
<blockquote>
<p>官网解释：A dangling image is one that is not tagged and is not referenced by any container。我们在此说明使用过程中产生 dangling image 的一种情景：编写 <code>image</code> 构建脚本并运行它，我们将得到一个 <code>image</code>；假定修改脚本相关配置但是不修改镜像名和标签，此时再次运行脚本，我们将再次得到一个 <code>image</code>。此时第一个 <code>image</code> 便成为 dangling image，使用 <code>docker image ls</code> 命令，我们将会得到如下内容 (第一个 <code>image</code> 所对应标识被清空，并被置为 <code>&lt;none&gt;</code>)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">REPOSITORY   TAG        IMAGE ID      ...</span><br><span class="line">image       0.0.3     e5d7b72aad05    ...</span><br><span class="line">&lt;none&gt;      &lt;none&gt;    8e2b049f9783    ...</span><br></pre></td></tr></table></figure>

<p>对于 <code>prune</code> 命令而言，如果指定 <code>-a</code> 参数，同样会删除未被任何容器引用的 <code>image</code>。</p>
</blockquote>
</li>
</ul>
<h2 id="container-容器"><a href="#container-容器" class="headerlink" title="container (容器)"></a>container (容器)</h2><p><code>container</code> 是 <code>image</code> 的运行实例。它对应的 CLI 命令可使用 <code>docker container --help</code> 进行查看：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Usage:  docker container COMMAND</span><br><span class="line"></span><br><span class="line">Manage containers</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">  attach      Attach local standard input, output, and error streams to a running container</span><br><span class="line">  commit      Create a new image from a container&#39;s changes</span><br><span class="line">  cp          Copy files&#x2F;folders between a container and the local filesystem</span><br><span class="line">  create      Create a new container</span><br><span class="line">  diff        Inspect changes to files or directories on a container&#39;s filesystem</span><br><span class="line">  exec        Run a command in a running container</span><br><span class="line">  export      Export a container&#39;s filesystem as a tar archive</span><br><span class="line">  inspect     Display detailed information on one or more containers</span><br><span class="line">  kill        Kill one or more running containers</span><br><span class="line">  logs        Fetch the logs of a container</span><br><span class="line">  ls          List containers</span><br><span class="line">  pause       Pause all processes within one or more containers</span><br><span class="line">  port        List port mappings or a specific mapping for the container</span><br><span class="line">  prune       Remove all stopped containers</span><br><span class="line">  rename      Rename a container</span><br><span class="line">  restart     Restart one or more containers</span><br><span class="line">  rm          Remove one or more containers</span><br><span class="line">  run         Run a command in a new container</span><br><span class="line">  start       Start one or more stopped containers</span><br><span class="line">  stats       Display a live stream of container(s) resource usage statistics</span><br><span class="line">  stop        Stop one or more running containers</span><br><span class="line">  top         Display the running processes of a container</span><br><span class="line">  unpause     Unpause all processes within one or more containers</span><br><span class="line">  update      Update configuration of one or more containers</span><br><span class="line">  wait        Block until one or more containers stop, then print their exit codes</span><br></pre></td></tr></table></figure>
<p>根据命令功能将它们分门别类，并简要介绍如下：</p>
<ul>
<li><p>构建相关</p>
<p><code>create</code>  –&gt;  基于某个 <code>image</code> 创建一个 <code>container</code>。</p>
<p><code>export</code>  –&gt;  保存容器内容至一个归档文件。</p>
<p><code>commit</code>  –&gt;  基于当前容器构建一个 <code>image</code>。</p>
</li>
<li><p>运行相关</p>
<p><code>run</code>  –&gt;  基于某个 <code>image</code> 创建 <code>container</code>，并运行它。</p>
<p><code>attach</code>  –&gt;  链接本地标准输入、输出、错误流至一个运行的 <code>container</code>。</p>
<p><code>exec</code>  –&gt;  在运行的 <code>container</code> 中运行指定命令。</p>
<p><code>start</code>  –&gt;  启动运行指定 <code>container</code>。</p>
<p><code>pause</code>  –&gt;  暂停运行指定<code>container</code>。</p>
<p><code>unpause</code>  –&gt;  恢复运行指定 <code>container</code>。</p>
<p><code>stop</code>  –&gt;  停止运行指定 <code>container</code>，其首先发送 SIGTERM 信号至容器，等待一段时间后，发送 SIGKILL 信号以终止容器。</p>
<p><code>kill</code>  –&gt;  终止运行指定 <code>container</code>，其直接发送 SIGKILL 信号以终止容器。</p>
<p><code>restart</code>  –&gt;  重启运行指定 <code>container</code>。</p>
<p><code>wait</code>  –&gt;  阻塞运行指定 <code>container</code>，当容器停止运行时，将打印其退出码。</p>
</li>
<li><p>查看相关</p>
<p><code>ls</code>  –&gt;  列举所有 <code>container</code>。</p>
<p><code>inspect</code> –&gt;  显示一个或多个 <code>container</code> 的详细信息。</p>
<p><code>logs</code>  –&gt;  获取指定 <code>container</code> 的日志信息。</p>
<p><code>diff</code>  –&gt;  检查指定 <code>container</code> 文件系统哪些部分发生改动。</p>
<p><code>port</code>  –&gt;  显示指定 <code>container</code> 的端口映射信息。</p>
<p><code>stats</code>  –&gt;  显示指定 <code>container</code> 的资源统计信息。</p>
<p><code>top</code>  –&gt;  显示指定 <code>container</code> 中各运行进程信息。</p>
</li>
<li><p>删除相关</p>
<p><code>rm</code>  –&gt;  删除一个或多个 <code>container</code>。</p>
<p><code>prune</code>   –&gt;  删除已停止的 <code>container</code>。</p>
</li>
<li><p>其他</p>
<p><code>cp</code>  –&gt;  在本机与指定 <code>container</code> 间拷贝文件或文件夹。</p>
<p><code>rename</code>  –&gt;  重命名指定 <code>container</code>。</p>
<p><code>update</code>  –&gt;  更新一个或多个 <code>container</code> 的配置信息。</p>
</li>
</ul>
<p>容器属于 Docker 的核心组成部分，其运行往往存在众多参数可选。这些参数主要分为四类：与容器运行模式相关、与容器环境配置相关、与容器资源限制相关、安全保护相关。</p>
<p>下面简要介绍若干重要参数：</p>
<ul>
<li><code>--detach</code>  –&gt;  是否后台运行容器。</li>
<li><code>--interactive</code>  –&gt;  始终保持标准输入打开。</li>
<li><code>--net</code>  –&gt;  指定容器所处网络。</li>
<li><code>--publish-all</code>   –&gt;  将容器内所有暴露端口自动映射为本机临时端口。</li>
<li><code>--publish</code>  –&gt;  将容器内指定端口映射为本机指定端口</li>
<li><code>--tty</code>  –&gt;  是否分配一个伪终端。</li>
<li><code>--volume</code>  –&gt;  挂载数据卷至容器。</li>
<li><code>--ip</code>  –&gt;  指定容器的 IPV4 地址。</li>
<li><code>--env</code>  –&gt;  指定容器内的环境变量。</li>
<li><code>--name</code>  –&gt;  指定容器别名。</li>
<li><code>--memory</code>  –&gt;  限制容器可使用的内存。</li>
</ul>
<h2 id="registry-注册服务器"><a href="#registry-注册服务器" class="headerlink" title="registry (注册服务器)"></a>registry (注册服务器)</h2><p><code>registry</code> 是集中存放 <code>repository</code> (仓库) 的地方，其中 <code>repository</code>  用于集中存放同类型不同版本的镜像。</p>
<blockquote>
<p><code>registry</code> 与 <code>repository</code> 的关系可类比于 <code>github</code> 与 <code>repository</code> 的关系。</p>
</blockquote>
<p>与 <code>registry</code> 相关的 CLI 命令具体如下：</p>
<ul>
<li><p><code>docker search</code></p>
<p>在默认 <code>registry</code> 中搜索指定内容。</p>
</li>
<li><p><code>docker pull/docker image pull</code></p>
<p>从默认 <code>registry</code> 处拉取一个 <code>image</code>。</p>
</li>
<li><p><code>docker push/docker image push</code></p>
<p>上传一个 <code>image</code> 至默认 <code>registry</code>。</p>
</li>
</ul>
<p>数据卷  +  网络  +  Dockerfile  +  容器管理/编排  +  底层原理 (涉及Linux东西，比较难)</p>
<p>底层原理    镜像组织、容器具体是什么、存储驱动</p>
]]></content>
      <categories>
        <category>docker学习</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟化技术介绍</title>
    <url>/2021/01/05/docker/docker1-virtualization/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在计算机技术中，<strong>虚拟化</strong> 是一种资源管理技术，它将计算机的各种实体资源进行抽象转换，并呈现出来，从而打破实体结构间不可分割的障碍，使得用户可更高效地使用这些资源。</p>
<a id="more"></a>

<p>虚拟化技术比较复杂，本文仅介绍其中两个点 —— <em>硬件层的虚拟化</em> 和 <em>操作系统层的虚拟化</em>。</p>
<h2 id="硬件层的虚拟化"><a href="#硬件层的虚拟化" class="headerlink" title="硬件层的虚拟化"></a>硬件层的虚拟化</h2><p><em>硬件层的虚拟化</em> 借助于 Hypervisor 抽象管理硬件资源，并为上层提供虚拟硬件以构建虚拟机，从而实现虚拟化。此种虚拟化技术比较简单、常见，代表性产品有 VMware、VirtualBox。</p>
<p>下图所示为物理机与虚拟机的结构分层图。</p>
<img src="/2021/01/05/docker/docker1-virtualization/image-20201227193743565.png" width="30%">

<p>对于物理机而言，操作系统所发指令直接作用于硬件之上。对于虚拟机而言，操作系统所发指令作用于虚拟机 (虚拟硬件) 之上，随后虚拟机将指令传递给 Hypervisor，最终指令作用于硬件之上。</p>
<p>据此可以得知：由于虚拟机指令的执行涉及若干次传递，因此其性能劣于物理机 (实际情况是，虚拟机性能相当劣于物理机性能)。</p>
<blockquote>
<p>就 <em>硬件层的虚拟化</em> 而言，Hypervisor 属于核心点。对于下层，它负责抽象并管理物理资源；对于上层，它负责分配虚拟资源并管理虚拟机。</p>
</blockquote>
<p>根据 Hypervisor 的所处位置，可具体分为如下两种 (Type-1 和 Type-2)：</p>
<img src="/2021/01/05/docker/docker1-virtualization/image-20201227203230290.png" width="70%">

<p>对于 Type-1 而言，Hypervisor 直接位于硬件之上；对于 Type-2 而言，Hypervisor 位于操作系统之上或之内。</p>
<p>在此两种类型之上，又可具体分为如下几种：</p>
<ul>
<li><p>寄居虚拟化</p>
<p>属于 Type-2。它是最为常见的虚拟化架构，VMware Workstation 即是此种。</p>
<p>优点：简单、易于实现。</p>
<p>缺点：依赖于物理机操作系统、性能开销大。</p>
</li>
<li><p>裸金属虚拟化</p>
<p>属于 Type-1。</p>
<p>优点：不依赖于具体操作系统。</p>
<p>缺点：虚拟层内核开发难度很大。</p>
</li>
<li><p>操作系统虚拟化 (容器化)</p>
<p>既不属于 Type-1，也不属于 Type-2。对于该种架构而言，其中并不存在 Hypervisor，即不存在对硬件资源的抽象化。它对操作系统内核进行虚拟化，从而实现用户应用隔离。因为用户应用之外需要添加额外的模板库文件，因此其整体称为容器。</p>
<p>优点：简单、易于实现、管理开销十分低。</p>
<p>缺点：隔离性差，多应用共享同一操作系统。</p>
</li>
<li><p>混合虚拟化</p>
<p>属于 Type-2，其虚拟化层直接嵌于操作系统之内。</p>
<p>优点：相比于寄居虚拟化而言，指令所需传递次数较少，因而具有更高性能。</p>
<p>缺点：底层硬件需支持扩展功能。</p>
</li>
</ul>
<p><img src="/2021/01/05/docker/docker1-virtualization/image-20201227204011674.png"></p>
<h2 id="操作系统层的虚拟化"><a href="#操作系统层的虚拟化" class="headerlink" title="操作系统层的虚拟化"></a>操作系统层的虚拟化</h2><p><em>操作系统层的虚拟化</em> 借助于操作系统提供的若干特性，为应用提供相互隔离的资源以构建不同的虚拟环境，从而实现虚拟化。此种虚拟化技术比较流行，代表性产品有 Docker。</p>
<p>下图所示为此种虚拟化技术的结构分层图。</p>
<p><img src="/2021/01/05/docker/docker1-virtualization/image-20201227204011674%20-%20%E5%89%AF%E6%9C%AC.png"></p>
<p>从中可以看到：应用与必须的系统模板库共同构建成为虚拟容器，该虚拟容器作为一个 <em>单独应用</em> 运行于操作系统之上 (正因如此，<em>操作系统层的虚拟化</em> 也称为 <em>容器化</em>)。相比于物理机运行应用而言，该种虚拟化技术仅在应用之上添加了一个外层，因此其性能略差于物理机性能。</p>
<h2 id="两种虚拟化的比较"><a href="#两种虚拟化的比较" class="headerlink" title="两种虚拟化的比较"></a>两种虚拟化的比较</h2><p>对于 <em>硬件层的虚拟化</em> 和 <em>操作系统层的虚拟化</em> 而言，二者区别如下：</p>
<img src="/2021/01/05/docker/docker1-virtualization/%E5%AE%B9%E5%99%A8%E5%92%8C%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AF%B9%E6%AF%94.png" width="70%">

<h2 id="容器化与-Docker"><a href="#容器化与-Docker" class="headerlink" title="容器化与 Docker"></a>容器化与 Docker</h2><p>容器化基于操作系统提供的若干特性以构建容器。基于操作系统直接构建容器比较麻烦，因此众多容器技术出现以简化此过程，例如 Docker、Rocket。</p>
<p>Docker 是一个开源引擎，可以轻松地为任何应用创建一个轻量级的、可移植的、自给自足的容器。在此基础之上，它为应用的开发和部署提供一站式解决方案。</p>
<p>下图所示为 Docker 的结构分层图，其中 Docker Engine 仅负责管理容器，指令运行不涉及 Docker Engine 的传递。</p>
<img src="/2021/01/05/docker/docker1-virtualization/image-20210105171821597.png" width="35%">]]></content>
      <categories>
        <category>docker学习</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>git 工作流程</title>
    <url>/2020/12/22/git/gitstudy6-workflow/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>git 作为一种源码管理系统，不可避免地涉及到多人协作。为提升项目开发效率，若干种规范化的工作流程 (workflow) 被提出。</p>
<p>本文之中，我们介绍三种常见的工作流程：Git Flow、Github Flow、Gitlab Flow。</p>
<a id="more"></a>

<h2 id="Git-Flow"><a href="#Git-Flow" class="headerlink" title="Git Flow"></a>Git Flow</h2><img src="/2020/12/22/git/gitstudy6-workflow/5228524-c1f45f59fa064059.png" width="30%" alt="图一：Git Flow 工作流程">

<p>Git Flow 之中，master 分支和 develop 分支为两个长期分支；其余分支均为短期分支，相关功能开发完成后，其将被合并至长期分支。</p>
<ul>
<li><p>master 分支</p>
<p>用于存放对外发布的稳定版本。它只能通过合并其他分支而得到。</p>
</li>
<li><p>develop 分支</p>
<p>用于存放项目开发的最新版本。当向项目中添加新功能时，就会新建 feature 分支，随后在此分支中开发功能。功能开发及测试完成后，此分支就会被合并至 develop 分支。</p>
</li>
<li><p>feature 分支</p>
<p>用于开发某个功能点。</p>
</li>
<li><p>release 分支</p>
<p>当管理人员认为 develop 分支所代表的项目功能已经开发完成，此分支就会被合并至 release 分支。测试人员在此分支上进行最终测试，如果通过测试则合并至 master 分支。</p>
</li>
<li><p>hotfix 分支</p>
<p>当稳定版本发现 Bug，管理人员便会生成 hotfix 分支以紧急修复，随后将其合并至 master 分支和 develop 分支。</p>
</li>
</ul>
<p>Git Flow 具有如下优缺点：</p>
<ul>
<li><p>优点</p>
<p>分支清晰、可控。</p>
</li>
<li><p>缺点</p>
<p>分支众多，比较复杂。</p>
</li>
</ul>
<blockquote>
<p>对于 Git Flow 而言，长期分支 develop 用于开发，涉及频繁操作；长期分支 master 用于发布，不定期产生稳定版本。鉴于两者的使用频率不同，该种工作流程适用于“版本发布”类型的项目 (不定期上线新版本)。</p>
</blockquote>
<h2 id="Github-Flow"><a href="#Github-Flow" class="headerlink" title="Github Flow"></a>Github Flow</h2><p>鉴于 Git Flow 过于麻烦，Github Flow 被提出。它是一个简化版的 Git Flow，其中仅有一个长期分支—— master 分支。</p>
<p><img src="/2020/12/22/git/gitstudy6-workflow/bg2015122305.png" alt="图二：Github Flow 工作流程"></p>
<p>Github Flow 的使用流程如下：</p>
<ol>
<li>根据需求，从 master 拉取新分支。</li>
<li>新分支功能开发完成后，向 master 发起 <code>pull merge</code> 请求。</li>
<li>master 负责人测试新分支功能，如果没有问题，可合并其至 master。</li>
</ol>
<blockquote>
<p>对于 Github Flow 而言，长期分支 master 不仅用作开发，也用作发布，即 master 分支的开发与发布是同步的。鉴于此，该种工作流程适用于“持续发布”类型的项目。</p>
<p>可以看到，这种工作流程十分适用于开源项目，但是极大概率不适用于公司项目 (毕竟开发和发布之间往往存在间隔)。</p>
</blockquote>
<h2 id="Gitlab-Flow"><a href="#Gitlab-Flow" class="headerlink" title="Gitlab Flow"></a>Gitlab Flow</h2><p>Gitlab Flow 综合了 Git Flow 和 Github Flow 两者的优点，从而使得其可同时适用于“版本发布”类型和“持续发布”类型的项目开发。</p>
<p>Gitlab Flow 的最主要原则为 **上游优先 (upstream first)**，即 master 分支为所有其他分支的上游分支，当下游分支出现 Bug 时，其会开启分支进行修复，随后将此分支合并至 master 分支，master 分支再往出现 Bug 的分支合并其内容。</p>
<h3 id="持续发布"><a href="#持续发布" class="headerlink" title="持续发布"></a>持续发布</h3><p>对于“持续发布”类型的项目而言，Gitlab Flow 建议：除 master 分支外，建立其他环境分支。例如，master 分支用于开发环境、pre-production 分支用于预发环境，production 分支用于生产环境；且master 分支为 pre-production 分支的“上游分支”，pre-production 分支为 production 的“上游分支”。</p>
<img src="/2020/12/22/git/gitstudy6-workflow/bg2015122306.png" width="30%">

<h3 id="版本发布"><a href="#版本发布" class="headerlink" title="版本发布"></a>版本发布</h3><p>对于“版本发布”类型的项目而言，Gitlab Flow 建议：每发布一个稳定版本，就从 master 分支中拉取一个分支。</p>
<img src="/2020/12/22/git/gitstudy6-workflow/bg2015122307.png" width="30%">]]></content>
      <categories>
        <category>git学习</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>git merge的合并策略</title>
    <url>/2020/12/21/git/gitintroduce1-mergeStrategy/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>git merge</code> 的合并策略分为两种 —— fast-forward 和“三方合并”。fast-forward 合并策略的使用场景及具体操作已经介绍于 <a href="/2020/10/05/git/gitstudy3-branchOperation/" title="git 分支操作">git 分支操作</a>，本文主要介绍“三方合并”相关内容。</p>
<a id="more"></a>

<h2 id="三方合并"><a href="#三方合并" class="headerlink" title="三方合并"></a>三方合并</h2><p>如果当前分支不是待合并分支的前驱，此时便不会执行 fast-forward 合并策略，而是执行“三方合并”  (以当前分支所在快照、待合并分支所在快照、两分支最近公共祖先所在快照为依据，实施合并)。</p>
<img src="/2020/12/21/git/gitintroduce1-mergeStrategy/image-20201004193646647.png" alt="图一：三方合并场景" width="40%" height="40%">

<p>在介绍“三方合并”之前，我们先行谈谈为什么不能使用“二方合并” (以当前分支所在快照、待合并分支所在快照为依据，实施合并)？</p>
<p>为回答这个问题，我们使用例子进行说明。</p>
<p>假定需要合并文件 <code>1bdd3be5</code> 和 <code>d6c1b0e2</code>，且其内容展示如下：</p>
<p><img src="/2020/12/21/git/gitintroduce1-mergeStrategy/image-20201221202140807.png"></p>
<p>通过对比两个文件，我们发现第1,2,4,5行内容不同，便认为这些地方所示内容冲突。如果仅根据此冲突信息进行合并，那么将会得到：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; <span class="string">HEAD</span></span><br><span class="line"><span class="string">1</span></span><br><span class="line"><span class="string">=======</span></span><br><span class="line"><span class="string">5</span></span><br><span class="line"><span class="string">&gt;&gt;&gt;&gt;&gt;&gt;&gt; branch</span></span><br><span class="line"><span class="string">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span></span><br><span class="line">2</span><br><span class="line">=======</span><br><span class="line">4</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; branch</span><br><span class="line">3</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>仔细观察合并文件，可以发现：它仅提供了冲突信息，并没有任何合并功能的体现。由此我们可以得出结论：<em>仅提供当前分支所在快照、待合并分支所在快照信息，而不提供任何上下文信息，无法执行合并操作</em>。</p>
<p>在“三方合并”之中，它需要两分支最近公共祖先所在快照信息，从而据此提供上下文信息，并以此顺利实现合并操作。</p>
<p>假定需要合并文件 <code>1bdd3be5</code> 和 <code>d6c1b0e2</code>，并且两者祖先文件为 <code>ba8beb31</code>，三者内容展示如下：</p>
<p><img src="/2020/12/21/git/gitintroduce1-mergeStrategy/image-20201221210120443.png"></p>
<p>基于祖先文件内容，我们可以得知当前文件对祖先文件进行了哪些修改 (使用 ‘*’ 加以标记)：</p>
<p><img src="/2020/12/21/git/gitintroduce1-mergeStrategy/image-20201221210247460.png"></p>
<p>对于待合并文件而言，如果一者某部分内容已修改而另一者未曾修改，则合并后的内容为修改后的内容；如果两者均已修改，则需显示冲突信息，等待用户自己决定应当保留哪部分数据。根据此原则，合并后的文件内容如下：</p>
<p><img src="/2020/12/21/git/gitintroduce1-mergeStrategy/image-20201221210547803.png"></p>
<blockquote>
<p>注意：最近公共祖先所在快照信息的不同，可能会引发不同的合并结果。</p>
</blockquote>
]]></content>
      <categories>
        <category>git学习</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>git 基本原理</title>
    <url>/2020/10/08/git/gitstudy5-basePrinciple/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文简要介绍 <code>git</code> 版本控制系统的内部工作原理。</p>
<a id="more"></a>

<p>在介绍具体工作原理之前，需要声明如下几点：</p>
<ol>
<li>从本质来讲，Git 是一个 <strong>内容寻址 (content-addressable) 文件系统</strong>，其核心部分是一个简单的键值对数据库 (key-value data store)。当我们向 Git 中插入任意类型的数据时，它以键值对方式存储该数据，并返回一个唯一标识的键值，借助于该键值，我们可引用至该数据。</li>
<li>Git 提供两种指令 —— 上层指令和底层指令，上层指令允许我们以更友好地方式使用版本控制系统，底层指令帮助我们以更直观地方式理解版本控制系统。故而，此节之中会涉及若干底层指令。</li>
</ol>
<h2 id="Git-目录"><a href="#Git-目录" class="headerlink" title="Git 目录"></a>Git 目录</h2><p>当在一个空目录下执行 <code>git init</code> 命令时，Git 会创建一个 <code>.git</code> 目录，该目录几乎包含了 Git 存储和操纵所需的任何内容。<code>.git</code> 目录中各文件或文件夹的具体作用列举如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">config  ==&gt; 本地库配置相关内容。</span><br><span class="line">description  ==&gt; 仅供GitWeb程序使用，无需关心。</span><br><span class="line">HEAD  ==&gt; 指代HEAD指针，其内容指向项目的当前分支。(重点)</span><br><span class="line">index  ==&gt; 虽尚未创建，但是它保存暂存区信息。(重要)</span><br><span class="line">hooks/  ==&gt; 与客户端和服务端相关的钩子脚本集，基本无需关心。</span><br><span class="line">info/  ==&gt; 仅包含一个全局性排除文件exclude，与.gitignore类似。</span><br><span class="line">objects/  ==&gt; 存储所有数据内容。(重要)</span><br><span class="line">refs/  ==&gt; 存储分支、标签、远程仓库等所指向的提交记录。(重要)</span><br></pre></td></tr></table></figure>
<p>接下来，我们主要介绍标识为 “<strong>(重点)</strong>“ 的文件或文件夹，它们均为 Git 的核心内容。</p>
<h3 id="objects-目录"><a href="#objects-目录" class="headerlink" title="objects 目录"></a>objects 目录</h3><p><code>ojbects</code> 目录存储所有数据内容，具体包括 <code>git object</code>、<code>tree object</code>、<code>commit object</code>、<code>tag object</code>。正因其存储数据，Git 的键值对数据库本质在此体现地淋漓尽致。</p>
<p>我们首先依次介绍 <code>git object</code>、<code>tree object</code>、<code>commit object</code> 、<code>tag-object</code>。由于它们在目录 <code>objects</code> 中存储形式一致，所以我们仅在 <code>git object</code> 中展现各种操作完成后的目录情况。另外，由于数据存储仍涉及其他具体操作，故而我们在 <a href="#%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8">对象存储</a> 一节中详细描述存储过程，并在此节中介绍 <code>objects</code> 目录中两个子目录 <code>info</code> 和 <code>pack</code> 的作用。</p>
<h4 id="git-object"><a href="#git-object" class="headerlink" title="git object"></a>git object</h4><p><code>git object</code> 用于存储 Git 数据对象。底层命令 <code>git hash-object</code> 可将任意数据保存于 <code>objects</code> 目录，并返回与其相关的唯一标识。</p>
<p>我们首先说明 <code>objects</code> 目录情况：当前目录下存在两个空目录 —— <code>info</code> 和 <code>pack</code>。</p>
<p>控制台输入 <code>echo &#39;test content&#39; | git hash-object -w --stdin</code> (参数 <code>-w</code> 表示获取对应散列值并将其存入 Git 数据库)，它将手动创建一个数据对象并基于命令 <code>git hash-object</code>  将其存入 Git 数据库中，随后控制台输出如下内容，它为此数据对象的唯一标识，其本质是一个 <code>SHA-1</code> 散列值。</p>
<p><img src="/2020/10/08/git/gitstudy5-basePrinciple/image-20201007230816329.png"></p>
<p>此时我们查看 <code>objects</code> 目录情况：当前目录下存在两个空目录 —— <code>info</code> 和 <code>pack</code>、一个子目录 <code>d6</code>，且子目录 <code>d6</code> 中存储二进制文件 <code>70460b4b4aece5915caf5c68d12f560a9fe3e4</code>。</p>
<p>根据 <code>objects</code> 目录情况，可以总结得到：<strong>Git 将待存储数据映射为一个 <code>SHA-1</code> 散列值，并以此散列值的前 2 个字符作为子目录，后 38 个字符作为文件名重新命名待存储数据</strong>。</p>
<p>为进行验证，我们可以使用底层命令 <code>git cat-file -p &lt;hash&gt;</code> (参数 <code>-p</code> 表示自动推断内容类型并大致显示其结果)查看指定键值所对应文件内容：</p>
<p><img src="/2020/10/08/git/gitstudy5-basePrinciple/image-20201007231028751.png"></p>
<p>接下来，我们使用如下命令，向当前目录中添加一个文件并将其存入 Git 数据库、随后修改此文件，同时将其存入 Git 数据库：</p>
<p><img src="/2020/10/08/git/gitstudy5-basePrinciple/image-20201008091800933.png"></p>
<p>此时查看 <code>objects</code> 目录，可以发现：两个版本的 <code>test.txt</code> 文件皆存在；查看 <code>git253</code> 目录，可以发现：存在 <code>test.txt</code> 文件，且其内容为 “version 2 –253”。</p>
<p>随后删除 <code>git253</code> 目录中 <code>test.txt</code> 文件，随后使用 <code>objects</code> 目录中 <code>test.txt</code> 文件进行恢复，可以看到恢复成功。</p>
<p><img src="/2020/10/08/git/gitstudy5-basePrinciple/image-20201008092246858.png"></p>
<p>至此，我们已基本了解：文件如何存储于 Git 数据库，且其以何种方式存储于 Git 数据库。然而，我们需要注意两点：记住每个文件每个版本的 <code>SHA-1</code> 散列值并不现实、基于命令 <code>git hash-object</code> ，我们仅存储其内容，而没有存储其对应文件名。</p>
<blockquote>
<p><strong>基于 <code>git hash-object</code> 得到的数据对象，Git 中称为 <code>blob</code> 类型数据</strong>。使用命令 <code>git cat-file -t &lt;hash&gt;</code> ，我们可查看指定内容的具体类型。</p>
</blockquote>
<h4 id="tree-object"><a href="#tree-object" class="headerlink" title="tree object"></a>tree object</h4><p><code>git object</code> 解决了数据存储问题，<code>tree object</code> 则解决了数据对应文件名的存储问题。</p>
<p><code>tree object</code> 就是一棵树，其中存储若干树记录 <code>tree entry</code>。对于每条记录而言，其存储指向 <code>tree object</code> 或 <code>git object</code> 的 <code>SHA-1</code> 散列值以及相应内容的文件模式类型 (不同文件具有不同的模式类型，例如：100644 表示普通文件、100755 表示可执行文件、120000 表示符号链接、040000 表示目录)、文件类型 (Git 数据库中存储的实际类型，<code>git object</code> 对应 <code>blob</code>，<code>tree object</code> 对应 <code>tree</code>)、文件名。</p>
<p>命令 <code>git cat-file -p master^&#123;tree&#125;</code> 用于查看当前分支最新提交所对应的 <code>tree object</code>：</p>
<p><img src="/2020/10/08/git/gitstudy5-basePrinciple/image-20201008103948260.png"></p>
<p>我们使用图例形象化表示此 <code>tree object</code>：</p>
<p><img src="/2020/10/08/git/gitstudy5-basePrinciple/image-20201008105107988.png"></p>
<p>事实上，Git 会根据某时刻暂存区状态使用命令 <code>git write-tree</code> 自动创建一个 <code>tree object</code>，并返回相应的 <code>SHA-1</code> 散列值。</p>
<h4 id="commit-object"><a href="#commit-object" class="headerlink" title="commit object"></a>commit object</h4><p>就本质而言，<code>tree object</code> 便是 <strong>项目快照</strong>。如果我们想使用项目快照，就需要完全记住各项目快照所对应的 <code>SHA-1</code> 散列值。而这并不现实，因此 Git 使用 <code>commit-object</code> 保存项目快照信息。</p>
<p><code>commit-object</code> 表示为一个提交记录，其中包含待提交的 <code>tree object</code>、父提交 <code>commit-object</code>、提交者姓名、提交者电子邮件、提交时间戳、提交说明。底层命令 <code>git commit-tree &lt;tree-object-hash&gt; -p &lt;parent-hash&gt; -m &lt;commit-message&gt;</code> 可用于手动创建一个提交记录，并返回相应的 <code>SHA-1</code> 散列值。</p>
<h4 id="tag-object"><a href="#tag-object" class="headerlink" title="tag object"></a>tag object</h4><p>相比上面三种对象而言，<code>tag object</code> 显得可有可无。由于附注标签需要存储多种信息，因此底层实现中使用 <code>tag object</code> 进行存储。<br>对于 <code>tag object</code> 而言，其中包含提交者姓名、提交者电子邮件、提交时间戳、提交说明、某 <code>commit object</code>的 <code>SHA-1</code> 散列值。</p>
<blockquote>
<p>对于 <code>tag object</code> 而言，其可以不提交某 <code>commit object</code> 的 <code>SHA-1</code> 散列值，转而提交其他信息，例如某 <code>git object</code> 的 <code>SHA-1</code> 散列值。</p>
</blockquote>
<h4 id="对象存储"><a href="#对象存储" class="headerlink" title="对象存储"></a>对象存储</h4><p>我们在此简要描述 Git 存储对象的具体过程：</p>
<ol>
<li><p>基于待存储数据内容，计算头部信息 header。header 共分为四大部分，具体如下：</p>
<ul>
<li><p>获取待存储数据类型 (<code>blob</code>、<code>tree</code> 或 <code>commit</code>)，并以此作为 header 的第一部分内容。</p>
</li>
<li><p>空格作为 header 的第二部分内容。</p>
</li>
<li><p>获取待存储数据长度，并以此作为 header 的第三部分内容。</p>
</li>
<li><p>空字节作为 header 的第四部分内容。</p>
</li>
</ul>
<p>举例而言，对于文本串 <code>what is up, doc?</code> 而言，其对应 header 为 <code>blob 16 \0</code>。</p>
</li>
<li><p> 将 header 与待存储数据内容拼接起来，计算其 <code>SHA-1</code> 散列值 (它将作为存储数据的唯一标识返回)。</p>
</li>
<li><p>使用 zlib 压缩待存储数据，并基于路径构建原则 “``SHA-1` 散列值的前 2 个字符作为子目录名称，后 38 个字符则作为子目录内待存储数据对应的文件名” ，将数据存储至其中。需要注意：<strong>如果子目录或指定文件不存在，则创建相应内容，随后写入数据。如果指定文件存在，则重写之</strong>。</p>
</li>
</ol>
<p>基于上面所得知识，可以知道：当使用命令 <code>git add</code> 添加工作区文件至暂存区时，Git 一定会将修改过的文件添加到 <code>objects</code> 目录中 (即使该文件曾经已经被添加至 <code>objects</code> 目录，但是由于内容不同，故而需要再次添加)。这样就会引申出一个问题：当频繁使用命令 <code>git add</code> 后，<code>objects</code> 目录将会存在同一文件的众多版本。这种情况将会使得 <code>objects</code> 目录所占空间迅速增大，那么 Git 是如何解决此问题的？</p>
<p>与其他集中式版本控制系统类似，Git 基于保存文件差异实现压缩空间。具体而言，最初 zlib 压缩所采用的格式为 <em>松散对象格式</em>。当目录中松散格式文件过多、向远程服务器推送项目、或者手动输入命令 <code>git gc</code> 时，Git 会根据文件名和文件大小将松散格式文件打包为若干基于二进制存储的 <strong>包文件</strong>。</p>
<p>包文件存在于 <code>objects/pack</code> 目录之下，每个包文件具体对应两个文件 —— <code>xxx.idx</code> 索引文件和 <code>xxx.pack</code> 存储对象打包文件，其中 <code>xxx.pack</code> 存储相关对象的打包结果，<code>xxx.idx</code> 存储各数据对象在打包文件中的偏移位置。</p>
<blockquote>
<p><code>objects/info</code> 目录存储一些附加信息，似乎不太重要。</p>
</blockquote>
<h3 id="refs-目录"><a href="#refs-目录" class="headerlink" title="refs 目录"></a>refs 目录</h3><p>当需要查看特定提交记录的具体内容时，我们可以直接使用相应的 <code>SHA-1</code> 散列值进行获取，但是这种方法比较繁琐。如果我们可以使用别名替代 <code>SHA-1</code> 散列值，则该操作将变得简单、易用。在 Git 中，它使用 <strong>引用 (ref)</strong> 达成此效果，其实质在于：在特定位置存放与引用名同名的文件，该文件中存放特定提交记录的 <code>SHA-1</code> 散列值。当使用引用时，Git 会自动将其替换为该引用所对应文件中的 <code>SHA-1</code> 散列值。</p>
<p>Git 中所有引用文件均位于 <code>refs</code> 目录，这些引用文件分别对应于分支 (其均位于 <code>.git/refs/heads</code>)、标签 (其均位于 <code>.git/refs/tags</code>)、远程跟踪分支 (其均位于 <code>.git/refs/remotes</code>)。</p>
<p><img src="/2020/10/08/git/gitstudy5-basePrinciple/image-20201008171841959.png"></p>
<p>按照 Git 引用原理，我们可通过写入一个 <code>SHA-1</code> 散列值至文件，从而得到该散列值的引用，其具体命令为 <code>echo &lt;hash&gt; &gt; ./git/refs/heads/&lt;fileName&gt;</code>。</p>
<p>由于直接编辑文件比较危险，Git 提供命令 <code>git update-ref &lt;refName&gt; &lt;commit-id&gt;</code> 以更新指定文件内容，其中 <code>refName</code> 具体为 <code>refs/**</code>。举例：命令 <code>git update-ref refs/heads/master 1a410</code>。</p>
<h4 id="branch-ref"><a href="#branch-ref" class="headerlink" title="branch ref"></a>branch ref</h4><p>Git 引用原理已经知晓，我们在此说明分支引用的若干操作原理：</p>
<ul>
<li><p><code>git branch &lt;branchName&gt;</code></p>
<p>Git 首先基于 <code>HEAD</code> 指针获取当前分支的最新提交记录 ID，随后新建文件 <code>refs/heads/&lt;branchName&gt;</code>，并将此 ID 写入其中。</p>
</li>
<li><p><code>git checkout &lt;branchName&gt;</code></p>
<p>假定当前分支名为 <code>currBranName</code>，Git 会将 <code>ref: refs/heads/currBranName</code> 写入 <code>HEAD</code> 文件之中 (<code>HEAD</code> 文件含义下见)。</p>
</li>
</ul>
<h4 id="tag-ref"><a href="#tag-ref" class="headerlink" title="tag ref"></a>tag ref</h4><p>上面已经提及 <code>tag object</code> 和 Git 引用原理，那么 <code>tag ref</code> 应该就比较好理解了：</p>
<ol>
<li>如果为轻量标签，则其 <code>ref/tags/&lt;tagName&gt;</code> 内容为某 <code>commit object</code> 的 <code>SHA-1</code> 散列值。</li>
<li>如果为附注标签，则其 <code>ref/tags/&lt;tagName&gt;</code> 内容为某 <code>tag object</code> 的 <code>SHA-1</code> 散列值。</li>
</ol>
<h4 id="remote-ref"><a href="#remote-ref" class="headerlink" title="remote ref"></a>remote ref</h4><p><code>remote ref</code> 指代远程跟踪分支，其引用原理已经介绍，与本地分支的区别也已经介绍，所以就没什么可说的了。</p>
<h3 id="HEAD-文件"><a href="#HEAD-文件" class="headerlink" title="HEAD 文件"></a>HEAD 文件</h3><p>在之前文章中，我们提及 <code>HEAD</code> 指针指代当前项目具体位于哪一分支。HEAD 文件其实就是这个 <code>HEAD</code> 指针，其内容便指明当前项目具体位于哪一分支。为理解这些话，只要查看本地文件 <code>.git/HEAD</code> 即可：</p>
<p><img src="/2020/10/08/git/gitstudy5-basePrinciple/image-20201008173453477.png"></p>
<p>我们可直接编辑该文件以修改 <code>HEAD</code> 指针指向，Git 同样提供命令 <code>git symbolic-ref HEAD [&lt;refname&gt;/&lt;commit-id&gt;]</code> 以修改 <code>HEAD</code> 指针指向。</p>
<p>根据上文，我们知道：命令 <code>git checkout</code> 同样具有修改 <code>HEAD</code> 指针的作用。如果使用命令 <code>git checkout &lt;commit-id&gt;</code>，<code>HEAD</code> 指针便不再指向具体分支，而是指向具体 <code>SHA-1</code> 散列值，此时 Git 将报警 “ You are in ‘detached HEAD’ state.”。</p>
<h3 id="index-文件"><a href="#index-文件" class="headerlink" title="index 文件"></a>index 文件</h3><p>该文件保存暂存区的文件信息。它是一个二进制文件，无法直接查看具体内容，因此我们在此仅说明其内容组成：</p>
<ol>
<li><p>header 部分</p>
<p>共计 12 字节。前四字节标识该文件是否为合法 index 文件；中间四字节标识 index 文件的版本类型；后四字节标识暂存区内所管理的文件数量。</p>
</li>
<li><p>条目部分</p>
<p>条目部分用于记录暂存区内的文件信息。每一个条目具体对应于一个文件，不同条目之间使用 8 个连续的 0 进行分隔。</p>
<p>针对一个条目而言，其包括如下内容：</p>
<ul>
<li>8 字节的文件创建时间、8 字节的文件修改时间</li>
<li>4 字节的文件存储设备号、4 字节的文件存储 inode 号</li>
<li>4 字节的文件权限描述</li>
<li>4 字节的 UID (User ID)、4 字节的 GID (Group ID)</li>
<li>4 字节的文件大小</li>
<li>20 字节的文件 SHA-1 哈希值 (用于指代对应文件在 .git/objects 目录中的位置)</li>
<li>2 字节的状态信息 (包括假定不变标识符、阶段标识、文件名长度等)</li>
<li>若干字节的文件路径信息</li>
</ul>
</li>
<li><p>目录索引</p>
<p>目录索引用于存放目录信息，以实现快速重建工作目录。</p>
</li>
<li><p>校验值</p>
<p>20 字节的 index 文件校验值。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>git学习</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>git 高级操作</title>
    <url>/2020/10/07/git/gitstudy4-advanceOperation/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文介绍使用 <code>git</code> 版本控制系统过程中所涉的一部分高级操作命令。</p>
<a id="more"></a>

<h2 id="查看提交记录"><a href="#查看提交记录" class="headerlink" title="查看提交记录"></a>查看提交记录</h2><p>命令 <code>git log</code> 可以查看全部提交记录信息，而借助于命令 <code>git show</code> ，我们可以查看单个提交记录、区间提交记录的具体信息。</p>
<h3 id="单个提交记录"><a href="#单个提交记录" class="headerlink" title="单个提交记录"></a>单个提交记录</h3><p>对于提交记录而言，它们使用 <code>&lt;commit-id&gt;</code> 进行标识 (<code>&lt;commit-id&gt;</code> 实际为 <code>SHA-1</code> 散列值)，因此我们可使用命令 <code>git show &lt;conmmit-id&gt;</code> 查看指定提交记录的具体信息。由于 <code>&lt;commit-id&gt;</code> 往往很长且难于记忆，所以 Git 提供快捷方式：允许使用不少于 4 个字符的 <code>SHA-1</code> 散列值代替 <code>&lt;commit-id&gt;</code>，如果该散列值仅能对应到一个 <code>&lt;commit-id&gt;</code>，则查询成功，否则查询失败。针对图例，等价命令可以是：<code>git show f58af6ceb89e5e00</code>、<code>git show f58a</code>。</p>
<blockquote>
<p>借助于命令 <code>git log --abbrev-commit --oneline</code> ，Git 可为提交记录显示简短而唯一的 <code>SHA-1</code> 散列值，默认截取 <code>&lt;commit-id&gt;</code> 前 7 个字符。</p>
</blockquote>
<img src="/2020/10/07/git/gitstudy4-advanceOperation/image-20201006172007992.png" style="zoom: 67%;">

<p>除上面这种查看方式外，Git 仍提供其他多种方式拥有查看特定分支的提交信息：</p>
<ul>
<li><p>如果特定提交记录为某分支的顶端提交，则可使用该分支名表示此提交记录，针对上图例中提交，我们可使用等价命令 <code>git show 250</code>。</p>
</li>
<li><p>使用工具工作之时，Git 会在<em>本机本地</em>的后台保存一个引用日志 (reflog)，它用于记录 <code>HEAD</code> 和各分支所指向的提交记录。命令 <code>git reflog</code> 可用于查看这些信息：</p>
<img src="/2020/10/07/git/gitstudy4-advanceOperation/image-20201006194030938.png" style="zoom:67%;">

<p>那么 <code>HEAD</code> 和各分支对提交记录就存在一一对应关系，使用命令 <code>git show HEAD@&#123;2&#125;/250@&#123;2&#125;</code> 可用于查看 <code>HEAD</code> 或分支 <code>250</code> 所指向的倒数第 2 个提交记录。</p>
</li>
<li><p>借助于特殊字符 <code>^&lt;num&gt;</code>，我们可以查看特定提交记录的第 <code>&lt;num&gt;</code> 个父提交记录信息。例如：命令 <code>git show f58a^</code> 用于查看 <code>f58a</code> 所示提交记录的第 1 个父提交记录信息；命令 <code>git show f58a^2</code> 用于查看 <code>f58a</code> 所示提交记录的第 2 个父提交记录信息。</p>
<blockquote>
<p>第 <code>&lt;num&gt;</code> 个父提交记录仅对于分支合并所产生的提交记录有用。对于该记录而言，它的第 1 个父提交记录位于合并分支之上，第 2 个父提交记录位于被合并分支之上。</p>
</blockquote>
</li>
<li><p>借助于特殊字符 <code>~&lt;num&gt;</code>，我们可以查看特定提交记录的祖父级提交记录信息，例如：命令 <code>git show f58a~/f582~1</code> 与命令 <code>git show f58a^</code> 具有相同作用，均用于查看 <code>f58a</code> 所示提交记录的父提交记录信息；命令 <code>git show f58a~2</code> 用于查看 <code>f58a</code> 所示提交记录的父提交记录的父提交记录信息。</p>
<blockquote>
<p>默认均指代第 1 父提交记录。</p>
</blockquote>
</li>
</ul>
<h3 id="区间提交记录"><a href="#区间提交记录" class="headerlink" title="区间提交记录"></a>区间提交记录</h3><p>区间提交记录可用于解决问题 “某分支还有哪些提交记录尚未合并至特定分支？”。它共有三种语法：</p>
<ul>
<li><p>双点</p>
<p>命令 <code>git log &lt;branchA&gt;..&lt;branchB&gt;</code> 用于查看在分支 <code>&lt;branchB&gt;</code> 中且不在分支 <code>&lt;branchA&gt;</code> 中的提交记录。</p>
</li>
<li><p>多点</p>
<p>为弥补双点命令不能作用于多个分支，多点命令被提出。它使用 <code>&lt;branchA&gt;</code> 表示在分支 <code>&lt;branchA&gt;</code> 、使用 <code>^&lt;branchA&gt;/--not &lt;branchA&gt;</code> 表示不在分支 <code>&lt;branchA&gt;</code> ，从而提供多分支支持。</p>
<p>命令 <code>git log &lt;branchA&gt; &lt;branchB&gt; ^&lt;branchC&gt;</code> 或命令 <code>git log &lt;branchA&gt; &lt;branchB&gt; --not &lt;branchC&gt;</code> 用于查看在分支 <code>&lt;branchA&gt;</code> 或在分支 <code>&lt;branchB&gt;</code> 且不在分支 <code>&lt;branchC&gt;</code> 中的提交记录。</p>
</li>
<li><p>三点</p>
<p>命令 <code>git log &lt;branchA&gt;...&lt;branchB&gt; --left-right</code> 用于查看被两分支之一包含且不被两分支同时包含的提交记录。借助于参数 <code>--left-right</code>，输出结果将标识哪些提交记录仅出现于哪个分支。</p>
</li>
</ul>
<h2 id="交互式暂存"><a href="#交互式暂存" class="headerlink" title="交互式暂存"></a>交互式暂存</h2><p>交互式暂存 Git 命令可用于将项目文件的特定部分组合为一次提交。换言之，如果我们修改大量文件后，希望将这些改动拆分为若干提交而非一次提交，使用交互式暂存命令将会很容易做到这一点。</p>
<p>使用命令 <code>git add -i/--interactive</code> 后，我们将进入交互式终端模式。该模式界面比较特殊，它显示了已暂存文件区和未暂存文件区，同时下方列出可执行的命令。</p>
<img src="/2020/10/07/git/gitstudy4-advanceOperation/image-20201006212352167.png" style="zoom:67%;">

<p>如果希望列出交互式暂存状态，可在 <code>What now&gt;</code> 提示符后键入 <code>1</code>、<code>s</code> 或 <code>status</code>。</p>
<img src="/2020/10/07/git/gitstudy4-advanceOperation/image-20201006213644632.png" style="zoom:67%;">

<p>如果希望暂存文件，可在 <code>What now&gt;</code> 提示符后键入 <code>2</code>、<code>u</code> 或 <code>update</code>，随后选择文件对应数字以待暂存此文件 (数字前有 <code>*</code> 表示文件处于待暂存状态)，如果某次待暂存文件集为空，则表示暂存文件工作完成。</p>
<img src="/2020/10/07/git/gitstudy4-advanceOperation/image-20201006213859406.png" style="zoom:67%;">

<p>如果希望取消暂存文件，可在 <code>What now&gt;</code> 提示符后键入 <code>3</code>、<code>r</code> 或 <code>revert</code>，随后操作与暂存文件过程类似。</p>
<p>如果希望添加未追踪未经，可在 <code>What now&gt;</code> 提示符后键入 <code>4</code>、<code>a</code> 或 <code>add untracked</code>。</p>
<p>如果希望暂存指定文件的特定部分，可在 <code>What now&gt;</code> 提示符后键入 <code>5</code>、<code>p</code> 或 <code>patch</code>，随后选择待部分暂存文件对应数字，接下来 Git 会根据修改部分一一询问是否暂存。</p>
<img src="/2020/10/07/git/gitstudy4-advanceOperation/image-20201007094444009.png" style="zoom:67%;">

<p>如果希望查看已暂存文件 (指代真实位于暂存区的文件) 与暂存文件 (指代 <code>staged</code> 列表中文件)的区别，可在 <code>What now&gt;</code> 提示符后键入 <code>6</code>、<code>d</code> 或 <code>diff</code>，随后选择待查看文件对应数字即可。</p>
<img src="/2020/10/07/git/gitstudy4-advanceOperation/image-20201006214945873.png" style="zoom:67%;">

<h2 id="贮藏与清理"><a href="#贮藏与清理" class="headerlink" title="贮藏与清理"></a>贮藏与清理</h2><p>当对某分支的若干文件进行部分改动、且想要切换到另一个分支完成其他事宜时，按照 Git 使用规程，我们必须提交此次修改，然后才能完成分支切换，否则报如下错误。如果不想单独为此创建一次提交，我们可使用命令 <code>git stash</code> 加以解决。</p>
<img src="/2020/10/07/git/gitstudy4-advanceOperation/image-20201007094041514.png" width="50%" height="50%">

<p>命令 <code>git stash</code> 或命令 <code>git stash push</code> 用于将工作目录中未完成的修改 (包括已暂存和未暂存的已追踪文件) 保存至 Git 栈中，同时你可在任何分支中应用这些修改。</p>
<img src="/2020/10/07/git/gitstudy4-advanceOperation/image-20201007095753746.png" style="zoom:67%;">

<p>命令 <code>git stash list</code> 用于查看所有保存至 Git 栈中的修改列表。</p>
<img src="/2020/10/07/git/gitstudy4-advanceOperation/image-20201007100155277.png" style="zoom:67%;">

<p>命令 <code>git stash apply [--index] [stash@&#123;&lt;num&gt;&#125;]</code> 用于将修改 <code>stash@&#123;&lt;num&gt;&#125;</code> 应用于当前分支。如果不使用参数 <code>--index</code>，则将所有改动恢复至工作区；如果使用参数 <code>--index</code> ，则将暂存区改动恢复至暂存区、工作区改动恢复至工作区。如果不添加参数 <code>stash@&#123;&lt;num&gt;&#125;</code> ，默认应用栈顶修改。，需要注意的是：如果当前分支相应内容已经修改，可能会发生合并冲突。</p>
<img src="/2020/10/07/git/gitstudy4-advanceOperation/image-20201007102210289.png" width="50%" height="50%">

<p>命令 <code>git stash drop [stash@&#123;&lt;num&gt;&#125;]</code> 用于从 Git 栈中删除指定修改 <code>stash@&#123;&lt;num&gt;&#125;</code>。</p>
<p>命令 <code>git stash pop</code> 用于应用栈顶修改并从 Git 栈中删除之。</p>
<p>命令 <code>git stash</code> 存在若干变种，我们简单介绍一二：</p>
<ul>
<li><p><code>git stash --keep-index</code></p>
<p>该命令不仅将工作目录中未完成的修改保存至 Git 栈中，同时将已暂存文件仍然保留在暂存区中。</p>
</li>
<li><p><code>git stash --include-untracked</code></p>
<p>该命令不仅将工作目录中未完成的修改保存至 Git 栈中，也会将未追踪文件保存至 Git 栈中。</p>
</li>
<li><p><code>git stash branch &lt;new branchname&gt;</code></p>
<p>创建新分支，并将栈顶修改应用至该分支，随后丢弃栈顶修改。</p>
</li>
</ul>
<p>如果希望删除工作目录中未追踪文件或文件夹，可使用命令 <code>git clean -d -f</code> (<code>-f</code> 表示强制删除)。为防止错删，可先行执行命令 <code>git clean -d --dry-run</code> ，它会列出将要删除的文件和文件夹。</p>
<h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><p>Git 提供两个工具用于快速从其数据库中搜索指定内容。</p>
<p>命令 <code>git grep &lt;searchContent&gt;</code> 用于从工作目录中搜索指定内容，同时显示该内容所在文件名。该命令存在若干参数可以选择：</p>
<ul>
<li><p><code>-n</code></p>
<p> 用于显示搜索内容在相应文件中的行号。</p>
</li>
<li><p><code>-c/--count</code></p>
<p>搜索结果的统计信息，包括指定内容出现在哪些文件，指定内容在这些文件中出现的次数。</p>
</li>
<li><p><code>-p/--show-function</code></p>
</li>
</ul>
<p>命令 <code>git log -S &lt;searchContent&gt;</code> 用于从提交记录中搜索指定内容。</p>
<h2 id="重置"><a href="#重置" class="headerlink" title="重置"></a>重置</h2><p>重置操作可用于任意切换仓库区中的历史版本，它具体通过命令 <code>git reset</code> 实现。</p>
<p>在具体说明命令 <code>git rest</code> 之前，简单回顾 Git 仓库：它由三部分组成 —— 工作区、暂存区、仓库区。借助于命令 <code>git add</code>，工作区文件可转至暂存区；借助于命令 <code>git commit</code>，暂存区文件转至仓库区。仓库区由一系列提交记录所组成，这些记录构成一个有向无环图。所谓分支便是一个指向提交记录的指针，<code>HEAD</code> 指针则指向当前分支。</p>
<p>命令 <code>git reset &lt;commit-id&gt;</code> 主要有三个版本：</p>
<ul>
<li><p><code>git reset --soft &lt;commit-id&gt;</code></p>
<p>该命令仅会调整当前分支使其指向特定提交记录，从而切换仓库区中当前版本为某特定历史版本。</p>
</li>
<li><p><code>git reset [--mixed] &lt;commit-id&gt;</code></p>
<p>命令 <code>git reset</code> 默认使用参数 <code>--mixed</code>，除 <code>git reset --soft &lt;commit-id&gt;</code> 所完成的工作外，该命令会使用仓库区中 <code>&lt;commit-id&gt;</code> 所示提交记录的快照更新暂存区。</p>
</li>
<li><p><code>git reset --hard &lt;commit-id&gt;</code></p>
<p>除 <code>git reset --mixed &lt;commit-id&gt;</code> 所完成的工作外，该命令会使用暂存区中内容更新工作区。</p>
</li>
</ul>
<p>除使用 <code>&lt;commit-id&gt;</code> 执行重置外，还可根据文件或文件夹路径进行重置。由于此时可能涉及多个提交记录，因此仓库区中内容不会发生变化 (也即 <code>git reset --soft</code> 所指代过程不会发生) 。具体涉及如下命令：</p>
<ul>
<li><p><code>git reset [--mixed] &lt;commit-id&gt; &lt;file&gt;</code></p>
<p>此命令使用 <code>&lt;commit-id&gt;</code> 所指代提交记录更新暂存区中的文件 <code>&lt;file&gt;</code>。</p>
<p>如果命令中 <code>&lt;commit-id&gt;</code> 具体为 <code>HEAD</code>，则其等价于取消对文件 <code>&lt;file&gt;</code> 的暂存。</p>
</li>
<li><p><code>git reset --hard &lt;commit-id&gt; &lt;file&gt;</code></p>
<p>此命令使用 <code>&lt;commit-id&gt;</code> 所指代提交记录更新暂存区中的文件 <code>&lt;file&gt;</code>，同时使用暂存区中文件更新工作区。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>git学习</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>git 分支操作</title>
    <url>/2020/10/05/git/gitstudy3-branchOperation/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文介绍使用 <code>git</code> 版本控制系统过程中所涉的各种分支命令。</p>
<a id="more"></a>

<p>几乎所有的版本控制系统都以某种形式支持分支。使用分支便意味着你可以把你的工作从开发主线上分离开来，<br>以免影响开发主线。在很多版本控制系统中，这是一个略微低效的过程——常常需要完全创建一个源代码副本。而对 Git 而言，其分支处理过程极其轻量。正是由于这一点，其分支模型也称为 Git 的 “必杀技特性” 。</p>
<blockquote>
<p>Git 分支模型实战网址：<a href="https://learngitbranching.js.org/?NODEMO=&amp;locale=zh_CN%E3%80%82">https://learngitbranching.js.org/?NODEMO=&amp;locale=zh_CN。</a></p>
</blockquote>
<h2 id="本地分支"><a href="#本地分支" class="headerlink" title="本地分支"></a>本地分支</h2><p>正如 <a href="/2020/09/29/git/gitstudy1-origin/" title="git 起源">git 起源</a> 中所言，每次提交将会产生一个项目快照。另外，每次提交还会产生一个提交对象 ，该对象保存项目快照引用、提交人的姓名和电子邮箱、父提交对象引用等信息。经过若干提交，我们将会得到一张有向无环图，该图以提交对象为顶点，按照父提交对象引用进行构建边。</p>
<img src="/2020/10/05/git/gitstudy3-branchOperation/image-20201004103039132.png" alt="图一：提交后形成的有向无环图" width="80%">

<p>在 Git 之中，分支实质上就是指向该有向无环图中提交对象的可变指针，可变指针所指之处，即为当前分支最新状态。当构建 Git 仓库后，其默认存在初始分支 (主分支) <code>master</code>。每进行一次提交，有向无环图中就增加一个顶点及若干边，当前分支所示的可变指针便向前移动以使其指向当前分支的最新状态。</p>
<img src="/2020/10/05/git/gitstudy3-branchOperation/image-20201004111433763.png" alt="图二：master分支" width="50%">

<h3 id="分支创建"><a href="#分支创建" class="headerlink" title="分支创建"></a>分支创建</h3><p>命令 <code>git branch &lt;branchName&gt;</code> 即可创建新分支，该过程本质上就是：创建一个可变指针，并令其与当前分支的可变指针指向相同。需要注意的是：<strong>创建分支后，当前项目仍然处于当前分支，而不会自动切换到新分支</strong>。 </p>
<img src="/2020/10/05/git/gitstudy3-branchOperation/image-20201004112159576.png" alt="图三：创建分支" width="50%">

<blockquote>
<p><code>HEAD</code> 是 Git 中的特殊指针，它指向当前项目所在分支。之所以使用它，原因在于：需要确定当前项目具体在哪个分支之上。</p>
</blockquote>
<h3 id="分支切换"><a href="#分支切换" class="headerlink" title="分支切换"></a>分支切换</h3><p>命令 <code>git checkout &lt;branchName&gt;</code> 用于切换至指定分支。如下图所示，切换分支之后，<code>HEAD</code> 指针便指向分支 <code>testing</code>。</p>
<img src="/2020/10/05/git/gitstudy3-branchOperation/image-20201004192423480.png" alt="图四：切换分支" width="50%">

<p>此时，如果我们在当前分支中作一次提交，将会得到如图结果。可以看到：当前项目所在分支 <code>testing</code> 向前移动一步，而分支 <code>master</code> 并无任何变化。</p>
<img src="/2020/10/05/git/gitstudy3-branchOperation/image-20201004193043011.png" alt="图五：testing分支作一次提交" width="50%">

<p>随后，我们切换至分支 <code>master</code> 并完成一次提交，将会得到如图结果。可以看到：当前项目所在分支 <code>master</code> 向前移动一步，并与分支 <code>testing</code> 产生实际意义上的分支。</p>
<img src="/2020/10/05/git/gitstudy3-branchOperation/image-20201004193646647.png" alt="图六：master分支作一次提交" width="50%">

<blockquote>
<p>如果我们希望创建分支的同时，能够自动切换至新创建的分支，可使用命令 <code>git checkout -b &lt;branchName&gt;</code>。</p>
</blockquote>
<h3 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a>分支合并</h3><p>命令 <code>git merge &lt;branchName&gt; </code> 用于将分支 <code>branchName</code> 合并至当前分支。</p>
<p>分支合并存在两种情况：</p>
<ul>
<li><p>当前分支为分支 <code>branchName</code> 的前驱</p>
<p>这种情况的合并比较简单，只需要令当前分支所示指针与分支 <code>branchName</code> 所示指针指向相同即可 (进行合并之时，如果合并情况为此，GIt 将会提示 fast-forward)。</p>
<p>如图七所示，需要合并分支 <code>hotfix</code> 至当前分支 <code>master</code>，其正好满足此条件，故而只需要令分支 <code>master</code> 所示指针指向 <code>C4</code> 即可。</p>
<p><img src="/2020/10/05/git/gitstudy3-branchOperation/image-20201004210231197.png" alt="图七：分支合并:当前分支为分支branchName的前驱"></p>
</li>
<li><p>当前分支不为分支 <code>branchName</code> 的前驱</p>
<p>这种情况的合并比较麻烦，它会提取当前分支、分支 <code>branchName</code>、两分支公共祖先的项目快照，做一<em>三方合并</em>  (这是最简单的合并策略)，随后将合并内容作为当前分支的一次新提交。如果合并过程中发生冲突，需要手动处理冲突。</p>
<img src="/2020/10/05/git/gitstudy3-branchOperation/image-20201004193646647.png" alt="图八：分支合并：当前分支不为分支branchName的前驱" width="50%">

<blockquote>
<p>直观来看，应当直接合并当前分支、分支 <code>branchName</code> 的项目快照 (称为<em>两方合并</em>)。但是两方合并是不可行的，原因在于：我们无法根据二者差异决定合并策略 (具体见<a href="#">Post not found: git/gitstudy6</a>)。</p>
</blockquote>
</li>
</ul>
<h3 id="分支删除"><a href="#分支删除" class="headerlink" title="分支删除"></a>分支删除</h3><p>命令 <code>git branch -d/-D &lt;branchName&gt;</code> 用于删除指定分支。当使用 <code>-d</code> 参数时，如果分支 <code>branchName</code> 已合并至其他分支，则可成功删除；否则由于存在未合并内容，则会删除失败。此时如果需要强制删除，则可使用 <code>-D</code> 参数进行强制删除。</p>
<h3 id="分支查询"><a href="#分支查询" class="headerlink" title="分支查询"></a>分支查询</h3><p>命令 <code>git branch</code> 用于查询当前项目的所有分支。</p>
<p>命令 <code>git branch -v</code> 不仅可查询当前项目的所有分支，而且可查看每个分支的最后一次提交信息。</p>
<p>命令 <code>git branch --merged/--no-merged [&lt;branchName&gt;]</code> 用于查询已合并或未合并至分支 <code>branchName</code> (不加参数便是指当前分支) 的分支。</p>
<h2 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h2><p>远程分支 (remote branch) 指代位于远程服务器中的分支，此节介绍与其相关的两个内容 —— 远程跟踪分支 (remote-tracking branch) 、跟踪分支 (tracking branch)。</p>
<blockquote>
<p>通常存在 <strong>远程引用</strong> 这一概念，它是对远程仓库中分支、标签等内容的引用 (指针)。我们可借由命令 <code>git ls-remote</code> 显式获取远程引用的完整列表，也可使用命令 <code>git remote</code>  显式获取远程分支引用的完整列表。</p>
</blockquote>
<h3 id="远程跟踪分支"><a href="#远程跟踪分支" class="headerlink" title="远程跟踪分支"></a>远程跟踪分支</h3><p><strong>远程跟踪分支</strong> 是本地仓库对远程分支状态的记录，它们属于无法移动的本地引用，并以 <code>&lt;serverName&gt;/&lt;branchName&gt;</code> 形式命名。其作用类似于书签，用于标识该分支在远程仓库中的位置。当我们同步远程仓库内容时，它会自动更新其在远程仓库中的位置信息。</p>
<p>远程跟踪分支可能比较难理解，我们举例说明。</p>
<p>假定我们从 <code>git.ourcompany.com</code> 服务器中克隆项目至本地，<code>git clone</code> 命令会自动完成如下工作：设置远程服务器名为 <code>origin</code>、拉取项目完整内容、创建远程跟踪分支 <code>origin/master</code> 并自动设置其指向、创建本地分支 <code>master</code> 并令其与远程跟踪分支 <code>origin/master</code> 指向相同。克隆完成后，远程仓库与本地仓库可表示如下：</p>
<img src="/2020/10/05/git/gitstudy3-branchOperation/image-20201005102247388.png" alt="图九：克隆后的远程仓库与本地仓库" width="50%">

<p>随后我们在本地分支 <code>master</code> 做些提交，同时间段又有人在远程仓库的 <code>master</code> 分支做些提交，此时远程仓库与本地仓库可表示如下。可以看到：远程分支 <code>master</code> 发生变动，而远程跟踪分支 <code>origin/master</code> 未曾发生变动。</p>
<img src="/2020/10/05/git/gitstudy3-branchOperation/image-20201005104442560.png" alt="图十：若干提交后的远程仓库与本地仓库" width="50%">

<p>既然远程仓库内容有所变动，我们使用命令 <code>git fetch</code> 拉取其至本地，此时远程仓库与本地仓库可表示如下。可以看到：Git 会抓取本地仓库所没有的内容，随后更新远程跟踪分支 (如果存在相应的远程跟踪分支)。</p>
<img src="/2020/10/05/git/gitstudy3-branchOperation/image-20201005111447301.png" alt="图十一：拉取内容后的远程仓库与本地仓库" width="50%">

<p>此时可使用命令 <code>git merge</code> 合并分支 <code>origin/master</code> 与分支 <code>master</code>，从而更新本地分支 <code>master</code>；当然也可使用命令 <code>git checkout -b branchMaster origin/master</code> 新建分支 <code>branchMaster</code>，并令其与远程跟踪分支 <code>origin/master</code> 指向相同。</p>
<img src="/2020/10/05/git/gitstudy3-branchOperation/image-2020105.png" alt="图十二：与远程跟踪分支合并或新建分支与远程跟踪分支同步" width="50%">

<h3 id="跟踪分支"><a href="#跟踪分支" class="headerlink" title="跟踪分支"></a>跟踪分支</h3><p>基于远程跟踪分支 <code>checkout</code> 出来的本地分支便是 <strong>跟踪分支</strong>，该分支所对应的远程跟踪分支称为它的<em>上游分支</em>。跟踪分支是与远程分支有直接关联的本地分支，<strong>如果在跟踪分支之上输入 <code>git pull</code> 命令，Git 能够自动识别应当去哪个远程服务器的哪个分支上抓取内容，然后将其合并至当前分支</strong>。值得一说的是，使用命令 <code>git clone</code> 克隆项目时，它会基于远程跟踪分支 <code>origin/master</code> 自动创建跟踪分支 <code>master</code>。</p>
<p>跟踪分支的创建命令之前已经提及，就是 <code>git checkout -b &lt;branchName&gt; &lt;serverName/branchName&gt;</code>。由于此命令比较常用，故而存在两个简化命令，其一： <code>git checkout --track &lt;serverName/branchName&gt;</code>，其二：当使用命令 <code>git checkout &lt;branchName&gt;</code> 之时，如果该分支不存在、但是存在同名远程分支，则 Git 会自动创建相应的跟踪分支。</p>
<p>如果已经创建分支，但是需要将其关联至某远程分支，可使用命令 <code>git branch -u/--set-upsteam-to &lt;serverName/branchName&gt;</code> 设置当前分支的上游分支。</p>
<p>如果需要查看各分支的跟踪信息，可使用命令 <code>git branch -vv</code>。根据如下例子可以看到：分支 <code>testing</code> 没有跟踪任何远程分支；分支 <code>master</code> 跟踪远程分支 <code>master</code>，且两者处于同步状态；分支 <code>serverfix</code> 跟踪分支 <code>server-fix-good</code>，且存在 <code>ahead 3,behind 1</code>，此表示当前分支存在 3 个提交未曾推送至远程分支、远程分支存在 1 个提交未曾合并至本地分支。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch -vv</span><br><span class="line">testing 5ea463a trying something new</span><br><span class="line">master 1ae2a45 [origin/master] deploying index fix</span><br><span class="line">* serverfix f8674d9 [teamone/server-fix-good: ahead 3, behind 1] this should <span class="keyword">do</span> it</span><br></pre></td></tr></table></figure>
<blockquote>
<p>此命令并不涉及与远程分支的通信，其比较对象为最后一次从远程分支所获取的服务器数据 (通过命令 <code>git fetch</code> 做到)。</p>
</blockquote>
<h2 id="变基"><a href="#变基" class="headerlink" title="变基"></a>变基</h2><p><strong>变基</strong> (rebase) 属于分支合并中较为高级的操作，我们在此简单介绍。</p>
<h3 id="简单情景"><a href="#简单情景" class="headerlink" title="简单情景"></a>简单情景</h3><p>假定存在如图提交记录：</p>
<img src="/2020/10/05/git/gitstudy3-branchOperation/image-20201005170857635.png" width="50%">

<p>为合并两个分支，我们通常做法是采用命令 <code>git merge</code>，它会进行一次三方合并，并将合并结果作为一次提交。此时，提交记录如下：</p>
<img src="/2020/10/05/git/gitstudy3-branchOperation/image-20201005171258225.png" width="50%">

<p>可以看到，基于命令 <code>git merge</code> 的合并方式存在一大缺陷：使得提交记录不线性。为使得记录线性化，我们可使用命令 <code>git rebase &lt;topicBranch&gt;</code> ，它用于将当前分支上的所有修改移动至特定分支之上，这种操作便称为 <strong>变基</strong>。</p>
<blockquote>
<p>另有变基命令 <code>git rebase &lt;baseBranch&gt; &lt;topicBranch&gt;</code>，它用于将指定分支上的所有修改移动至特定分支之上。</p>
</blockquote>
<p>以上图为例，简述变基原理：首先找到当前分支 <code>experiment</code> 和分支 <code>master</code> 的公共祖先 <code>C2</code>，随后将公共祖先 <code>C2</code> 至当前分支所指之处的修改保存至临时文件之中，切换至分支 <code>master</code> 并将临时文件中的修改依次添加至该分支，随后再切换回分支 <code>experiment</code> 。经变基操作后，其提交记录如下：</p>
<blockquote>
<p><strong>经变基操作后，提交 <code>C4</code> 等都仍然在，只是当前分支通过日志记录查不到</strong>。</p>
</blockquote>
<img src="/2020/10/05/git/gitstudy3-branchOperation/image-20201005172538496.png" width="100%">

<p>此时切换至分支 <code>master</code>，执行命令 <code>git merge experiment</code>，可以发现它属于 “fast-forward”，合并过程简单，只需调整相关指针即可。可以看到：基于变基操作实现的合并结果是线性的。此时，其提交记录如下：</p>
<p><img src="/2020/10/05/git/gitstudy3-branchOperation/image-20201005183736856.png"></p>
<h3 id="复杂情景"><a href="#复杂情景" class="headerlink" title="复杂情景"></a>复杂情景</h3><p>上例仅涉及一个分支，比较简单。接下来我们看一个涉及多分支的例子。</p>
<p>假定存在如图提交记录，现在我们希望将分支 <code>client</code> 变基至分支 <code>master</code>，同时要求涉及分支 <code>server</code> 的任何修改不动。</p>
<img src="/2020/10/05/git/gitstudy3-branchOperation/image-20201005193209265.png" width="50%">

<p>基于此要求，我们可使用命令 <code>git rebase --onto master server client</code> 做到，该命令意思为：找到分支 <code>client</code> 与分支 <code>server</code> 的公共祖先，随后将公共祖先至分支 <code>client</code> 所指之处的修改移动并添加至分支 <code>master</code>。经过变基操作后，其提交记录如下：</p>
<img src="/2020/10/05/git/gitstudy3-branchOperation/image-20201005194221234.png" width="50%">

<h3 id="风险"><a href="#风险" class="headerlink" title="风险"></a>风险</h3><p>只要满足准则 —— “<strong>如果提交存在于你的仓库之外，而别人可能基于这些提交进行开发，那么不要执行变基</strong>”，变基操作就不会引人风险，否则就会引入麻烦。</p>
<p>我们同样通过例子说明该麻烦。假定我们从远程服务器克隆项目并对此执行若干提交，远程仓库与本地仓库的提交记录如下：</p>
<img src="/2020/10/05/git/gitstudy3-branchOperation/image-20201005204343785.png" width="50%">

<p>随后，其他人向远程服务器做若干提交，我们拉取其内容并合并至本地。此时，远程仓库与本地仓库的提交记录如下：</p>
<img src="/2020/10/05/git/gitstudy3-branchOperation/image-20201005204804646.png" width="50%">

<p>接下来，之前那个人决定使用变基操作替代合并操作，随后使用本地内容强制覆盖远程服务器中内容。如果我们此时拉取远程服务器中内容至本地，由于命令 <code>git fetch</code> 会将当前仓库中并不存在的内容拉取下来，故而会得到这样的提交记录：</p>
<img src="/2020/10/05/git/gitstudy3-branchOperation/image-20201005210031489.png" width="50%">

<p>为上传本地仓库至远程服务器，我们首先需要合并拉取下来的内容，这样我们就会重复合并提交 <code>C4</code> (<em>此为麻烦一，混乱日志信息</em>)。此时，远程仓库与本地仓库的提交记录如下：</p>
<img src="/2020/10/05/git/gitstudy3-branchOperation/image-20201005211515992.png" width="60%">

<p>此时如果我们将其上传至远程服务器，之前那个人不想要的提交 <code>C4</code> 和 <code>C6</code> 又会再次出现在远程服务器 (<em>此为麻烦二</em>)。为避免这种情况发生，最初我们应当将分支 <code>master</code> 变基至远程跟踪分支 <code>teamone/master</code>，这样就可以避免上面所述麻烦。此时，远程仓库与本地仓库的提交记录如下：</p>
<img src="/2020/10/05/git/gitstudy3-branchOperation/image-20201005213714608.png" width="60%">

<blockquote>
<p>对远程服务器中分支采用变基操作有两种命令，其一：首先使用命令 <code>git fetch</code> 获取数据，随后使用 <code>git rebase</code> 执行变基操作；其二：直接使用命令 <code>git pull --rebase</code> 代替前面的两条命令。</p>
</blockquote>
<h3 id="其他应用"><a href="#其他应用" class="headerlink" title="其他应用"></a>其他应用</h3><p>命令 <code>git rebase</code> 不仅可作用于不同分支以执行变基操作，也可作用于当前分支的若干提交以实现压缩提交功能。实现压缩提交功能的具体命令有 <code>git rabse -i HEAD~&lt;num&gt;</code>，它可压缩当前分支的最近 <code>&lt;num&gt;</code> 次提交为一次提交；<code>git rebase -i &lt;commit-id&gt;</code>，它可压缩当前分支提交 <code>commit-id</code> 之后的所有提交为一次提交。</p>
<h3 id="变基vs合并"><a href="#变基vs合并" class="headerlink" title="变基vs合并"></a>变基vs合并</h3><p>变基和合并均可实现分支合并，实际应用中应当着重选择哪种方式？</p>
<p>首先，我们需要回答问题：提交记录的作用何在？通常有两种观点：1. 提交记录用于记录实际发生过什么，它属于历史文档，不应当随意篡改；2. 提交记录用于记录项目开发过程中有意义的提交。如果持有观点 1，那么应当仅使用合并、杜绝使用变基以实现分支合并；如果持有观点 2，那么只有在满足准则情况下才使用变基、否则使用合并以实现分支合并。、</p>
<blockquote>
<p>除分支合并功能外，变基还可压缩提交。如果持有观点 1，则不应使用变基以压缩提交；如果持有观点 2，则可适当使用变基以压缩提交，从而使提交记录更为清晰。</p>
</blockquote>
<h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><p>命令 <code>git cherry-pick</code> 与命令 <code>git rebase</code> 类似，它不是将当前分支上全部提交作用于特定分支之上，而是将当前分支上某些提交作用于特定分支之上。其具体命令为 <code>git cherry-pick &lt;commit-id&gt;</code> ，应用 ID 为 <code>&lt;commit-id&gt;</code> 的提交至当前分支之上。</p>
]]></content>
      <categories>
        <category>git学习</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>git 基本操作</title>
    <url>/2020/09/30/git/gitstudy2-baseOperation/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文介绍使用 <code>git</code> 版本控制系统过程中所涉的各种基本命令。</p>
<a id="more"></a>

<blockquote>
<p>书写 <code>git</code> 命令时，如果参数使用 <code>[]</code> 括起来，则表明其可使用也可不使用；如果参数使用 <code>/</code> 进行分隔，则表示两者等价，可任选一个使用；如果某个参数使用 <code>&lt;&gt;</code> 括起来，则表明此为一个取值。</p>
</blockquote>
<h2 id="获取仓库"><a href="#获取仓库" class="headerlink" title="获取仓库"></a>获取仓库</h2><p>通常有两种方式用于获取 <code>git</code> 仓库：</p>
<ol>
<li><p>将尚未进行版本控制的本地目录转换为 Git 仓库。</p>
<p>进入到指定的本地目录，执行 <code>git init</code> 命令即可将当前目录转换为 <code>git</code> 仓库。</p>
</li>
<li><p>从其它服务器<em>克隆</em>一个已存在的 Git 仓库。</p>
<p>使用 <code>git clone &lt;url&gt; [folderName]</code> 命令可将位于 <code>url</code> 位置的 Git 仓库克隆至本地，并将其文件夹名更改为 <code>folderName</code>。</p>
</li>
</ol>
<blockquote>
<p><code>git init</code> 命令将会在本地创建一个 <code>.git</code> 文件夹，克隆得到的 <code>git</code> 仓库中同样存在 <code>.git</code> 文件夹。对于 <code>git</code> 仓库而言，此文件夹是十分重要的，它存放着当前 <code>git</code> 仓库的各种信息。关于此文件夹的详细信息，具体见 <a href="/2020/10/08/git/gitstudy5-basePrinciple/" title="git 基本原理">git 基本原理</a>。</p>
</blockquote>
<h2 id="文件追踪"><a href="#文件追踪" class="headerlink" title="文件追踪"></a>文件追踪</h2><p>Git 仓库所在目录中的文件共有五种状态 —— 未追踪 (untracked)、未修改 (unmodified)、已修改 (modified)、已暂存 (staged)、已提交 (commited)。如果一个文件处于未追踪状态，则表明其尚未被 Git 仓库所管理；如果一个文件处于未修改状态，则表明自上次提交后，该文件尚未被修改；如果一个文件处于已修改状态，则表明自上次提交后，该文件已被修改；如果一个文件处于已暂存状态，则表明其位于暂存区；如果一个文件处于已提交状态，则表明其刚被提交。</p>
<p>文件状态间转换关系及所涉操作具体如下图所示 (未修改和已提交其实是一种状态，之所以如此写，希望与上篇文章中所提文件状态保持一致)：</p>
<img src="/2020/09/30/git/gitstudy2-baseOperation/image-20200930201714034.png" alt="图一：文件状态转换" width="80%">

<p>首先，我们介绍用于查看文件状态的两个命令：</p>
<ul>
<li><p><code>git status [--short]</code> </p>
<p>此命令用于查看当前目录中各文件所处状态 (如果文件处于未追踪、已修改、已暂存状态，则会列出其文件名)。添加 <code>--short</code> 参数后，该命令将会以一种简洁方式查看当前目录中各文件所处状态。</p>
<p><img src="/2020/09/30/git/gitstudy2-baseOperation/image-20200930210806912.png"></p>
<p>如图所示，输入 <code>git status</code> 命令后，它指出 <code>333.txt</code> 处于未追踪状态、<code>222.txt</code> 处于已修改状态、<code>111.txt</code> 处于已暂存状态。</p>
</li>
<li><p><code>git diff [--staged/--cached]</code></p>
<p>此命令用于查看工作区中文件与暂存区中文件的差异、暂存区中文件与仓库区中文件的差异 (此时需要使用 <code>--staged</code> 参数)。</p>
<p><img src="/2020/09/30/git/gitstudy2-baseOperation/image-20200930212317188.png"></p>
<p>如图所示，输入 <code>git diff</code> 命令后，它就指出工作区中 <code>222.txt</code> 与暂存区中 <code>222.txt</code> 的差异 ( <strong><code>diff</code> 命令输出中，使用 <code>a/</code>、<code>b/</code> 标识不同区内的文件，<code>a</code> 用于标识具有较旧内容的文件，<code>b</code> 用于标识具有较新内容的文件</strong>)。</p>
</li>
</ul>
<p>接下来，我们介绍与状态转换相关的命令：</p>
<ul>
<li><p><code>git checkout -- &lt;fileNmae&gt;</code></p>
<p>此命令用于将处于已修改状态的文件回退为未修改状态的文件，即撤销工作区中文件的已有修改。<strong>如此操作，工作区中文件的已有修改将被完全覆盖，并永远不可恢复</strong>。</p>
</li>
<li><p><code>git add</code></p>
<p>此命令用于将处于未追踪或已修改状态的文件加入暂存区，从而将文件状态转换为已暂存。</p>
<p>此命令通常有三种用法：</p>
<ol>
<li><code>git add .</code> ：将当前目录中所有符合条件的文件加入暂存区。</li>
<li><code>git add *.xxx</code>：将当前目录中满足 <code>*.xxx</code> 通配符匹配规则的文件加入暂存区。</li>
<li><code>git add xxx</code>：将当前目录中指定文件 <code>xxx</code> 加入暂存区。</li>
</ol>
</li>
<li><p><code>git reset HEAD &lt;fileName&gt;</code></p>
<p>此命令用于将处于已暂存状态的文件放回至工作区，从而将文件状态转换为已修改。该命令含有与 <code>git add</code> 命令含义刚好相反。</p>
</li>
<li><p><code>git commit[-m &quot;xxx&quot;]</code></p>
<p>此命令用于将处于已暂存状态的文件提交到仓库区，这便形成一次快照。</p>
<p>如果直接输入 <code>git commit</code> 命令，则其会跳转到编辑器页面，需要你输入提交说明，随后退出编辑器页面以完成提交；如果输入 <code>git commit -m &quot;xxx&quot;</code> 命令，则 <code>xxx</code> 作为提交说明并完成提交。</p>
<p>如果我们希望跳过暂存操作，直接执行提交操作，可使用 <code>git comit -am &quot;xxx&quot;</code> 命令，它等价于 <code>git add .,git commit -m &quot;xxx&quot;</code> 命令。</p>
<p>如果我们提交完一次快照后，发现若干文件忘记提交获取提交说明书写错误，此时可输入 <code>git commit --amend</code> 命令，它会将暂存区中内容提交至最新快照之中，同时启动编辑器页面，以允许你修改最新快照的提交说明。</p>
<p><img src="/2020/09/30/git/gitstudy2-baseOperation/image-20201001123912772.png"></p>
</li>
<li><p><code>git rm [-r] [--cached] xxx</code></p>
<p>如果直接输入 <code>git rm xxx</code>，则其会将文件 <code>xxx</code> 从暂存区中删除，同时删除工作区中文件 <code>xxx</code>。</p>
<p><img src="/2020/09/30/git/gitstudy2-baseOperation/image-20200930232540969.png"></p>
<p>如果输入 <code>git rm --cached xxx</code>，则其仅会将文件 <code>xxx</code> 从暂存区中删除，此时文件状态变更为未追踪 (<strong>将文件从暂存区中删除，此操作将等待被提交给仓库区，故而会出现于 <code>Changes to be commit</code></strong>)。</p>
<p><img src="/2020/09/30/git/gitstudy2-baseOperation/image-20200930233651644.png"></p>
<p>参数 <code>-r</code> 表明所删内容为文件夹。</p>
<blockquote>
<p><strong>如果工作区中文件与暂存区中文件不一致，则系统报错，此时可使用 <code>git rm -f xxx</code> 强制删除，这种操作的后果便是：工作区中修改部分将会永远不可恢复</strong>。</p>
<p><img src="/2020/09/30/git/gitstudy2-baseOperation/image-20200930235030276.png"></p>
<p>如果我们直接使用 <code>rm xxx</code> 命令，则其仅会删除工作区中文件 <code>xxx</code>，暂存区中的文件 <code>xxx</code> 仍然保留存在。</p>
</blockquote>
</li>
<li><p><code>git mv [-r]</code></p>
<p>此命令用于移动或重命名文件或文件夹。</p>
<p>Git 并不显式跟踪文件移动，为实现跟踪文件移动功能，实际上我们需要借由如下三条命令加以实现：<code>mv old new,git rm old,git add new</code>。<code>git rm</code> 命令则是此三者命令的集合版本，可帮助简化跟踪文件移动操作。</p>
</li>
<li><p><code>git </code></p>
</li>
</ul>
<p>最后我们介绍一下 <code>.gitignore</code> 文件。</p>
<p>对于一个项目而言，当前目录中的编译结果、日志输出等文件都是无需交由 Git 管理的，而且我们也不会希望它们处于未追踪状态，此时便可使用 Git 提供的 <code>.gitignore</code> 文件记录它们。如此操作，Git 便会忽略其中文件。</p>
<p>文件 <code>.gitignore</code> 的格式规范如下：</p>
<ul>
<li>所有空行或者以 <code>#</code> 开头的行都会被 Git 忽略。</li>
<li>可以使用标准的 glob 模式(正则表达式的阉割版) 匹配，它会递归地应用在整个工作区中。</li>
<li>匹配模式可以 (/) 开头防止递归。</li>
<li>匹配模式可以 (/) 结尾指定目录。</li>
<li>要忽略指定模式以外的文件或目录，可以在模式前加上叹号 (!)，以示取反。</li>
</ul>
<p><code>.gitignore</code> 所匹配文件集合应当为：前四条规范所示集合取并集，随后与第五条规范所示集合取交集 (<em>个人理解</em>)。假定存在 <code>.gitignore</code> 文件如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">*.a</span><br><span class="line">!lib.a</span><br></pre></td></tr></table></figure>
<p>此文件表示忽略除 <code>lib.a</code> 以外的所有以 <code>.a</code> 结尾的文件。</p>
<blockquote>
<p><code>.gitignore</code> 位于哪个文件夹之中，它就仅对此文件夹中所有文件起作用。</p>
<p>网址 <a href="https://github.com/github/gitignore">https://github.com/github/gitignore</a> 提供针对数十种项目及语言的 <code>.gitignore</code> 文件模板。</p>
</blockquote>
<h2 id="历史记录"><a href="#历史记录" class="headerlink" title="历史记录"></a>历史记录</h2><p>我们可使用 <code>git log</code> 命令获取已提交的历史记录，其默认按照时间顺序排列。对于每条历史记录而言，它会列出此次记录的 SHA-1 校验值、提交人、提交人的电子邮件、提交时间及提交说明。</p>
<p><img src="/2020/09/30/git/gitstudy2-baseOperation/image-20201001110236617.png"></p>
<p>对于 <code>git log</code> 命令而言，它存在很多参数可以选择，我们在此列出若干经常使用的参数：</p>
<ul>
<li><p><code>-p/--patch</code></p>
<p>使用此参数后，除显示基本记录信息外，它还会显示每次提交所引入的差异 (类似于 <code>git diff 当前记录 上次记录</code>)。</p>
<p><img src="/2020/09/30/git/gitstudy2-baseOperation/image-20201001111449919.png"></p>
</li>
<li><p><code>-&lt;n&gt;</code></p>
<p>此参数用于限制显示的历史记录条数。如果输入 <code>git log -2</code> 命令，它将仅显示最近的两条历史记录。</p>
<p>另外还有若干用于筛选历史记录的参数，我们在此简单介绍一二：<code>--since=&lt;date&gt;</code>，筛选时间节点 <code>date</code> 之后的历史记录；<code>--until=&lt;date&gt;</code>，筛选时间节点 <code>date</code> 之前的历史记录。</p>
</li>
<li><p><code>--stat</code></p>
<p>使用此参数后，除显示基本记录信息外，它还会显示每次提交的一些统计信息。</p>
<p><img src="/2020/09/30/git/gitstudy2-baseOperation/image-20201001111834198.png"></p>
</li>
<li><p><code>--pretty</code></p>
<p>此参数存在若干选值：<code>online</code>、<code>short</code>、<code>full</code>、<code>fuller</code> 等，选择不同选值，可以不同于默认格式的方式显示历史记录。</p>
<p>如果输入 <code>git log --pretty=online</code> 命令，它会简化记录信息，并将每个记录放在一行进行显示。</p>
<p><img src="/2020/09/30/git/gitstudy2-baseOperation/image-20201001112514711.png"></p>
<p>此参数存在一个特殊选值 <code>format</code>，它允许自定义显示方式 (具体比较麻烦，点到为止)。</p>
</li>
<li><p><code>--graph</code></p>
<p>使用此参数后，除显示基本记录信息外，它狐疑在日志旁以 ASCII 图形显示分支与合并历史。</p>
<p><img src="/2020/09/30/git/gitstudy2-baseOperation/image-20201001112911613.png"></p>
</li>
</ul>
<h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><p>远程仓库是指托管在因特网或其他网络中你的项目的版本库。借助于远程仓库，我们可方便实现多人合作项目开发。</p>
<p>为完成协作开发，我们需要管理此远程仓库。此节首先给出管理仓库命令之间的关系，随后详细介绍他们。</p>
<p><img src="/2020/09/30/git/gitstudy2-baseOperation/bg2014061202.jpg" alt="图二：远程仓库相关操作"></p>
<ul>
<li><p><code>git remote [-v]</code></p>
<p>此命令用于查看你所配置的远程服务器名。如果使用参数 <code>-v</code>，则不仅可看到远程服务器名，也可看到远程服务器的具体 URL。</p>
<p><img src="/2020/09/30/git/gitstudy2-baseOperation/image-20201001144519193.png"></p>
<p><code>git remote</code> 命令除查看配置的远程服务器信息外，也可执行与远程服务器配置相关的若干功能。</p>
<ol>
<li><code>git remote add  &lt;serverName&gt; &lt;serverUrl&gt;</code>：添加远程服务器。</li>
<li><code>git remote show &lt;serverName&gt;</code> ：显示指定远程服务器的详细信息。</li>
<li><code>git remote rm &lt;serverName&gt;</code>：删除指定远程服务器。</li>
<li><code>git remote rename &lt;oldserverName&gt; &lt;newserverName&gt;</code> ：指定远程服务器重命名。</li>
</ol>
</li>
<li><p><code>git fetch &lt;serverName&gt;</code></p>
<p>此命令用于从远程服务器 <code>serverName</code> 中拉取本地仓库中所没有的数据。需要注意的是：<strong>该命令只会拉取数据至本地仓库，而不会将其合并至工作区</strong>。</p>
<blockquote>
<p><code>git pull</code> 命令不仅会拉取数据至本地仓库，同时将其合并至工作区。</p>
</blockquote>
</li>
<li><p><code>git push &lt;serverName&gt; &lt;branch&gt;</code></p>
<p>此命令用于将本地仓库当前分支推送至远程服务器 <code>serverName</code> 的 <code>branch</code> 分支。</p>
</li>
</ul>
<h2 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h2><p>与其他版本控制系统一样，Git 可以给本地仓库历史记录中的某一个提交打上标签，以示其重要性。实际使用中，人们常用此功能标记发布的不同版本。</p>
<p>我们这里介绍与标签相关的若干命令：</p>
<ul>
<li><p><code>git tag [-l/--list &quot;通配模式&quot;]</code></p>
<p>此命令用于查看已有标签，其按照字母顺序列出。如果添加参数 <code>-l</code>，则其会列出与通配模式匹配的标签。</p>
</li>
<li><p><code>git tag ...</code></p>
<p>Git 支持两种标签 —— 轻量标签和附注标签。轻量标签只是某个特定提交的引用；附注标签则是存储于 Git 数据库中的完整对象，它包含打标签者的姓名、打标签者的电子邮件、打标签日期及标签信息 (可以看到，附注标签信息与提交快照信息基本一致)。通常情况下，建议使用附注标签。</p>
<p><code>git tag &lt;tagName&gt;</code> 命令用于创建最新提交的轻量标签；<code>git tag -a &lt;tagName&gt; -m &lt;tagMessage&gt;</code> 命令则用于创建最新提交的附注标签。</p>
<p>如果需要对以往提交打标签，则需使用 <code>git tag &lt;tagName&gt; &lt;以往提交的校验和&gt;</code> 或 <code>git tag -a &lt;tagName&gt; -m &lt;tagMessage&gt; &lt;以往提交的校验和&gt;</code> 命令。</p>
</li>
<li><p><code>git show &lt;tagName&gt;</code></p>
<p>此命令用于显示指定标签对应的详细信息。</p>
</li>
<li><p><code>git push &lt;serverName&gt; [&lt;tagName&gt;/--tags]</code></p>
<p>默认情况下，<code>git push</code> 命令并不会将标签信息传送至远程服务器。创建完标签后，我们需要显式推送标签至远程服务器。<code>git push &lt;serverName&gt; &lt;tagName&gt;</code> 便可做到这件事。</p>
<p>如果希望一次性推送很多标签，可使用 <code>git push &lt;serverName&gt; --tags</code> 命令，它会将远程服务器中不存在的标签全部传送过去 (两种标签都会传送过去)。</p>
</li>
<li><p><code>git tag -d &lt;tagName&gt;</code></p>
<p>此命令用于删除指定标签。</p>
<p>此命令仅会删除本地仓库中的标签，而不会删除远程服务器中的标签 (如果远程服务器中有此标签的话)，为删除远程服务器中的标签，我们可使用 <code>git push &lt;serverName&gt; :refs/tags/&lt;tagName&gt;</code> (将冒号前的空值推送至远程服务器中的指定标签名) 或 <code>git push &lt;serverName&gt; --delete &lt;tagName&gt;</code>。</p>
</li>
<li><p><code>git checkout &lt;tagName&gt;</code></p>
<p>此命令用于查看特定标签所指代的文件版本。此命令会使得本地仓库处于 <code>detachecd HEAD</code> 状态，它会存在一定副作用。</p>
</li>
</ul>
<p>由于某些命令比较复杂，具体使用比较繁琐，Git 提供 <strong>别名</strong> 功能以允许用户自定义简洁命令以替代复杂命令。我们在此举一个例子：<code>git config --global alias.unstage &#39;reset HEAD&#39;</code>，它将 <code>unstage</code> 定义为 <code>reset HEAD --</code> 的别名。以往取消暂存区文件至工作区，需要使用命令 <code>git reset HEAD &lt;fileName&gt;</code>，现在可使用命令 <code>git unstage &lt;fileName&gt;</code>。</p>
]]></content>
      <categories>
        <category>git学习</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>git 起源</title>
    <url>/2020/09/29/git/gitstudy1-origin/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文首先介绍了三种版本控制系统，并简要指明各自优缺点，随后介绍了 <code>git</code> 及首次安装所需的若干配置。</p>
<a id="more"></a>

<h2 id="版本控制系统"><a href="#版本控制系统" class="headerlink" title="版本控制系统"></a>版本控制系统</h2><p><strong>版本控制系统</strong> 就是一种记录若干文件内容变化，以便将来查阅特定版本修订情况的系统。换言之，借助于该系统，我们可以保存若干文件的历史版本，并根据需要能够快速获取指定版本的具体内容。</p>
<h3 id="本地版本控制系统"><a href="#本地版本控制系统" class="headerlink" title="本地版本控制系统"></a>本地版本控制系统</h3><p>最基本的版本控制系统应当是这样的 —— 复制整个项目所在目录以保存不同版本，同时为项目目录名添加时间以示区别。这种位于本机的版本控制系统称为 <em>本地版本控制系统</em>。</p>
<p>经过若干年发展，本地版本控制系统大多基于如下原理进行实现：使用某种简单数据库存储项目文件的历次更新差异。</p>
<img src="/2020/09/29/git/gitstudy1-origin/image-20200927205659718.png" alt="图一：本地版本控制系统" width="50%">

<p>在这其中，最为流行的便是 RCS，它在硬盘之上保存补丁集 (即文件修订前后的变化)，通过应用所有补丁，可以计算得到各个版本的具体内容。</p>
<p>本地版本控制系统具有如下优缺点：</p>
<ul>
<li>优点<ul>
<li>便于个人管理项目。</li>
</ul>
</li>
<li>缺点<ul>
<li>无法实现多人合作同时开发项目。</li>
</ul>
</li>
</ul>
<h3 id="集中式版本控制系统"><a href="#集中式版本控制系统" class="headerlink" title="集中式版本控制系统"></a>集中式版本控制系统</h3><p>本地版本控制系统存在一个最大的问题：无法实现多人合作同时开发项目。为解决此问题，<em>集中式版本控制系统</em> 应运而生。集中式版本控制系统大多基于如下原理实现：单一集中管理的服务器存储项目文件的所有历史版本 (基于保存版本文件间差异而实现，也可以直接称为补丁集)，协同工作的人们通过客户端连接到服务器，取出最新项目文件开始工作，随后执行提交操作以更新项目文件。</p>
<img src="/2020/09/29/git/gitstudy1-origin/image-20200927213559486.png" alt="图二：集中式版本控制系统" width="50%">

<p>集中式版本控制系统具有如下优缺点：</p>
<ul>
<li>优点<ul>
<li>方便管理、操作简单、易于上手。</li>
<li>集中式服务器更能保证安全性。</li>
<li>项目一致性非常高。</li>
</ul>
</li>
<li>缺点<ul>
<li>服务器性能要求极高。如果服务器发生宕机，这段时间便无法协同开发项目；如果服务器磁盘发生损坏，可能导致项目所有版本数据丢失。</li>
<li>必须联网以开发项目 (这是集中式版本控制系统的劣势)。</li>
<li>分支管控功能不够灵活。</li>
</ul>
</li>
</ul>
<h3 id="分布式版本控制系统"><a href="#分布式版本控制系统" class="headerlink" title="分布式版本控制系统"></a>分布式版本控制系统</h3><p>为解决集中式版本控制系统的若干缺点，分布式版本控制系统被提出。</p>
<img src="/2020/09/29/git/gitstudy1-origin/image-20200928110410990.png" alt="图三：分布式版本控制系统" width="50%">

<p>相比于集中式版本控制系统而言，它具有如下特征：</p>
<ol>
<li>客户端不仅提取最新项目文件，而且将其所有历史版本一同提取到本机。如此操作，一旦存放项目文件的服务器 (此处的服务器与集中式版本控制系统中的服务器含义不同，此处的服务器仅用于托管项目文件) 发生故障，即可使用本地所存文件进行恢复。</li>
<li>客户端不仅可以同服务器进行交互以开发项目；而且可以直接与其他用户进行交互以开发项目。</li>
</ol>
<p>分布式版本控制系统具有如下优缺点：</p>
<ul>
<li>优点<ul>
<li>项目文件本地化，更能保证项目文件的完整性。</li>
<li>不联网时也可完成项目开发。</li>
<li>分支管控功能往往十分灵活、强大。</li>
</ul>
</li>
<li>缺点<ul>
<li>学习成本高，不容易上手。</li>
</ul>
</li>
</ul>
<h2 id="git"><a href="#git" class="headerlink" title="git"></a>git</h2><p>我们在此介绍一种十分著名、广泛使用的分布式版本控制系统 —— <code>git</code>。</p>
<p>经过多年发展，<code>git</code> 已日臻完善，并具有如下特征：</p>
<ol>
<li>设计简单、易于上手。</li>
<li>速度飞快，适合大项目管理。</li>
<li>完全分布式。</li>
<li>具有极其强大的分支管理系统，以保证对非线性开发模式的强力支持。</li>
</ol>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>这里，我们借由差异对比以介绍 <code>git</code> 工具：</p>
<ol>
<li><p>对于其他版本控制系统而言，它们将所需存储的项目文件看作是一组基本文件和每个文件随时间逐步积累的差异 (这种类型的版本控制系统可统称为 <em>基于差异的版本控制系统</em>)。</p>
<p><img src="/2020/09/29/git/gitstudy1-origin/image-20200929085836559.png" alt="图四：其他版本控制系统的项目文件"></p>
<p>对于 <code>git</code> 而言，每更新一次项目状态，它就为项目所有文件创建快照 (可简单理解为当前项目所有文件的一个副本) 并保存该快照的索引。如果某文件未曾发生变动，则仅保留一个指向之前存储该文件的链接。故而，<code>git</code> 将所需存储的项目文件看作为 <strong>快照流</strong>。</p>
<p><img src="/2020/09/29/git/gitstudy1-origin/image-20200929090912163.png" alt="图五：git 的项目文件"></p>
</li>
<li><p>为实现多人合作项目开发，其他版本控制系统基本都需要进行联网；对于 <code>git</code> 而言，绝大多数操作均为本地操作，仅有少数操作需要进行联网。</p>
</li>
<li><p><code>git</code> 底层使用 SHA-1 计算文件校验和，并以此作为文件索引。</p>
</li>
<li><p><code>git</code> 将项目中文件分为三种状态：已提交 (commited)、已暂存 (staged)、已修改 (modified)。已修改表示修改了文件，但还未对其做任何管理操作；已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中；已提交表示数据已经安全地保存在本地仓库中。</p>
<p>根据这三种文件状态，<code>git</code> 项目拥有三种阶段 —— 工作区、暂存区以及 Git 仓库 (也称仓库区、本地仓库、版本库)。</p>
<img src="/2020/09/29/git/gitstudy1-origin/image-20200929105215986.png" alt="图六：git 项目阶段" width="80%">

<p>工作区是对项目的某个版本独立提取出来的内容。 这些从 Git 仓库的压缩数据库中提取出来，放在磁盘上供你使用或修改。</p>
<p>暂存区是一个文件，保存了下次将要提交的文件列表信息，一般在 Git 仓库目录中。 按照 Git 术语，其应当称为 “index”，但一般还是称为“暂存区”。</p>
<p>Git 仓库是 Git 用来保存项目元数据和对象数据库的地方。 这是 Git 中最重要的部分，它具体表现为 <code>.git</code> 文件夹。</p>
</li>
</ol>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>从 <a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a> 下载相应平台版本后，傻瓜式安装即可。</p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>首次下载 <code>git</code> 工具后，我们需要执行一些信息配置工作。<code>git</code> 提供 <code>git config</code> 命令帮助设置控制 Git 外观和行为相关的配置变量。根据使用命令的具体参数不同，这些变量将存储于三种不同的位置：</p>
<ol>
<li><code>/etc/gitconfig</code> 文件：包含系统级通用配置信息。如果使用 <code>git config --system</code> 配置变量，其将位于此文件中。在 Windows 系统中，其通常位于 <code>C:\Documents and Settings\All Users\Application Data\Git\config</code>。</li>
<li><code>~/.gitconfig</code> 文件：包含用户级通用配置信息。如果使用 <code>git config --global</code> 配置变量，其将位于此文件中。在 Windows 系统中，其通常位于 <code>C:/User/$User/.gitconfig</code>。</li>
<li>当前仓库下 <code>.git</code> 文件：包含本仓库的配置信息。如果直接使用 <code>git config</code> 配置变量，其将位于此文件中。</li>
</ol>
<blockquote>
<p>变量配置是否生效基于就近原则，即当前仓库下 <code>.git</code> 文件中的配置信息将会覆盖 <code>~/.gitconfig</code> 文件中的配置信息，<code>~/.gitconfig</code> 文件中的配置信息将会覆盖 <code>/etc/gitconfig</code> 文件中的配置信息。</p>
</blockquote>
<p>由于每次提交到 Git 仓库需要使用个人信息，因此我们需要配置用户名和邮件地址信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">&quot;John Doe&quot;</span></span><br><span class="line">$ git config --global user.email johndoe@example.com</span><br></pre></td></tr></table></figure>
<p>另外我们也可通过 <code>git config --list --show-orign</code> 查看所有已配置的变量信息及其所在文件位置。借于此，我们可以知道哪些变量可配置，从而使用 <code>git config</code> 命令修改现有配置。</p>
]]></content>
      <categories>
        <category>git学习</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-动态规划(十)</title>
    <url>/2020/09/20/algorithm/algorithm-dynamicprogramming10/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文主要介绍 DAG 上 DP，与其相关的题目有：嵌套矩形、硬币问题。</p>
<a id="more"></a>

<p>DAG 上 DP 问题，其本质在于将题目转换为有向无环图 (DAG) 上的最短路径、最长路径、路径计数等问题，从而使用动态规划进行求解。</p>
<h2 id="嵌套矩形"><a href="#嵌套矩形" class="headerlink" title="嵌套矩形"></a>嵌套矩形</h2><h3 id="题目描述及示例"><a href="#题目描述及示例" class="headerlink" title="题目描述及示例"></a>题目描述及示例</h3><p>有 $n$ 个矩形，每个矩形可以用 $a,b$ 来描述，分别表示长和宽。矩形 $X(a,b)$ 可以嵌套在矩形 $Y(c,d)$ 中当且仅当$a&lt;c,b&lt;d$ 或者 $b&lt;c,a&lt;d$。例如 $(1,5)$ 可以嵌套在 $(6,2)$ 内，但不能嵌套在 $(3,4)$ 中。你的任务是选出尽可能多的矩形排成一行，使得除最后一个外，每一个矩形都可以嵌套在下一个矩形内。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line"><span class="comment">// 第一行包含整数n，表示矩形数量。</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="comment">// 接下来n行，每行包含两个整数，分别表示矩形长和宽。</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">5</span> <span class="number">8</span></span><br><span class="line"><span class="number">6</span> <span class="number">10</span></span><br><span class="line"><span class="number">7</span> <span class="number">9</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span></span><br><span class="line"><span class="number">5</span> <span class="number">8</span></span><br><span class="line"><span class="number">12</span> <span class="number">10</span></span><br><span class="line"><span class="number">9</span> <span class="number">7</span></span><br><span class="line"><span class="number">2</span> <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">Output:</span><br><span class="line"><span class="comment">// 输出一个整数，表示最多符合条件的矩形数目。</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>数据存储</p>
<p>根据题意，可以看到：矩形嵌套成立条件有些复杂，为简化操作，对于每个矩形而言，我们将小值作为矩形的宽，大值作为矩形的长。此时只需判断两个矩形的宽长是否满足大小，即可判断矩形嵌套是否成立。</p>
<p>这道题目可以如此理解：每个矩形对应图中一个结点，如果矩形 $A$ 可以嵌套于矩形 $B$ 之内，则矩形 $B$ 所在结点引出一条有向边指向矩形 $A$ 所在结点。“最多符合嵌套条件的矩形数目” 便可理解为图中最长路径的所占结点数量。</p>
<p><code>graph[i][j]</code> 用于存储结点间权值信息，如果结点间存在边，则权值为 $1$，否则权值为 $0$。</p>
</li>
<li><p>状态表示</p>
<p>我们可以这样表示状态 $f[i]$：以当前结点 $i$ 作为终点，其路径上所占结点的最多数量。</p>
</li>
<li><p>状态转移</p>
<p>状态表示已然出现，状态转移便是比较简单。对于状态 $f[i]$ 而言，其应当由状态 $f[j]$ (结点 $j$ 需有边指向结点 $i$) 转移得到。</p>
<p>状态转移方程具体表示如下：</p>
<p>$$f[i] = max(f[j] + graph[j][i]),(0 \leq j &lt; n)$$</p>
<blockquote>
<p>因边权值设置，我们可如此表示状态。</p>
</blockquote>
</li>
<li><p>状态初始化</p>
<p>对于图而言，自然使用记忆化搜索实现。首先需要将所有状态置为未知 (可使用状态值为 $-1$ 表示未知)；搜索过程中，如果不存在指向当前结点 $i$ 的结点，则置 $f[i] = 1$。</p>
</li>
</ul>
<h2 id="硬币问题"><a href="#硬币问题" class="headerlink" title="硬币问题"></a>硬币问题</h2><h3 id="题目描述及示例-1"><a href="#题目描述及示例-1" class="headerlink" title="题目描述及示例"></a>题目描述及示例</h3><p>有 $n$ 种硬币，面值分别为 $V_1, V_2···,V_n$，每种都有无限多。给定非负整数 $S$ ，可以选用多少个硬币，使得面值之和恰好为 $S$？输出硬币数目的最小值和最大值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line"><span class="comment">// 第一行包含两个整数n,s。</span></span><br><span class="line"><span class="number">3</span> <span class="number">18</span></span><br><span class="line"><span class="comment">// 接下来n行，每行包含一个整数，表示硬币面值。</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line"><span class="comment">// 输出两个整数，分别表示硬币数目的最小值和最大值。</span></span><br><span class="line"><span class="number">5</span> <span class="number">18</span></span><br></pre></td></tr></table></figure>
<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>数据存储</p>
<p>该题可以这样理解：整数 $0 \sim S$ 分别表示图中一个顶点，对于整数 $i,j \ (j &gt; i)$ 而言，如果 $j - i$ 对应某种面值的硬币，则整数 $i$ 所在结点引出一条有向边指向整数 $j$ 所在结点。“硬币数目的最小值和最大值” 便可理解为：从整数 $0$ 所在结点到整数 $S$ 所在结点的所有路径中，最长路径的长度和最短路径的长度。</p>
<p><code>graph[i][j]</code> 用于存储结点间权值信息，如果结点间存在边，则权值为 $1$，否则权值为 $0$。</p>
</li>
<li><p>状态表示</p>
<p>我们可以这样表示状态 $f[i]$：以当前结点 $i$ 作为终点，其最长路径的长度，$p[i]$：以当前结点 $i$ 作为终点，其最短路径的长度。</p>
</li>
<li><p>状态转移</p>
<p>状态转移与上题类似，我们直接给出状态转移方程：</p>
<p>$$f[i] = max(f[j] + graph[j][i]),(0 \leq j &lt; n)$$</p>
<p>$$p[i] = min(p[j] + graph[j][i]),(0 \leq j &lt; n)$$</p>
</li>
<li><p>状态初始化</p>
<p>对于图而言，自然使用记忆化搜索实现。首先需要将所有状态置为未知 (可使用状态值为 $-1$ 表示未知)；搜索过程中，如果当前结点所示整数为 $0$，则置 $f[i] = 0,p[i] = 0$，如果当前结点没有任何结点指向，则置 $f[i] = -INF,p[i] = INF$ ($INF$ 表示无穷大)。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>DAG上DP</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-动态规划(九)</title>
    <url>/2020/09/20/algorithm/algorithm-dynamicprogramming9/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文主要介绍数位 DP，与其相关的题目有：度的数量、数字游戏。</p>
<a id="more"></a> 

<p>数位 DP 是在数位之上执行 DP，其实现往往有模板可循，我们在此列举并说明其模板：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数位DP通常需要求取指定区间[a,b]内满足条件的树的个数，为此我们可以求取[0,b] - [0,a-1]。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 状态表示：第i位为j时，满足条件的数的个数。</span></span><br><span class="line"><span class="keyword">int</span>[][] f;</span><br><span class="line"><span class="comment">// 基于某进制保存各位上的数。</span></span><br><span class="line"><span class="keyword">int</span>[] nums;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从高到底遍历各位。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = nums.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="comment">// 获取当前位</span></span><br><span class="line">    <span class="keyword">int</span> num = nums[i];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当前位取0~num-1时，统计个数。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当前位取num时，记录相关信息</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当i=0时，循环即将结束，可能需要做一些边界处理。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>数位 DP 其实就数位统计，只不过有些统计需要用到 DP 而已。</p>
</blockquote>
<h2 id="度的数量"><a href="#度的数量" class="headerlink" title="度的数量"></a>度的数量</h2><h3 id="题目描述及示例"><a href="#题目描述及示例" class="headerlink" title="题目描述及示例"></a>题目描述及示例</h3><p>求给定区间 $[X,Y]$ 中满足下列条件的整数个数：这个数恰好等于 $K$ 个互不相等的 $B$ 的整数次幂之和。</p>
<p>例如，设 $X=15,Y=20,K=2,B=2$，则有且仅有下列三个数满足题意：$17=2^4+2^0$$、18=2^4+2^1$、$20=2^4+2^2$。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line"><span class="comment">// 第一行包含两个整数，分别表示X、Y。</span></span><br><span class="line"><span class="number">15</span> <span class="number">20</span></span><br><span class="line"><span class="comment">// 第二行包含两个整数，分别表示K、B。</span></span><br><span class="line"><span class="number">2</span> <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">Output:</span><br><span class="line"><span class="comment">// 输出一个整数，表示满足条件的整数个数。</span></span><br></pre></td></tr></table></figure>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>数据存储</p>
<p><code>numX[i]</code> 用于存储 $B$ 进制表示的 $X$，<code>numY[i]</code> 用于表示 $B$ 进制表示的 $Y$。</p>
</li>
<li><p>状态表示</p>
<p>根据题意，如果一个数满足条件，则其 $B$ 进制表示中 $K$ 位为 $1$，其余位均为 $0$。我们在此先行给出状态表示 $f[i][j]$：组合数 $C_i^j$ ，具体原因后续将会看到。</p>
</li>
<li><p>状态转移</p>
<p>按照最上面所述的解题模板，我们应当从最高位第 $i$ 位进行枚举。假定需要求取指定区间 $[0,X]$ 内满足条件的数的个数、此时最高位为 $numX[i]$，如果 $numX[i] &gt; 1$，则其有两种选择：其一，当前位取 $1$，后续 $i$ 位任取 $k - 1$ 个 $1$，如此组合得到的数一定满足条件，其个数为 $C_i^{k - 1}$ (这就是我们的状态表示)；其二，当前位取 $0$，后续 $i$ 位任取 $k$ 个 $1$，如此组合得到的数也一定满足条件，其个数为 $C_i^k$；如果 $numX[i] = 1$，则其同样有两种选择：其一，当前位取 $0$，后续 $i$ 位任取 $k$ 个 $1$，如此组合得到的数也一定满足条件，其个数为 $C_i^k$；其二，当前位取 $1$，此时后续 $i$ 位无法任意取 $i - 1$ 个 $1$，因为任取得到的数可能大于 $X$，此时就需要枚举第 $i - 1$ 位，根据其情况再做判断；如果 $numX[i] = 0$，则直接枚举第 $i - 1$ 位即可。</p>
<blockquote>
<p>如果 $numX[i] &gt; 1$，统计两种选择所满足的数的个数后就可以直接退出循环了。如果按照解题模板那样，当前位取 $numX[i]$ 所得到的数都是不满足条件的。</p>
<p>如果 $numX[i] = 1$，当前位取 $1$ 并开始枚举第 $i - 1$ 位时，需要统计当前位前方已有多少个 $1$。</p>
<p>当枚举到第 $0$ 位时，如果当前位为 $0$ 且当前位前方已有 $K$ 个 $1$，则这也是一个满足条件的数。</p>
</blockquote>
<p>我们在此介绍简单说明 $f[i][j]$ 的状态转移方程 (就是组合公式 $C_i^k = C_{i - 1}^k + C_{i - 1}^{k - 1}$)：</p>
<p>$$f[i][j] = f[i - 1][j - 1] + f[i - 1][j]$$</p>
</li>
<li><p>状态初始化</p>
<p>我们只需置 $f[i][0] = 1,(i \leq 0 &lt; f.length)$ 即可。</p>
</li>
</ul>
<h2 id="数字游戏"><a href="#数字游戏" class="headerlink" title="数字游戏"></a>数字游戏</h2><h3 id="题目描述及示例-1"><a href="#题目描述及示例-1" class="headerlink" title="题目描述及示例"></a>题目描述及示例</h3><p>科协里最近很流行数字游戏。某人命名了一种不降数，这种数字必须满足从左到右各位数字呈非下降关系，如 $123,446$。现在大家决定玩一个游戏，指定一个整数闭区间 $[a,b]$，问这个区间内有多少个不降数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line"><span class="comment">// 输入两个整数，分别表示a,b。</span></span><br><span class="line"><span class="number">1</span> <span class="number">19</span></span><br><span class="line">    </span><br><span class="line">Output:</span><br><span class="line"><span class="comment">// 输出一个整数，表示满足条件的数的个数。</span></span><br><span class="line"><span class="number">18</span></span><br></pre></td></tr></table></figure>
<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>数据存储</p>
<p><code>numA[i]</code> 用于存储十进制表示的 $a$，<code>numB[i]</code> 用于存储十进制表示的 $b$ (假定数组高位对应数字的高位)。</p>
</li>
<li><p>状态表示</p>
<p>我们可以这样表示状态 $f[i][j]$：第 $i$ 位放置 $j$、其余位随意放置时，满足条件的数的个数。</p>
</li>
<li><p>状态转移</p>
<p>这道题与上题类似，假定需要求取指定区间 $[0,A]$ 内满足条件的数的个数，且最高有效位为第 $i$ 位、最高位数字为 $numA[i]$。当前位置取 $0 \sim (numA[i] - 1)$ 时，其余位可任取，故而我们统计 $\sum_{j = 0}^{numA[i]}(f[i][j])$ 以得到满足条件的数的个数；当前位置取 $numA[i]$ 时，其余位不可任取 (原因同上)，故而需要枚举第 $i - 1$ 位以根据其情况再做判断。</p>
<blockquote>
<p>当枚举第 $i - 1$ 位时，因为需要满足不降数条件，其取值需要小于等于 $numA[i]$，。</p>
</blockquote>
<p>对于状态 $f[i][j]$ 而言，它应当由状态 $f[i - 1][k],(k \leq j)$ 转移得到。其状态转移方程具体如下：</p>
<p>$$f[i][j] = \sum_{k = 0}^j(f[i - 1][k])$$</p>
</li>
<li><p>状态初始化</p>
<p>根据状态表示，我们如此初始化：指定 $f[0][j] = j,(0 \leq j &lt; 10)$。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>数位DP</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-动态规划(八)</title>
    <url>/2020/09/20/algorithm/algorithm-dynamicprogramming8/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文主要介绍树形 DP (简而言之，就是在树结构上完成 DP)，与其相关的题目有：没有上司的舞会、树的最长路径、树的中心、皇宫看守。</p>
<a id="more"></a>

<h2 id="没有上司的舞会"><a href="#没有上司的舞会" class="headerlink" title="没有上司的舞会"></a>没有上司的舞会</h2><h3 id="题目描述及示例"><a href="#题目描述及示例" class="headerlink" title="题目描述及示例"></a>题目描述及示例</h3><p>Ural 大学有 $N$ 名职员，编号为 $1~N$。他们的关系就像一棵以校长为根的树，父节点就是子节点的直接上司。每个职员有一个快乐指数，用整数 $Hi$ 给出，其中 $1 \leq i \leq N$。现在要召开一场周年庆宴会，不过，没有职员愿意和直接上司一起参会。在满足这个条件的前提下，主办方希望邀请一部分职员参会，使得所有参会职员的快乐指数总和最大，求这个最大值?</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line"><span class="comment">// 第一行包含一个整数。</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="comment">// 接下来N行，每行包含一个整数，表示职员的快乐指数。</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="comment">// 接下来N-1行，记录各职员的直接上司。</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">6</span> <span class="number">4</span></span><br><span class="line"><span class="number">7</span> <span class="number">4</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">3</span> <span class="number">5</span></span><br><span class="line">    </span><br><span class="line">Output:</span><br><span class="line"><span class="comment">// 输出一个整数，表示最大的快乐指数。</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>数据存储</p>
<p><code>w[i]</code> 用于存储各职员的快乐指数，<code>child[i][*]</code> 用于存储各职员的直接下级，<code>root</code> 用于存储根职员。</p>
</li>
<li><p>状态表示</p>
<p>对于树形 DP 而言，状态表示往往类似于：在以当前节点为根节点的子树中进行操作，所能得到的最大/最小价值。另外，本题中每个节点具有两种状态 —— 选或不选，则我们可以这样定义状态 $f[i][0]$：在以当前节点 $i$ 为根节点的子树中，选择职员参加舞会且当前节点所示职员不参加舞会情况下，所能得到的最大快乐指数，和 $f[i][1]$：在以当前节点 $i$ 为根节点的子树中，选择职员参加舞会且当前节点所示职员参加舞会情况下，所能得到的最大快乐指数。</p>
</li>
<li><p>状态转移</p>
<p>根据状态表示及题目描述，可很容易得到如下的状态转移方程：</p>
<p>当前节点所示职员参加舞会：</p>
<p>$$f[i][1] = \sum_{j = 1}^{child[j].length}(f[son][0]),(son = child[i][j])$$</p>
<p>当前节点所示职员不参加舞会：</p>
<p>$$f[i][0] = \sum_{j = 1}^{child[j].length}(max(f[son][0],f[son][1])),(son = child[i][j])$$</p>
</li>
<li><p>状态初始化</p>
<p>树形 DP 往往采用记忆化搜索实现，故而需要先将所有状态置为未知 (可使用状态值为 $-1$ 表示未知)；搜索过程中，如果当前节点为叶节点，则设置 $f[i][0] = 0,f[i][1] = w[i]$ 即可。</p>
<blockquote>
<p>执行记忆化搜索之时，需从根职员开始。</p>
</blockquote>
</li>
</ul>
<h2 id="树的最长路径"><a href="#树的最长路径" class="headerlink" title="树的最长路径"></a>树的最长路径</h2><h3 id="题目描述及示例-1"><a href="#题目描述及示例-1" class="headerlink" title="题目描述及示例"></a>题目描述及示例</h3><p>给定一棵树，树中包含 $n$ 个结点（编号 $1 \sim n$）和 $n−1$ 条无向边，每条边都有一个权值 (权值非负)。现在请你找到树中的一条最长路径，换句话说，要找到一条路径，使得路径两个端点的距离最远。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line"><span class="comment">// 第一行包含整数n。</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="comment">// 接下来n−1行，每行包含三个整数ai,bi,ci，表示点ai和bi之间存在一条权值为ci的边。</span></span><br><span class="line"><span class="number">5</span> <span class="number">1</span> <span class="number">6</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">6</span> <span class="number">3</span> <span class="number">9</span></span><br><span class="line"><span class="number">2</span> <span class="number">6</span> <span class="number">8</span></span><br><span class="line"><span class="number">6</span> <span class="number">1</span> <span class="number">7</span></span><br><span class="line">    </span><br><span class="line">Output:</span><br><span class="line"><span class="comment">// 输出一个整数，表示树的最长路径的长度。</span></span><br><span class="line"><span class="number">22</span></span><br></pre></td></tr></table></figure>
<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>数据存储</p>
<p><code>child[i][*]</code> 用于存储各节点间关系，<code>graph[i][k]</code> 用于存储节点间权值信息，<code>root</code> 用于存储根节点。</p>
</li>
<li><p>状态表示</p>
<p>根据题意：任意两点距离的最大值即为树的最长路径 (注意：该定义无视树边的有向性)。除使用基本的路径算法外，我们可以这样求取任意两个节点 $A,B$ 的距离：假定 $A,B$ 两点路径中最靠近树根的节点为 $C$，那么我们只需要求取节点 $C$ 到节点 $A,B$ 的距离，二者之和便是两节点的距离。这一求解方式是此题状态表示的基础，针对此题，我们可以这样定义状态 $f[i][0]$：当前节点到其子树节点的最大距离，和 $f[i][1]$：当前节点到其子树节点的次大距离。</p>
<p>当对所有节点求取两种状态后，树的最长路径值便是 $max(f[i][0] + f[i][1]),(0 \leq i &lt; n)$。</p>
</li>
<li><p>状态转移</p>
<p>此题目的状态转移比较特殊，我们我们使用方程进行表述：</p>
<p>$$(f[i][0]) = maxFirst(0,f[j][0] + graph[i][j]),(0 \leq j &lt; child[i].length)$$</p>
<p>$$(f[i][1]) = maxSecond(0,f[j][0] + graph[i][j]),(0 \leq j &lt; child[i].length)$$</p>
<blockquote>
<p><code>maxFirst</code> 表示最大值，<code>maxSecond</code> 表示次大值。</p>
</blockquote>
</li>
<li><p>状态初始化</p>
<p>此题同样需要使用记忆化搜索加以实现。首先需要将所有状态置为未知 (可使用状态值为 $-1$ 表示未知)；搜索过程中，如果当前节点为叶节点，则置 $f[i][0] = f[i][1] = 0$。</p>
</li>
</ul>
<h2 id="树的中心"><a href="#树的中心" class="headerlink" title="树的中心"></a>树的中心</h2><h3 id="题目描述及示例-2"><a href="#题目描述及示例-2" class="headerlink" title="题目描述及示例"></a>题目描述及示例</h3><p>给定一棵树，树中包含 $n$ 个结点（编号 $1~n$）和 $n−1$ 条无向边，每条边都有一个权值。请你在树中找到一个点，使得该点到树中其他结点的最远距离最近。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line"><span class="comment">// 第一行包含整数n。</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="comment">// 接下来n−1行，每行包含三个整数ai,bi,ci，表示点ai和bi之间存在一条权值为ci的边。</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">1</span> </span><br><span class="line"><span class="number">3</span> <span class="number">2</span> <span class="number">1</span> </span><br><span class="line"><span class="number">4</span> <span class="number">3</span> <span class="number">1</span> </span><br><span class="line"><span class="number">5</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">Output:</span><br><span class="line"><span class="comment">// 输出一个整数，表示所求点到树中其他结点的最远距离。</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>数据存储</p>
<p><code>child[i][*]</code> 用于存储各节点间关系，<code>graph[i][k]</code> 用于存储节点间权值信息，<code>root</code> 用于存储根节点。</p>
</li>
<li><p>状态表示</p>
<p>如果我们求得任意一点向下走和向上走所能到达树中其他节点的最远距离，那么此题便迎刃而解。我们首先简单看一个例子：</p>
<img src="/2020/09/20/algorithm/algorithm-dynamicprogramming8/image-20200919110935307.png" style="zoom:50%;">

<p>其中：我们求取节点 $3$ 向下走 (红线) 和向上走 (绿线) 所能达到树中其他节点的最远距离。</p>
<p>为求解向下走和向上走的最远距离，我们需要定义如下状态 $f[i][0]$：当前节点向下走所能走到的最远距离，$f[i][1]$：当前节点向下走所能走到的次远距离 (保存该值是有意义的，例子中节点 $3$ 向上走的最远距离就使用到节点 $8$ 的次远距离)；$f[i][3]$：当前节点向上走所能走到的最远距离。另外我们需要保存当前节点向下走最远距离时所选择的节点及当前节点向下走次远距离时所选择的节点，分别使用 $p0[i]$ 和 $p1[i]$ 进行存储。</p>
</li>
<li><p>状态转移</p>
<p>$f[i][0]$ 和 $f[i][1]$ 的状态转移与上题一致，我们主要介绍 $f[i][3]$ 的状态转移。</p>
<p>对于状态 $f[i][3]$ 而言，它一定经由父节点的状态转移得到。如果当前节点非为父节点向下走最远路径时所选择节点，则当前状态应当由 $f[i][3]$ 或 $f[i][0]$ 转移得到；否则应当由 $f[i][3]$ 或 $f[i][1]$ 转移得到，故而其状态转移方程可表示如下：</p>
<p>$$f[i][3] = max(f[parent][3],f[i][0]) + graph[parent][i],(i \neq p0[parent])$$</p>
<p>$$f[i][3] = max(f[parent][3],f[i][1]) + graph[parent][i],(i = p0[parent])$$</p>
<blockquote>
<p>实际实现中，我们会根据当前节点信息更新子节点状态，而非状态转移中根据父节点信息更新当前节点状态。</p>
<p>$f[i][0],f[i][1]$ 应当自底向上记忆化搜索，$f[i][3]$ 应当自顶向下搜索，且同时使用到状态 $f[i][0],f[i][1]$ ，故而此题应当分两次搜索，首先执行自底向上记忆化搜索，随后自顶向下搜索，以完成所有状态的更新。</p>
</blockquote>
</li>
<li><p>状态初始化</p>
<p>如上所述，此题使用记忆化搜索实现 DP。首先需要将所有状态置为未知 (可使用状态值为 $-1$ 表示未知)；当记忆化搜索 $f[i][0],f[i][1]$ 时，如果当前节点为叶节点，则置 $f[i][0] = f[i][1] = 0$；当搜索 $f[i][3]$ 时，我们直接置 $f[root][3] = 0$ 即可。</p>
</li>
</ul>
<h2 id="皇宫看守"><a href="#皇宫看守" class="headerlink" title="皇宫看守"></a>皇宫看守</h2><h3 id="题目描述及示例-3"><a href="#题目描述及示例-3" class="headerlink" title="题目描述及示例"></a>题目描述及示例</h3><p>太平王世子事件后，陆小凤成了皇上特聘的御前一品侍卫。皇宫各个宫殿的分布，呈一棵树的形状，宫殿可视为树中结点，两个宫殿之间如果存在道路直接相连，则该道路视为树中的一条边。已知，在一个宫殿镇守的守卫不仅能够观察到本宫殿的状况，还能观察到与该宫殿直接存在道路相连的其他宫殿的状况。</p>
<p>大内保卫森严，三步一岗，五步一哨，每个宫殿都要有人全天候看守，在不同的宫殿安排看守所需的费用不同。可是陆小凤手上的经费不足，无论如何也没法在每个宫殿都安置留守侍卫。帮助陆小凤布置侍卫，在看守全部宫殿的前提下，使得花费的经费最少。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line"><span class="comment">// 第一行包含整数n,表示树中结点个数。</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="comment">// 接下来n行，每行描述一个宫殿信息，具体包括该宫殿结点标号i，安置侍卫所需的经费k，子结点数m，具体的子结点。</span></span><br><span class="line"><span class="number">1</span> <span class="number">30</span> <span class="number">3</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">2</span> <span class="number">16</span> <span class="number">2</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line"><span class="number">3</span> <span class="number">5</span> <span class="number">0</span></span><br><span class="line"><span class="number">4</span> <span class="number">4</span> <span class="number">0</span></span><br><span class="line"><span class="number">5</span> <span class="number">11</span> <span class="number">0</span></span><br><span class="line"><span class="number">6</span> <span class="number">5</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">Output:</span><br><span class="line"><span class="comment">// 输出一个整数，表示最少的经费。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>数据存储</p>
<p><code>child[i][*]</code> 用于存储各节点间关系，<code>w[i]</code> 用于存储节点权值信息，<code>root</code> 用于存储根节点。</p>
</li>
<li><p>状态表示</p>
<p>题目要求每个结点都能够被看到，而且一个结点存在三种被看到的情况，故而我们可以这样定义状态 $f[i][0]$：当前子树的所有结点被看到、当前结点由父节点看到时，所需的最小代价，$f[i][1]$：当前子树的所有结点被看到、当前结点由子节点看到时，所需的最小代价，$f[i][2]$：当前子树的所有结点被看到、当前结点由自己看到时，所需的最小代价。</p>
</li>
<li><p>状态转移</p>
<p>对于 $f[i][0]$ 而言，当前节点已由父节点看到，那么子结点要么由自己看到，要么由其子结点看到；对于 $f[i][1]$ 而言，当前节点已由子结点看到，那么至少存在一个子结点需要由自己看到，其余子结点可选择由自己看到，也可选择由子节点看到；对于 $f[i][2]$ 而言，当前阶段已由自己看到，那么子结点要么由父节点看到，要么由自己看到，要么由子节点看到。</p>
<p>状态转移方程具体可表示如下：</p>
<p>$$f[i][0] = SUM,(SUM = \sum(min(f[j][1],f[j][2])),0 \leq j &lt; child[i].length)$$</p>
<p>$$f[i][1] = min(SUM - min(f[j][1],f[j][2]) + f[j][2]),(0 \leq j &lt; child[i].length)$$</p>
<p>$$f[i][2] = \sum(f[j][0],f[i][1],f[i][2]),(0 \leq &lt; j &lt; child[i].length)$$</p>
</li>
</ul>
<ul>
<li><p>状态初始化</p>
<p>本题同样使用记忆化搜索实现 DP。首先需要将所有状态置为未知 (可使用状态值为 $-1$ 表示未知)；搜索过程中，如果当前结点为叶结点，则置 $f[i][0] = 0,f[i][1] = INF,f[i][2] = w[i]$ ($INF$ 表示无穷大)。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-动态规划(七)</title>
    <url>/2020/09/18/algorithm/algorithm-dynamicprogramming7/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文主要介绍区间 DP，与其相关的题目有：石子合并、棋盘分割。</p>
<a id="more"></a>

<h2 id="石子合并"><a href="#石子合并" class="headerlink" title="石子合并"></a>石子合并</h2><h3 id="题目描述及示例"><a href="#题目描述及示例" class="headerlink" title="题目描述及示例"></a>题目描述及示例</h3><p>设有 $N$ 堆石子排成一排，其编号为 $1，2，3，…，N$。每堆石子有一定的质量，可以用一个整数来描述，现在要将这 $N$ 堆石子合并成为一堆。每次只能合并相邻的两堆，合并的代价为这两堆石子的质量之和，合并后与这两堆石子相邻的石子将和新堆相邻，合并时由于选择的顺序不同，合并的总代价也不相同。</p>
<p>例如有 $4$ 堆石子分别为 $1 3 5 2$， 我们可以先合并 $1、2$ 堆，代价为 $4$，得到 $4 \ 5 \ 2$， 又合并 $1，2$ 堆，代价为 $9$，得到 $9 \ 2$ ，再合并得到 $11$，总代价为 $4+9+11=24$。如果第二步是先合并 $2，3$ 堆，则代价为 $7$，得到 $4 7$，最后一次合并代价为 $11$，总代价为 $4+7+11=22$。</p>
<p>问题是：找出一种合理的方法，使总的代价最小?</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line"><span class="comment">// 第一行包含一个数N，表示石子的堆数。</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="comment">// 第二行包含N个数，表示每堆石子的质量。</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">5</span> <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">Output:</span><br><span class="line"><span class="comment">// 输出一个整数，表示最小代价。</span></span><br><span class="line"><span class="number">22</span></span><br></pre></td></tr></table></figure>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>数据存储</p>
<p><code>prefix[i]</code> 用于存储石子质量的前缀和。</p>
</li>
<li><p>状态表示</p>
<p>我们直接这样表示状态 $f[i][j]$：合并区间 $[i,j]$ 所示石子，所需的最小代价。</p>
</li>
<li><p>状态转移</p>
<p>题目要求 “只有相邻石子才能合并”，故而当前状态 $f[i][j]$ 一定是由 $f[i][k]$ 和 $f[k + 1][j]$ 转移得到。由于并不知道具体 $k$ 取值，故而需要枚举区间内所有合法 $k$ 值。</p>
<p>状态转移方程具体如下：</p>
<p>$$f[i][j] = min(f[i][j], f[i][k] + f[k + 1][j] + prefix[j] - prefix[i - 1]),(i \leq k &lt; j)$$</p>
</li>
<li><p>状态初始化</p>
<p>题意要求求取最小值，故而首先将全部状态初始化为无穷大，随后指定 $f[i][i] = 0,(0 \leq i \leq N)$。</p>
</li>
</ul>
<p>对于区间 DP 问题，使用记忆化搜索实现比较简单；使用递推实现则比较麻烦，但是它具有一定模板，我们在此列出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 状态表示(N*N矩阵)。</span></span><br><span class="line"><span class="keyword">int</span>[][] f;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 首先枚举步长，随后枚举起点。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j + i &lt; N; j++) &#123;</span><br><span class="line">        <span class="comment">// 获取区间左右端点。</span></span><br><span class="line">        <span class="keyword">int</span> L = j, R = j + i;</span><br><span class="line">        <span class="comment">// 枚举区间中间点，实现状态转移。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = j; k &lt; R; k++) &#123;</span><br><span class="line">            f[L][R] = transfer(f[L][k],f[k + <span class="number">1</span>][R]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>此题有一个十分重要的变体 —— 环形石子合并，即当石子环形放置时，如何合并才能使得代价最小。</p>
<p>我们可以枚举所有断点，从而将环形石子合并问题转换为 $N$ 个石子合并问题 (根据上面代码，可以知道其时间复杂度为 $O(N^3)$)，最终寻找 $N$ 个石子合并问题的最小代价即可。容易得知：这种方法的时间复杂度为 $O(N^4)$。</p>
<p>上面这种方法的时间复杂度偏高，另有一种取巧的方法可以大大降低时间复杂度：复制 $N$ 个石子并将它们按序排列在原先 $N$ 个石子序列之后，从而形成长度为 $2N$ 的石子序列 (举例：对于例题而言，形成的石子序列便是 <code>1 3 5 2 1 3 5 2</code>)。对此序列执行区间 DP 并寻找 $f[i,i + N],(0 \leq i &lt; N)$ 的最小值作为环形石子合并的最小代价即可。容易得知：此种方法的时间复杂度为 $(2N)^2 = 8N^2$。</p>
</blockquote>
<h2 id="棋盘分割"><a href="#棋盘分割" class="headerlink" title="棋盘分割"></a>棋盘分割</h2><h3 id="题目描述及示例-1"><a href="#题目描述及示例-1" class="headerlink" title="题目描述及示例"></a>题目描述及示例</h3><p>将一个 $8 \times 8$ 的棋盘进行如下分割：将原棋盘割下一块矩形棋盘并使剩下部分也是矩形，再将剩下的部分继续如此分割，这样割了 $(n-1)$ 次后，连同最后剩下的矩形棋盘共有 $n$ 块矩形棋盘 (每次切割都只能沿着棋盘格子的边进行)。</p>
<p><img src="/2020/09/18/algorithm/algorithm-dynamicprogramming7/image-20200917223418041.png"></p>
<p>原棋盘上每一格有一个分值，一块矩形棋盘的总分为其所含各格分值之和。现在需要把棋盘按上述规则分割成 $n$ 块矩形棋盘，并使各矩形棋盘总分的均方差最小 (均方差：$\sigma = \sqrt{\sum_{i = 1}^n(x_i - \overline{x})^2/n}$，其中 $x_i$ 为各棋盘分值，$\overline{x}$ 为各棋盘分值的平均值)。</p>
<p>请编程对给出的棋盘及n，求出均方差的最小值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line"><span class="comment">// 第一行包含一个整数n。</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="comment">// 接下来8行，每行8个整数，表示棋盘各位置的分值。</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line"><span class="comment">// 输出一个浮点数，表示最小均方差值。</span></span><br><span class="line"><span class="number">1.633</span></span><br></pre></td></tr></table></figure>
<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>数据存储</p>
<p>我们可以先行求取 $n \times \sigma^2$ 的最小值，随后一步转换便得到题目要求的均方差最小值。在求取 $n \times \sigma^2$ 时，我们需要动态获取棋盘分值，故而使用 <code>prefix[i][j]</code> 存储二维前缀和，随后基于此可一步求得指定棋盘分值。另外，我们需要获取各棋盘分值的平均值，此可通过  $prefix[7][7] / 8$ 求得。</p>
</li>
<li><p>状态表示</p>
<p>此题属于区间 DP 的二维扩展，另外题目涉及分割次数，故而我们直接给出状态表示 $f[x1][y1][x2][y2][k]$：将 $(x1,y1) \sim (x2,y2)$ 所示矩形区间分割 $k$ 次，所需的最小代价 (具体指代 $(x_i - \overline{x})^2$)。 </p>
</li>
<li><p>状态转移</p>
<p>根据题目而言，可以采取横向分割，也可采取纵向分割，故而状态转移方程可具体表示如下：</p>
<p>横向切割：</p>
<p>$$f[x1][y1][x2][y2][k] = min(f[x1][y1][x2][y2][k], f[x1][y1][t][y2][k - 1] + sum(x1,y1,t,y2),f[t + 1][y1][x2][y2][k - 1] + sum(t + 1,y1,x2,y2)),(x1 \leq t &lt; x2)$$</p>
<p>纵向切割：</p>
<p>$$f[x1][y1][x2][y2][k] = min(f[x1][y1][x2][y2][k],f[x1][y1][x2][t][k - 1] + sum(x1,y1,x2,k),f[x1][k + 1][x2][y2][k - 1] + sum(x1,k + 1,x2,y2)),(y1 \leq t &lt; y2)$$</p>
<blockquote>
<p><code>sum(x1,y1,x2,y2)</code> 使用二维前缀和求取矩形区间内元素之和，具体返回值为 <code>prefix[x2][y2] - prefix[x1 - 1][y2] - prefix[x2][y1 - 1] + prefix[x1 - 1][y1 - 1]</code>。</p>
</blockquote>
</li>
<li><p>状态初始化</p>
<p>这道题目没有办法使用递推，因为没有可用的初始化状态，故而应当使用记忆化搜索实现 DP。所有状态最初全部设为未知 (可使用状态值为 $-1$ 表示未知)；搜索过程中，如果无法继续分割，直接计算相关值即可。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>区间DP</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-动态规划(六)</title>
    <url>/2020/09/16/algorithm/algorithm-dynamicprogramming6/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文主要介绍状态压缩 DP，与其相关的题目有：玉米地、炮兵阵地、最短 Hamilton 路径、开宝箱。</p>
<a id="more"></a>

<p>状态压缩 DP 属于一种比较另类的动态规划，类似于暴力破解，常用于 NP 问题的小规模求解。其核心在于使用二进制表示集合状态，故而我们需要简单介绍基于二进制的集合。</p>
<p>对于 <code>int</code> 整形而言，它由 $32$ 个 $bit$ 位组成。每个 $bit$ 位存在两种取值，故而每个 $bit$ 位可以表示两种状态，这刚好可以表示集合中元素是否存在。故而我们可以基于整数表示集合中元素状态。举例而言：假定存在五个依序而放的坑位，每个坑位可以种胡萝卜，也可不种胡萝卜，如何表示其所有状态？我们使用五个 $bit$ 位表示五个坑位，如果 $bit$ 位取值为 $1$，表示此坑位种胡萝卜；否则表示此坑位不种胡萝卜。那么区间 $[0,2^5 - 1]$ 中每个整数都映射为一个集合状态，共计 $2^5$ 种状态。</p>
<p>接下来我们简单介绍一些位操作：</p>
<ul>
<li><p><code>&amp;​</code></p>
<p>当使用二进制表示集合时，它可用于求取两个集合的交集。</p>
</li>
<li><p><code>|</code></p>
<p>当使用二进制表示集合时，它可用于求取两个集合的并集。</p>
</li>
<li><p><code>~</code></p>
<p>当使用二进制表示集合时，它可用于求取一个集合的补集。</p>
</li>
<li><p><code>^</code></p>
<p>当使用二进制表示集合时，它可用于求取两个集合的对称差。</p>
</li>
<li><p><code>x | (1 &lt;&lt; (i - 1))</code></p>
<p>将数字 $x$ 的第 $i$ 位置为 $1$。</p>
</li>
<li><p><code>x &amp; (x - 1)</code></p>
<p>将数字 $x$ 的最低位 $1$ 变为 $0$。</p>
</li>
<li><p><code>x &amp; -x</code></p>
<p>将除最低位 $1$ 外的其余 $1$ 变为 $0$ (也就是树状数组中的 $lowBit$ 操作)。</p>
</li>
</ul>
<blockquote>
<p>状态压缩 DP 主要分为两种题型 —— 棋盘式、集合式。玉米地、炮兵阵地属于棋盘式题目，最短 Hamilton 路径、开宝箱属于集合式题目。棋盘式题目往往存在套路可用，而集合式题目则需随机应变 (换言之，就是难)。</p>
</blockquote>
<h2 id="玉米地"><a href="#玉米地" class="headerlink" title="玉米地"></a>玉米地</h2><h3 id="题目描述及示例"><a href="#题目描述及示例" class="headerlink" title="题目描述及示例"></a>题目描述及示例</h3><p>一块土地 $ m \times n $ 个小方格组成，现在要在土地中种植玉米。部分土地是不育的，无法种植；而且相邻的土地不能同时种植玉米，也就是种植玉米的所有方格之间都不会有公共边缘。现在给定土地的大小，请你求出有多少种种植方法。土地上什么都不种也算是一种方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数据范围：0 &lt;= n,m &lt;= 12。</span></span><br><span class="line">Input:</span><br><span class="line"><span class="comment">// 第一行包含两个整数M和N，用于表示土地长宽。</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> </span><br><span class="line"><span class="comment">// 接下来包含M行，每行包含N个整数，表示当前方格是否贫瘠(1表示土地肥沃，0表示土地贫瘠)。</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">Output:</span><br><span class="line"><span class="comment">// 输出一个整数，表示种植方法树。</span></span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>数据存储</p>
<p><code>g[i]</code> 用于存储每行方格状态，如果该方格所代表土地肥沃，则置相应位为 $0$；否则置相应位为 $1$。对于例子而言，$g[0] = 0b000 = 0,g[1] = 0b101 = 5$。<code>state[i]</code> 用于存储可用状态。</p>
</li>
<li><p>状态表示</p>
<p>对于这道题目而言，我们可以看到数据范围十分小，那么基本上可以确定它需要使用状态压缩 DP 进行解决。对于棋盘式题目，我们通常这样定义状态 $f[i][b]$：第 $i$ 行处于 $b$ 所示集合状态时，种植玉米的方案数。 </p>
</li>
<li><p>状态转移</p>
<p>进行状态转移之前，我们需要确定哪些集合状态可用。按照题目所言，横向相邻方格无法同时种植玉米，那么 $0b1001$ 这种状态是可用的，而 $0b110$ 这种状态是不可用的。我们需要从全体状态中选择所有可用状态至 <code>state[i]</code> 之中。</p>
<p>由于纵向相邻方格也无法同时种植玉米，而且当前行状态仅与上一行状态相关，故而我们应当先行循环遍历上一行状态 (记为 $a$)，随后遍历当前行状态 (记为 $b$)，如果两者不相容，则当前状态 $b$ 无效，否则使用如下状态转移方程进行更新：</p>
<p>$$f[i][b] = f[i][b] + f[i - 1][a],(a与b相容,b与g[i]相容)$$</p>
<p>这里探讨两个问题：如何判断状态 $a$ 与 $b$ 是否相容？如何判断状态 $b$ 与 $g[i]$ 是否相容？</p>
<p>首先回答第一个问题：$state[i]$ 中状态均满足“横向相邻方格无法同时种植玉米” 条件，现在需要判断满足 “纵向相邻方格也无法同时种植玉米”  这一条件。如果纵向相邻方格存在同时种植玉米，则相应位一定为 $1$，对状态 $a$、$b$ 执行与操作，其结果一定大于零。所以我们通过 <code>a &amp; b &gt; 0</code> 判断状态 $a$、$b$ 是否相容。</p>
<p>接下来回答第二个问题：正如上面给定的 $g[i]$ 定义，如果 <code>g[i] &amp; b &gt; 0</code>，则贫瘠土地中种有玉米，不符合种植要求。故而使用此式可判断状态 $b$ 与 $g[i]$ 是否相容。</p>
<blockquote>
<p>提前将可用状态放置在 $state[i]$ 之中，意在减小搜索量。</p>
</blockquote>
</li>
<li><p>状态初始化</p>
<p>为简化初始化操作，我们使用 $g[1]$ 存放第 $0$ 行状态，依次而行，使用 $g[m + 1]$ 存放第 $m$ 行状态，此时状态维度便是 $(m + 1) \times state.length$。这样我们只需初始化 $f[0][state] = 0,(0 \leq state &lt; state.length)$ 即可。</p>
</li>
</ul>
<p>棋盘式状态压缩 DP 解题代码往往具有一定程式，我们在此举一模板：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 状态表示存储(默认全部设为某值)。</span></span><br><span class="line"><span class="keyword">int</span>[][] f;</span><br><span class="line"><span class="comment">// 可用状态存储.</span></span><br><span class="line"><span class="keyword">int</span>[] state;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化相关状态。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; f[<span class="number">0</span>].length; i++) &#123;</span><br><span class="line">    f[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 状态转移（首先枚举行，随后枚举上一行状态，最后枚举当前行状态）。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; f.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">0</span>; a &lt; state.length; a++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> b = <span class="number">0</span>; b &lt; state.length; b++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (b 有效 &amp;&amp; a与b相容) &#123;</span><br><span class="line">                f[i][b] = transfer(f[i][a]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到题目答案。</span></span><br><span class="line"><span class="keyword">return</span> f[*][*];</span><br></pre></td></tr></table></figure>
<h2 id="炮兵阵地"><a href="#炮兵阵地" class="headerlink" title="炮兵阵地"></a>炮兵阵地</h2><h3 id="题目描述及示例-1"><a href="#题目描述及示例-1" class="headerlink" title="题目描述及示例"></a>题目描述及示例</h3><p>司令部的将军们打算在 $N \times M$ 的网格地图上部署他们的炮兵部队。一个 $N \times M$的地图由 $N$ 行 $M$ 列组成，地图的每一格可能是山地 (用“H” 表示)，也可能是平原 (用“P”表示)，如下图所示。在每一格平原地形上最多可以布置一支炮兵部队 (山地上不能够部署炮兵部队)；一支炮兵部队在地图上的攻击范围如图中黑色区域所示：</p>
<p><img src="/2020/09/16/algorithm/algorithm-dynamicprogramming6/1185_1.jpg"></p>
<p>如果在地图中的灰色所标识的平原上部署一支炮兵部队，则图中的黑色网格表示它能够攻击到的区域：沿横向左右各两格，沿纵向上下各两格。图上其它白色网格均攻击不到。从图上可见炮兵的攻击范围不受地形的影响。现在，将军们规划如何部署炮兵部队，在防止误伤的前提下 (保证任何两支炮兵部队之间不能互相攻击，即任何一支炮兵部队都不在其他支炮兵部队的攻击范围内)，在整个地图区域内最多能够摆放多少我军的炮兵部队?</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数据范围：0 &lt;= n &lt;= 100，0 &lt;= m &lt;= 10。</span></span><br><span class="line">Input:</span><br><span class="line"><span class="comment">// 第一行包含两个正整数，分别表示N和M。</span></span><br><span class="line"><span class="number">5</span> <span class="number">4</span></span><br><span class="line"><span class="comment">// 接下来N行，每一行含有连续的M个字符(&#x27;P&#x27;或者&#x27;H&#x27;)，表示地图具体情况。</span></span><br><span class="line">PHPP</span><br><span class="line">PPHH</span><br><span class="line">PPPP</span><br><span class="line">PHPP</span><br><span class="line">PHHP</span><br><span class="line">    </span><br><span class="line">Output:</span><br><span class="line"><span class="comment">// 输出一个整数，表示最多能摆放的炮兵部队的数量。</span></span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure>
<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>数据存储</p>
<p><code>g[i]</code> 用于存储每行方格状态，如果该方格可以放置炮兵，则置相应位为 $0$；否则置相应位为 $1$。对于例子而言，$g[0] = 0b0010 = 2,g[1] = 0b1100 = 12$。<code>state[i]</code> 用于存储可用状态，$cnt[i]$ 用于存储各可用状态中 $1$ 的个数。</p>
</li>
<li><p>状态表示</p>
<p>与上题基本一致，数据范围比较小，可以使用状态压缩 DP 加以解决。由于当前行状态与前两行状态均有关，故而我们这样表示状态 $f[i][a][b]$：第 $i$ 行处于 $b$ 所示集合状态，且第 $i - 1$ 行处于 $a$ 所示集合状态时，能够摆放的最多炮兵部队数量。</p>
</li>
<li><p>状态转移</p>
<p>我们首先确定哪些状态可用。按照题目所言，横向炮兵之间最少间隔两个方格，那么 $0b1001$ 这种状态是可用的，而 $0b0101$ 这种状态是不可用的。我们需要从全体状态中选择所有可用状态至 <code>state[i]</code> 之中，并计算相应的 $cnt[i]$。</p>
<p>由于当前状态与前两行状态均有关，并且纵向炮兵之间最少间隔两个方格，故而我们应当先行循环遍历倒数第二行状态 (记为 $c$)，随后遍历倒数第一行状态 (记为 $a$)，最后遍历当前行状态 (记为 $b$)，如果三者状态不相容，则当前状态 $b$ 无效，否则使用如下状态转移方程进行更新：</p>
<p>$$f[i][a][b] = max(f[i][a][b],f[i - 1][c][a] + cnt[i]),(a与g[i - 1]相容,b与g[i]相容，a,b,c之间相容)$$</p>
<blockquote>
<p>状态 $a$ 与 $g[i - 1]$、状态 $b$ 与 $g[i]$ 是否相容，与上题判断方法相同。我们使用 <code>a &amp; g[i - 1] &gt; 0、b &amp; g[i] &gt; 0</code> 进行判断即可。</p>
<p>状态 $a$、$b$、$c$ 之间是否相容，需要判断各状态相同位置是否同时放置炮兵，那么我们可以使用等式 <code>(a &amp; b) | (b &amp; c) | (a &amp; c) &gt; 0</code> 进行判断。</p>
</blockquote>
</li>
<li><p>状态初始化</p>
<p>为简化初始化操作，我们使用 $g[1]$ 存放第 $0$ 行状态，依次而行，使用 $g[n + 1]$ 存放第 $n$ 行状态，此时状态维度便是 $(n + 1) \times state.length$。此时我们直接将所有状态初始化为 $0$ 即可。</p>
</li>
</ul>
<h2 id="最短-Hamilton-路径"><a href="#最短-Hamilton-路径" class="headerlink" title="最短 Hamilton 路径"></a>最短 Hamilton 路径</h2><h3 id="题目描述及示例-2"><a href="#题目描述及示例-2" class="headerlink" title="题目描述及示例"></a>题目描述及示例</h3><p>给定一张 $N$ 个点的带权无向图，点从 $0 \sim N-1$ 标号，求起点 $0$ 到终点 $N-1$ 的最短Hamilton路径。 Hamilton路径的定义是从 $0$ 到 $N-1$ 不重不漏地经过每个点恰好一次。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数据范围：1 &lt;= N &lt;= 20。</span></span><br><span class="line">Input:</span><br><span class="line"><span class="comment">// 第一行输入整数N。</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="comment">// 接下来N行,每行N个整数，其中第i行第j个整数表示点i到j的距离。</span></span><br><span class="line"><span class="number">0</span> <span class="number">2</span> <span class="number">4</span> <span class="number">5</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">0</span> <span class="number">6</span> <span class="number">5</span> <span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="number">6</span> <span class="number">0</span> <span class="number">8</span> <span class="number">3</span></span><br><span class="line"><span class="number">5</span> <span class="number">5</span> <span class="number">8</span> <span class="number">0</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">3</span> <span class="number">5</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">Output:</span><br><span class="line"><span class="comment">// 输出一个整数，表示最短Hamilton路径的长度。</span></span><br><span class="line"><span class="number">18</span></span><br></pre></td></tr></table></figure>
<h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>数据存储</p>
<p><code>graph[i][j]</code> 用于存储图信息。</p>
</li>
<li><p>状态表示</p>
<p>这道题目同样是数据范围比较小，另外求取最短 Hamilton 路径属于 NP 问题，因而可以使用状态压缩 DP 进行求解。</p>
<p>题意需要获取从 $0$ 到 $N$ 的最短 Hamilton 路径，</p>
<p>此题属于集合式题目，状态表示一般没有定式。我们在此直接给出状态表示 $f[i][state]$：从起点 $0$ 开始，依次经过 $state$ 状态所示点 (如果经过该点，则置相应位为1)，最终到达 $i$ ，所需的最短路径长度。</p>
</li>
<li><p>状态转移</p>
<p>状态表示已经完成，状态转移就比较好理解：对于任意点 $k$ 而言，如果 $graph[k][i] != INF$，则我们由状态 $f[i][state - (1 &lt;&lt; (i - 1))]$ 转移到 $f[i][state]$。</p>
<p>状态转移方程具体表示如下：</p>
<p>$$f[i][state] = min(f[i][state],f[k][state - (1 &lt;&lt; (i - 1)) + graph[k][i]]),(0 \leq k &lt; graph.length \ 且 \ i \neq k)$$</p>
<blockquote>
<p><strong>注意</strong>：<code>state</code> 状态的第 $i$、$k$ 位均需为 1；考虑到状态转移所使用到的状态，我们应当先行循环 <code>state</code>，随后循环 $i$ (如果觉得别扭，可以将状态表示改为 $f[state][i]$)。</p>
</blockquote>
</li>
<li><p>状态初始化</p>
<p>题意要求求取最小值，故而首先全部初始化为无穷大，随后指定 $f[0][1] = 0$ 即可。</p>
</li>
</ul>
<h2 id="开宝箱"><a href="#开宝箱" class="headerlink" title="开宝箱"></a>开宝箱</h2><h3 id="题目描述及示例-3"><a href="#题目描述及示例-3" class="headerlink" title="题目描述及示例"></a>题目描述及示例</h3><p>我们有 $N$ 个上锁的藏宝箱，编号依次为 $1 \sim N$。现有一家商店售卖 $M$ 把钥匙，第 $i$ 把钥匙售价为 $a_i$ 元，并且它可以解锁 $b_i$ 个宝箱 (对应编号为 $c_{i1} \sim c_{ib_i}$ )。请问打开所有箱子，最少需要多少钱？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数据范围：1 &lt;= N &lt;= 12,1 &lt;= M &lt;= 1000。</span></span><br><span class="line">Input:</span><br><span class="line"><span class="comment">// 第一行包含两个整数，分别表示N和M。</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="comment">// 接下来包含M组数据，每组数据由两行组成，第一行包含两个整数，表示钥匙价格及解锁宝箱数，第二行包含一系列数，表示可以解锁的宝箱编号。</span></span><br><span class="line"><span class="number">10</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">15</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">30</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">Output:</span><br><span class="line"><span class="comment">// 输出一个整数，表示所需最少的钱。</span></span><br><span class="line"><span class="number">25</span></span><br></pre></td></tr></table></figure>
<h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>数据存储</p>
<p><code>price[i]</code> 用于存储第 $i$ 把钥匙价格，<code>g[i]</code> 用于存储第 $i$ 把钥匙所能打开的宝箱 (使用二进制进行存储)，<code>corr[i][*]</code> 用于存储能够开启第 $i$ 个宝箱的钥匙集合。</p>
</li>
<li><p>状态表示</p>
<p>$N$ 的数据范围比较小，那么可以考虑使用状态压缩 DP 进行解决。此为集合式题目，我们直接给出状态表示 $f[state]$：打开 $state$ 所示宝箱，所需的最少钱。</p>
</li>
<li><p>状态转移</p>
<p>以往状态转移都是根据已计算状态求解当前状态，这里我们采用另外一种状态转移方式：根据当前状态逐步求解未知状态。</p>
<p>为处理状态转移，我们需要遍历 $f[state]$ 并求解它。假定我们遍历到 $f[t]$ 且 $f[t]$ 已求解得到，随后我们找到第一个尚未被解开的宝箱，根据 <code>corr[i][*]</code> 执行如下状态转移：</p>
<p>$$f[t | g[key]] = min(f[t | g[key]],f[t] + price[key]),(key = corr[i][j],0 \leq j &lt; corr[i].length)$$</p>
</li>
<li><p>状态初始化</p>
<p>根据状态定义，首先全部初始化为无穷大，随后我们执行如下初始化：$f[0] = 0$。</p>
</li>
</ul>
<blockquote>
<p>对于此题而言，我们还可这样定义状态 $f[i][state]$：使用前 $i$ 把钥匙，打开 $state$ 所示宝箱，所需的最少钱。</p>
<p>那此时状态转移就略微麻烦：如果不使用当前钥匙，则 $f[i][state] = min(f[[i][state],f[i - 1][state]])$；如果使用当前钥匙，则 $f[i][state | key[i]] = min(f[i][state | key[i]], f[i][state] + price[i])$。</p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>状态压缩DP</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-动态规划(五)</title>
    <url>/2020/09/15/algorithm/algorithm-dynamicprogramming5/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文主要介绍状态机 DP，与其相关的题目有：大盗阿福、小 Q 假期、买卖股票的最佳时机 IV、最佳买卖股票时机含冷冻期。</p>
<a id="more"></a>

<p>对于一些动态规划题目而言，它们在某个时刻的状态仅涉及一个抉择 (例如：<a href="/2020/09/14/algorithm/algorithm-dynamicprogramming3/" title="最长上升子序列">最长上升子序列</a>，直接选择当前数字)；而对于另外一些动态规划题目而言，它们在某个时刻的状态可能涉及多个抉择 (例如：<a href="/2020/09/14/algorithm/algorithm-dynamicprogramming4/" title="01 背包">01 背包</a>，某个时刻可选择当前物品或者不选择当前物品；小 Q 假期，一天之内存在休息、工作、健身三种选择)，此时就需要使用状态机 DP 进行处理，它可以很好地展现状态间转移情况，同时易于理解。</p>
<p>状态机 DP 借助于有限状态自动机构建状态，并据此进行状态转移，从而实现动态规划。</p>
<p><img src="/2020/09/15/algorithm/algorithm-dynamicprogramming5/440px-DFAexample.svg.png" alt="图一：有限状态自动机机"></p>
<blockquote>
<p>如果所涉抉择数目为 2，可以选择使用普通 DP 进行处理，也可以选择使用状态机 DP 进行处理。</p>
</blockquote>
<h2 id="大盗阿福"><a href="#大盗阿福" class="headerlink" title="大盗阿福"></a>大盗阿福</h2><h3 id="题目描述及示例"><a href="#题目描述及示例" class="headerlink" title="题目描述及示例"></a>题目描述及示例</h3><p>阿福是一名经验丰富的大盗。趁着月黑风高，阿福打算今晚洗劫一条街上的店铺。这条街上一共有 $N$ 家店铺，每家店中都有一些现金。阿福事先调查得知，只有当他同时洗劫了两家相邻的店铺时，街上的报警系统才会启动，然后警察就会蜂拥而至。作为一向谨慎作案的大盗，阿福不愿意冒着被警察追捕的风险行窃。他想知道，在不惊动警察的情况下，他今晚最多可以得到多少现金？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line"><span class="comment">// 第一行包含整数N，表示一共有N家店铺。</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="comment">// 第二行包含N个整数，表示每一家店铺中的现金数量。</span></span><br><span class="line"><span class="number">10</span> <span class="number">7</span> <span class="number">6</span> <span class="number">14</span></span><br><span class="line">    </span><br><span class="line">Output:</span><br><span class="line"><span class="comment">// 输出一个整数，表示阿福在不惊动警察的情况下可以得到的最多现金数量。</span></span><br><span class="line"><span class="number">24</span></span><br></pre></td></tr></table></figure>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>我们先使用普通 DP 解决此问题。</p>
<ul>
<li><p>数据存储</p>
<p><code>money[i]</code> 用于存储各店铺现金数量。</p>
</li>
<li><p>状态表示</p>
<p>既然数据是一维的，状态表示大概率也是一维的。我们可以这样定义状态 $f[i]$：在不惊动警察情况下，从前 $i$ 家店铺抢劫，所能得到的最下现金数量。</p>
</li>
<li><p>状态转移</p>
<p>这道题目的难点在于：如何保证不会同时洗劫两家相邻的店铺？对于状态 $f[i]$ 而言，如果选择洗劫当前店铺，则其只能从状态 $f[i - 2]$ 转移得到；否则从状态 $f[i - 1]$ 转移得到。故而状态转移方程可表示如下：</p>
<p>$$f[i] = max(f[i - 1], f[i - 2] + money[i]),(2 \leq i &lt; money.length)$$</p>
</li>
<li><p>状态初始化</p>
<p>根据状态表示，我们可以这样初始化：指定 $f[0] = 0$。</p>
</li>
</ul>
<p>接下来我们使用状态机 DP 解决此问题。</p>
<ul>
<li><p>数据存储</p>
<p><code>money[i]</code> 用于存储各店铺现金数量。</p>
</li>
<li><p>状态表示</p>
<p>对于店铺而言，它具有两种选择：被阿福抢劫和不被阿福抢劫。故而我们可以这样定义状态 $f[i][0]$：在不惊动警察情况下，抢劫以往店铺并且不抢劫当前店铺，所能得到的最下现金数量，和 $f[i][1]$：在不惊动警察情况下，抢劫以往店铺并且抢劫当前店铺，所能得到的最下现金数量。</p>
</li>
<li><p>状态转移</p>
<p>根据上述状态表示及 “无法同时抢劫相邻两家店铺” 要求，我们可以得到如下状态转移图：</p>
<p><img src="/2020/09/15/algorithm/algorithm-dynamicprogramming5/image-20200915112352564.png"></p>
<p>故而状态转移方程可表示如下：</p>
<p>$$f[i][0] = max(f[i - 1][0], f[i - 1][1])$$</p>
<p>$$f[i][1] = f[i - 1][0] + money[i]$$</p>
</li>
<li><p>状态初始化</p>
<p>根据状态表示，我们可以这样初始化：指定 $f[0][0] = 0,f[0][1] = money[0]$。</p>
</li>
</ul>
<h2 id="小-Q-假期"><a href="#小-Q-假期" class="headerlink" title="小 Q 假期"></a>小 Q 假期</h2><h3 id="题目描述及示例-1"><a href="#题目描述及示例-1" class="headerlink" title="题目描述及示例"></a>题目描述及示例</h3><p>由于业绩优秀，公司给小 Q 放了 $N$ 天的假，身为工作狂的小 Q 打算在假期中工作、锻炼或者休息。他有个奇怪的习惯：不会连续两天工作或锻炼。只有当公司营业时，小 Q 才能去工作，只有当健身房营业时，小 Q 才能去健身，小 Q 一天只能干一件事。现给出假期中公司，健身房的营业情况，求小 Q 最少需要休息几天？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line"><span class="comment">// 第一行包含一个整数N，表示放假天数。</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="comment">// 第二行包含N个数，第i个数表示公司在第i天是否营业（1为营业 0为不营业）。</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="comment">// 第三行包含N个数，第i个数表示健身房在第i天是否营业（1为营业 0为不营业）。</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">Output：</span><br><span class="line"><span class="comment">// 输出一个整数，表示小Q休息的最少天数。</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>数据存储</p>
<p><code>company[i]</code> 用于存储公司营业信息，<code>gym[i]</code> 用于存储健身房营业信息。</p>
</li>
<li><p>状态表示</p>
<p>对于任意一天，小 Q 具有三种选择 —— 休息、健身、工作。故而我们可以这样定义状态 $f[i][0]$：当天选择休息时，累计的最小休息天数，$f[i][1]$：当天选择健身时，累计的最小休息天数，$f[i][2]$：当天选择工作时，累计的最小休息天数。</p>
</li>
<li><p>状态转移</p>
<p>根据上述状态表示及 “不会连续两天工作或锻炼” 要求，我们可以得到如下状态转移图：</p>
<p><img src="/2020/09/15/algorithm/algorithm-dynamicprogramming5/image-20200915171213037.png"></p>
<p>故而状态转移方程可表示如下：</p>
<p>$$f[i][0] = min(f[i - 1][0],f[i - 1][1],f[i - 1][2]) + 1$$</p>
<p>$$f[i][1] = min(f[i - 1][0],f[i - 1][2])$$</p>
<p>$$f[i][2] = min(f[i - 1][0],f[i - 1][1])$$</p>
<blockquote>
<p>只有当天允许健身或工作，才会有状态 $f[i][1]$、$f[i][2]$ 的转移，否则该状态非法。</p>
</blockquote>
</li>
<li><p>状态初始化</p>
<p>因为存储非法状态且需要求取最小值，故而我们首先将所有状态初始化为无穷大，随后指定合法初始状态：$f[0][0] = 1,f[0][1] = 0(if \ gym[i] = 1),f[0][2] = 0(if \ company[i]=1)$。</p>
</li>
</ul>
<h2 id="买卖股票的最佳时机-IV"><a href="#买卖股票的最佳时机-IV" class="headerlink" title="买卖股票的最佳时机 IV"></a>买卖股票的最佳时机 IV</h2><h3 id="题目描述及示例-2"><a href="#题目描述及示例-2" class="headerlink" title="题目描述及示例"></a>题目描述及示例</h3><p>给定一个数组，它的第 $i$ 个元素是一支给定的股票在第 $i$ 天的价格。设计一个算法来计算你所能获取的最大利润。你最多可以完成 $K$ 笔交易。注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line"><span class="comment">// 第一行包含整数N和K，表示数组长度以及可以完成的最大交易数量。</span></span><br><span class="line"><span class="number">6</span> <span class="number">2</span></span><br><span class="line"><span class="comment">// 第二行包含N个正整数，表示完整的数组。</span></span><br><span class="line"><span class="number">3</span> <span class="number">2</span> <span class="number">6</span> <span class="number">5</span> <span class="number">0</span> <span class="number">3</span></span><br><span class="line">    </span><br><span class="line">Output:</span><br><span class="line"><span class="comment">// 输出一个整数，表示最大利润。</span></span><br><span class="line"><span class="number">7</span></span><br></pre></td></tr></table></figure>
<h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>数据存储</p>
<p><code>price[i]</code> 用于存储股票价格。</p>
</li>
<li><p>状态表示</p>
<p>对于任意一天，”我” 具有两种状态：手中有股票和手中无股票。那么我们可以这样定义状态 $f[i][0]$：第 $i$ 天手中没有股票，所能获取的最大利益，和 $f[i][1]$：第 $i$ 天手中有股票，所能获取的最大利益。</p>
<p>另外，对于本题目而言，它考虑交易次数，故而我们这样定义状态 $f[i][0][k]$：第 $i$ 天手中没有股票，且处于第 $k$ 次交易已经完成时，所能获取的最大利益；和 $f[i][1][k]$：第 $i$ 天手中有股票，且正处于第 $k$ 次交易时，所能获取的最大利益。</p>
<blockquote>
<p>买入股票即看作一次交易的开始。</p>
</blockquote>
</li>
<li><p>状态转移</p>
<p>根据上述状态表示，我们可以得到如下状态转移图：</p>
<p><img src="/2020/09/15/algorithm/algorithm-dynamicprogramming5/image-20200915183417515.png"></p>
<p>故而状态转移方程可表示如下：</p>
<p>$$f[i][0][k] = max(f[i - 1][0][k],f[i - 1][1][k] + price[i])$$</p>
<p>$$f[i][1][k] = max(f[i - 1][1][k],f[i - 1][0][k - 1] - price[i])$$</p>
</li>
<li><p>状态初始化</p>
<p>为求取状态最大值，首先将所有状态初始化为无穷小。由于状态表示为第 $i$ 天，故而需要这样初始化：指定 $f[0][0][k] = 0(0 \leq k \leq K),f[0][1][1] = -price[0]$。</p>
</li>
</ul>
<h2 id="最佳买卖股票时机含冷冻期"><a href="#最佳买卖股票时机含冷冻期" class="headerlink" title="最佳买卖股票时机含冷冻期"></a>最佳买卖股票时机含冷冻期</h2><h3 id="题目描述及示例-3"><a href="#题目描述及示例-3" class="headerlink" title="题目描述及示例"></a>题目描述及示例</h3><p>给定一个长度为 $N$ 的数组，数组中的第 $i$ 个数字表示一个给定股票在第 $i$ 天的价格。设计一个算法计算出最大利润，在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）。你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。卖出股票后，你无法在第二天买入股票 (即冷冻期为 $1$ 天)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line"><span class="comment">// 第一行包含整数N，表示数组长度。</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="comment">// 第二行包含N个正整数，表示完整的数组。</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">0</span> <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">Output:</span><br><span class="line"><span class="comment">// 输出一个整数，表示最大利润。</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>数据存储</p>
<p><code>price[i]</code> 用于存储股票价格。</p>
</li>
<li><p>状态表示</p>
<p>相比上一道题目，”我” 具有三种状态：手中有股票、手中无股票的第一天、手中无股票的第 $i \geq 2$ 天。 那么我们可以这样定义状态 $f[i][0]$：第 $i$ 天且手中有股票，所能获取的最大利益，$f[i][1]$：第 $i$ 天且手中无股票的第一天，所能获取的最大利益，$f[i][2]$：第 $i$ 天且手中无股票的第 $i \geq 2$ 天，所能获取的最大利益。</p>
</li>
<li><p>状态转移</p>
<p>根据上述状态表示及 “冷冻期” 要求，我们可以得到如下状态转移图：</p>
<p><img src="/2020/09/15/algorithm/algorithm-dynamicprogramming5/image-20200915190433395.png"></p>
<p>故而状态转移方程可表示如下：</p>
<p>$$f[i][0] = max(f[i - 1][0],f[i - 1][2] - price[i])$$</p>
<p>$$f[i][1] = f[i - 1][0] + price[i]$$</p>
<p>$$f[i][2] = max(f[i - 1][2],f[i - 1][1])$$</p>
</li>
<li><p>状态初始化</p>
<p>为求取状态最大值，首先将所有状态初始化为无穷小。由于状态表示为第 $i$ 天，故而需要这样初始化：指定 $f[0][0] = -price[i],f[0][2] = 0$。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>状态机DP</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-动态规划(四)</title>
    <url>/2020/09/14/algorithm/algorithm-dynamicprogramming4/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文主要介绍背包 DP，与其相关的题目有：01 背包、完全背包、多重背包、混合背包、二维费用的背包、分组背包、有依赖的背包。</p>
<a id="more"></a>

<h2 id="01-背包"><a href="#01-背包" class="headerlink" title="01 背包"></a>01 背包</h2><h3 id="题目描述及示例"><a href="#题目描述及示例" class="headerlink" title="题目描述及示例"></a>题目描述及示例</h3><p>有 $N$ 件物品和一个容量是 $V$ 的背包。每件物品只能使用一次。第 $i$ 件物品的体积是 $v_i$，价值是 $w_i$。求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大?</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line"><span class="comment">// 第一行包含两个整数，分别表示物品数量和背包容积。</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="comment">// 接下来N行，每行两个整数vi,wi，分别表示第i件物品的体积和价值。</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span></span><br><span class="line">    </span><br><span class="line">Output:</span><br><span class="line"><span class="comment">// 输出一个整数，表示最大价值。</span></span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>数据存储</p>
<p><code>v[i]</code> 用于存储各物品体积，<code>w[i]</code> 用于存储各物品价值。</p>
</li>
<li><p>状态表示</p>
<p>对于背包问题而言，状态表示往往都是二维的。我们可以这样表示状态 $f[i][j]$：从前 $i$ 个物品中选择，并将它们装入容量为 $j$ 的背包中，所能得到的最大价值。</p>
</li>
<li><p>状态转移</p>
<p>对于状态 $f[i][j]$ 而言，如果它选择当前物品 $i$，则其应当由状态 $f[i - 1][j - v[i]]$ 转移得到；否则应当由状态 $f[i - 1][j]$ 转移得到。故而状态转移方程可表示如下：</p>
<p>$$f[i][j] = max(f[i - 1][j], f[i - 1][j - v[i]] + w[i]),(j \geq v[i])$$</p>
<blockquote>
<p>观察状态转移方程，可以发现：状态 $f[i][\ast]$ 的转移仅涉及 $f[i - 1][\ast]$。故而实现之中，我们可以使用滚动数组以优化空间。更进一步，我们发现：状态 $f[i][j]$ 仅从状态 $f[i - 1][k],(k &lt; j)$ 转移得到，故而我们可从后往前更新一维数组以达到滚动数组的效果 (<strong>此时状态表示优化为 $f[j]$，表示将物品装入容量为 $j$ 的背包中所能得到的最大价值</strong>)。</p>
</blockquote>
</li>
<li><p>状态初始化</p>
<p>根据状态表示，我们可这样初始化：指定 $f[0][j] = 0,(0 \leq j \leq  V)$。</p>
</li>
</ul>
<h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><h3 id="题目描述及示例-1"><a href="#题目描述及示例-1" class="headerlink" title="题目描述及示例"></a>题目描述及示例</h3><p>有 $N$ 种物品和一个容量是 $V$ 的背包，每种物品都有无限件可用。第 $i$ 种物品的体积是 $v_i$，价值是 $w_i$。求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大?</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line"><span class="comment">// 第一行包含两个整数，分别表示物品数量和背包容积。</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="comment">// 接下来N行，每行两个整数vi,wi，分别表示第i件物品的体积和价值。</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span></span><br><span class="line">    </span><br><span class="line">Output:</span><br><span class="line"><span class="comment">// 输出一个整数，表示最大价值。</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>
<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>数据存储</p>
<p><code>v[i]</code> 用于存储各物品体积，<code>w[i]</code> 用于存储各物品价值。</p>
</li>
<li><p>状态表示</p>
<p>与 <em>01 背包</em> 状态表示相同，我们可以这样表示状态 $f[i][j]$：从前 $i$ 个物品中选择，并将它们转入容量为 $j$ 的背包中，所能得到的最大价值。</p>
</li>
<li><p>状态转移</p>
<p>由于物品可无限次选用，故而对于状态 $f[i][j]$ 而言，如果它不选择当前物品 $i$，则应当由状态 $f[i - 1][j]$ 转移得到；如果它选择一个当前物品 $i$，则应当由状态 $f[i - 1][j - v[i]]$ 转移得到；如果它选择 $k$ 个当前物品 $i$，则应当由状态 $f[i - 1][j - k \times v[i]]$ 转移得到。</p>
<p>状态转移方程具体表示如下：</p>
<p>$$f[i][j] = max(f[i - 1][j],f[i - 1][j - v[i]] + w[i],\dots,f[i - 1][j - k \times v[i]] + k \times w[i]),(j \geq k*w[i])$$</p>
<blockquote>
<p>对于状态 $f[i][j - v[i]]$ 而言，其状态转移方程具体为：</p>
<p>$$f[i][j - v[i]] = max(f[i - 1][j - v[i]],f[i - 1][j - 2 \times v[i]] + w[i],\dots,f[i - 1][j - k \times v[i]] + k \times w[i])$$</p>
<p>将状态 $f[i][j - v[i]]$ 代入 $f[i][j]$ 的状态转移方程中，我们可以得到：</p>
<p>$$f[i][j] = max(f[i - 1][j], f[i][j - v[i]] + w[i])$$</p>
<p>该式与 <em>01 背包</em> 的状态转移方程十分相似，故而可使用相似的空间优化方法 —— 从后往前更新一维数组以更新相关状态。对于完全背包而言，其状态转移方程涉及 $f[i][j - v[i]]$，而非 $f[i - 1][j - v[i]]$，故而其应当从前往后更新一维数组。</p>
</blockquote>
</li>
<li><p>状态初始化</p>
<p>与 <em>01 背包</em> 状态初始化相同，我们这样初始化：指定 $f[0][j] = 0,(0 \leq j \leq  V)$。</p>
</li>
</ul>
<h2 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h2><h3 id="题目描述及示例-2"><a href="#题目描述及示例-2" class="headerlink" title="题目描述及示例"></a>题目描述及示例</h3><p>有 $N$ 件物品和一个容量是 $V$ 的背包。第 $i$ 种物品最多有 $s_i$ 件，每件体积是 $v_i$，价值是 $w_i$。求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大?</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line"><span class="comment">// 第一行包含两个整数，分别表示物品数量和背包容积。</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="comment">// 接下来N行，每行三个整数 vi,wi,si分别表示第i种物品的体积、价值和数量。</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">Output:</span><br><span class="line"><span class="comment">// 输出一个整数，表示最大价值。</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>
<h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>数据存储</p>
<p><code>v[i]</code> 用于存储各物品体积，<code>w[i]</code> 用于存储各物品价值，<code>s[i]</code> 用于存储各物品个数。</p>
</li>
<li><p>状态表示</p>
<p>与 <em>01 背包</em> 状态表示相同，我们可以这样表示状态 $f[i][j]$：从前 $i$ 个物品中选择，并将它们转入容量为 $j$ 的背包中，所能得到的最大价值。</p>
</li>
<li><p>状态转移</p>
<p>该题与 <em>01 背包</em>  和 <em>完全背包</em> 类似，仅是物品可有限次选用，类比于 <em>完全背包</em> 的状态转移方程，其状态转移方程可表示如下：</p>
<p>$$f[i][j] = max(f[i - 1][j],f[i - 1][j - v[i]] + w[i],\dots,f[i - 1][j - k \times v[i]] + k \times w[i]),(j \geq k*w[i] \  且 \ s[i] \geq k)$$</p>
<blockquote>
<p>该状态转移方程所具特性与 <em>01 背包</em> 的状态转移方程所具特性基本一致，故而其可使用相同的空间优化方法 —— 从后往前更新一维数组以更新相关状态。由于其中涉及众多状态取最大值，故而需要使用一个循环完成。</p>
</blockquote>
</li>
<li><p>状态初始化</p>
<p>与 <em>01 背包</em> 状态初始化相同，我们这样初始化：指定 $f[0][j] = 0,(0 \leq j \leq  V)$。</p>
</li>
</ul>
<p>上面这种属于最基本的解题思路，我们可以发现其时间复杂度为 $O(N \times S \times V)$ ($S$ 表示物品的平均个数)。</p>
<p>接下来我们从另一角度看待多重背包：如果一个物品存在 $m$ 件，我们便将其分解为 $m$ 个数量均为 $1$的不同物品，此时每个物品仅有选与不选两种选择，故而多重背包就转换为 01 背包。</p>
<p>现在我们思考一个问题：将 $m$ 拆分为 $m$ 个 $1$，可以表达 “选择区间 $[0,m]$ 内任意数”，那么有没有更简便地方法以达到此目的？</p>
<p>这种更为简便地方式就是：二进制。例如：我们希望选择区间 $[0,15]$ 内任意数，我们只需要 $(2^0 = 1,2^1 = 2, 2^2 = 4,2^3 = 8)$ 四个数即可；如果我们希望选择区间 $[0,12]$ 内任意数，我们只需要 $(2^0 = 1,2^1 = 2, 2^2 = 4,12-4-2-1=5)$ 四个数即可。</p>
<p>基于二进制，我们重新看待多重背包：如果一个物品存在 $m$ 件，我们便基于二进制将其分解为 $\lceil log_2^m \rceil$ 个具有不同数量的物品，此时每个物品同样仅具有选与不选两种选择，故而多重背包就转换为 01 背包。可以发现：该种解法的时间复杂度降低为 $O(N \times \lceil log_2^{S} \rceil \times V)$ 。</p>
<p>对于多重背包而言，另有一种基于单调队列的优化方案，它可将时间复杂度降低为 $O(N \times V)$。这种方法比较复杂，我们在此简单介绍。</p>
<p>经空间优化后，多重背包的状态表示为 $f[j]$，并且每次循环中，根据当前物品 $i$ 更新状态 $f[j]$ 。根据状态更新流程，我们可将状态分为如下几类：</p>
<p>$$f[0 + k \times v[i]],f[1 + k \times v[i]],\dots,f[m + k \times v[i]](m = v[i] - 1,k \times v[i] \leq V)$$</p>
<p>对于任意一类状态 $f[t + k \times v[i]](0 \leq t &lt; v[i],k \times v[i] \leq V)$，我们构建 $(f[t + k \times v[i]] - k \times w[i],k)$ 键值对 (该式可理解为所有状态在同等基准下的增益)，并排序它们。对于任意 $f[j]$ 而言，如果容量、物品数量条件满足，则从具有最大增益的状态转移将会使得更新后的 $f[j]$ 最大，此时具有最大增益的状态就是 $f[j]$ 转移所需的最佳状态。借助于排序，可使得一步找到状态转移所需的最佳状态，如此便可降低时间复杂度。</p>
<blockquote>
<p>具体实现中，我们并不需要使用排序，只需使用单调队列即可。</p>
</blockquote>
<h2 id="混合背包"><a href="#混合背包" class="headerlink" title="混合背包"></a>混合背包</h2><h3 id="题目描述及示例-3"><a href="#题目描述及示例-3" class="headerlink" title="题目描述及示例"></a>题目描述及示例</h3><p>有 $N$ 种物品和一个容量是 $V$ 的背包，物品一共有三类：</p>
<ul>
<li>第一类物品只能用 $1$ 次 (01背包)；</li>
<li>第二类物品可以用无限次 (完全背包)；</li>
<li>第三类物品最多只能用 $s_i$ 次 (多重背包)；</li>
</ul>
<p>每种体积是 $v_i$，价值是 $w_i$。求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大?</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line"><span class="comment">// 第一行包含两个整数，分别表示物品数量和背包容积。</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="comment">// 接下来N行，每行三个整数vi,wi,si，分别表示第i种物品的体积、价值和数量。</span></span><br><span class="line"><span class="comment">// 数量为-1，表示可使用无限次。</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> -<span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">0</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">Output:</span><br><span class="line"><span class="comment">// 输出一个整数，表示最大价值。</span></span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure>
<h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><p>这道题目属于上面三道题目的综合。首先我们可以基于二进制将多重背包转换为 01 背包；对于 01 背包和多重背包而言，二者区别仅在于从后往前更新一维数组还是从前往后更新一维数组，此时根据物品只能使用 $1$ 次还是无限次，动态选择循环方向即可。</p>
<h2 id="二维费用的背包"><a href="#二维费用的背包" class="headerlink" title="二维费用的背包"></a>二维费用的背包</h2><h3 id="题目描述及示例-4"><a href="#题目描述及示例-4" class="headerlink" title="题目描述及示例"></a>题目描述及示例</h3><p>有 $N$ 种物品和一个容量是 $V$ 的背包，背包能承受的最大重量是 $M$。每件物品只能用一次，体积是 $v_i$，重量是 $m_i$，价值是 $w_i$。求解将哪些物品装入背包，可使物品总体积不超过背包容量，总重量不超过背包可承受的最大重量，且价值总和最大?</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line"><span class="comment">// 第一行包含三个整数，分别表示物品数量、背包容积和背包所能承受的最大重量。</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line"><span class="comment">// 接下来N行，每行三个整数vi,mi,wi，分别表示第i种物品的体积、重量和价值。</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line">    </span><br><span class="line">Output:</span><br><span class="line"><span class="comment">// 输出一个整数，表示最大价值。</span></span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure>
<h3 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>数据存储</p>
<p><code>v[i]</code> 用于存储各物品体积，<code>m[i]</code> 用于存储各物品重量，<code>w[i]</code> 用于存储各物品价值。</p>
</li>
<li><p>状态表示</p>
<p>这道题目纯属 <em>01 背包</em> 的二维扩展，故而我们可以这样表示状态 $f[i][j][k]$：从前 $i$ 个物品中选择，并将它们装入容量为 $j$ 、所能承受的最大重量为 $k$ 的背包中，所能得到的最大价值。</p>
</li>
<li><p>状态转移</p>
<p>已有 <em>01 背包</em> 相关知识，该题目的状态转移方程可表示如下：</p>
<p>$$f[i][j][k] = max(f[i - 1][j][k], f[i - 1][j - v[i]][k - m[i]] + w[i]),(j \geq v[i] \ 且 \ k \geq m[i])$$</p>
<blockquote>
<p>类比于 <em>01 背包</em> ，我们可使用二维数组 $f[j][k]$ 优化空间。</p>
</blockquote>
</li>
<li><p>状态初始化</p>
<p>根据状态表示，我们可这样初始化：指定 $f[0][j][k] = 0,(0 \leq j \leq  V \ 且 \ 0 \leq k \leq M)$。</p>
</li>
</ul>
<h2 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a>分组背包</h2><h3 id="题目描述及示例-5"><a href="#题目描述及示例-5" class="headerlink" title="题目描述及示例"></a>题目描述及示例</h3><p>有 $N$ 组物品和一个容量是 $V$ 的背包，每组物品有若干个，同一组内的物品最多只能选一个。每件物品的体积是 $v_{ij}$，价值是 $w_{ij}$，其中 $i$ 是组号，$j$ 是组内编号。求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大?</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line"><span class="comment">// 第一行包含两个整数，分别表示物品数量和背包容积。</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="comment">// 接下来有N组数据：每组数据第一行有一个整数Si，表示第i个物品组的物品数量；</span></span><br><span class="line"><span class="comment">// 每组数据接下来有Si行，每行有两个整数vij,wij，分别表示第i个物品组的第j个物品的体积和价值；</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span></span><br><span class="line">    </span><br><span class="line">Output:</span><br><span class="line"><span class="comment">// 输出一个整数，表示最大价值。</span></span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure>
<h3 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>数据存储</p>
<p><code>id[i]</code> 用于存储各物品组号、<code>v[i]</code> 用于存储各物品体积，<code>w[i]</code> 用于存储各物品价值。</p>
</li>
<li><p>状态表示</p>
<p>与 <em>01 背包</em> 状态表示类似，我们可以这样表示状态 $f[i][j]$：从前 $i$ 个物品组中选择，并将它们转入容量为 $j$ 的背包中，所能得到的最大价值。</p>
</li>
<li><p>状态转移</p>
<p>对于状态 $f[i][j]$ 而言，如果它不选择当前物品组 $i$，则其应当由状态 $f[i - 1][j]$ 转移得到；否则就会选择当前物品组，由于一个物品组中只能选择一个物品，故而其应当由状态 $f[i - 1][j - v[k]],(id[k] = i)$ 转移得到。</p>
<p>$$f[i][j] = max(f[i - 1][j], f[i - 1][j - v[k]] + w[k]),(0 \leq k &lt; id.length \ 且 \ id[k] = i)$$</p>
<blockquote>
<p>与 <em>01 背包</em> 类似，其可使用相同的空间优化方法 —— 从后往前更新一维数组以更新相关状态。</p>
</blockquote>
</li>
<li><p>状态初始化</p>
<p>与 <em>01 背包</em> 状态初始化类似，我们这样初始化：指定 $f[0][j] = 0,(0 \leq j \leq  V)$。</p>
</li>
</ul>
<h2 id="有依赖的背包"><a href="#有依赖的背包" class="headerlink" title="有依赖的背包"></a>有依赖的背包</h2><h3 id="题目描述及示例-6"><a href="#题目描述及示例-6" class="headerlink" title="题目描述及示例"></a>题目描述及示例</h3><p>有 $N$ 个物品和一个容量是 $V$ 的背包，物品之间具有依赖关系，且依赖关系组成一棵树的形状。如果选择一个物品，则必须选择它的父节点。如下图所示：</p>
<p><img src="/2020/09/14/algorithm/algorithm-dynamicprogramming4/1_bb51ecbcd2-QQ%E5%9B%BE%E7%89%8720181018170337.png"></p>
<p>如果选择物品 5，则必须选择物品 1 和 2。这是因为 2 是 5 的父节点，1 是 2 的父节点。</p>
<p>每件物品的编号是 $i$，体积是 $v_i$，价值是 $w_i$，依赖的父节点编号是 $p_i$。物品的下标范围是 $1…N$。求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大?</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line"><span class="comment">// 第一行包含两个整数，分别表示物品数量和背包容积。</span></span><br><span class="line"><span class="number">5</span> <span class="number">7</span></span><br><span class="line"><span class="comment">// 接下来有N行数据，每行数据有三个整数vi,wi,pi，分别表示物品的体积、价值和依赖的物品编号。</span></span><br><span class="line"><span class="comment">// 如果依赖的物品编号为-1，表明该物品为根节点，数据保证所有物品构成一棵树。</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> -<span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">5</span> <span class="number">1</span></span><br><span class="line"><span class="number">4</span> <span class="number">7</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">6</span> <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">Output:</span><br><span class="line"><span class="comment">// 输出一个整数，表示最大价值。</span></span><br><span class="line"><span class="number">11</span></span><br></pre></td></tr></table></figure>
<h3 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>数据存储</p>
<p><code>v[i]</code> 用于存储各物品体积，<code>w[i]</code> 用于存储各物品价值，<code>graph[i][j]</code> 用于存储节点间依赖关系，表示物品 $j$ 依赖于物品 $i$。</p>
</li>
<li><p>状态表示</p>
<p>这道题目属于背包 DP 与树形 DP 的结合，比较困难。我们直接定义状态 $f[u][j]$：从物品 $u$ 所在子树中选择物品，并将它们转入容量为 $j$ 的背包中，所能得到的最大价值。</p>
</li>
<li><p>状态转移</p>
<p>对于状态 $f[u][j]$ 而言，如果不选择当前物品，则各子物品都无法选择，可直接置 $f[u][j] = 0$；否则就需要根据子物品及容量动态转移得到。</p>
<p>如果选择当前物品，则其状态转移方程为：</p>
<p>$$f[u][j] = max(f[son][t] + f[u][j - t - v[i]] + w[i]),(son = graph[u][k],0 \leq k &lt; graph[u].length, 0 \leq t \leq j - v[i])$$</p>
<p>如果不选择当前物品，则其状态转移方程为：</p>
<p>$$f[u][j] = 0,(0 \leq j \leq V)$$</p>
<blockquote>
<p>如果我们将当前物品的子物品所在子树看做一个个物品组，将具有不同容量的 $f[son][k]$ 看做一个个物品，那么一个物品组中只能选择一个物品，故而这是一个分组背包问题。按照分组背包解法可以求解得到 $f[u][j],(0 \leq j \leq V)$。</p>
</blockquote>
</li>
<li><p>状态初始化</p>
<p>此题的状态初始化比较简单，默认不选择所有物品，故而直接指定 $f[u][j] = 0,(0 \leq j \leq V)$。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>背包DP</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-动态规划(三)</title>
    <url>/2020/09/14/algorithm/algorithm-dynamicprogramming3/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文主要介绍线性 DP 中的最长上升子序列模型，与该模型相关的题目有：最长上升子序列、登山、友好城市、最大上升子序列和。</p>
<a id="more"></a>

<h2 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a>最长上升子序列</h2><h3 id="题目描述及示例"><a href="#题目描述及示例" class="headerlink" title="题目描述及示例"></a>题目描述及示例</h3><p>给定一个长度为 $N$ 的数列，求数值严格单调递增的子序列长度最长是多少?</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line"><span class="comment">// 第一行包含整数N。</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="comment">// 第二行包含N个整数，表示完整序列。</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">2</span> <span class="number">1</span> <span class="number">8</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line">    </span><br><span class="line">Output:</span><br><span class="line"><span class="comment">// 输出一个整数，表示最大长度。</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>数据存储</p>
<p><code>nums[i]</code> 用于存储完整序列。</p>
</li>
<li><p>状态表示</p>
<p>既然数据是一维的，状态表示大概率也是一维的。我们可以这样定义 $f[i]$：以 $nums[i]$ 为结尾、数值严格单调递增的所有子序列中最长的序列长度。</p>
</li>
<li><p>状态转移</p>
<p>子序列要求数值严格单调递增，故而 $f[i]$ 可由那些位于 $num[i]$ 前方、数值小于 $num[i]$ 的 $f[k]$ 转移得到，故而状态转移方程可表示如下：</p>
<p>$$f[i] = max(f[k] + 1,f[i]),(0\leq k &lt; i \  且 \ nums[k] &lt; nums[i])$$</p>
</li>
<li><p>状态初始化</p>
<p>对于此题目而言，状态初始化比较复杂，需要指定 $f[i] = 1,(0 \leq i &lt; nums.length)$ 。</p>
</li>
</ul>
<h2 id="登山"><a href="#登山" class="headerlink" title="登山"></a>登山</h2><h3 id="题目描述及示例-1"><a href="#题目描述及示例-1" class="headerlink" title="题目描述及示例"></a>题目描述及示例</h3><p>五一到了，ACM 队组织大家去登山观光，队员们发现山上一个有 $N$ 个景点，并且决定按照顺序来浏览这些景点，即每次所浏览景点的编号都要大于前一个浏览景点的编号。同时队员们还有另一个登山习惯，就是不连续浏览海拔相同的两个景点，并且一旦开始下山，就不再向上走了。队员们希望在满足上面条件的同时，尽可能多的浏览景点，你能帮他们找出最多可能浏览的景点数么？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line"><span class="comment">// 第一行包含整数N，表示景点数量。</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="comment">// 第二行包含N个整数，表示每个景点的海拔。</span></span><br><span class="line"><span class="number">186</span> <span class="number">186</span> <span class="number">150</span> <span class="number">200</span> <span class="number">160</span> <span class="number">130</span> <span class="number">197</span> <span class="number">220</span></span><br><span class="line">    </span><br><span class="line">Output:</span><br><span class="line"><span class="comment">// 输出一个整数，表示最多能浏览的景点数。</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>
<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>数据存储</p>
<p><code>nums[i]</code> 用于存储景点海拔序列。</p>
</li>
<li><p>状态表示</p>
<p>我们先对题意作一简单分析：队员所浏览景点海拔可看做先单调上升后单调下降的曲线，那么我们可首先求得从前往后到任意点的最长单调上升子序列长度，随后求取从后往前到任意点的最长单调上升子序列长度，统计各点作为最高点时的曲线长度，最长者便是最多可浏览的景点数。</p>
<p>这里我们需要定义两个状态 $f[i]$：以 $nums[i]$ 为结尾、数值严格单调递增的所有子序列中最长的序列长度， 和 $g[i]$：以 $nums[i]$ 为起始，数值严格单调递减的所有子序列中最长的序列长度。</p>
</li>
<li><p>状态转移</p>
<p>状态转移基本与 <em>最长上升子序列</em> 相同，两者的状态转移方程可表示如下：</p>
<p>$$f[i] = max(f[k] + 1,f[i]),(0\leq k &lt; i \  且 \ nums[k] &lt; nums[i])$$</p>
<p>$$g[i] = max(g[k] + 1, g[i]),(i &lt; k &lt; nums.length \ 且 \ nums[k] &lt; nums[i])$$</p>
</li>
<li><p>状态初始化</p>
<p>状态初始化也基本与 <em>最长上升子序列</em> 相同，需要指定 $f[i] = g[i] = 1,(0 \leq i &lt; nums.length)$ 。</p>
</li>
</ul>
<h2 id="友好城市"><a href="#友好城市" class="headerlink" title="友好城市"></a>友好城市</h2><h3 id="题目描述及示例-2"><a href="#题目描述及示例-2" class="headerlink" title="题目描述及示例"></a>题目描述及示例</h3><p>Palmia 国有一条横贯东西的大河，河有笔直的南北两岸，岸上各有位置各不相同的 $N$ 个城市。北岸的每个城市有且仅有一个友好城市在南岸，而且不同城市的友好城市不相同。每对友好城市都向政府申请在河上开辟一条直线航道连接两个城市，但是由于河上雾太大，政府决定避免任意两条航道交叉，以避免事故。编程帮助政府做出一些批准和拒绝申请的决定，使得在保证任意两条航线不相交的情况下，被批准的申请尽量多。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line"><span class="comment">// 第一行包含整数N，表示城市数。</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="comment">// 第二行到第n+1行，每行两个整数，分别表示南岸和北岸的一对友好城市的坐标。</span></span><br><span class="line"><span class="number">22</span> <span class="number">4</span></span><br><span class="line"><span class="number">2</span> <span class="number">6</span></span><br><span class="line"><span class="number">10</span> <span class="number">3</span></span><br><span class="line"><span class="number">15</span> <span class="number">12</span></span><br><span class="line"><span class="number">9</span> <span class="number">8</span></span><br><span class="line"><span class="number">17</span> <span class="number">17</span></span><br><span class="line"><span class="number">4</span> <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">Output:</span><br><span class="line"><span class="comment">// 输出一个整数，表示政府所能批准的最多申请数。</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>
<h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>数据存储</p>
<p><code>first[i]</code> 存储北岸城市坐标，<code>second[i]</code> 用于存储与北岸对应的友好城市坐标。</p>
</li>
<li><p>状态表示</p>
<p>如果两条航道发生交叉，一定满足如下条件：$(first[i] &lt; first[j] \ 且 \ second[i] &gt; second[j])$  或 $(first[i] &gt; first[j] \ 且 \ second[i] &lt; second[j])$。如果我们对 $first[i]$ 从小到大进行排序，并根据排序结果调整各友好城市在 $second[j]$ 中的坐标位置，为使得航道之间不会发生交叉结果，我们就需要保证：所选择的友好城市坐标满足单调递增。那么这样就将该题转换为 <em>最长上升子序列</em>。所以我们可以这样定义 $f[i]$：以 $second[i]$ 为结尾、坐标位置严格单调递增的所有子序列中最长的序列长度。</p>
</li>
<li><p>状态转移</p>
<p>状态转移基本与 <em>最长上升子序列</em> 相同，状态转移方程可表示如下：</p>
<p>$$f[i] = max(f[k] + 1,f[i]),(0\leq k &lt; i \  且 \ second[k] &lt; second[i])$$</p>
</li>
<li><p>状态初始化</p>
<p>状态初始化也基本与 <em>最长上升子序列</em> 相同，需要指定 $f[i] = g[i] = 1,(0 \leq i &lt; second.length)$ 。</p>
</li>
</ul>
<h2 id="最大上升子序列和"><a href="#最大上升子序列和" class="headerlink" title="最大上升子序列和"></a>最大上升子序列和</h2><h3 id="题目描述及示例-3"><a href="#题目描述及示例-3" class="headerlink" title="题目描述及示例"></a>题目描述及示例</h3><p>一个数的序列 $bi$，当 $b1&lt;b2&lt;…&lt;bS$ 时，我们称这个序列是上升的。对于给定的一个序列 (a1,a2,…,aN)，我们可以得到一些上升的子序列 (ai1,ai2,…,aiK)，其中 $1≤i1&lt;i2&lt;…&lt;iK≤N$。比如，对于序列 (1,7,3,5,9,4,8)，有它的一些上升子序列，如 (1,7),(3,4,8) 等。这些子序列中和最大为18，为子序列 (1,3,5,9) 的和。</p>
<p>你的任务，就是对于给定的序列，求出最大上升子序列和。注意：最长的上升子序列的和不一定是最大的，比如序列 (100,1,2,3) 的最大上升子序列和为 100，而最长上升子序列为 (1,2,3)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line"><span class="comment">// 第一行是序列长度N。</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="comment">// 第二行给出序列中的N个整数</span></span><br><span class="line"><span class="number">1</span> <span class="number">7</span> <span class="number">3</span> <span class="number">5</span> <span class="number">9</span> <span class="number">4</span> <span class="number">8</span></span><br><span class="line">    </span><br><span class="line">Output:</span><br><span class="line"><span class="comment">// 输出一个整数，表示最大上升子序列和。</span></span><br><span class="line"><span class="number">18</span></span><br></pre></td></tr></table></figure>
<h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>数据存储</p>
<p><code>nums[i]</code> 用于存储完整序列。</p>
</li>
<li><p>状态表示</p>
<p>与 <em>最长上升子序列</em> 类似，我们可以这样定义状态 $f[i]$：以 $nums[i]$ 为结尾、数值严格单调递增的所有子序列中最大的序列和。$f[i]$ 中最大值即为最长上升子序列和。</p>
</li>
<li><p>状态转移</p>
<p>状态转移基本与 <em>最长上升子序列</em> 相同，状态转移方程可表示如下：</p>
<p>$$f[i] = max(f[k] + nums[i],f[i]),(0\leq k &lt; i \  且 \ nums[k] &lt; nums[i])$$</p>
</li>
<li><p>状态初始化</p>
<p>由于状态存储序列和，故而需要如此初始化：指定 $f[i] = nums[i],(0 \leq i &lt; nums.length)$ 。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>线性DP</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-动态规划(二)</title>
    <url>/2020/09/13/algorithm/algorithm-dynamicprogramming2/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文主要介绍线性 DP 中的数字三角形模型，与该模型相关的题目有：数字三角形、摘花生、最低通行费、方格取数。</p>
<a id="more"></a>

<h2 id="数字三角形"><a href="#数字三角形" class="headerlink" title="数字三角形"></a>数字三角形</h2><h3 id="题目描述及示例"><a href="#题目描述及示例" class="headerlink" title="题目描述及示例"></a>题目描述及示例</h3><p>给定一个如下图所示的数字三角形，从顶部出发，在每一结点可以选择移动至其左下方的结点或移动至其右下方的结点，一直走到底层，要求找出一条路径，使路径上的数字的和最大。</p>
<p><img src="/2020/09/13/algorithm/algorithm-dynamicprogramming2/image-20200913101045695.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line"><span class="comment">// 第一行包含整数n，表示数字三角形的层数。</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="comment">// 接下来n行，每行包含若干整数，其中第i行表示数字三角形第i层包含的整数。</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">3</span> <span class="number">8</span></span><br><span class="line"><span class="number">8</span> <span class="number">1</span> <span class="number">0</span> </span><br><span class="line"><span class="number">2</span> <span class="number">7</span> <span class="number">4</span> <span class="number">4</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">2</span> <span class="number">6</span> <span class="number">5</span></span><br><span class="line">    </span><br><span class="line">Output:</span><br><span class="line"><span class="comment">// 输出一个整数，表示最大的路径数字和。</span></span><br><span class="line"><span class="number">30</span></span><br></pre></td></tr></table></figure>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>数据存储</p>
<p> <code>triangle[i][j]</code> 用于存储数字三角形 (存储方式与输入示例相同，每行数据从前往后依次存储即可)。</p>
</li>
<li><p>状态表示</p>
<p>既然数据是二维的，状态表示大概率也是二维的。我们可以这样定义 $f[i][j]$：以 $triangle[0][0]$ 为起点、$triangle[i][j]$ 为终点的所有路径中最大的路径数字和。</p>
</li>
<li><p>状态转移</p>
<p>“在每一结点可以选择移动至其左下方的结点或移动至其右下方的结点” 表明：对于 $f[i][j]$ 而言，它可由其左上方结点所示状态或右上方结点所示状态转移得到。故而状态转移方程可表示如下：</p>
<p>$$f[i][j] = max(f[i - 1][j - 1], f[i - 1][j]) + triangle[i][j]$$</p>
<blockquote>
<p>如果 $f[i][j]$ 为最左侧结点所示状态，则它只能由其右上方结点所示状态转移得到；如果 $f[i][j]$ 为最右侧结点所示状态，则它只能由其左上方结点所示状态转移得到。</p>
</blockquote>
</li>
<li><p>状态初始化</p>
<p>对于此题目而言，状态初始化比较简单，直接指定 $f[0][0] = triangle[0][0]$ 即可。</p>
</li>
</ul>
<h2 id="摘花生"><a href="#摘花生" class="headerlink" title="摘花生"></a>摘花生</h2><h3 id="题目描述及示例-1"><a href="#题目描述及示例-1" class="headerlink" title="题目描述及示例"></a>题目描述及示例</h3><p>Hello Kitty 想摘点花生送给她喜欢的米老鼠。她来到一片有网格状道路的矩形花生地 (如下图)，从西北角进去，东南角出来。地里每个道路的交叉点上都有种着一株花生苗，上面有若干颗花生，经过一株花生苗就能摘走该它上面所有的花生。Hello Kitty 只能向东或向南走，不能向西或向北走。问 Hello Kitty 最多能够摘到多少颗花生？</p>
<p><img src="/2020/09/13/algorithm/algorithm-dynamicprogramming2/20200831223250167.gif"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line"><span class="comment">// 第一行包含两个整数，分别代表花生苗的行数R和列数C。</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="comment">// 接下来R行数据，从北向南依次描述每行花生苗的情况。</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">6</span> <span class="number">5</span></span><br><span class="line">    </span><br><span class="line">Output:</span><br><span class="line"><span class="comment">// 输出一个整数，表示Hello Kitty能摘到得最多的花生颗数。</span></span><br><span class="line"><span class="number">16</span></span><br></pre></td></tr></table></figure>
<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>数据存储</p>
<p><code>rectangle[i][j]</code> 用于存储花生苗信息。</p>
</li>
<li><p>状态表示</p>
<p>与上题类似，我们可以这样定义状态 $f[i][j]$：以 $rectangle[0][0]$ 为起点、$rectangle[i][j]$ 为终点的所有路径中，Hello Kitty 所能摘到的最大花生数。</p>
</li>
<li><p>状态转移</p>
<p>“Hello Kitty 只能向东或向南走” 表明：对于 $f[i][j]$ 而言，它可由其左侧状态或其上侧状态转移得到。故而状态转移方程可表示如下：</p>
<p>$$f[i][j] = max(f[i][j - 1], f[i - 1][j]) + rectangle[i][j]$$</p>
<blockquote>
<p>如果 $f[i][j]$ 为最左侧状态，则它只能由其上侧状态转移得到；如果 $f[i][j]$ 为最上侧状态，则它只能由其右侧状态转移得到。</p>
</blockquote>
</li>
<li><p>状态初始化</p>
<p>对于此题目而言，状态初始化也是比较简单，直接指定 $f[0][0] = rectangle[0][0]$ 即可。</p>
</li>
</ul>
<h2 id="最低通行费"><a href="#最低通行费" class="headerlink" title="最低通行费"></a>最低通行费</h2><h3 id="题目描述及示例-2"><a href="#题目描述及示例-2" class="headerlink" title="题目描述及示例"></a>题目描述及示例</h3><p>一个商人穿过一个 $N\times N$ 的正方形网格，去参加一个非常重要的商务活动。他要从网格的左上角进，右下角出。<br>每穿越中间 1 个小方格，都要花费 1 个单位时间。商人必须在 (2N-1) 个单位时间内穿越出去，而在经过中间的每个小方格时，都需要缴纳一定的费用。这个商人期望在规定时间内用最少费用穿越出去。请问至少需要多少费用？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line"><span class="comment">// 第一行是一个整数，表示正方形的宽度N。</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="comment">// 接下来N行，为网格上每个小方格的费用。</span></span><br><span class="line"><span class="number">1</span>  <span class="number">4</span>  <span class="number">6</span>  <span class="number">8</span>  <span class="number">10</span> </span><br><span class="line"><span class="number">2</span>  <span class="number">5</span>  <span class="number">7</span>  <span class="number">15</span> <span class="number">17</span> </span><br><span class="line"><span class="number">6</span>  <span class="number">8</span>  <span class="number">9</span>  <span class="number">18</span> <span class="number">20</span> </span><br><span class="line"><span class="number">10</span> <span class="number">11</span> <span class="number">12</span> <span class="number">19</span> <span class="number">21</span> </span><br><span class="line"><span class="number">20</span> <span class="number">23</span> <span class="number">25</span> <span class="number">29</span> <span class="number">33</span></span><br><span class="line">    </span><br><span class="line">Output:</span><br><span class="line"><span class="comment">// 输出一个整数，表示至少需要的费用。</span></span><br><span class="line"><span class="number">109</span></span><br></pre></td></tr></table></figure>
<h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>数据存储</p>
<p><code>rectangle[i][j]</code> 用于存储网格费用。</p>
</li>
<li><p>状态表示</p>
<p>这道题目意思比较隐晦，我们先对题意作一简单分析：<em>“商人必须在 (2N-1) 个单位时间内穿越出去” ，这句话也就是说：商人只能向下或向右行走，而不能走回头路。</em></p>
<p>此时题意与上题基本类似，我们可以这样定义状态 $f[i][j]$：从 $rectangle[0][0]$ 出发、到达 $rectangle[i][j]$ 所需的最少费用。</p>
</li>
<li><p>状态转移</p>
<p>根据 “商人必须在 (2N-1) 个单位时间内穿越出去” ，状态转移方程可表示如下：</p>
<p>$$f[i][j] = min(f[i][j - 1],f[i - 1][j]) + rectangle[i][j]$$</p>
<blockquote>
<p>如果 $f[i][j]$ 为最左侧状态，则它只能由其上侧状态转移得到；如果 $f[i][j]$ 为最上侧状态，则它只能由其右侧状态转移得到。</p>
</blockquote>
</li>
<li><p>状态初始化</p>
<p>对于此题目而言，状态初始化也是比较简单，直接指定 $f[0][0] = rectangle[0][0]$ 即可。</p>
</li>
</ul>
<h2 id="方格取数"><a href="#方格取数" class="headerlink" title="方格取数"></a>方格取数</h2><h3 id="题目描述及示例-3"><a href="#题目描述及示例-3" class="headerlink" title="题目描述及示例"></a>题目描述及示例</h3><p>设有 $N \times N$ 的方格图，我们在其中的某些方格中填入正整数，而其它的方格中则放入数字 0。如下图所示：</p>
<p><img src="/2020/09/13/algorithm/algorithm-dynamicprogramming2/19_764ece6ed5-2.gif"></p>
<p>某人从图中的左上角 A 出发，可以向下行走，也可以向右行走，直到到达右下角的 B 点。在走过的路上，他可以取走方格中的数 (取走后的方格中将变为数字0)。此人从 A 点到 B 点共走了两次，试找出两条这样的路径，使得取得的数字和为最大。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line"><span class="comment">// 第一行为一个整数，表示方格图的宽度。</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="comment">// 接下来的每行有三个整数，第一个为行号数，第二个为列号数，第三个为在该行、该列上所放的数,一行“0 0 0”表示结束。</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">13</span></span><br><span class="line"><span class="number">2</span> <span class="number">6</span> <span class="number">6</span></span><br><span class="line"><span class="number">3</span> <span class="number">5</span> <span class="number">7</span></span><br><span class="line"><span class="number">4</span> <span class="number">4</span> <span class="number">14</span></span><br><span class="line"><span class="number">5</span> <span class="number">2</span> <span class="number">21</span></span><br><span class="line"><span class="number">5</span> <span class="number">6</span> <span class="number">4</span></span><br><span class="line"><span class="number">6</span> <span class="number">3</span> <span class="number">15</span></span><br><span class="line"><span class="number">7</span> <span class="number">2</span> <span class="number">14</span></span><br><span class="line">    </span><br><span class="line">Output:</span><br><span class="line"><span class="comment">// 输出一个整数，表示两条路径上取得的最大和。</span></span><br><span class="line"><span class="number">67</span></span><br></pre></td></tr></table></figure>
<h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>数据存储</p>
<p><code>rectangle[i][j]</code> 用于存储方格信息。</p>
</li>
<li><p>状态表示</p>
<p>这道题可以先执行 DP 求取一个最大和，随后将相关方格中的数置为 0，再次执行 DP 取得一个最大和，二者相加即是结果。</p>
<p>这道题目可以看做是数字三角形模型在二维空间中的扩展，所以我们直接在此空间之上构建状态。我们可以这样定义状态 $f[i1][j1][i2][j2]$：以 $rectangle[0][0]$ 为起点、 $rectangle[i1][j1]$ 和 $rectangle[i2][j2]$ 分别为终点的所有路径中，所能取得数字的最大和。</p>
</li>
<li><p>状态转移</p>
<p>由于涉及两个终点，类比数字三角形模型可知：当前状态 $f[i1][j1][i2][j2]$ 可由四个状态转移得到。具体的状态转移方程表示如下：</p>
<p>$$f[i1][j1][i2][j2] = max(f[i1][j1 - 1][i2][j2 - 1],f[i1 - 1][j1][i2 - 1][j2],f[i1][j1 - 1][i2 - 1][j2],f[i1 - 1][j1][i2][j2 - 1]) + rectangle[i1][j1] + rectangle[i2][j2] (i1 \neq i2 \ 或 \ j1 \neq j2)$$</p>
<p>$$f[i1][j1][i2][j2] = max(f[i1][j1 - 1][i2][j2 - 1],f[i1 - 1][j1][i2 - 1][j2],f[i1][j1 - 1][i2 - 1][j2],f[i1 - 1][j1][i2][j2 - 1]) + rectangle[i1][j1] (i1 = i2 \ 且 \ j1 = j2)$$</p>
</li>
<li><p>状态初始化</p>
<p>状态初始化仍然是比较简单的，直接指定 $f[0][0][0][0] = rectangle[0][0]$ 即可。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>线性DP</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-动态规划(一)</title>
    <url>/2020/09/12/algorithm/algorithm-dynamicprogramming1/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>动态规划</strong> 与分治法类似，皆是通过组合子问题解来求解原问题，二者不同点在于前者适用于子问题重叠场景，后者适用于子问题不重叠场景。正是由于存在子问题重叠，故而动态规划借助表格存储子问题解，通过多阶段决策以逐步组合得到原问题解。</p>
<a id="more"></a>

<p>动态规划所能求解的问题常具有如下三大特征：</p>
<ul>
<li><p>最优子结构</p>
<p>原问题解一定可由子问题解组合得到，换言之，通过组合子问题解一定可得到原问题的解。</p>
</li>
<li><p>重叠子问题</p>
<p>不同子问题之间存在公共子子问题。</p>
</li>
<li><p>无后效性</p>
<p>假定当前问题 A 由子问题 B 和 C 组成。无后效性指的是：求得 B、C 问题解后，A 问题求解过程中所使用到的决策不会对 B、C 问题解存在影响。</p>
</li>
</ul>
<p>动态规划求解过程主要涉及三个部分：</p>
<ul>
<li><p>状态表示</p>
<p>我们使用表格存储子问题解，那么状态表示指代表格中任意一格的具体含义是什么。例如，$f[i][j]$ 表示 xxx。</p>
</li>
<li><p>状态转移</p>
<p>状态转移指代一个子问题解应当根据哪些子问题解组合得到且以何种方式组合得到。例如，$f[i][j] = min(f[i - 1][j], f[i - 1][j - 1])$。</p>
</li>
<li><p>状态初始化</p>
<p>为得到原问题解，首先需要初始化相关子问题解，这样通过逐步递推将会得到原问题解。例如：$f[0][0] = 0$。</p>
</li>
</ul>
<p>动态规划求解过程看似简单，实际上没有比较多的积累是很难想到解法的。由于不是专业竞赛选手，故而我们只要简单了解一些动态规划题型就可以了。</p>
<p>本文之中，我们将简要介绍动态规划的两种实现方式，并比较二者区别。接下来几篇文章中，我们将进一步针对不同动态规划类型进行介绍，这些类型具体包括 —— 线性 DP (它所含内容比较多，主要介绍数字三角形模型和最长上升子序列模型)、背包 DP、状态机 DP、状态压缩 DP、区间 DP、树形 DP、数位 DP、DAG 上 DP。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>动态规划有两种实现方式 —— 递归和递推。</p>
<p>递归采用自顶向下方式进行实现。在该种实现方式中，为求得当前问题解，就需要递归求解子问题，随后基于子问题解组合得到当前问题解。由于存在子问题重叠，故而实现过程中需要使用公共空间存储子问题解 (正是由于使用公共空间存储子问题解，该种实现方式又称为 <strong>记忆化搜索</strong>)。</p>
<p>其实现代码大致如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 公共空间(默认初始化为-1，表明该子问题尚未被求解)。</span></span><br><span class="line"><span class="keyword">int</span> f[i][j];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记忆化搜索。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (f[i][j] != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> f[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 状态转移部分，首先求解子问题解，随后组合得到当前问题解。</span></span><br><span class="line">    ...</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>递推采用自底向上方式进行实现。在该种实现方式中，按照表格顺序依次求解各个子问题解即可。</p>
<p>其实现代码大致如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 表格。</span></span><br><span class="line"><span class="keyword">int</span> f[i][j];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; f.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; f[i].length; j++) &#123;</span><br><span class="line">        <span class="comment">// 状态转移部分。</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原问题解就在f[i][j]之中，返回相应值即可。</span></span><br><span class="line"><span class="keyword">return</span> f[][];</span><br></pre></td></tr></table></figure>
<p>既然存在两种实现方式，自然需要进行比较一番：</p>
<ul>
<li>两种方式往往可以自由转换。通常情况下，递推实现动态规划比较简单；而在某些情况下，递归实现动态规划比较简单。针对具体题目，选择方便实现的方式即可。</li>
<li>由于递归本身具有搜索特性，故而递归方式可使用剪枝以避免无效搜索 (换言之，可优化时间复杂度)，但是它无法对空间进行优化。</li>
<li>递推方式无法对时间进行优化，但是基于滚动数组等方式可大大优化空间复杂度。</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>动态规划</category>
      </categories>
  </entry>
  <entry>
    <title>算法-图搜索</title>
    <url>/2020/08/29/algorithm/algorithm-graphsearch/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>图搜索</strong> 最初用于遍历图内节点，现在往往用于最优解搜索等问题。</p>
<a id="more"></a>

<p>我们在此介绍五种搜索算法 —— DFS (深度优先搜索) 、BFS (广度优先搜索)、IDDFS (迭代深化深度优先搜索)、A*、IDA*。</p>
<blockquote>
<p>我们在此仅讨论搜索算法用于求解最优解搜索问题。随后在可行解内找具有最小代价的最优解。</p>
</blockquote>
<h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><p>DFS 属于盲目搜索，它会遍历解空间中所有解，故而其也是一种暴力搜索。</p>
<p>当用其解决最优解搜索问题时，首先需要找到解空间内所有可行解，随后在可行解内找具有最小代价的最优解。</p>
<h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><p>BFS 属于有目的搜索，它会按层次搜索解空间中的解。</p>
<p>当用其解决最优解搜索问题时，只要搜索到解，那么该解一定是最优解。</p>
<blockquote>
<p>最优解搜索问题中有一类称为最短路径搜索。该问题用于查找图中两点间最短路径。</p>
<p>如果图中任意两点间边代价相同，则从起点开始，BFS 动态搜索止点，一旦搜索到止点，其搜索路径就是最短路径。</p>
</blockquote>
<h2 id="IDDFS"><a href="#IDDFS" class="headerlink" title="IDDFS"></a>IDDFS</h2><p>对于 DFS 而言，深度越深，递归层级越高，此时容易栈溢出；对于 BFS 而言，广度越广，队列所需空间越大，此时容易内存溢出。当需要寻找最优解时，由于 DFS 往往需要遍历解空间，故而使得其时间复杂度过高。</p>
<p>实际中，内存溢出远比栈溢出容易 (深度越深，大概率意味着广度越广)。为在内存空间有限条件下快速搜索最优解，IDDFS (迭代深化深度优先搜索，即带有深度限制地深度优先搜索) 被提出，它借助于 DFS 以模拟 BFS，从而达到搜索效率和内存空间两不误。</p>
<p>我们简单描述其过程如下：</p>
<ol>
<li>初始化深度限制为 1，使用 DFS 搜索最优解。</li>
<li>如果 DFS 搜索得到最优解或者深度限制已达最大深度限制，则退出循环，否则设置深度限制为当前深度限制加一，重新进行 DFS 搜索最优解。</li>
</ol>
<blockquote>
<p>深度加一，解空间应当呈指数增加，之前搜索部分的时间复杂度便可忽略不计，故而 IDDFS 的时间复杂度主要由最优解所在深度那层深搜决定；BFS 同样需要搜索到最优解所在深度，但是由于它一次搜索到位，故而其时间复杂度仅略好于 IDDFS 。</p>
</blockquote>
<p>这里简单说明一下 IDDFS 的适用场景：深度未知、广度很大、同时最优解深度又比较低。</p>
<h2 id="A"><a href="#A" class="headerlink" title="A*"></a>A*</h2><p>当进行最短路径搜索时，BFS 会将当前搜索点的所有未搜索邻居点加入至队列 (简称为扩展当前搜索点)，然后按序取出队列内容进行扩展，这种扩展方式略显愚笨。</p>
<p>按照人们直观理解来看，我们应当优先扩展距离目标点更近地搜索点。那么这种搜索算法就称为 <strong>最佳优先搜索</strong>。</p>
<p>最佳优先搜索问题在于：没有考虑搜索点到起始点情况。在 A* 中，它优先扩展具有最小代价值 (该代价值与起始点和目标点均相关) 的搜索点，其中代价值基于启发函数确定。</p>
<p>在 A* 算法中，启发函数表示为 $f(x) = g(x) + h(x)$，其中 $g(x)$ 指代起始点至当前节点的所需代价，$h(x)$ 指代当前节点至目标点的预估代价。</p>
<p>$g(x)$ 在搜索过程中可以得到，而 $h(x)$ 通常需要精心设计。我们在此列举 $h(x)$ 的常见形式：</p>
<ul>
<li>如果图中搜索节点时仅允许上下左右探索，则其应为曼哈顿距离。</li>
<li>如果图中搜索节点时仅允许八方向 (即上、下、左、右、左上、右上、左下、右下) 探索，则其应为对角距离。</li>
<li>如果图中搜索节点时允许任意方向移动，则其应为欧几里得距离。</li>
</ul>
<h2 id="IDA"><a href="#IDA" class="headerlink" title="IDA*"></a>IDA*</h2><p>A* 算法等价于 BFS + 启发函数，IDA* 则等价于 IDDFS + 启发函数。</p>
<p>在 IDA* 中，启发函数可用于两处：1. 根据启发函数动态增加深度，而非每次加一。2. 根据启发函数判断当前解情况下是否需要继续进行深度优先搜索。</p>
<blockquote>
<p>我们在此简单介绍一些避免无效搜索地操作：</p>
<ol>
<li><p>记忆化搜索</p>
<p>如果搜索过程发生重复搜索，我们可以现行保存搜索结果，随后直接使用搜索结果替代搜索。</p>
</li>
<li><p>可行性剪枝</p>
<p>如果当前解已经无法满足要求，则无需再进行搜索。</p>
</li>
<li><p>最优性剪枝</p>
<p>如果当前解比已知最优解更差，则无需再进行搜索。</p>
</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>BFS</tag>
        <tag>IDDFS</tag>
        <tag>A*</tag>
        <tag>IDA*</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-最短路径</title>
    <url>/2020/08/28/algorithm/algorithm-shortestpath/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>最短路径</strong> 属于图论用语，它旨在求解图中任意两点间的最短距离。</p>
<a id="more"></a>

<p>我们在此介绍四种最短路径搜索算法 —— Dijkstra 算法、Floyd 算法、Bellman-Ford 算法及 SPFA 算法。</p>
<h2 id="Dijkstra-算法"><a href="#Dijkstra-算法" class="headerlink" title="Dijkstra 算法"></a>Dijkstra 算法</h2><p>Dijkstra 算法用于求取单源最短路径，它仅适用于无负权边场景。</p>
<p>该算法思想与 Prim 算法基本一致，均是基于贪心思想。其步骤描述如下 (假定图中节点集合为 $V$)：</p>
<ol>
<li>选定图中某一节点指定为单源，记为 $root$。</li>
<li>构建两个集合 $S$ 和 $T$ ($S$ 表示节点集合中已求得最短路径的节点集，$T$ 表示节点集合中未求得最短路径的节点集)，并初始化它们为 $S = {root}, T = V - {root}$。</li>
<li>选择 $T$ 中距离 $root$ 节点最近的节点，将其从 $T$ 中删去并将其加入至 $S$ 中，根据此节点更新 $T$ 中其余节点到 $root$ 节点的距离信息。</li>
<li>循环迭代步骤 3，直至 $S == V$。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] dijkstra(<span class="keyword">int</span>[][] graph) &#123;</span><br><span class="line">    <span class="comment">// 存放最短路径值及具体路径信息。</span></span><br><span class="line">    <span class="keyword">int</span>[] distance = <span class="keyword">new</span> <span class="keyword">int</span>[graph.length];</span><br><span class="line">    <span class="keyword">int</span>[][] paths = <span class="keyword">new</span> <span class="keyword">int</span>[graph.length][graph[<span class="number">0</span>].length];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认求取0号节点到其余节点的最短路径，首先初始化相关信息。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.length; i++) &#123;</span><br><span class="line">        distance[i] = graph[<span class="number">0</span>][i];</span><br><span class="line">        Arrays.fill(paths[i], INF);</span><br><span class="line">        <span class="keyword">if</span> (distance[i] != INF) &#123;</span><br><span class="line">            paths[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            paths[i][<span class="number">1</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    distance[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    paths[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环迭代获取最短路径。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> minIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minDistance = INF;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到T中距离0号节点最近的节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; graph.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (distance[j] &gt; <span class="number">0</span> &amp;&amp; distance[j] &lt; minDistance) &#123;</span><br><span class="line">                minIndex = j;</span><br><span class="line">                minDistance = distance[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果一个节点到0号节点的距离为负数，表明该点已加入S中。</span></span><br><span class="line">        distance[minIndex] = -distance[minIndex];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果T中节点经由minIndex节点后到达0号节点的距离变短，则更新之。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; graph.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (distance[j] &gt; <span class="number">0</span> &amp;&amp; minDistance + graph[minIndex][j] &lt; distance[j]) &#123;</span><br><span class="line">                distance[j] = minDistance + graph[minIndex][j];</span><br><span class="line">                <span class="comment">// 更新路径信息。</span></span><br><span class="line">                Arrays.fill(paths[j], INF);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; paths[minIndex].length; s++) &#123;</span><br><span class="line">                    paths[j][s] = paths[minIndex][s];</span><br><span class="line">                    <span class="keyword">if</span> (paths[j][s] == INF) &#123;</span><br><span class="line">                        paths[j][s] = j;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回最短路径。</span></span><br><span class="line">    <span class="keyword">return</span> paths;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Floyd-算法"><a href="#Floyd-算法" class="headerlink" title="Floyd 算法"></a>Floyd 算法</h2><p>Floyd 算法用于求取全局最短路径，它适用于有无负权边场景，但是不适用于负环回路场景，它基于动态规划而实现。</p>
<p>从任意节点 $i$ 到任意节点 $j$ 的最短路径不外乎两种情况：从 $i$ 直接到达 $j$ 、从 $i$ 出发借助于中间节点 $k$ 到达 $j$。基于此我们可构建状态 $f[k][i][j]$，它表示借助于前 $k$ 个节点作为中间节点所构建 $i$ 到 $j$ 的最短路径值。那么容易得到状态方程：</p>
<p>$$f[k][i][j] = min(f[k - 1][i][j], f[k - 1][i][k], f[k - 1][k][j])$$</p>
<p>初始状态即为 $f[0][i][j] = edge[i][j]$ ($edge[i][j]$ 表示边权重)，循环迭代处理至 $f[V.size()][i][j]$ ($V$ 表示图顶点集) 便得到全局最短路径。</p>
<p>观察该状态转换方程，我们可以发现：当前状态 $f[k][<em>][</em>]$ 仅依赖于 $f[k - 1][<em>][</em>]$，故而使用两个矩阵迭代更新即可完成循环迭代过程。</p>
<p>更进一步，我们发现：$f[k - 1][i][k] == f[k][i][k] 且  f[k - 1][k][j] == f[k][k][j]$，此时我们可直接在当前矩阵中完成更新操作 (<strong>非常神奇地观察</strong>)。</p>
<p>此时可以给出 Floyd 算法，十分地简洁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] floyd(<span class="keyword">int</span>[][] graph) &#123;</span><br><span class="line">    <span class="comment">// 存放借助于前k个节点作为中间节点时i到j的最短路径。</span></span><br><span class="line">    <span class="keyword">int</span>[][] D = <span class="keyword">new</span> <span class="keyword">int</span>[graph.length][graph[<span class="number">0</span>].length];</span><br><span class="line">    <span class="comment">// 存放i到j的最短路径中第一个使用地中间节点(借助它可获取最短路径信息)。</span></span><br><span class="line">    <span class="keyword">int</span>[][] P = <span class="keyword">new</span> <span class="keyword">int</span>[graph.length][graph[<span class="number">0</span>].length];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化矩阵。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; graph[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">            D[i][j] = graph[i][j];</span><br><span class="line">            P[i][j] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 三重循环迭代处理。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; graph.length; k++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; graph[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="comment">// 这个看似简单，主要基于上面那个观察。</span></span><br><span class="line">                <span class="keyword">if</span> (D[i][k] + D[k][j] &lt; D[i][j]) &#123;</span><br><span class="line">                    D[i][j] = D[i][k] + D[k][j];</span><br><span class="line">                    P[i][j] = P[i][k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> P;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Bellman-Ford-算法"><a href="#Bellman-Ford-算法" class="headerlink" title="Bellman-Ford 算法"></a>Bellman-Ford 算法</h2><p>Bellman-Ford 算法用于求取单源最短路径，它适用于有无负权边场景，同时可判断是否存在负环回路。</p>
<p>Bellman-Ford 算法步骤描述如下 (假定图中节点集合为 $V$)：</p>
<ol>
<li>选定图中某一节点指定为单源，记为 $root$。</li>
<li>初始化所有节点到 $root$ 的最短路径值，记为 $distance[i]$。</li>
<li>对图中所有边尝试执行松弛操作，即对于边 $edge[i][j]$ 而言，如果 $distance[i] + edge[i][j] &lt; distance[j]$，则更新 $distance[j] = distance[i] + edge[i][j]$。</li>
<li>循环迭代步骤 3 $V.size() - 1$ 次即可得到结果。</li>
</ol>
<p>重点解释：为什么循环迭代 $V.size() - 1$ 次可以得到单源最短路径结果？</p>
<p>松弛操作具有一个性质：如果 $p = (v_0,v_1,\dots,v_k)$ 是从源点 $v_0$ 到终点 $v_k$ 的最短路径，并且我们执行松弛操作的顺序为 $edge[v_0][v_1],\dots,edge[v_{k-1},v_k]$，那么这些松弛操作完成后得到的 $distance[v_k]$ 必定是源点 $v_0$ 到终点 $v_k$ 的最短路径值。并且该性质成立条件与其他松弛操作无关，即可在这些松弛操作中穿插其他松弛操作，只要保证这些松弛操作按序执行即可。</p>
<p>该性质比较容易理解，故而我们不予证明 (好吧，就是不会 😅)。由于组成单源最短路径的边数不可能超过 $V.size() - 1$，根据松弛操作性质，我们可在 $V.size() - 1$ 次内得到单源最短路径。如果我们再次循环一次，此时如果存在松弛操作被执行，便可判断图中存在负环回路。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] bellmanFord(<span class="keyword">int</span>[][] graph) &#123;</span><br><span class="line">    <span class="comment">// 存放各节点到单源的最短路径值及最短路径信息。</span></span><br><span class="line">    <span class="keyword">int</span>[] distance = <span class="keyword">new</span> <span class="keyword">int</span>[graph.length];</span><br><span class="line">    <span class="keyword">int</span>[][] paths = <span class="keyword">new</span> <span class="keyword">int</span>[graph.length][graph[<span class="number">0</span>].length];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化相关信息。</span></span><br><span class="line">    Arrays.fill(distance, INF);</span><br><span class="line">    distance[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.length; i++) &#123;</span><br><span class="line">        Arrays.fill(paths[i], INF);</span><br><span class="line">    &#125;</span><br><span class="line">    paths[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环v.size()-1次。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; graph.length; k++) &#123;</span><br><span class="line">        <span class="comment">// 对图中所有边执行松弛操作。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; graph[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="comment">// 松弛操作。</span></span><br><span class="line">                <span class="keyword">if</span> (graph[i][j] != INF &amp;&amp; distance[i] + graph[i][j] &lt; distance[j]) &#123;</span><br><span class="line">                    distance[j] = distance[i] + graph[i][j];</span><br><span class="line">                    <span class="comment">// 更新路径信息。</span></span><br><span class="line">                    Arrays.fill(paths[j], INF);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; paths[i].length; s++) &#123;</span><br><span class="line">                        paths[j][s] = paths[i][s];</span><br><span class="line">                        <span class="keyword">if</span> (paths[j][s] == INF) &#123;</span><br><span class="line">                            paths[j][s] = j;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> paths;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="SPFA-算法"><a href="#SPFA-算法" class="headerlink" title="SPFA 算法"></a>SPFA 算法</h2><p>SPFA 算法是 Bellman-Ford 算法的优化版本，其优化点在于：针对需要进行松弛操作的边执行松弛操作。</p>
<p>在 Bellman-Ford 算法中，直接对图中所有边尝试执行松弛操作，然而并非所有的边都是需要进行松弛操作的。如果可以避免无效的尝试松弛操作，那么就可以进一步降低算法的时间复杂度。</p>
<p>第一轮执行 Bellman-Ford 算法时，我们将会发现只有以单源为出发点的那些边才是真正需要进行松弛操作的，其余边的松弛操作尝试均是没有必要地，并且记基于松弛操作更新最短路径信息的点集为 $v$；第二轮执行 Bellman-Ford 算法时，我们又会发现只有以 $v$ 中点为出发点的那些边才是真正需要进行松弛操作的，其余边的松弛操作尝试均是没有必要地，以此类推，均是如此规律。</p>
<p>基于此规律，我们可将待松弛点依次放入队列之中，按序松弛点对应边。当队列为空时，松弛操作完成并且最短路径求取完成，这基本上是 SPFA 算法的核心要义。</p>
<blockquote>
<p>在 SPFA 算法中，如果需要判断图中是否存在负环回路，只要判断特定待松弛点进入队列次数是否超过 $V.size() - 1$ 次即可。</p>
<p>在代码实现中，如果待松弛点已经入队，则无需再次入队。如此操作的原因在于：即使不将该点再次放入队列之中，已放入队列的该点它会完成所需的松弛操作，将其再次放入队列之中完全是没有必要的。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] spfa(<span class="keyword">int</span>[][] graph) &#123;</span><br><span class="line">    <span class="comment">// 存放各节点到单源的最短路径值及最短路径信息。</span></span><br><span class="line">    <span class="keyword">int</span>[] distance = <span class="keyword">new</span> <span class="keyword">int</span>[graph.length];</span><br><span class="line">    <span class="keyword">int</span>[][] paths = <span class="keyword">new</span> <span class="keyword">int</span>[graph.length][graph[<span class="number">0</span>].length];</span><br><span class="line">    <span class="comment">// 用于存放待松弛点的队列。</span></span><br><span class="line">    ArrayDeque&lt;Integer&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    <span class="comment">// 判断点是否位于队列之中。</span></span><br><span class="line">    <span class="keyword">boolean</span>[] in = <span class="keyword">new</span> <span class="keyword">boolean</span>[graph.length];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化相关信息。</span></span><br><span class="line">    Arrays.fill(distance, INF);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.length; i++) &#123;</span><br><span class="line">        Arrays.fill(paths[i], INF);</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.fill(in, <span class="keyword">false</span>);</span><br><span class="line">    distance[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    paths[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    in[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">    queue.push(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 队列中吐出一个节点。</span></span><br><span class="line">        Integer index = queue.pop();</span><br><span class="line">        <span class="comment">// 对节点对应边尝试执行松弛操作。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph[<span class="number">0</span>].length; i++) &#123;</span><br><span class="line">            <span class="comment">// 松弛操作。</span></span><br><span class="line">            <span class="keyword">if</span> (graph[index][i] != INF &amp;&amp; distance[index] + graph[index][i] &lt; distance[i]) &#123;</span><br><span class="line">                distance[i] = distance[index] + graph[index][i];</span><br><span class="line">                <span class="comment">// 更新路径信息。</span></span><br><span class="line">                Arrays.fill(paths[i], INF);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; paths[index].length; s++) &#123;</span><br><span class="line">                    paths[i][s] = paths[index][s];</span><br><span class="line">                    <span class="keyword">if</span> (paths[i][s] == INF) &#123;</span><br><span class="line">                        paths[i][s] = i;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果i位于队列之中，则无需再入队列。</span></span><br><span class="line">                <span class="keyword">if</span> (in[i] == <span class="keyword">false</span>) &#123;</span><br><span class="line">                    queue.push(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> paths;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>算法-最小生成树</title>
    <url>/2020/08/27/algorithm/algorithm-minimumspanningtree/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>最小生成树</strong> 属于图论用语，它是连通图中具有最小边代价和的生成树。求取它的实际意义在于：如果需要为城镇部署线网，按照最小生成树进行部署，既可保证用户全覆盖，又可保证代价最小。</p>
<a id="more"></a>

<p>我们在此介绍两种最小生成树求解算法 —— Prim 算法 (又称 “加点法”) 和 Kruskal 算法 (又称 “加边法”)。</p>
<h2 id="Prim-算法"><a href="#Prim-算法" class="headerlink" title="Prim 算法"></a>Prim 算法</h2><p>Prim 算法步骤描述如下 (假定图中节点集合为 $V$)：</p>
<ol>
<li>选定图中某一节点为根节点，记为 $root$。</li>
<li>构建两个集合 $S$ 和 $T$ ($S$ 表示节点集合中属于最小生成树中节点的节点集，$T$ 表示节点集合中不属于最小生成树中节点的节点集)，并初始化它们为 $S = {root}, T = V - {root}$。</li>
<li>选择 $T$ 中距离 $S$ 中节点最近的节点，将其从 $T$ 中删去并加入到 $S$ 中。</li>
<li>循环迭代步骤 3，直至 $S == V$。</li>
</ol>
<blockquote>
<ul>
<li>从步骤描述中可以看到：需要时刻维护 $T$ 中节点到 $S$ 中节点的距离 (即边代价)。</li>
<li>最小生成树基于添加点而构建，故而其称为 “加点法”。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果边权重为INF，表明该边不存在。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] prim(<span class="keyword">int</span>[][] graph) &#123;</span><br><span class="line">    <span class="comment">// 维护T中节点到S中节点的边代价</span></span><br><span class="line">    <span class="keyword">int</span>[] destination = <span class="keyword">new</span> <span class="keyword">int</span>[graph.length];</span><br><span class="line">    <span class="keyword">int</span>[] distance = <span class="keyword">new</span> <span class="keyword">int</span>[graph.length];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认使用0号节点作为最小生成树树根，首先初始化相关信息。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph[<span class="number">0</span>].length; i++) &#123;</span><br><span class="line">        destination[i] = <span class="number">0</span>;</span><br><span class="line">        distance[i] = graph[<span class="number">0</span>][i];</span><br><span class="line">    &#125;</span><br><span class="line">    distance[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环迭代以构建最小生成树。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; graph.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> minIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minDistance = INF;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到T中最小代价边。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; distance.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (distance[j] != <span class="number">0</span> &amp;&amp; distance[j] &lt; minDistance) &#123;</span><br><span class="line">                minIndex = j;</span><br><span class="line">                minDistance = distance[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        distance[minIndex] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 依据最小代价边更新信息。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; distance.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (distance[j] != <span class="number">0</span> &amp;&amp; distance[j] &gt; graph[minIndex][j]) &#123;</span><br><span class="line">                destination[j] = minIndex;</span><br><span class="line">                distance[j] = graph[minIndex][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> destination;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Kruskal-算法"><a href="#Kruskal-算法" class="headerlink" title="Kruskal 算法"></a>Kruskal 算法</h2><p>Kruskal 算法步骤描述如下 (假定图中节点集合为 $V$)：</p>
<ol>
<li>将图中所有边按照边代价从小到大进行排序。</li>
<li>清空图中所有边，使得图仅剩所有顶点。</li>
<li>从小到大依次选择边，如果该边对应的两个顶点已经连通，则不作任何处理，否则在图中添加此边。</li>
<li>循环迭代步骤 3， 直至图中添加地边数为 $V.size - 1$。</li>
</ol>
<blockquote>
<ul>
<li>判断顶点是否连通，可使用并查集快速做到。</li>
<li>最小生成树基于添加边而构建，故而其称为 “加边法”。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 边信息(包含起止点、边代价)，用于排序及最后输出记录。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EdgeInfo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> distance;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EdgeInfo</span><span class="params">(<span class="keyword">int</span> distance, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.distance = distance;</span><br><span class="line">        <span class="keyword">this</span>.i = i;</span><br><span class="line">        <span class="keyword">this</span>.j = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;EdgeInfo&gt; <span class="title">kruskal</span><span class="params">(<span class="keyword">int</span>[][] graph)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 并查集，用于判断两点是否连通。</span></span><br><span class="line">    UnionFind uf = <span class="keyword">new</span> UnionFind(graph.length);</span><br><span class="line">    <span class="comment">// 存放最小生成树记录。</span></span><br><span class="line">    ArrayList&lt;EdgeInfo&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 使用优先队列按照边代价对图中所有边从小到大排序。</span></span><br><span class="line">    PriorityQueue&lt;EdgeInfo&gt; edges = <span class="keyword">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; &#123;</span><br><span class="line">        EdgeInfo edge1 = (EdgeInfo) o1;</span><br><span class="line">        EdgeInfo edge2 = (EdgeInfo) o2;</span><br><span class="line">        <span class="keyword">return</span> (edge1.distance - edge2.distance);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化优先队列。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; graph[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (graph[i][j] != INF) &#123;</span><br><span class="line">                edges.add(<span class="keyword">new</span> EdgeInfo(graph[i][j], i, j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!edges.isEmpty()) &#123;</span><br><span class="line">        EdgeInfo tmp = edges.remove();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 边对应的两个顶点不连通，则合并之，同时将该边置于最终结果。</span></span><br><span class="line">        <span class="keyword">if</span> (uf.find(tmp.i) != uf.find(tmp.j)) &#123;</span><br><span class="line">            uf.union(tmp.i, tmp.j);</span><br><span class="line">            result.add(tmp);</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果结果集中已有v.size-1条边，则最小生成树已构建完成，退出循环。</span></span><br><span class="line">        <span class="keyword">if</span> (k == graph.length - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构-LSM树</title>
    <url>/2020/08/26/dataStructure/dataStructure-lsmtree/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>LSM 树</strong> 是一种文件组织数据结构，它常用作非关系型数据库的底层实现 (B+ 树则常用作关系型数据库的底层实现)。</p>
<a id="more"></a>

<p>通常情况下，数据读取需求大于数据写入需求，故而产生了 B+ 树这种文件组织结构。由于物联网地兴起，数据写入需求大于数据读取需求的情况发生，此时如果仍然使用 B+ 树组织文件，则性能较差，故而产生了 LSM 树这种文件组织结构。</p>
<p>我们首先看看磁盘访问性能比较图：</p>
<p><img src="/2020/08/26/dataStructure/dataStructure-lsmtree/16b47414ad22f35a.png" alt="图一：磁盘访问性能比较图"></p>
<p>观察该图，容易得知：磁盘顺序访问性能远大于磁盘随机访问性能，且甚至超越了内存随机访问性能。<strong>正是基于这一点观察，LSM 树将磁盘随机访问操作转换为磁盘顺序访问操作，从而使得随机写操作性能大大提升，与之对应的便是随机读性能有所下降 (可通过布隆过滤器等操作弥补随机读性能)。</strong></p>
<h2 id="LSM-树"><a href="#LSM-树" class="headerlink" title="LSM 树"></a>LSM 树</h2><p><img src="/2020/08/26/dataStructure/dataStructure-lsmtree/v2-37576525d52091fd713bb13556c92861_720w.jpg" alt="图二：LSM树结构"></p>
<p>LSM 树通常由三部分组成：</p>
<ul>
<li><p>memtable</p>
<p>它是位于内存之中的数据结构，用于存储最近更新地数据，而且这些数据按照键值有序排列，故而 memtable 通常表现为红黑树、跳跃表等高效排序结构。</p>
<p>由于内存属于不稳定介质，故而插入元素至 memtable 之前，需通过 WAL(Write-ahead logging) 将其插入至日志之中，以保证数据的可靠性。</p>
</li>
<li><p>immutable memtable</p>
<p>它是位于内存之中、不可修改的数据结构。它是将 memtable 转变为 sstable 的中间状态，其目的在于：转存过程中仍然可以通过 memtable 进行写操作。</p>
</li>
<li><p>sstable</p>
<p>它是有序键值对集合，是位于磁盘之中的数据结构。如果希望加快 sstable 读取性能，可为其建立索引或使用布隆过滤器。</p>
<p><img src="/2020/08/26/dataStructure/dataStructure-lsmtree/v2-9eeda5082f56b1df20fa555d36b0e0ae_720w.png" alt="图三：sstable结构"></p>
</li>
</ul>
<p>接下来简单介绍其上的插入、删除、查询、修改操作。</p>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>为保证数据完整性，首先需要基于 WAL 将数据插入至日志之中，随后将其插入至 memtable 之中。如果 memtable 所存数据量超过阈值，则需要将其转换为 immutable memtable，随后 immutable memtable 又将转存为 sstable。如果 sstable 数量过多，则需要进一步合并 sstable。</p>
<blockquote>
<p>如果单纯仅转存为 sstable，如此将会引入大量 sstable，此时查找性能将大大下降，故而需要根据一定规则适当合并 sstable (<strong>合并规则是 LSM 树的重中之重</strong>)。</p>
</blockquote>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>如果直接删除待删除元素，这样会直接导致磁盘内容发生变更，不利于顺序访问磁盘。</p>
<p>为删除一个元素，我们需要将其关键字及删除标志插入至 LSM 树中。当 sstable 合并时，此时根据删除标志将该元素删去。</p>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>查询操作比较复杂，从上述结构中可以看到：memtable 中数据最新、immutable memtable 中数据其次、sstable 中数据最旧。</p>
<p>当进行查询操作时，我们首先在 memtable 中进行查找，如果找到则返回，否则继续查找 immutable memtable，最后查找 sstable。</p>
<h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><p>与删除操作类似，修改操作亦是基于插入操作实现。</p>
<p>为修改一个元素，我们需要将其关键字及修改内容插入至 LSM 中。当 sstable 合并时，将关键字对应数据内容更新至最新内容即可。</p>
<h2 id="合并策略"><a href="#合并策略" class="headerlink" title="合并策略"></a>合并策略</h2><p>从 LSM 树的各项操作中，可以看到：所有操作中都涉及合并操作，故而合并策略就显得尤为重要。</p>
<p>在介绍合并策略之前，首先介绍三个概念：</p>
<ul>
<li><p>读放大</p>
<p>读取数据时实际读取地数据量大于真正地数据量。例如：在 LSM 树中需要先在 memtable 查看指定关键字是否存在，不存在继续从immutable memtable、sstable 中寻找。</p>
</li>
<li><p>写放大</p>
<p>写入数据时实际写入的数据量大于真正地数据量。例如：在 LSM 树中写入数据引发合并操作，合并操作将会涉及大量写入。</p>
</li>
<li><p>空间放大</p>
<p>数据实际占用的磁盘空间大于真正地数据量。例如：在 LSM 树中，由于删除、修改操作均基于插入实现，故而将会引入大量重复关键字及其对应数据。</p>
</li>
</ul>
<p>接下来我们介绍两种合并策略：size-tiered 和 leveled。</p>
<h3 id="size-tiered"><a href="#size-tiered" class="headerlink" title="size-tiered"></a>size-tiered</h3><p><img src="/2020/08/26/dataStructure/dataStructure-lsmtree/v2-bedb057fde7a4ce4d5be2ea34fe86f59_720w.jpg" alt="图四：size-tiered合并策略"></p>
<p>size-tiered 策略对 sstable 进行分级，如果当前层级 sstable 个数超过阈值，则合并这些 sstable 以得到一个更高层级的 sstable。容易得知：sstable 层级越高，其所含数据越多，对应文件就越大。</p>
<p>在这种策略中，同一层级的 sstable 可以包含具有相同关键字的数据，这使得耗费多余空间且存在过多旧副本，故而其空间放大问题较为严重，同时读放大问题较为严重。相比于下面的 leveled 策略而言，该种策略的写放大问题并不明显。</p>
<blockquote>
<p>当进行合并时，首先顺序读取当前层级 sstable，然后按照外部归并排序操作依次合并，随后将合并结果 sstable 顺序存入磁盘之中。</p>
</blockquote>
<h3 id="leveled"><a href="#leveled" class="headerlink" title="leveled"></a>leveled</h3><p><img src="/2020/08/26/dataStructure/dataStructure-lsmtree/v2-5f8de2e435e979936693631617a60d16_720w.jpg" alt="图五：leveled合并策略"></p>
<p>leveled 策略基于层级文件大小进行分级，每一层级由若干 sstable 组成，而且这些 sstable 有序排列且互相不含相同关键字。</p>
<p>进行合并之时，如果某一层级文件大小超过阈值，则从中选择一个 sstable 并将其与下一层级中与此部分所含关键字存在交集部分的 sstable 合并，随机继续判断当前层级文件大小是否超过阈值，如果超过则继续选择 sstable 进行类似合并操作，否则递归判断下一层级文大小是否超过阈值。</p>
<p><img src="/2020/08/26/dataStructure/dataStructure-lsmtree/v2-663d136cefaaf6f8301833bf29c833e9_720w.jpg" alt="图六：leveled策略举例"></p>
<p>在这种策略中，同一层级的 sstable 不会包含具有相同关键字的数据，故而其空间放大问题及读放大问题得以缓解。但是其合并策略可能使得写放大问题较为严重，例如：某个层级文件大小超过阈值，而且选择合并的 sstable 所含关键字范围几乎囊括下一层级中所有 sstable，此时就涉及极大地写入问题。</p>
<h2 id="LSM-VS-B"><a href="#LSM-VS-B" class="headerlink" title="LSM VS B+"></a>LSM VS B+</h2><p>这里简单比较 LSM 树和 B+ 树：</p>
<ol>
<li>两者均为文件组织数据结构，用于处理大数据存取问题。</li>
<li>前者基于 “磁盘顺序访问性能远大于磁盘随机访问性能，且甚至超越了内存随机访问性能” 观察而产生，后者则基于 “磁盘随机访问性能较差，应当尽可能减少随机访问操作” 观察而产生。</li>
<li>前者适用于写多读少场景，后者则适用于写少读多场景。</li>
</ol>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-R树</title>
    <url>/2020/08/25/dataStructure/dataStructure-rtree/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>R 树</strong> 是一种处理高维空间存储问题的数据结构。值得注意的是：(R 树，B 树) 和 (k-d 树，二叉查找树) 具有类似关系，即前者是后者在高维空间的扩展，不同点在于 R 树是平衡的而 k-d 树是不平衡的。</p>
<a id="more"></a>

<p>虽然网上资料显示 “R 树是 B 树在高维空间的扩展”，但是随着对 R 树的深入了解，我觉得 “R 树应当是 B+ 树在高维空间的扩展”。故而我将以 B+ 树为例引出 R 树。</p>
<p>首先看一个 B+ 树示例：</p>
<p><img src="/2020/08/25/dataStructure/dataStructure-rtree/image-20200825143929462.png" alt="图一：B+树示例"></p>
<p>在 B+ 树中，叶节点存放所有关键字及相应数据；索引节点存放索引关键字，根据这些索引关键字可进一步找到部分关键字及其数据，如此我们可称索引节点掌管若干关键字及其数据。例如：R 节点掌管所有关键字及其数据，其下三个子节点 A、B、C 各掌管 R 节点所掌管关键字及其数据的一部分。当进行查询时，首先在 R 节点处根据索引关键字确定待查找关键字在哪个子节点的掌管范围之内，随后递归到子节点中进行处理，直至到达叶节点。如果叶节点中包含指定关键字，则查询成功，否则查询失败。如此一个查询过程，其本质就是基于索引信息逐步缩减待查找范围。</p>
<p>其次我们看一个高维空间查找示例：如何快速查询中国地图内的某一村庄？最愚蠢的办法就是遍历所有村庄，一一比对。而更为高效地做法便是：首先根据村庄位置信息锁定搜索范围到省、市、县、镇，最后在镇中遍历所有村庄，一一比对。</p>
<p>从上述两个例子中可以看出：无论高维空间查询还是低维空间查询，其本质都是建立数据索引，随后在查找过程中逐步缩减待查找范围 (<strong>所有加快查询速度的数据结构都是这样做的，只不过缩减时所依据的信息不同而已</strong>)。</p>
<p>接下来，简单看看 R 树是如何缩减待查找范围的，这里以二维空间例子说明 (图中仅 R3 区域数据详细标识，其余区域数据直接省略)：</p>
<p><img src="/2020/08/25/dataStructure/dataStructure-rtree/1051369-20170404131434878-399064987.jpg" alt="图二：R树示例"></p>
<p>关于此图，我们可以这样看：所有点散布于平面之上，根据某些规则首先将点划分为块 R8、R9 … R19；在此基础之上，我们划分块为 R3、R4 … R7；更进一步划分块为 R1、R2；最终划分为一个整块。对于点而言，其中保存关键字 (标识为 ${x,y}$) 及其数据信息；对于块而言，其中保存子块索引及当前块所含点的 MBR 位置信息。当进行查询时，根据待查询关键字及块信息，可逐步缩减查询范围至块 R8、R9 … R19 中之一，然后将其中点信息与待查询关键字一一比对，从而判断查询是否成功。</p>
<blockquote>
<p>MBR (Minimum Bounding Retangle)：假定存在若干点，最小限定矩形就是可以包含这些点的最小矩形，它可通过获取所有点的最大最小坐标值得到，假定获取的坐标值依次为 $minX,minY,maxX,maxY$，此时最小限定矩形可表示为 ${(minX,minY),(maxX,maxY)}$。</p>
<p><img src="/2020/08/25/dataStructure/dataStructure-rtree/1051369-20170404131435300-1195117158.jpg" alt="图三：MBR示意图"></p>
</blockquote>
<p>维基百科中并未给出 R 树具体定义。根据所查资料，基本上可以这样说：R 树定义与 B+ 树定义基本一样，二者不同点则在于节点实现。</p>
<blockquote>
<p>下面实现中，我们直接以二维空间中的 R 树为例，以说明各项操作 (不作实现)。当然，二维空间扩展为多维空间是很简单的。</p>
</blockquote>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>在 B+ 树中，节点分为索引节点和叶节点。R 树中亦是如此，故而这里以伪代码形式给出两种节点结构的详细信息 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 索引节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">indexNode</span> <span class="keyword">extends</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 两者综合表征MBR。</span></span><br><span class="line">    <span class="keyword">private</span> Point bottomLeft, TopRight;</span><br><span class="line">    <span class="comment">// 子节点索引。</span></span><br><span class="line">    ArrayList&lt;Node&gt; childrens;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 叶节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">leafNode</span> <span class="keyword">extends</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 两者综合表征MBR。</span></span><br><span class="line">    <span class="keyword">private</span> Point bottomLeft, TopRight;</span><br><span class="line">    <span class="comment">// 两者共同构建键值对。</span></span><br><span class="line">    ArrayList&lt;Ponit&gt; keys;</span><br><span class="line">    ArrayList&lt;value&gt; values;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>查询操作与 B+ 树类似，这里简单描述：</p>
<ol>
<li>置当前子树根节点为 $root$。</li>
<li>如果 $root$ 为索引节点，则一一判断子节点的 MBR 是否与待搜索关键字重合，如果重合则递归处理子节点，并返回递归结果。</li>
<li>如果 $root$ 为叶节点，则一一判断各关键字是否与待搜索关键字相同，如果相同则返回该关键字及相应数据。</li>
</ol>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>插入操作比较复杂，首先简单描述其过程：</p>
<ol>
<li>将待插入关键字及其数据插入至合适的叶节点之中。</li>
<li>如果叶节点所含关键字个数 (或者索引节点所含关键字个数) 大于阈值，则分裂为两个叶节点。父节点中删除原始节点索引，并新建这两个叶节点的节点索引。</li>
<li>如果当前节点发生分裂，则递归处理父节点。</li>
</ol>
<p>关于插入操作，我们需要着重说明两个问题：1. 如何插入至合适叶节点？2. 如何分裂节点？</p>
<ol>
<li><p>如何插入至合适叶节点？</p>
<p>关于这个问题，R 树具体操作方法是十分巧妙的。简要描述如下：</p>
<ul>
<li>如果当前节点为叶节点，则直接插入即可。</li>
<li>如果当前节点为索引节点，则首先更新当前节点的 MBR，随后依次遍历所有子节点，找到添加待插入关键字后使得子节点的 MBR 扩张最小的节点 (如果存在多个，则选择 MBR 面积最小的那个节点)，然后递归处理子节点。</li>
</ul>
<p><img src="/2020/08/25/dataStructure/dataStructure-rtree/image-xxx.png" alt="图三：扩张示意图"></p>
</li>
<li><p>如何分裂节点？</p>
<p>通过执行分裂算法以分裂节点，现有多种分裂算法，最常用地便是二次方方案。</p>
<p>在二次方方案中，首先，它将两重循环遍历所有子节点，对于任意两个子节点 $N1$ 和 $N2$，计算可包裹这两个节点中所有关键字的 MBR，随后计算增量 $d = MBR - N1.MBR - N2.MBR$，接下来找到具有最大增量的两个子节点 (记为 $d1$ 和 $d2$)，并将它们分别放置到分裂后的两个节点之中。最后，对于其余节点而言，如果该节点距离 $d1$ 更近，则将其放置到 $d1$ 所在的分裂节点之中，否则放置到 $d2$ 所在的分裂节点之中。</p>
<p><img src="/2020/08/25/dataStructure/dataStructure-rtree/image-20200826121048565.png" alt="图四：分裂示意图"></p>
<blockquote>
<p>增量越大，表明两个节点的对角线距离越远。选择具有最大增量的两个节点，就是选择对角线距离最大的两个节点，如此操作可尽可能保证分裂后两个节点的 MBR 相交较少。</p>
</blockquote>
</li>
</ol>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>在 B+ 树中，删除指定关键字后，通过借调关键字或合并节点完成调整操作；而在 R 树中，删除指定关键字后，它通过重新插入至 R 树中完成调整操作。具体操作如下：</p>
<ol>
<li>找到待删除关键字所在的叶节点，并将该关键字及其数据从中删除。</li>
<li>如果删除后的叶节点所含关键字 (或者索引节点所含关键字个数) 小于阈值，则将这些关键字及其数据 (或者索引节点) 放置到链表 Q 中，并在父节点中删除对应的节点索引。</li>
<li>递归处理父节点。</li>
<li>经过以上调整之后，将 Q 中所有数据重新插入至 R 树之中。如果数据为关键字及其数据，则按照普通插入操作插入即可；如果数据为索引节点，需要将其插入至原先所在层级，如此做的原因在于保证所有叶节点仍然处于同一层级。</li>
</ol>
<p><img src="/2020/08/25/dataStructure/dataStructure-rtree/image-20200826123646166.png" alt="图五：删除图例"></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-字符串匹配(三)</title>
    <url>/2020/08/20/algorithm/algorithm-stringmatch3/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Sunday 算法是一种经典地字符串匹配算法。它通过简化 BM 算法操作而成，并且实践证明：Sunday 算法查询性能好于 BM 算法，故而该种算法在字符串匹配问题上应用最为广泛。 </p>
 <a id="more"></a>

<p>我们首先简单回顾一下 BM 算法：它采用从后往前方式比较字符，使用坏字符规则和好后缀规则实现跳跃无效匹配。值得注意的是：BM 算法实践之中，有人统计发现：绝大多数地跳跃操作均来自于坏字符规则。另外，由于好后缀表构造比较麻烦而坏字符表构造简单，所以就提出了一种 BM 算法阉割版——仅使用坏字符规则实现跳跃。</p>
<p>Sunday 算法就属于 BM算法阉割版地一种，但是它对坏字符规则进行了修改：在 BM 算法中，匹配失败的字符称为坏字符；而在 Sunday 算法中，匹配失败时参与匹配的最末位字符的下一位字符称为坏字符。举例而言：对于 BM 算法而言，图中 <code>text[1] = &#39;u&#39;</code> 属于坏字符；对于 Sunday 算法而言，图中 <code>text[6] = &#39;i&#39;</code> 属于坏字符。</p>
<p><img src="/2020/08/20/algorithm/algorithm-stringmatch3/image-20200820223650493.png" alt="图一：坏字符归属"></p>
<p>正是由于这样地修改，使得 Sunday 算法并不局限于从后往前比较字符，它同样可以采用从前往后比较字符。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>BM 已然实现，这种实现就比较简单。其实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] genBc(String pattern) &#123;</span><br><span class="line">    <span class="comment">// 假定所有字符均为ascii，如果存在其他字符，这里也可使用map加以实现。</span></span><br><span class="line">    <span class="keyword">int</span>[] bc = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">    <span class="comment">// 初始化为-1，表示未曾出现。</span></span><br><span class="line">    Arrays.fill(bc, -<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从前往后，根据字符信息覆盖数组该位置原始信息。</span></span><br><span class="line">    <span class="comment">// 正是如此操作，才可保证所存位置信息均为对应字符的最右侧位置。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pattern.length(); i++) &#123;</span><br><span class="line">        bc[pattern.charAt(i)] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> bc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">match</span><span class="params">(String text, String pattern)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">int</span>[] bc = genBc(pattern);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= text.length() - pattern.length(); ) &#123;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="comment">// 尝试匹配pattern与text[i,i+pattern.length()]</span></span><br><span class="line">        <span class="keyword">for</span> (j = pattern.length() - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; text.charAt(i + j) == pattern.charAt(j); j--);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// j=-1表明完全匹配成功，退出即可。</span></span><br><span class="line">        <span class="keyword">if</span> (j == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 匹配失败，如果坏字符不存在，则直接返回-1。</span></span><br><span class="line">        <span class="keyword">if</span> (i + pattern.length() &gt;= text.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 获取坏字符，并根据坏字符规则确定移动步数。</span></span><br><span class="line">            i += (pattern.length() - bc[text.charAt(i + pattern.length())]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="时空复杂度"><a href="#时空复杂度" class="headerlink" title="时空复杂度"></a>时空复杂度</h3><p>理论证明：最坏时间复杂度为 $O(text.length * pattern.length)$，平均时间复杂度为 $O(text.length)$，空间复杂度为 $O(pattern.length)$。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>字符串匹配</category>
      </categories>
      <tags>
        <tag>Sunday</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-字符串匹配(二)</title>
    <url>/2020/08/20/algorithm/algorithm-stringmatch2/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>BM 算法是一种经典地字符串匹配算法，而且实践证明：该算法比 KMP 算法匹配性能快 $3$ ~ $5$ 倍，故而文本编辑器的 “查询” 功能通常基于此算法实现。</p>
 <a id="more"></a>

<p>在 KMP 算法中，文本串 <code>text</code> 与模式串 <code>pattern</code> 中字符采用从前往后方式进行比较。而在 BM 算法中，文本串 <code>text</code> 与模式串 <code>pattern</code> 中字符采用从后往前方式进行比较，其原因在于：1. 当采用从前往后方式比较时，如果第一个字符匹配失败，则 <code>text</code> 仅能前进一步 (即 <code>i = i + 1</code>)；当采用从后往前方式比较时，如果最后一个字符匹配失败，则 <code>text</code> 可前进 <code>pattern.length()</code> 步 (即 <code>i = i + pattern.length()</code> ) 。故而采用从后往前方式比较可取得更大的前进步数。2. 采用从后往前方式比较，存在多种事实规则以跳过无效匹配。</p>
<p>接下来，我们将首先给出从后往前比较字符以实施匹配字符串的算法，随后在此基础之上介绍 BM 算法。</p>
<h2 id="基础算法"><a href="#基础算法" class="headerlink" title="基础算法"></a>基础算法</h2><p>从后往前比较字符以实现字符串匹配算法，其实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">match</span><span class="params">(String text, String pattern)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; text.length() - pattern.length(); ) &#123;</span><br><span class="line">            <span class="comment">// 尝试匹配pattern与text[i,i+pattern.length()]</span></span><br><span class="line">            <span class="keyword">for</span> (j = pattern.length() - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; text.charAt(i + j) == pattern.charAt(j); j--);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// j=-1表明完全匹配成功，退出即可。</span></span><br><span class="line">            <span class="keyword">if</span> (j == -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 移动一步。</span></span><br><span class="line">            i += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="BM-算法"><a href="#BM-算法" class="headerlink" title="BM 算法"></a>BM 算法</h2><p>BM 算法对基础算法的修改点就在于：基于某些事实规则尽可能多地移动步数 ( 即<code>i += ?</code> )。</p>
<p>BM 算法中，存在两种事实规则 —— 坏字符规则和好后缀规则 (详细内容可参见 <a href="https://www.ruanyifeng.com/blog/2013/05/boyer-moore_string_search_algorithm.html">字符串匹配的Boyer-Moore算法</a>)。</p>
<p>当 <code>text</code> 与 <code>pattern</code> 中字符匹配失败时，根据两种规则计算移动步数，随后根据二者大者进行移动，然后继续进行匹配。</p>
<h3 id="坏字符表"><a href="#坏字符表" class="headerlink" title="坏字符表"></a>坏字符表</h3><p>坏字符表用于实现坏字符规则，它是一个数组 <code>bc[]</code>，其中 <code>bc[i]</code> 具有如下含义：<code>bc[i]</code> 所示字符在 <code>pattern</code> 中最右侧出现位置。</p>
<p>坏字符表实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] genBc(String pattern) &#123;</span><br><span class="line">    <span class="comment">// 假定所有字符均为ascii，如果存在其他字符，这里也可使用map加以实现。</span></span><br><span class="line">    <span class="keyword">int</span>[] bc = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">    <span class="comment">// 初始化为-1，表示未曾出现。</span></span><br><span class="line">    Arrays.fill(bc, -<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从前往后，根据字符信息覆盖数组该位置原始信息。</span></span><br><span class="line">    <span class="comment">// 正是如此操作，才可保证所存位置信息均为对应字符的最右侧位置。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pattern.length(); i++) &#123;</span><br><span class="line">        bc[pattern.charAt(i)] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> bc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="好后缀表"><a href="#好后缀表" class="headerlink" title="好后缀表"></a>好后缀表</h3><p>好后缀表用于实现好后缀规则，它由两个数组组成，一个是 <code>suffix[]</code>，其中 <code>suffix[k]</code> 具有如下含义：长度为 $k$ 的后缀在 <code>pattern</code> 中出现时其首字母位置下标，一个是 <code>prefix[]</code>，其中 <code>prefix[k]</code> 具有如下含义：长度为 $k$ 的后缀是否存在一个相同的前缀。</p>
<p>此时重点就在于：如何根据 <code>pattern</code> 求取 <code>suffix[]</code> 和 <code>prefix[]</code>。求取方式十分巧妙：遍历 <code>pattern</code> 的所有真前缀，随后求取真前缀与 <code>pattern</code> 的公共后缀。在求取公共后缀过程中，我们可以动态得到这两个数组。具体参见如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">genGs</span><span class="params">(String pattern, <span class="keyword">int</span>[] suffix, <span class="keyword">boolean</span>[] prefix)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化。</span></span><br><span class="line">    Arrays.fill(suffix, -<span class="number">1</span>);</span><br><span class="line">    Arrays.fill(prefix, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有真前缀与pattern匹配</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pattern.length() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = i;</span><br><span class="line">        <span class="comment">// k表示已匹配字符串长度</span></span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 真前缀与pattern从后往前匹配各个字符。</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; pattern.charAt(j) == pattern.charAt(pattern.length() - <span class="number">1</span> - j)) &#123;</span><br><span class="line">            <span class="comment">// 匹配成功则k++</span></span><br><span class="line">            k++;</span><br><span class="line">            <span class="comment">// 根据suffix定义可设置该值。</span></span><br><span class="line">            suffix[k] = j;</span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// j=-1表明真前缀与某个后缀相同，则可设置prefix为true。</span></span><br><span class="line">        <span class="keyword">if</span> (j == -<span class="number">1</span>) &#123;</span><br><span class="line">            prefix[k] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="匹配过程"><a href="#匹配过程" class="headerlink" title="匹配过程"></a>匹配过程</h3><p>BM 匹配过程十分简单，就是根据匹配失败位置及两种规则计算移动步数，随后选择大者进行移动即可。具体实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">moveByGs</span><span class="params">(<span class="keyword">int</span>[] suffix, <span class="keyword">boolean</span>[] prefix, <span class="keyword">int</span> j, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 确定好后缀长度</span></span><br><span class="line">    <span class="keyword">int</span> k = length - <span class="number">1</span> - j;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果出现相同后缀，则根据其首字母位置计算步数。</span></span><br><span class="line">    <span class="keyword">if</span> (suffix[k] != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> j + <span class="number">1</span> - suffix[k];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果存在与好后缀相同的前缀，则根据前缀计算步数。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> r = k - <span class="number">1</span>; r &gt;= <span class="number">1</span>; r--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prefix[r]) &#123;</span><br><span class="line">            <span class="keyword">return</span> length - r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 否则，直接设移动步数为length。</span></span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BM</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">match</span><span class="params">(String text, String pattern)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">int</span>[] bc = genBc(pattern);</span><br><span class="line">    <span class="keyword">int</span>[] suffix = <span class="keyword">new</span> <span class="keyword">int</span>[pattern.length() + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">boolean</span>[] prefix = <span class="keyword">new</span> <span class="keyword">boolean</span>[pattern.length() + <span class="number">1</span>];</span><br><span class="line">    genGs(pattern, suffix, prefix);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt;= text.length() - pattern.length(); ) &#123;</span><br><span class="line">        <span class="comment">// 尝试匹配pattern与text[i,i+pattern.length()]</span></span><br><span class="line">        <span class="keyword">for</span> (j = pattern.length() - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; text.charAt(i + j) == pattern.charAt(j); j--);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// j=-1表明完全匹配成功，退出即可。</span></span><br><span class="line">        <span class="keyword">if</span> (j == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 基于坏字符规则确定需要移动的步数</span></span><br><span class="line">        <span class="keyword">int</span> x = j - bc[text.charAt(i + j)];</span><br><span class="line">        <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 如果存在好后缀，则基于好后缀规则确定需要移动的步数。</span></span><br><span class="line">        <span class="keyword">if</span> (j &lt; pattern.length() - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 基于好后缀计算移动步数比较复杂，故而需要封装为函数。</span></span><br><span class="line">            y = moveByGs(suffix, prefix, j, pattern.length());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取最大移动步数。</span></span><br><span class="line">        i += Math.max(x, y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="时空复杂度"><a href="#时空复杂度" class="headerlink" title="时空复杂度"></a>时空复杂度</h3><p>理论证明：最坏时间复杂度为 $O(text.length + pattern.length)$，最好时间复杂度为 $O(text.length)$，空间复杂度为 $O(pattern.length)$。</p>
<h3 id="与-KMP-比较"><a href="#与-KMP-比较" class="headerlink" title="与 KMP 比较"></a>与 KMP 比较</h3><p>简单说明 KMP 与 BM 匹配算法的异同点：</p>
<ol>
<li>两种算法均基于某些事实规则以跳跃无效匹配。</li>
<li>在 KMP 算法中，基于相同前后缀实施跳跃；在 BM 中，基于坏字符规则和好后缀规则实施跳跃，并且好后缀规则中包含了相同前后缀。</li>
<li>在 KMP 算法中，从前往后匹配 <code>text</code> 与 <code>pattern</code> 中字符；在 BM 算法中，从后往前匹配 <code>text</code> 与 <code>pattern</code> 中字符。</li>
<li>在 KMP 算法中，主要移动 <code>pattern</code> ；在 BM 算法中，主要移动 <code>text</code>。</li>
</ol>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>字符串匹配</category>
      </categories>
      <tags>
        <tag>BM</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-字符串匹配(一)</title>
    <url>/2020/08/20/algorithm/algorithm-stringmatch1/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>字符串匹配：判断模式串 <code>pattern</code> 是否出现于文本串 <code>text</code> 之中。常见匹配算法有：BF、KMP、BM、Sunday。</p>
 <a id="more"></a>

<p>字符串匹配算法构建十分精妙，往往难于理解，因此我们将通过三篇文章详细介绍字符串匹配算法。第一篇文章介绍 BF 和 KMP 算法，第二篇文章介绍 BM 算法，第三篇文章介绍 Sunday 算法。</p>
<h2 id="BF-算法"><a href="#BF-算法" class="headerlink" title="BF 算法"></a>BF 算法</h2><p>BF 全称为 Brute Force，即暴力匹配字符串——遍历 <code>text</code> 所有子串，将其与 <code>pattern</code> 进行匹配，其实现如下： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">match</span><span class="params">(String text, String pattern)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; text.length() - pattern.length(); i++)  &#123;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; pattern.length(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (text.charAt(i + j) != pattern.charAt(j)) &#123;</span><br><span class="line">                flag = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析上述代码，容易得知：BF 算法的时间复杂度为 $O(text.length * pattern.length)$，空间复杂度为 $O(1)$。</p>
<h2 id="KMP-算法"><a href="#KMP-算法" class="headerlink" title="KMP 算法"></a>KMP 算法</h2><p>BF 算法匹配过程十分粗暴，致使匹配效率过低。那么不由得思考：是否能够借助某些技巧加快匹配过程？换言之，是否能够借助某些事实以尽可能多地跳过无效匹配？</p>
<p>我们首先看一个字符串匹配示例：</p>
<p><img src="/2020/08/20/algorithm/algorithm-stringmatch1/bg2013050107.png" alt="图一：字符串匹配示例"></p>
<p>此时 <code>text[10] != pattern[6]</code>，故而需要重新匹配。如果按照 BF 算法的尿性，它会置 $i = 5, j = 0$ 并重新匹配 <code>pattern</code>。</p>
<p>我们简单观察字符串 <code>pattern</code> ，可以发现未匹配字符 <code>D</code> 之前的子串 <code>ABCDAB</code> 具有一个性质：前缀 <code>AB</code> 与后缀 <code>AB</code> 相同。另外，观察 <code>text</code>，可以发现 <code>text[10]</code> 之前的子串就是 <code>ABCDAB</code> (原因十分简单：这部分属于匹配成功部分)。</p>
<p><strong>综合这二者观察，我们可以这样执行重新匹配操作：$i$ 标识下标保持不变，置 $j = 2$ (之所以能够置为 2，原因在于：<code>text</code> 未匹配字符之前的内容是 <code>AB</code> (对应 <code>pattern</code> 后缀)，<code>pattern</code> 开始的内容也是 <code>AB</code> (对应 <code>pattern</code> 前缀)，二者相同故无需再次匹配)。</strong>  这基本就是 KMP 的思想 —— 借助于相同的前后缀以跳过无效匹配。</p>
<p>在 KMP 中，跳转操作是基于 <code>next[]</code> 实现的，其中 <code>next[j]</code> 具有如下含义：如果 <code>pattern[j]</code> 与 <code>text[i]</code> 匹配失败，则 <code>j</code> 需赋值为 <code>next[j]</code>，随后与 <code>text[i]</code> 再次匹配。如果 <code>next[j] = -1</code>，此时需要置 <code>i = i + 1, j = 0</code>，并重新开始匹配。</p>
<h3 id="匹配过程"><a href="#匹配过程" class="headerlink" title="匹配过程"></a>匹配过程</h3><p>我们将基于例子说明 KMP 匹配过程，随后给出 KMP 匹配代码 (这里先不指明 <code>next</code> 如何求取)。</p>
<p>初始状态：</p>
<p><img src="/2020/08/20/algorithm/algorithm-stringmatch1/image-20200820175009712.png"></p>
<p><code>text[0] != pattern[0]</code>，则 <code>j = next[j] = -1</code>，因为 <code>next[j] = -1</code>，故而需要执行 <code>i = i + 1, j = 0</code> ：</p>
<p><img src="/2020/08/20/algorithm/algorithm-stringmatch1/image-20200820175256179.png"></p>
<p><code>text[1,2,3] = pattern[0,1,2]</code>，则继续比较下一位：</p>
<p><img src="/2020/08/20/algorithm/algorithm-stringmatch1/image-20200820175437260.png"></p>
<p><code>text[4] != pattern[3]</code>，则 <code>j = next[j] = 1</code> ：</p>
<p><img src="/2020/08/20/algorithm/algorithm-stringmatch1/image-20200820175618987.png"></p>
<p><code>text[4] != pattern[1] </code>，则 <code>j = next[j] = 0</code> ：</p>
<p><img src="/2020/08/20/algorithm/algorithm-stringmatch1/image-20200820175949982.png"></p>
<p><code>text[4] != pattern[0]</code>，则 <code>j = next[j] = -1</code>，因为 <code>next[j] = -1</code>，故而需要执行 <code>i = i + 1, j = 0</code> ：</p>
<p><img src="/2020/08/20/algorithm/algorithm-stringmatch1/image-20200820180049495.png"></p>
<p><code>text[5,6,7,8] = pattern[0,1,2,3]</code> ，匹配成功。</p>
<p>根据上述过程，可以知道：在 KMP 匹配过程中，<code>i</code> 总是向前行进地，<code>j</code> 则随 <code>next[]</code> 进行调整。</p>
<p>KMP 匹配实现代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">match</span><span class="params">(String text, String pattern)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取next[]。</span></span><br><span class="line">    <span class="keyword">int</span>[] next = getNext(pattern);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; text.length(); ) &#123;</span><br><span class="line">        <span class="comment">// j=-1或者字符匹配成功，i,j均加一。</span></span><br><span class="line">        <span class="keyword">if</span> (j == -<span class="number">1</span> || text.charAt(i) == pattern.charAt(j)) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 字符匹配失败，j根据next[]进行调整。</span></span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 表明pattern中所有字符均已匹配，则返回匹配字符子串的开始位置。</span></span><br><span class="line">        <span class="keyword">if</span> (j == pattern.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> i - j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 匹配失败，返回-1。</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="next-求取"><a href="#next-求取" class="headerlink" title="next 求取"></a>next 求取</h3><p><code>next[]</code> 求取过程比较复杂，我们直接给代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] getNext(String pattern) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[pattern.length()];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化。</span></span><br><span class="line">    next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = -<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (i &lt; next.length - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == -<span class="number">1</span> || pattern.charAt(i) == pattern.charAt(j)) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            next[i] = j;</span><br><span class="line">            <span class="comment">// 这几行注释代码是对 next[i]=j 的进一步优化。</span></span><br><span class="line">            <span class="comment">// next[j]表示匹配失败时需要重新匹配的下标位置。如果i,j所在字符相同，则当i所示字符与text中指定字符匹配失败时，重新匹配下标位置j也一定会匹配失败，故而这里直接赋值next[j]。</span></span><br><span class="line">            <span class="comment">// if (pattern.charAt(i) == pattern.charAt(j)) &#123;</span></span><br><span class="line">            <span class="comment">//     next[i] = next[j];</span></span><br><span class="line">            <span class="comment">// &#125; else &#123;</span></span><br><span class="line">            <span class="comment">//     next[i] = j;</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果 <code>next</code> 求取实现代码看不懂，可以先看一下 <a href="https://oi-wiki.org/string/kmp/">优化求解前缀函数</a>。</p>
</blockquote>
<h3 id="时空复杂度"><a href="#时空复杂度" class="headerlink" title="时空复杂度"></a>时空复杂度</h3><p>理论证明：时间复杂度为 $O(text.length + pattern.length)$，空间复杂度为 $O(pattern.length)$。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>字符串匹配</category>
      </categories>
      <tags>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-排序</title>
    <url>/2020/08/17/algorithm/algorithm-sort/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>排序算法</strong> 用于将无序数组转换为有序数组。常见排序算法有：冒泡排序、选择排序、插入排序、希尔排序、归并排序、快速排序、堆排序、计数排序、桶排序、基数排序。</p>
<a id="more"></a>

<p>我们将实现上述常见排序算法，并给出相应算法的时间复杂度、空间复杂度及稳定性。</p>
<blockquote>
<ul>
<li><p>假定待排序数组中存在关键字相同的元素，我们使用排序算法排序该数组。如果排序前后，具有相同关键字的元素在数组中相对顺序保持不变，则该排序算法是稳定的。举例：以数组元素的第一个值为关键字排序数组 $a = [[1,11],[2,22],[1,9]]$，如果排序算法稳定，则排序结果中元素 $[1,11]$ 总是在元素 $[1,9]$ 之前。</p>
</li>
<li><p>假定我们需要基于多关键字 $[a,b,c]$ 排序待排序数组，通常做法就是重新编写比较函数。如果一个排序算法是稳定的，我们还可以这样做：首先基于关键字 $a$ 排序待排序数组，随后基于关键字 $b$ 排序待排序数组，最后基于关键字 $c$ 排序待排序数组。</p>
</li>
<li><p>冒泡排序、选择排序、插入排序、希尔排序、归并排序、快速排序、堆排序均基于比较元素实现排序，计数排序、桶排序、基数排序则不是如此。</p>
</li>
</ul>
</blockquote>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>实现各排序算法之前，首先做如下声明：</p>
<ol>
<li>为简化实现流程，假定数组元素中仅有关键字一项内容。</li>
<li>所有排序算法按照从小到大进行排序。</li>
</ol>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>冒泡排序的思想在于：遍历未排序部分数组，如果当前元素关键字大于下一个元素关键字，则交换二者，如此操作会将未排序部分数组中含最大关键字的元素逐步交换 (冒泡) 至排序部分数组首部/未排序部分数组尾部。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(Integer[] objects)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 每次循环可冒泡一个元素。为实现排序，只需冒泡objects.length-1次即可。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; objects.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 遍历未排序部分数组。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; objects.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="comment">// 相邻元素关键字大小关系不符递增要求，则交换二者。</span></span><br><span class="line">            <span class="keyword">if</span> (objects[j] &gt; objects[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                Integer tmp = objects[j];</span><br><span class="line">                objects[j] = objects[j + <span class="number">1</span>];</span><br><span class="line">                objects[j + <span class="number">1</span>] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>时间复杂度</p>
<p>排序算法使用双重循环，而且每次循环所需 $O(N)$ 时间，故而该算法的时间复杂度为 $O(N^2)$。</p>
</li>
<li><p>空间复杂度</p>
<p>排序算法需要一个额外空间以实现元素交换，故而该算法的空间复杂度为 $O(1)$。</p>
</li>
<li><p>稳定性</p>
<p>代码实现中，只有当前元素关键字大于下一个元素关键字，元素交换才会发生。如果当前元素关键字等于下一个元素关键字，交换不会发生，从而保证具有相同关键字元素之间的相对顺序保持不变，故而该算法是稳定的。</p>
</li>
</ul>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>选择排序的思想在于：遍历未排序部分数组，将其中含最小关键字的元素置于排序部分数组尾部。</p>
<p>选择排序与冒泡排序的区别有两点：</p>
<ol>
<li>选择排序的排序部分数组位于未排序部分数组的前方，冒泡排序则正好相反。</li>
<li>选择排序将含最小关键字的元素置于排序部分数组尾部，冒泡排序则是将含最大关键字的元素置于排序部分数组首部。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(Integer[] objects)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 每次循环排序一个元素。为实现排序，只需循环objects.length-1次即可。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; objects.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 记录当前位置下标。</span></span><br><span class="line">        <span class="keyword">int</span> k = i;</span><br><span class="line">        <span class="comment">// 遍历未排序部分数组，获取具有最小关键字的元素下标。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; objects.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (objects[j] &lt; objects[k]) &#123;</span><br><span class="line">                k = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果当前位置与具有最小关键字的元素位置不同，则需交换二者(以此实现插入含最小关键字的元素至排序部分数组尾部)。</span></span><br><span class="line">        <span class="keyword">if</span> (k != i) &#123;</span><br><span class="line">            Integer tmp = objects[i];</span><br><span class="line">            objects[i] = objects[k];</span><br><span class="line">            objects[k] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>时间复杂度</p>
<p>排序算法使用双重循环，而且每次循环所需 $O(N)$ 时间，故而该算法的时间复杂度为 $O(N^2)$。</p>
</li>
<li><p>空间复杂度</p>
<p>排序算法需要两个额外空间，一个用于记录当前位置下标，一个用于实现元素交换，故而该算法的空间复杂度为 $O(1)$。</p>
</li>
<li><p>稳定性</p>
<p>代码实现中，从前往后遍历未排序部分数组以获取具有最小关键字的元素下标，并且只有当前元素的关键字小于当前最小关键字时才更新具有最小关键字的元素下标，如此两项操作足以保证具有相同关键字元素之间的相对顺序保持不变，故而该算法是稳定的。</p>
</li>
</ul>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>插入排序的思想在于：将未知元素依次插入至排序部分数组之中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(Integer[] objects)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将未知元素插入至排序部分数组之中，故而从下标1处开始即可。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; objects.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 获取未知元素。</span></span><br><span class="line">        Integer item = objects[i];</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 寻找插入位置，并插入。</span></span><br><span class="line">        <span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (objects[j] &gt; item) &#123;</span><br><span class="line">                objects[j + <span class="number">1</span>] = objects[j];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        objects[j + <span class="number">1</span>] = item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>时间复杂度</p>
<p>排序算法使用双重循环，而且每次循环所需 $O(N)$ 时间，故而该算法的时间复杂度为 $O(N^2)$。</p>
</li>
<li><p>空间复杂度</p>
<p>排序算法需要两个额外空间，一个用于记录未知元素，一个用于记录插入位置，故而该算法的空间复杂度为 $O(1)$。</p>
</li>
<li><p>稳定性</p>
<p>寻找插入位置的代码实现中，只有当前元素的关键字大于未知元素的关键字，才将当前元素后移一位。另外，所有元素采用从前往后顺序依次插入。如此两项操作足以保证具有相同关键字元素之间的相对顺序保持不变，故而该算法是稳定的。</p>
</li>
</ul>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>希尔排序是插入排序的一种改进版本。在插入排序中，为将未知元素插入至排序部分数组，我们需要按位后移元素。如果未知元素位于排序部分数组前部，则其所需后移元素过多。在希尔排序中，它基于步长将数组划分为若干子数组，对子数组实行插入排序，此时基于步长可将元素快速放至合适位置，最后通过逐步减少步长到1实现整个数组的排序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 开始位置为begin，步长为k所构建的子数组进行排序(过程类似插入排序)。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">shell</span><span class="params">(Integer[] objects, <span class="keyword">int</span> begin, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = begin; i &lt; objects.length; i = i + k) &#123;</span><br><span class="line">        Integer item = objects[i];</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">for</span> (j = i - k; j &gt;= <span class="number">0</span>; j = j - k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (objects[j] &gt; item) &#123;</span><br><span class="line">                objects[j + k] = objects[j];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        objects[j + k] = item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(Integer[] objects)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义步长数组，最后一个元素一定为1。</span></span><br><span class="line">    <span class="keyword">int</span>[] steps = &#123;<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="comment">// 逐步缩小步长。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; steps.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 按照步长对所有子数组进行插入排序。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; steps[i]; j++) &#123;</span><br><span class="line">            shell(objects, j, steps[i]);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>时间复杂度</p>
<p>其复杂度分析比较困难，而且不同步长具有不同的时间复杂度。这里给出一个大致的时间复杂度：$O(N^{3/2})$。</p>
</li>
<li><p>空间复杂度</p>
<p>基本与插入排序相同，故而该算法的空间复杂度为 $O(1)$。</p>
</li>
<li><p>稳定性</p>
<p>子数组排序过程可保证具有相同关键字元素之间的相对顺序保持不变。如果具有相同关键字的元素位于不同子数组之中，元素之间的相对顺序则难以保证，故而该算法是不稳定的。</p>
</li>
</ul>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>归并排序的思想在于：基于分治思想将未排序数组划分为若干子数组，排序子数组后依次合并各个子数组，从而得到整个数组的排序结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 递归合并objects[l,r]中元素。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(Integer[] objects, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 仅有一个元素，无需合并，直接返回即可。</span></span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取中间位置，递归合并左右部分子数组。</span></span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    merge(objects, l, mid);</span><br><span class="line">    merge(objects, mid + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 借助临时数组合并两个子数组。</span></span><br><span class="line">    Integer[] tmp = <span class="keyword">new</span> Integer[objects.length];</span><br><span class="line">    <span class="keyword">int</span> index1 = l, index2 = mid + <span class="number">1</span>, index3 = l;</span><br><span class="line">    <span class="keyword">for</span> (; index1 &lt;= mid &amp;&amp; index2 &lt;= r;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (objects[index1] &lt;= objects[index2]) &#123;</span><br><span class="line">            tmp[index3++] = objects[index1++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tmp[index3++] = objects[index2++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (index1 &lt;= mid) &#123;</span><br><span class="line">        tmp[index3++] = objects[index1++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (index2 &lt;= r) &#123;</span><br><span class="line">        tmp[index3++] = objects[index2++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制临时数组中内容至objects。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">        objects[i] = tmp[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(Integer[] objects)</span> </span>&#123;</span><br><span class="line">    merge(objects, <span class="number">0</span>, objects.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>时间复杂度</p>
<p>记归并排序的时间复杂度为 $T(N)$，其中 $N$ 为待排序数组长度。</p>
<p>根据递归过程，我们可得到：$T(N) = 2 \times T(N/2) + N$。求解该式，最终将得到：$T(N) = Nlog^N$。故而该算法的时间复杂度为 $O(Nlog^N)$。</p>
</li>
<li><p>空间复杂度</p>
<p>排序算法需要一个额外数组空间用于合并子数组、若干额外空间用于记录下标位置。故而该算法的空间复杂度为 $O(N)$。</p>
</li>
<li><p>稳定性</p>
<p>代码实现中，子数组合并过程可以保证具有相同关键字元素之间的相对顺序保持不变，故而该算法是稳定的。</p>
</li>
</ul>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>快速排序的思想在于：每个过程将数组中一个元素放置到正确位置 (即其前方元素的关键字均小于该元素的关键字，其后方元素的关键字均大于该元素的关键字)，随后递归处理左半部分和右半部分即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 递归排序objects[l,r]中元素。(这是一个快排模板)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quick</span><span class="params">(Integer[] objects, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 仅有一个元素，无需排序，直接返回即可。</span></span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>;</span><br><span class="line">    Integer x = objects[(l + r) &gt;&gt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调整元素顺序，使得x之前元素关键字均小于其关键字，x之后元素关键字均大于其关键字。</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">while</span> (objects[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125; <span class="keyword">while</span> (objects[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">            Integer tmp = objects[i];</span><br><span class="line">            objects[i] = objects[j];</span><br><span class="line">            objects[j] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归处理左右部分。</span></span><br><span class="line">    quick(objects, l, j);</span><br><span class="line">    quick(objects, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(Integer[] objects)</span> </span>&#123;</span><br><span class="line">    quick(objects, <span class="number">0</span>, objects.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>时间复杂度</p>
<p>记快速排序的时间复杂度为 $T(N)$，其中 $N$ 为待排序数组长度。</p>
<p>根据递归过程，我们可得到：$T(N) = 2 \times T(N/2) + N$。求解该式，最终将得到：$T(N) = Nlog^N$。故而该算法的时间复杂度为 $O(Nlog^N)$。</p>
</li>
<li><p>空间复杂度</p>
<p>排序算法需要若干额外空间用于记录下标位置，故而该算法的空间复杂度为 $O(1)$。</p>
</li>
<li><p>稳定性</p>
<p>调整元素顺序的代码实现中，交换元素将会使得位于后面的元素被放置到前方，这种操作无法保证具有相同关键字的元素之间相对顺序保持不变，故而该算法是不稳定的。</p>
</li>
</ul>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>堆排序借助于堆数据结构实现排序数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调整index位置元素至堆中合适位置(堆结构从数组下标0开始，故而左儿子为2*index+1，右儿子为2*index+2)。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">heap</span><span class="params">(Integer[] objects, <span class="keyword">int</span> index, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    Integer x = objects[index];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 寻找合适位置。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span> * index + <span class="number">1</span>; j &lt;= end; j = <span class="number">2</span> * j + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j &lt; end &amp;&amp; objects[j] &lt; objects[j + <span class="number">1</span>]) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (objects[j] &gt; x) &#123;</span><br><span class="line">            objects[index] = objects[j];</span><br><span class="line">            index = j;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 填入原本index位置的值。</span></span><br><span class="line">    objects[index] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 堆排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(Integer[] objects)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 建堆过程。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = objects.length / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        heap(objects, i, objects.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每次循环将堆顶元素与堆数组中最后一个元素交换，随后堆数组长度减一并调整堆顶元素。当堆数组长度为1时，该数组就是递增的。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = objects.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        Integer tmp = objects[<span class="number">0</span>];</span><br><span class="line">        objects[<span class="number">0</span>] = objects[i];</span><br><span class="line">        objects[i] = tmp;</span><br><span class="line"></span><br><span class="line">        heap(objects, <span class="number">0</span>, i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>时间复杂度</p>
<p>堆是一棵完全二叉树，其树高为 $O(log^N)$，故而 <code>heap()</code> 的时间复杂度为 $O(log^N)$。</p>
<p>建堆过程的时间复杂度为 $O(N)$，循环操作的时间复杂度为 $O(Nlog^N)$，故而该算法的时间复杂度为 $O(N + Nlog^N) = O(Nlog^N)$。</p>
</li>
<li><p>空间复杂度</p>
<p>排序算法需要若干额外空间用于记录下标位置，故而该算法的空间复杂度为 $O(1)$。</p>
</li>
<li><p>稳定性</p>
<p>与快速排序类似，由于元素交换存在跳跃性，排序算法无法保证具有相同关键字的元素之间相对顺序保持不变，故而该算法是不稳定的。</p>
</li>
</ul>
<h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><p>计数排序的思想在于：使用额外数组统计待排序数组中各元素出现次数，遍历额外数组将各元素按照出现次数输出，输出结果便是排序结果。</p>
<p>计数排序的代码实现与思想描述有些差别，原因在于：代码实现考虑了稳定性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countSort</span><span class="params">(Integer[] objects)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构建额外数组，它指代关键字数据范围。</span></span><br><span class="line">    Integer[] count = <span class="keyword">new</span> Integer[MAX];</span><br><span class="line">    Arrays.fill(count, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 构建临时数组，用于存放排序结构。</span></span><br><span class="line">    Integer[] sorted = <span class="keyword">new</span> Integer[objects.length];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计关键字出现次数。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; objects.length; i++) &#123;</span><br><span class="line">        count[objects[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建前缀值，此时count[i]表示i应当位于元素数组中的下标位置(此部分作用类似于基数排序)。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; count.length; i++) &#123;</span><br><span class="line">        count[i] += count[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据count[i]将原始数组中元素依次放入到临时数组之中(必须为逆序放入)。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = objects.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        sorted[--count[objects[i]]] = objects[i];</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 拷贝排序结果至原始数组。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; objects.length; i++) &#123;</span><br><span class="line">        objects[i] = sorted[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>时间复杂度</p>
<p>排序算法的时间复杂度依赖于额外数组 (即关键字数据范围)，我们假定其长度为 $M$。</p>
<p>排序算法实现中，多次需要遍历额外数组及原始数组。通常关键字数据范围远大于数组元素个数，故而该算法的时间复杂度为 $O(M + N) \approx O(M)$ 。</p>
</li>
<li><p>空间复杂度</p>
<p>排序算法的空间复杂度同样依赖于额外数组，故而该算法的空间复杂度为 $O(M)$。</p>
</li>
<li><p>稳定性</p>
<p>该算法是稳定的，其稳定性基于此实现——根据前缀值将原始数组中元素逆序放入临时数组。</p>
</li>
</ul>
<h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>基数排序的思想在于：它将元素关键字 (限定为数字) 拆分为若干数位，例如 789 可拆分为 7\8\9 三个数位。从低到高依次对数位执行计数排序可实现排序元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假定关键字为十进制数字，则数位取值范围为[0,9]。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">radixSort</span><span class="params">(Integer[] objects)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构建数位数组，它指代数位取值范围。</span></span><br><span class="line">    Integer[] buckets = <span class="keyword">new</span> Integer[<span class="number">10</span>];</span><br><span class="line">    <span class="comment">// 构建临时数组，存储排序结果。</span></span><br><span class="line">    Integer[] tmp = <span class="keyword">new</span> Integer[objects.length];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 十进制数字第0位基数为1,第1位基数为10,...，主要用于求解指定位置的数位。</span></span><br><span class="line">    Integer radix = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 按照从低到高排序数位，即首先根据个位排序，随后根据十位排序,...。</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 重置数位数组。</span></span><br><span class="line">        Arrays.fill(buckets, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 统计数位出现次数。</span></span><br><span class="line">        <span class="comment">// (objects[i] / radix) % 10表示获取当前待处理位置的数位。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; objects.length; i++) &#123;</span><br><span class="line">            buckets[(objects[i] / radix) % <span class="number">10</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果所有元素当前位置的数位均为0，表明已无需再做排序，退出即可。</span></span><br><span class="line">        <span class="keyword">if</span> (buckets[<span class="number">0</span>] == objects.length) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建前缀值。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; buckets.length; i++) &#123;</span><br><span class="line">            buckets[i] += buckets[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据数位信息将原始数组中元素逆序填入临时数组。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = objects.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            tmp[--buckets[(objects[i] / radix) % <span class="number">10</span>]] = objects[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拷贝排序结果至原始数组。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; objects.length; i++) &#123;</span><br><span class="line">            objects[i] = tmp[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新数位为下一位。</span></span><br><span class="line">        radix *= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>时间复杂度</p>
<p>排序算法实现中，需要多次循环数位数组和原始数组。通常数位数组远小于原始数组，故而该算法的时间复杂度为 $O(N)$。</p>
</li>
<li><p>空间复杂度</p>
<p>排序算法需要使用数位数组及临时数组。如上所述，数位数组通常远小于原始数组，故而该算法的空间复杂度为 $O(N)$。</p>
</li>
<li><p>稳定性</p>
<p>就本质而言，基数排序基于多次使用计数排序而实现的。由于计数排序是稳定的，该算法亦是稳定的。</p>
</li>
</ul>
<h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><p>桶排序十分简单，首先将数组元素映射到若干桶 (桶表示区间范围)，随后桶内排序元素，最后按序输出桶内元素即可。</p>
<p>如果将桶区间范围的大小限定为 1，此时桶排序就是计数排序。</p>
<p>桶排序比较简单，故而不再实现。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-二分搜索</title>
    <url>/2020/08/17/algorithm/algorithm-binarysearch/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>二分搜索</strong> 用于有序数组查询操作，它可将操作时间复杂度降为 $O(log^N)$。</p>
<a id="more"></a>

<p>二分搜索思想十分简单：首先确定待搜索区间，随后获取区间中间值并将其与待搜索值进行比对，如果区间中间值大于待搜索值，则待搜索区间应为左半部分，反之待搜索区间应为右半部分，最后递归处理待搜索区间即可。</p>
<p>二分搜索实现比较困难，原因在于：若干边界条件需要判断。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>如上所言，二分搜索实现较为困难。我们在此引入两个简洁地二分搜索模板，第一个模板用于寻找最后一个 $\leq item$ 的元素位置下标，第二个模板用于寻找第一个 $\geq item$ 的元素位置下标。</p>
<p>模板一：</p>
<p>该模板根据中间值将区间划分为 $[l,mid]$ 和 $[mid + 1, r]$。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(Integer[] objects, Integer item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = objects.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (objects[mid].compareTo(item) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            r = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>模板二：</p>
<p>该模板根据中间值将区间划分为 $[l,mid - 1]$ 和 $[mid, r]$。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(Integer[] objects, Integer item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = objects.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="comment">// 为防止死循环，需要如此取值。</span></span><br><span class="line">        <span class="keyword">int</span> mid = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">if</span> (objects[mid].compareTo(item) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            l = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>针对模板二中 <code>mid</code> 取值，做如下说明：</p>
<p>假定待搜索区间为 $[l,l+1]$ 且 $objects[l] \leq item$，此时如果采用 <code>mid = (l + r) &gt;&gt; 1</code> ，则 <code>mid = l</code>，由于 $objects[mid] \leq item$，则更新后的待搜索区间仍为 $[l,l+1]$，此时即造成死循环；如果采用 <code>mid = (l + r + 1) &gt;&gt; 1</code>，则不会造成这种情况。</p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>二分思想</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-B树</title>
    <url>/2020/08/09/dataStructure/dataStructure-btree/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>B 树</strong> 是一种自平衡的多叉查找树，它可在对数时间内完成查询、插入、删除操作，常用于大规模数据存取场景，例如：数据库、文件系统。</p>
<a id="more"></a>

<p>其结构图大致如下：</p>
<p><img src="/2020/08/09/dataStructure/dataStructure-btree/image-20200808220113024.png" alt="图一：B树"></p>
<p>当处理大规模数据时，由于内存无法存放所有数据，故而程序运行期间，往往是部分数据位于内存之中，部分数据位于磁盘之中。如果程序访问数据位于磁盘之中，操作系统则调用磁盘内容到内存之中，随后按照内存访问规则进行访问。由于磁盘访问速度远低于内存访问速度，故而此时程序运行时间主要依托于磁盘访问次数。</p>
<p>为降低程序运行时间，我们就要确保磁盘访问次数尽可能的少。为减少磁盘访问次数，我们就需要存储一定信息以实现跳跃搜索，自然而然可以想到二叉查找树。如果直接应用二叉查找树，那么磁盘访问次数基本等于树高。为进一步降低程序运行时间，我们可以使用多叉查找树以降低树高，从而减少磁盘访问次数。同时，为保证磁盘访问次数明确界限于树高，那么就需要对多叉查找树施加平衡条件。</p>
<p>上述所言基本是 B 树原理。接下来，我们将简要定义 B 树。</p>
<p>B 树是一棵满足如下性质的 $t$ 叉树 ($t$ 指代节点所含孩子节点个数，亦称为节点的阶)：</p>
<ol>
<li>所有叶节点到根节点的路径长度相同，即具有相同高度。</li>
<li>所有非叶节点和非根节点至少含有 $t$ 个孩子节点，根节点至少含有 $2$ 个孩子节点。</li>
<li>每个非叶节点至多含有 $2t$ 个孩子节点。</li>
<li>每个节点内部键值依次递增。</li>
<li>每个非叶节点所含孩子节点数总是比所含键值数多 $1$。</li>
</ol>
<blockquote>
<p>2-3 树、2-3-4 树均为 B 树特例，B+树、B*树均为 B 树扩展。</p>
</blockquote>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>B 树结构比较复杂，我们在代码中加以描述。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BTree</span>&lt;<span class="title">K</span> <span class="keyword">extends</span> <span class="title">Comparable</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 二元组，存放键值对。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span> <span class="keyword">extends</span> <span class="title">Comparable</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        K k;</span><br><span class="line">        V v;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Entry</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Entry</span><span class="params">(K k, V v)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.k = k;</span><br><span class="line">            <span class="keyword">this</span>.v = v;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> K <span class="title">getK</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> k;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setK</span><span class="params">(K k)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.k = k;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> V <span class="title">getV</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setV</span><span class="params">(V v)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.v = v;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 比较键值。</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(K k)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.k.compareTo(k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点结构</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span> <span class="keyword">extends</span> <span class="title">Comparable</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">// 关键字键值对(0号位置不使用，方便后续代码编写)</span></span><br><span class="line">        ArrayList&lt;Entry&lt;K, V&gt;&gt; entries;</span><br><span class="line">        <span class="comment">// 孩子节点</span></span><br><span class="line">        ArrayList&lt;Node&lt;K, V&gt;&gt; childrens;</span><br><span class="line">        <span class="comment">// 是否为叶节点</span></span><br><span class="line">        Boolean leaf;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 初始化，占位entries[0]、设非叶节点。</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.entries = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">this</span>.entries.add(<span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">this</span>.childrens = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">this</span>.leaf = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> ArrayList&lt;Entry&lt;K, V&gt;&gt; getEntries() &#123;</span><br><span class="line">            <span class="keyword">return</span> entries;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEntries</span><span class="params">(ArrayList&lt;Entry&lt;K, V&gt;&gt; entries)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.entries = entries;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> ArrayList&lt;Node&lt;K, V&gt;&gt; getChildrens() &#123;</span><br><span class="line">            <span class="keyword">return</span> childrens;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setChildrens</span><span class="params">(ArrayList&lt;Node&lt;K, V&gt;&gt; childrens)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.childrens = childrens;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Boolean <span class="title">getLeaf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> leaf;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeaf</span><span class="params">(Boolean leaf)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.leaf = leaf;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到&lt;=key的关键字位置(查找过程也可使用二分)。</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> SearchResult&lt;V&gt; <span class="title">search</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (index = <span class="number">1</span>; index &lt; <span class="keyword">this</span>.entries.size(); index++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.entries.get(index).compareTo(key) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            SearchResult&lt;V&gt; searchResult = <span class="keyword">new</span> SearchResult();</span><br><span class="line">            searchResult.setIndex(index - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (index == <span class="number">1</span> || <span class="keyword">this</span>.entries.get(index - <span class="number">1</span>).compareTo(key) != <span class="number">0</span>) &#123;</span><br><span class="line">                searchResult.setExist(<span class="keyword">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                searchResult.setExist(<span class="keyword">true</span>);</span><br><span class="line">                searchResult.setValue(<span class="keyword">this</span>.entries.get(index - <span class="number">1</span>).getV());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> searchResult;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 搜索结果</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SearchResult</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">// 对应关键字是否存在</span></span><br><span class="line">        <span class="keyword">boolean</span> exist;</span><br><span class="line">        <span class="comment">// 位置信息(如果关键字存在，则表示其在entries中位置下标，否则表示在childrens中待插入子树的位置下标)</span></span><br><span class="line">        <span class="keyword">int</span> index;</span><br><span class="line">        <span class="comment">// 关键字对应值</span></span><br><span class="line">        V value;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isExist</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> exist;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setExist</span><span class="params">(<span class="keyword">boolean</span> exist)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.exist = exist;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> index;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.index = index;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// B树根节点</span></span><br><span class="line">    <span class="keyword">private</span> Node&lt;K, V&gt; root;</span><br><span class="line">    <span class="comment">// B树阶(动态调整)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> order;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="辅助方法"><a href="#辅助方法" class="headerlink" title="辅助方法"></a>辅助方法</h3><ul>
<li><p>当前子树中查找指定键值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">searchTree</span><span class="params">(Node&lt;K, V&gt; root, K key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取查询结果</span></span><br><span class="line">    SearchResult&lt;V&gt; result = root.search(key);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果查询成功，直接返回值。</span></span><br><span class="line">    <span class="keyword">if</span> (result.exist) &#123;</span><br><span class="line">        <span class="keyword">return</span> result.getValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前节点为叶节点，无孩子节点可搜索，故而返回null。</span></span><br><span class="line">    <span class="keyword">if</span> (root.getLeaf()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前节点为非叶节点，在孩子节点中递归查找即可。</span></span><br><span class="line">    <span class="keyword">return</span> searchTree(root.getChildrens().get(result.getIndex()), key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>分裂指定节点的某个子节点</p>
<p>如果某个节点所含孩子节点数等于 $2t$，那么就需要分裂该节点。</p>
<p>分裂规则：节点含有 $2t$ 个孩子节点，那么对应含有 $2t - 1$ 个关键字。提升第 $t$ 个关键字到父节点，前 $t - 1$ 个关键字及 $t$ 个孩子节点组成一个节点，后 $t - 1$ 个关键字及 $t$ 个孩子节点组成一个节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">splitNode</span><span class="params">(Node&lt;K, V&gt; root, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取子节点</span></span><br><span class="line">    Node&lt;K, V&gt; child = root.getChildrens().get(index);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新建一个邻居子节点，该节点与子节点具有相同的节点属性(是否为叶节点)。</span></span><br><span class="line">    Node&lt;K, V&gt; siblingNode = <span class="keyword">new</span> Node&lt;&gt;();</span><br><span class="line">    siblingNode.setLeaf(child.getLeaf());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里通过拆分方式构成两个节点。</span></span><br><span class="line">    <span class="comment">// 转移[order + 1, order * 2 - 1]区间元素至siblingNode。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>.order; i++) &#123;</span><br><span class="line">        siblingNode.getEntries().add(child.getEntries().remove(<span class="keyword">this</span>.order + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取order位置关键字键值对，并将其从child中删去。</span></span><br><span class="line">    Entry&lt;K, V&gt; midEntry = child.getEntries().remove(<span class="keyword">this</span>.order);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果子节点并非叶节点，则需要转移[order, order * 2 - 1]区间元素至siblingNode。</span></span><br><span class="line">    <span class="keyword">if</span> (!child.getLeaf()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.order; i++) &#123;</span><br><span class="line">            siblingNode.getChildrens().add(child.getChildrens().remove(<span class="keyword">this</span>.order));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向指定节点中添加order位置关键字键值对</span></span><br><span class="line">    root.getEntries().add(index + <span class="number">1</span>, midEntry);</span><br><span class="line">    <span class="comment">// 向指定节点中添加siblingNode子节点</span></span><br><span class="line">    root.getChildrens().add(index + <span class="number">1</span>, siblingNode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>当前非满子树中添加键值对</p>
<p>为保证 B 树向下搜索过程中不会产生回溯过程，我们会对待插入节点进行预处理：如果待插入节点含有 $2t$ 个孩子节点，则需要拆分该节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insertNotFull</span><span class="params">(Node&lt;K, V&gt; root, K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取查询结果</span></span><br><span class="line">    SearchResult&lt;V&gt; result = root.search(key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表明当前节点内部存在该关键字，直接退出即可。</span></span><br><span class="line">    <span class="keyword">if</span> (result.isExist()) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前节点内部不存在该关键字，根据节点是否为叶节点，选择不同方式进行插入。</span></span><br><span class="line">    <span class="keyword">if</span> (root.getLeaf()) &#123;</span><br><span class="line">        <span class="comment">// 当前节点为叶节点，直接插入即可(注意result.index字段含义)。</span></span><br><span class="line">        root.getEntries().add(result.getIndex() + <span class="number">1</span>, <span class="keyword">new</span> Entry&lt;&gt;(key, value));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 对待插入节点进行预处理，然后递归插入。</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取待插入孩子节点。</span></span><br><span class="line">        Node&lt;K, V&gt; child = root.getChildrens().get(result.getIndex());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 孩子节点已满，需进行拆分。</span></span><br><span class="line">        <span class="comment">// 关键字个数为order * 2 - 1时表明已满，又因为代码实现中位置0处并未使用，故而条件判断为order * 2。</span></span><br><span class="line">        <span class="keyword">if</span> (child.getEntries().size() == <span class="keyword">this</span>.order * <span class="number">2</span>) &#123;</span><br><span class="line">            splitNode(root, result.getIndex());</span><br><span class="line">            <span class="comment">// 如果提升的关键字值小于待插入关键字值，则需要更新待插入孩子节点。</span></span><br><span class="line">            <span class="keyword">if</span> (root.getEntries().get(result.getIndex() + <span class="number">1</span>).compareTo(key) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                child = root.getChildrens().get(result.getIndex() + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归插入。</span></span><br><span class="line">        insertNotFull(child, key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>当前子树中删除指定键值</p>
<p>删除过程主要涉及如下情景：</p>
<p><strong>情景1：</strong>关键字 $key$ 位于节点 $x$ 之中，并且节点为叶节点，则直接从节点 $x$ 中删除 $key$ 表示的键值对即可。</p>
<p><strong>情景2：</strong>关键字 $key$ 位于节点 $x$ 之中，但是节点为非叶节点，则进行如下操作：</p>
<ul>
<li><p>如果节点 $x$ 中位于关键字 $key$ 之前的子节点 $y$ 中至少含有 $t$ 个关键字，则使用 $y$ 的最后一个关键字替换节点 $x$ 中的关键字 $key$，并递归调用子节点 $y$ 以删除它的最后一个关键字。</p>
</li>
<li><p>如果节点 $x$ 中位于关键字 $key$ 之后的子节点 $z$ 中至少含有 $t$ 个关键字，则使用 $z$ 的第一个关键字替换节点 $x$ 中的关键字 $key$ ，并递归调用子节点 $z$ 以删除它的第一个关键字。</p>
</li>
<li><p>子节点 $y$ 和 $z$ 均仅含有 $t - 1$ 个关键字，则融合 $z$ 中关键字及关键字 $key$ 至子节点 $y$，随后递归调用子节点 $y$ 以删除关键字 $key$ 。</p>
</li>
</ul>
<p><strong>情景3：</strong>关键字并不位于节点 $x$ 之中，此时需进入孩子节点以期删除关键字 $key$，故而需格外注意孩子节点状态，故而需进行如下操作：</p>
<ul>
<li><p>孩子节点至少含有 $t$ 个关键字，直接进入孩子节点，递归删除关键字 $key$。</p>
</li>
<li><p>孩子节点仅含有 $t - 1$ 个关键字，如果左兄弟孩子节点或右兄弟孩子节点至少含有 $t$ 个关键字，则借调一个关键字使得孩子节点含有 $t$ 个关键字，随后进入孩子节点，递归删除关键字 $key$。</p>
</li>
<li><p>孩子节点仅含有 $t - 1$ 个关键字，并且左兄弟孩子节点或右兄弟孩子节点也仅有 $t - 1$ 个关键字，则融合一个兄弟节点中关键字及节点 $x$ 中位于关键字 $x$ 之前的关键字至孩子节点，从而使得孩子节点含有 $2t - 1$ 个关键字，随后进入孩子节点，递归删除关键字 $key$。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteTree</span><span class="params">(Node&lt;K, V&gt; root, K key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取查询结果。</span></span><br><span class="line">    SearchResult&lt;V&gt; result = root.search(key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关键字存在于当前节点之中。</span></span><br><span class="line">    <span class="keyword">if</span> (result.isExist()) &#123;</span><br><span class="line">        <span class="comment">// 当前节点为叶节点，直接删除即可，对应情景1。</span></span><br><span class="line">        <span class="keyword">if</span> (root.getLeaf()) &#123;</span><br><span class="line">            root.getEntries().remove(result.getIndex());</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前节点为非叶节点，那么删除就需要考虑替换策略，对应情景2。</span></span><br><span class="line">        <span class="comment">// 获取key对应的左右孩子。</span></span><br><span class="line">        Node&lt;K, V&gt; leftChild = root.getChildrens().get(result.getIndex() - <span class="number">1</span>);</span><br><span class="line">        Node&lt;K, V&gt; rightChild = root.getChildrens().get(result.getIndex());</span><br><span class="line">        <span class="comment">// 左孩子含有关键字个数大于order-1，则可用其最后一个关键字替换key，并递归调用左孩子以删除该关键字，对应情景2.1。</span></span><br><span class="line">        <span class="keyword">if</span> (leftChild.getEntries().size() &gt; <span class="keyword">this</span>.order) &#123;</span><br><span class="line">            <span class="comment">// 获取左孩子的最后一个关键字。</span></span><br><span class="line">            Entry&lt;K, V&gt; next = leftChild.getEntries().get(leftChild.getEntries().size() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 替换key。</span></span><br><span class="line">            root.getEntries().remove(result.getIndex());</span><br><span class="line">            root.getEntries().add(result.getIndex(), next);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 递归删除。</span></span><br><span class="line">            deleteTree(leftChild, next.getK());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rightChild.getEntries().size() &gt; <span class="keyword">this</span>.order) &#123;</span><br><span class="line">            <span class="comment">// 右孩子含有关键字个数大于order-1，则可用其第一个关键字替换key，并递归调用左孩子以删除该关键字，对应情景2.2。</span></span><br><span class="line">            <span class="comment">// 获取右孩子的第一个关键字。</span></span><br><span class="line">            Entry&lt;K, V&gt; pre = rightChild.getEntries().get(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 替换key。</span></span><br><span class="line">            root.getEntries().remove(result.getIndex());</span><br><span class="line">            root.getEntries().add(result.getIndex(), pre);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 递归删除。</span></span><br><span class="line">            deleteTree(rightChild, pre.getK());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 此时左右孩子所含关键字个数均为order-1，则合并左右孩子关键字及当前关键字为一个节点，对应情景2.3。</span></span><br><span class="line">            <span class="comment">// 从当前节点中删除该关键字及其右孩子。</span></span><br><span class="line">            Entry&lt;K, V&gt; deleteKV = root.getEntries().remove(result.getIndex());</span><br><span class="line">            root.getChildrens().remove(result.getIndex());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 合并关键字。</span></span><br><span class="line">            leftChild.getEntries().add(deleteKV);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>.order; i++) &#123;</span><br><span class="line">                leftChild.getEntries().add(rightChild.getEntries().remove(<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如若右孩子为非叶节点，则需合并孩子节点。</span></span><br><span class="line">            <span class="keyword">if</span> (!rightChild.getLeaf()) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.order; i++) &#123;</span><br><span class="line">                    leftChild.getChildrens().add(rightChild.getChildrens().remove(<span class="number">0</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 合并可能导致树高降1，从而使得根节点发生变化。</span></span><br><span class="line">            <span class="keyword">if</span> (root == <span class="keyword">this</span>.root &amp;&amp; root.getEntries().size() == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.root = leftChild;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 递归删除。</span></span><br><span class="line">            deleteTree(leftChild, key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 当前节点不存在关键字，对应情景3。</span></span><br><span class="line">        <span class="comment">// 当前节点为叶节点，表明不存在该关键字，直接返回即可。</span></span><br><span class="line">        <span class="keyword">if</span> (root.getLeaf()) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取待搜索孩子节点</span></span><br><span class="line">        Node&lt;K, V&gt; childNode = root.getChildrens().get(result.getIndex());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 待搜索孩子节点所含关键字个数大于order-1，则直接递归删除即可，对应情景3.1。</span></span><br><span class="line">        <span class="keyword">if</span> (childNode.getEntries().size() &gt; <span class="keyword">this</span>.order) &#123;</span><br><span class="line">            deleteTree(childNode, key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 待搜索孩子节点所含关键字个数等于order-1，则需预处理使其所含关键字个数大于order-1。</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 尝试获取待搜索孩子节点的左右兄弟节点</span></span><br><span class="line">            Node&lt;K, V&gt; leftChild = <span class="keyword">null</span>;</span><br><span class="line">            Node&lt;K, V&gt; rightChild = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 是否存在一个兄弟节点所含关键字个数大于order-1</span></span><br><span class="line">            Boolean flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (result.getIndex() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                leftChild = root.getChildrens().get(result.getIndex() - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (leftChild.getEntries().size() &gt; <span class="keyword">this</span>.order) &#123;</span><br><span class="line">                    flag = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (result.getIndex() &lt; root.getChildrens().size() - <span class="number">1</span>) &#123;</span><br><span class="line">                rightChild = root.getChildrens().get(result.getIndex() + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (rightChild.getEntries().size() &gt; <span class="keyword">this</span>.order) &#123;</span><br><span class="line">                    flag = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// flag=true表明至少一个兄弟节点所含关键字个数大于order-1，则调用借调一个关键字给待搜索孩子节点，对应情景3.2，否则需要将待搜索孩子节点与一个兄弟节点进行合并，对应情景3.3。</span></span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                <span class="comment">// 左兄弟节点存在，且其所含关键字个数大于order-1，则将其一个关键字转移到待搜索孩子节点</span></span><br><span class="line">                <span class="keyword">if</span> (leftChild != <span class="keyword">null</span> &amp;&amp; leftChild.getEntries().size() &gt; <span class="keyword">this</span>.order) &#123;</span><br><span class="line">                    <span class="comment">// 将当前节点中小于指定关键字的第一个关键字下放至待搜索孩子节点的第一个关键字。</span></span><br><span class="line">                    childNode.getEntries().add(<span class="number">1</span>, root.getEntries().remove(result.getIndex()));</span><br><span class="line">                    <span class="comment">// 将左兄弟节点的最后一个关键字上升至当前节点</span></span><br><span class="line">                    root.getEntries().add(result.getIndex(), leftChild.getEntries().remove(leftChild.getEntries().size() - <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 左兄弟节点不为叶节点，则需要转移它的最后一个孩子节点到待搜索孩子节点</span></span><br><span class="line">                    <span class="keyword">if</span> (!leftChild.getLeaf()) &#123;</span><br><span class="line">                        childNode.getChildrens().add(<span class="number">0</span>, leftChild.getChildrens().remove(leftChild.getChildrens().size() - <span class="number">1</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 右兄弟节点存在，且其所含关键字个数大于order-1，则将其一个关键字转移到待搜索孩子节点。</span></span><br><span class="line">                    <span class="comment">// 将当前节点中大于指定关键字的第一个关键字下放至待搜索孩子节点的最后一个关键字。</span></span><br><span class="line">                    childNode.getEntries().add(root.getEntries().remove(result.getIndex() + <span class="number">1</span>));</span><br><span class="line">                    <span class="comment">// 将右兄弟节点的第一个关键字上升至当前节点。</span></span><br><span class="line">                    root.getEntries().add(result.getIndex() + <span class="number">1</span>, rightChild.getEntries().remove(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 右兄弟节点不为叶节点，则需要转移它的第一个孩子节点到待搜索孩子节点。</span></span><br><span class="line">                    <span class="keyword">if</span> (!rightChild.getLeaf()) &#123;</span><br><span class="line">                        childNode.getChildrens().add(rightChild.getChildrens().remove(<span class="number">0</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 递归删除。</span></span><br><span class="line">                deleteTree(childNode, key);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 左右兄弟节点都含有order-1个关键字，此时选择一个非空兄弟节点合并即可。</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> != leftChild) &#123;</span><br><span class="line">                    <span class="comment">// 左兄弟节点不为空</span></span><br><span class="line">                    <span class="comment">// 当前节点中删除小于指定关键字的第一个关键字及其右孩子，并将该关键字下放至待搜索孩子节点。</span></span><br><span class="line">                    childNode.getEntries().add(<span class="number">1</span>, root.getEntries().remove(result.getIndex()));</span><br><span class="line">                    root.getChildrens().remove(result.getIndex() - <span class="number">1</span>);</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 合并关键字。</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="keyword">this</span>.order - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                        childNode.getEntries().add(<span class="number">1</span>, leftChild.getEntries().remove(i));</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 待搜索孩子节点不为叶节点，则合并孩子节点。</span></span><br><span class="line">                    <span class="keyword">if</span> (!childNode.getLeaf()) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="keyword">this</span>.order - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                            childNode.getChildrens().add(<span class="number">0</span>, leftChild.getChildrens().remove(i));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">null</span> != rightChild)&#123;</span><br><span class="line">                    <span class="comment">// 右兄弟节点不为空</span></span><br><span class="line">                    <span class="comment">// 当前节点中删除大于指定关键字的第一个关键字及其右孩子，并将该关键字下放至待搜索孩子节点。</span></span><br><span class="line">                    childNode.getEntries().add(root.getEntries().remove(result.getIndex() + <span class="number">1</span>));</span><br><span class="line">                    root.getChildrens().remove(result.getIndex() + <span class="number">1</span>);</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 合并关键字。</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>.order; i++) &#123;</span><br><span class="line">                        childNode.getEntries().add(rightChild.getEntries().remove(<span class="number">1</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 待搜索孩子节点不为叶节点，则合并孩子节点。</span></span><br><span class="line">                    <span class="keyword">if</span> (!childNode.getLeaf()) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.order; i++) &#123;</span><br><span class="line">                            childNode.getChildrens().add(rightChild.getChildrens().remove(<span class="number">0</span>));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 合并可能导致树高降1，从而使根节点发生变化。</span></span><br><span class="line">                <span class="keyword">if</span> (root == <span class="keyword">this</span>.root &amp;&amp; root.getEntries().size() == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.root = childNode;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 递归删除。</span></span><br><span class="line">                deleteTree(childNode, key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p><strong>要点：</strong> 根节点需要初始化为叶节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BTree</span><span class="params">(<span class="keyword">int</span> order, Comparator&lt;? <span class="keyword">super</span> K&gt; comparator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.root = <span class="keyword">new</span> Node&lt;&gt;();</span><br><span class="line">    <span class="keyword">this</span>.root.setLeaf(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">this</span>.order = order;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><ul>
<li><p>查询指定关键字</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">search</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> searchTree(<span class="keyword">this</span>.root, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="操纵"><a href="#操纵" class="headerlink" title="操纵"></a>操纵</h3></li>
<li><p>B 树中添加键值对</p>
<p>根节点分裂涉及重新设置 <code>root</code>，我们将其单独处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">ublic <span class="keyword">void</span> <span class="title">add</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根节点已满，需分裂并重新设置根节点。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.root.getEntries().size() == <span class="keyword">this</span>.order * <span class="number">2</span>) &#123;</span><br><span class="line">        Node&lt;K, V&gt; newRoot = <span class="keyword">new</span> Node&lt;&gt;();</span><br><span class="line">        newRoot.getChildrens().add(<span class="keyword">this</span>.root);</span><br><span class="line">        splitNode(newRoot, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">this</span>.root = newRoot;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    insertNotFull(<span class="keyword">this</span>.root, key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>B 树中删除键值对</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    deleteTree(<span class="keyword">this</span>.root, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2></li>
</ul>
<p>B+ 树是 B 树的一种重要变体。相比于 B 树而言，其查询性能更为高效、更为稳定。</p>
<p>各种资料中 B+ 树的定义略有差异，我们采用维基百科上提供的定义。基于此定义，我们首先给出 B+ 树与 B 树之间的差异：</p>
<ul>
<li>在 B+ 树中，节点分为两种类型——内部节点 (索引节点) 和叶节点。内部节点 (索引节点) 存放关键字及孩子指针，叶节点存放关键字及其对应数据。在B 树中，节点只具有一种类型，它存放关键字、对应数据及孩子指针。基于此差异，我们可知：相比 B 树而言，B+ 树更为 <em>矮胖</em>。</li>
<li>在 B+ 树中，对于索引节点中关键字而言，其左子树中节点均小于该关键字，右子树中节点均大于等于该关键字 (以此保证能够索引至相应叶节点)。在 B 树中，对于节点中关键字而言，其左子树中节点均小于该关键字，右子树中节点均大于该关键字，此关键字及对应数据亦存于此节点之中。基于此差异，我们可知：B+ 树中同一关键字可能出现在多个节点之中。</li>
<li>在 B+ 树中，叶节点依关键字大小顺序进行链接。在 B 树中，叶节点之间并无任何关系。基于此差异，我们可知：B+ 树中可高效实现范围查询。</li>
<li>在 B+ 树中，需要存储根节点及最小关键字节点引用。在 B 树中，仅需存储根节点引用。</li>
</ul>
<p><img src="/2020/08/09/dataStructure/dataStructure-btree/ds_bplus_tree_def.png" alt="图二：B+ 树(前者定义)"></p>
<img src="/2020/08/09/dataStructure/dataStructure-btree/v2-5f069fd820637db1b877fdd6799a2b67_1440w.jpg" alt="图三：B+ 树(后者定义)" style="zoom: 33%;">

<blockquote>
<p>不同 B+ 树定义的差异点在于：如何处理节点内部关键字个数与孩子节点个数之间的关系。一种定义方式为：节点内部孩子节点个数等于关键字个数加一 (就是B 树原始定义)，另一种定义方式为：节点内部关键字个数与孩子节点个数相等。</p>
<p>我们很容易将基于前者定义的 B+ 树改造为基于后者的 B+ 树。在前者定义中，对于索引节点中关键字而言，其左子树中节点均小于该关键字，右子树中节点均大于等于该关键字。将其改造为后者定义便是，对于索引节点中关键字而言，其对应子树中节点均大于等于该关键字 。在该种定义中，我们舍弃小于当前节点中最小关键字的子树，这一点可使用如下操作进行替代：如果待插入关键字小于当前节点中最小关键字，我们就将当前节点中最小关键字修改为待插入关键字，随后进行插入。</p>
<p>当采用第二种定义方式时， 基于 B+ 树的一种变体 B* 树被定义。相比于 B+ 树，B* 树具有如下特点：1. 如果节点不为叶节点或根节点，则其内部需要存储一个指向右邻居关键字的引用。2. 节点内部所含关键字个数至少为 $\frac{2}{3}t$ (<strong>这使得其节点空间使用率更高</strong>)。由于节点所含最小关键字个数定义发生变动，故而其分裂规则亦发生变动：当插入关键字之时，如果当前节点所含关键字个数为 $2t - 1$ (已满)，则会判断右邻居节点所含关键字个数是否已满，如果未满则转移部分关键字至右邻居节点，否则新建一个右邻居节点，并将当前节点及原先右邻居节点的$\frac{1}{3}t$ 个关键字转移至其内。</p>
<p><strong>B+ 树肯定是很重要的，因为维基百科有定义且广泛应用于数据库之中；B* 树未必有用，因为维基百科没有定义且基本搜不到资料，了解就行了。</strong></p>
</blockquote>
<p>接下来，我们简单描述 B+ 树结构及其相关操作：</p>
<ul>
<li><p>结构</p>
<p>B+ 树涉及两种节点类型——内部节点和叶节点。对于内部节点而言，需使用数组存储关键字及孩子指针；对于叶节点，需使用数组存储关键字、对应数据及右邻居关键字引用。对于这两种节点而言，它们均需使用一个引用存储父节点、一个布尔值表示当前节点是否为叶节点。</p>
<p>对于 B+ 树而言，它需要存储根节点及具有最小关键字节点的引用，同时需要存储树阶。</p>
</li>
<li><p>查询</p>
<p>查询操作与 B 树基本一致，只是必须递归至叶节点完成查询。</p>
</li>
<li><p>插入</p>
<p>插入操作与 B 树存在较大差异，但是思路基本不变。</p>
<p>首先需要根据关键字索引至叶节点，然后将该数据插入其中。如果叶节点所含关键字个数已到达上限 (即含有 $2t$ 个关键字)，此时需要拆分为两个叶节点，前 $t$ 关键字位于左叶节点，后 $t$ 关键字位于右叶节点，并将右叶节点的第一个关键字插入至父节点。如果父节点所含关键字个数已达上限，此时需要拆分为两个索引节点，前 $t - 1$ 个关键字位于左索引节点，后 $t$ 个关键字位于右索引节点，并将第 $t$ 个关键字插入于父节点之中，随后递归更新父节点。</p>
</li>
<li><p>删除</p>
<p>删除操作与 B 树基本相同。</p>
<p>首先需要根据关键字索引至叶节点，随后删除该关键字。如果叶节点所含关键字个数已到达下限 (即含有 $t - 2$ 个关键字)，此时需要从左右邻居节点中借调一个关键字、或者合并邻居节点，随后更新父节点相应位置的关键字。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-后缀数组</title>
    <url>/2020/08/02/dataStructure/dataStructure-suffixarray/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>后缀数组</strong> 是特定字符串的所有后缀有序排列而成的一个数组。它比后缀树更为实用，常用于全文索引。</p>
<a id="more"></a>

<p>其结构图大致如下：</p>
<img src="/2020/08/02/dataStructure/dataStructure-suffixarray/sa1.png" alt="图一：后缀数组" style="zoom:50%;">

<p>后缀数组比较特殊，本文简单介绍其构建方法及应用。</p>
<h2 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h2><p>后缀数组并非直接存储后缀，而是后缀在特定字符串中的起始下标。</p>
<p>我们在此说明如下构造算法中可能使用到的重要变量名称：</p>
<ul>
<li><code>sa[i]</code> ：排名为 $i$ 的后缀在特定字符串中的起始下标。</li>
<li><code>rk[i]</code> ：起始下标为 $i$ 的后缀在所有后缀中的排名。</li>
<li><code>height[i]</code> ：排名为 $i$ 的后缀与排名为 $i - 1$ 的后缀的最长公共前缀。</li>
<li><code>LCP(str1,str2)</code> ：两个字符串的最长公共前缀。</li>
<li><code>sub[i][k]</code> ：特定字符串区间 $[i,i + 2^k - 1]$ 所表示的子串。</li>
<li><code>sa[i][k]</code> ：长度为 $2^k$ 的所有子串中，排名为 $i$ 的子串在特定字符串中的起始下标。 </li>
<li><code>rk[i][k]</code> ：长度为 $2^k$ 的所有子串中，起始下标为 $i$ 的子串在所有子串中的排名。</li>
<li><code>prefixs[i]</code> ：特定字符串的前缀哈希值。</li>
<li><code>squares[i]</code> ：存放 $2^i$ 系列值。</li>
</ul>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuffixArray</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 特定字符串</span></span><br><span class="line">    <span class="keyword">private</span> String T;</span><br><span class="line">    <span class="comment">// 排名对应起始下标数组(下标从1开始)</span></span><br><span class="line">    <span class="keyword">private</span> Integer[] sa;</span><br><span class="line">    <span class="comment">// 起始下标对应排名数组(下标从1开始)</span></span><br><span class="line">    <span class="keyword">private</span> Integer[] rk;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="朴素构造算法"><a href="#朴素构造算法" class="headerlink" title="朴素构造算法"></a>朴素构造算法</h3><p>朴素构造算法十分简单：排序所有后缀，然后按顺序存储各后缀在特定字符串中的起始下标。</p>
<p>排序操作的时间复杂度为 $O(Nlog^N)$，比较字符串的时间复杂度为 $O(N)$，故而该构造算法的时间复杂度为 $O(N^2log^N)$。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SuffixArray</span><span class="params">(String T)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 添加前缀，方便后续代码编写。</span></span><br><span class="line">    T = <span class="string">&quot;$&quot;</span> + T;</span><br><span class="line">    <span class="keyword">this</span>.T = T;</span><br><span class="line">    <span class="keyword">this</span>.sa = <span class="keyword">new</span> Integer[T.length()];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化sa</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>.sa.length; i++) &#123;</span><br><span class="line">        <span class="keyword">this</span>.sa[i]= i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Arrays.sort(<span class="keyword">this</span>.sa, <span class="number">1</span>, <span class="keyword">this</span>.sa.length, (o1, o2) -&gt; &#123;</span><br><span class="line">        <span class="keyword">int</span> index1 = (<span class="keyword">int</span>) o1;</span><br><span class="line">        <span class="keyword">int</span> index2 = (<span class="keyword">int</span>) o2;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.T.substring(index1).compareTo(<span class="keyword">this</span>.T.substring(index2));</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二分思想-Hash-优化"><a href="#二分思想-Hash-优化" class="headerlink" title="二分思想 + Hash 优化"></a>二分思想 + Hash 优化</h3><p>针对朴素构造算法中的字符串比较操作，我们可基于二分思想及 Hash 将其时间复杂度优化为 $O(log^N)$。</p>
<p>该优化操作源于如下观察：通过比较最长公共前缀所在位置的下一个字符，即可得到两个字符串的大小关系。</p>
<p>为获取最长公共前缀所在位置，我们可使用二分思想：如果 $[l1, l1 + mid - 1]$ 表示字符串的哈希值与 $[l2,l2 + mid - 1]$ 表示字符串的哈希值相等，表明最长公共前缀所在位置处于右半部分 ，否则表明最长公共前缀所在位置处于左半部分。</p>
<blockquote>
<ul>
<li>采用的哈希函数为：$\sum_{i = l}^{i = r}2^i * T[i]$ 。</li>
<li>如果需要获取指定区间 $[L,R]$ 表示字符串的哈希值，可借由前缀哈希值数组 <code>prefixs</code> 和 $2^k$ 预存数组 <code>squares</code> 推导得到：$(prefixs[R] - prefixs[L - 1]) / squares[L]$ 。</li>
<li><code>mid</code> 表示步长 (与普通二分算法中 <code>mid</code> 含义不同)。</li>
</ul>
</blockquote>
<p>由于字符串比较操作的时间复杂度降为 $O(log^N)$，故而该构造算法的时间复杂度为 $O(N(log^N)^2)$ 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SuffixArray</span><span class="params">(String T)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 添加前缀，方便后续代码编写。</span></span><br><span class="line">    T = <span class="string">&quot;$&quot;</span> + T;</span><br><span class="line">    <span class="keyword">this</span>.T = T;</span><br><span class="line">    <span class="keyword">this</span>.sa = <span class="keyword">new</span> Integer[T.length()];</span><br><span class="line">	<span class="keyword">this</span>.prefixs = <span class="keyword">new</span> Integer[<span class="keyword">this</span>.T.length()];</span><br><span class="line">    <span class="keyword">this</span>.squares = <span class="keyword">new</span> Integer[<span class="keyword">this</span>.T.length()];</span><br><span class="line">    prefixs[<span class="number">0</span>] = <span class="string">&#x27;$&#x27;</span> - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    squares[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化相关数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>.sa.length; i++) &#123;</span><br><span class="line">        <span class="keyword">this</span>.sa[i]= i;</span><br><span class="line">        squares[i] = squares[i - <span class="number">1</span>] * <span class="number">2</span>;</span><br><span class="line">        prefixs[i] = prefixs[i - <span class="number">1</span>] + (<span class="keyword">this</span>.T.charAt(i) - <span class="string">&#x27;a&#x27;</span>) * squares[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Arrays.sort(<span class="keyword">this</span>.sa, <span class="number">1</span>, <span class="keyword">this</span>.sa.length, (o1, o2) -&gt; &#123;</span><br><span class="line">        <span class="keyword">int</span> index1 = (<span class="keyword">int</span>) o1;</span><br><span class="line">        <span class="keyword">int</span> index2 = (<span class="keyword">int</span>) o2;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义步长左端、右端。</span></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = Math.min(<span class="keyword">this</span>.T.length() - index1, <span class="keyword">this</span>.T.length() - index2);</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="comment">// 获取中间步长</span></span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取相应子串的哈希值</span></span><br><span class="line">            <span class="keyword">int</span> strHash1 = (prefixs[index1 + mid - <span class="number">1</span>] - prefixs[index1 - <span class="number">1</span>]) / squares[index1];</span><br><span class="line">            <span class="keyword">int</span> strHash2 = (prefixs[index2 + mid - <span class="number">1</span>] - prefixs[index2 - <span class="number">1</span>]) / squares[index2];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果二者不等，表明步长应小于等于mid，否则表明步长应大于mid。</span></span><br><span class="line">            <span class="keyword">if</span> (strHash1 != strHash2) &#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 二分过程后，[index1,index + l - 1 - 1]对应字符串为最长公共前缀，那么只需比较对应位置下一个字符即可。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.T.charAt(index1 + l - <span class="number">1</span>) - <span class="keyword">this</span>.T.charAt(index2 + l - <span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="倍增思想"><a href="#倍增思想" class="headerlink" title="倍增思想"></a>倍增思想</h3><p>上述两种算法将两个后缀视为独立字符串进行比较，倍增思想则考虑后缀之间的内在联系。</p>
<p>倍增思想中主要涉及如下三个数组：<code>sub[i][k]</code> 、<code>rk[i][k]</code> 、<code>sa[i][k]</code> 。</p>
<p>假定我们已经获知 $sub[i][k]$ 对应排名为 $rk[i][k]$。如果需要判断任意两个子串 $sub[i][k+1]$ 和 $sub[j][k+1]$ 之间的大小关系，只需先行比较 $sub[i][k]$ 与 $sub[j][k]$ 对应排名，如果二者排名相同，则再比较 $sub[i + 2^k][k]$ 和 $sub[j + 2^k][k]$ 对应排名。</p>
<p>按照上述描述，基于 $rk[i][k]$ 可顺利推导得到长度为 $2^{k+1}$ 的各子串排序 (亦即 $sa[i][k+1]$)，基于 $sa[i][k+1]$ 又可方便得到 $rk[i][k+1]$。如此循环迭代，最终我们将得到 $sa[i][k],2^k \geq T.length$，此亦为特定字符串 $T$ 的后缀数组。</p>
<p>现在问题就在于：如何排序各子串得到 $sa[i][k+1]$ ？</p>
<p>一种可行做法是直接调用快速排序等方式。由于快速排序等方式的时间复杂度为 $O(Nlog^N)$，倍增循环 $O(log^N)$ 次，故而此时构造算法的时间复杂度为 $O(N(log^N)^2)$ 。</p>
<p>一种更为优秀做法是使用基数排序，这是因为 $rk[i][k + 1] \in (0,T.length)$ 。此时排序方式的时间复杂度为 $O(N)$，外加倍增循环 $O(log^N)$ 次，故而此时构造算法的时间复杂度为 $O(Nlog^N)$ 。</p>
<p>我们在此实现第二种做法。</p>
<p>实现代码与描述存在些许出入，故而在此总结一下：</p>
<ul>
<li>由于需要使用 $rk[i + 2^k][k]$，故而 $rk[i][k]$ 数组空间大小至少为特定字符串长度的两倍。由于 $rk[i][k]$ 数组与特定字符串存在一一对应关系，我们默认 $T[i] = ‘Null’, i \in [T.length,T.length * 2)$ ($Null$ 表示 ascii 码中的空字符)。</li>
<li>最初需要初始化 <code>rk[i][0]</code> 和 <code>sa[i][0]</code>。<code>rk[i][0]</code> 可直接使用对应字符的 ascii 码进行赋值 (如果 $i \geq T.length$，由于 $T[i]$ 为空，故而可设 <code>rk[i][0] = 0</code>)，随后基于基数排序可得到 <code>sa[i][0]</code> 。</li>
<li>由于最初使用 ascii 码赋值 <code>rk[i][0]</code>，故而 <code>rk[]</code> 和 <code>cnt[]</code> (基数排序中的桶) 空间最小需设为最大 ascii 码值。</li>
<li>倍增循环中，我们需要根据 $sub[i][k]$ 和 $sub[i + 2^k][k]$ 对应排名进行排序各子串。当使用基数排序进行排序各子串时，我们首先使用  $sub[i + 2^k][k]$ 对应排名(第二关键字) 排序各子串，然后使用 $sub[i][k]$ 对应排名 (第一关键字) 排序各子串即可。</li>
<li>代码实现中采用数组实现基数排序。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SuffixArray</span><span class="params">(String T)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 添加前缀，方便后续代码编写。</span></span><br><span class="line">    T = <span class="string">&quot;$&quot;</span> + T;</span><br><span class="line">    <span class="keyword">this</span>.T = T;</span><br><span class="line">    <span class="keyword">this</span>.sa = <span class="keyword">new</span> Integer[T.length()];</span><br><span class="line">    <span class="keyword">this</span>.rk = <span class="keyword">new</span> Integer[<span class="number">1000</span>];</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 桶</span></span><br><span class="line">    Integer[] cnt = <span class="keyword">new</span> Integer[<span class="number">1000</span>];</span><br><span class="line">    <span class="comment">// 临时存放sa</span></span><br><span class="line">    Integer[] id = <span class="keyword">new</span> Integer[<span class="keyword">this</span>.T.length()];</span><br><span class="line">    <span class="comment">// 存放旧rank</span></span><br><span class="line">    Integer[] oldRank;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始置0</span></span><br><span class="line">    Arrays.fill(cnt, <span class="number">0</span>, cnt.length, <span class="number">0</span>);</span><br><span class="line">    Arrays.fill(<span class="keyword">this</span>.rk, <span class="number">0</span>, <span class="keyword">this</span>.rk.length, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用基数排序初始化。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>.T.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">this</span>.rk[i] = Integer.valueOf(<span class="keyword">this</span>.T.charAt(i));</span><br><span class="line">        ++cnt[<span class="keyword">this</span>.rk[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; cnt.length; i++) &#123;</span><br><span class="line">        cnt[i] += cnt[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="keyword">this</span>.T.length() - <span class="number">1</span>; i &gt;=<span class="number">1</span> ; i--) &#123;</span><br><span class="line">        <span class="keyword">this</span>.sa[cnt[<span class="keyword">this</span>.rk[i]]--] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> w = <span class="number">1</span>; w &lt; <span class="keyword">this</span>.T.length(); w = w * <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 清空桶</span></span><br><span class="line">        Arrays.fill(cnt, <span class="number">0</span>, cnt.length, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>.T.length(); i++) &#123;</span><br><span class="line">            id[i] = <span class="keyword">this</span>.sa[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 基数排序第二关键字</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>.T.length(); i++) &#123;</span><br><span class="line">            ++cnt[<span class="keyword">this</span>.rk[id[i] + w]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; cnt.length; i++) &#123;</span><br><span class="line">            cnt[i] += cnt[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="keyword">this</span>.T.length() - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">this</span>.sa[cnt[<span class="keyword">this</span>.rk[id[i] + w]]--] = id[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 清空桶</span></span><br><span class="line">        Arrays.fill(cnt, <span class="number">0</span>, cnt.length, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>.T.length(); i++) &#123;</span><br><span class="line">            id[i] = <span class="keyword">this</span>.sa[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 基数排序第一关键字</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>.T.length(); i++) &#123;</span><br><span class="line">            ++cnt[<span class="keyword">this</span>.rk[id[i]]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; cnt.length; i++) &#123;</span><br><span class="line">            cnt[i] += cnt[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="keyword">this</span>.T.length() - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">this</span>.sa[cnt[<span class="keyword">this</span>.rk[id[i]]]--] = id[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        oldRank = Arrays.copyOf(<span class="keyword">this</span>.rk, <span class="keyword">this</span>.rk.length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新rank。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">1</span>, i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>.T.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">1</span> || (oldRank[<span class="keyword">this</span>.sa[i]] == oldRank[<span class="keyword">this</span>.sa[i - <span class="number">1</span>]] &amp;&amp; oldRank[<span class="keyword">this</span>.sa[i] + w] == oldRank[<span class="keyword">this</span>.sa[i - <span class="number">1</span>] + w])) &#123;</span><br><span class="line">                <span class="keyword">this</span>.rk[<span class="keyword">this</span>.sa[i]] = p;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.rk[<span class="keyword">this</span>.sa[i]] = ++p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>存在 $O(N)$ 复杂度构建后缀数组的方法，但是由于其过于复杂并不常用，故而不再介绍。</p>
</blockquote>
<h3 id="求取-Height"><a href="#求取-Height" class="headerlink" title="求取 Height"></a>求取 Height</h3><p>上面的构造算法仅能初始化数组 $sa[i]$ 和 $rk[i]$，数组 $height[i]$ 需单独初始化。</p>
<p>初始化数组 $height[i]$ 仍然存在多种方法，我们一一讲述：</p>
<ul>
<li><p>暴力解法</p>
<p>遍历整个数组，每次按序比较两个字符串，从而得到最长公共前缀。</p>
<p>容易得知：此种解法的时间复杂度为 $O(N^2)$。</p>
</li>
<li><p>二分 + hash</p>
<p>对应第二种构造算法。</p>
<p>容易得知：此种解法的时间复杂度为 $O(Nlog^N)$。</p>
</li>
<li><p>线性解法</p>
<p>线性解法基于一个定理：</p>
<p>$height[rk[i]] \geq height[rk[i - 1]] - 1，height[rk[i]] \approx LCP(suffix(i), suffix(rk[i] - 1))$。</p>
<p>该定理证明比较简单，在此简单说明：</p>
<ul>
<li>当 $height[rk[i - 1]] \leq 1$ 时，$height[rk[i]]$ 需要大于等于零，这显然成立。</li>
<li>当 $height[rk[i - 1]] &gt; 1$ 时，我们可以得知：$suffix(i - 1)$ 与 $suffix(rk[i - 1] - 1)$ 的最长公共前缀大于 $1$。我们将第一个公共字符消去，则此时二者的最长公共前缀变为 $height[rk[i - 1]] - 1$。由于 $suffix(i - 1)$ 消去第一个字符的结果就是 $suffix(i)$，那么可以知道 $height[rk[i]]$ 的结果至少等于 $height[rk[i - 1]] - 1$。</li>
</ul>
<p>基于这个定理，我们可按照 $height[rk[i]]$ 顺序递推求解高度：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">calHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// k = height[rk[i - 1]]</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>, k = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.T.length(); i++) &#123;</span><br><span class="line">        <span class="comment">// height[rk[i]] &gt;= height[rk[i - 1]] - 1，故而k值需减一</span></span><br><span class="line">        <span class="keyword">if</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从k开始继续探索当前后缀与对应排名的上一个后缀相应位置字符是否相等，相等则继续探索，否则k对应就是最长公共前缀。</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">this</span>.T.charAt(i + k) == <span class="keyword">this</span>.T.charAt(<span class="keyword">this</span>.sa[<span class="keyword">this</span>.rk[i] - <span class="number">1</span>] + k)) &#123;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">this</span>.height[<span class="keyword">this</span>.rk[i]] = k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>顾名思义：此种解法的时间复杂度为 $O(N)$。</p>
</li>
</ul>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="两后缀最长公共前缀"><a href="#两后缀最长公共前缀" class="headerlink" title="两后缀最长公共前缀"></a>两后缀最长公共前缀</h3><p>对于相邻后缀而言，其最长公共前缀就是 $height[i]$。</p>
<p>对于不相邻后缀而言，由于所有后缀按照字典序进行排序，故而不相邻后缀的最长公共前缀应当等于此二者在数组 $sa$ 对应区间内 $height[i]$ 的最小值。</p>
<h3 id="不同子串的数目"><a href="#不同子串的数目" class="headerlink" title="不同子串的数目"></a>不同子串的数目</h3><p>子串最初被定义为 $T[i,j]$，当然它也可以被定义为某个后缀的前缀。</p>
<p>那么为求解不同子串数目，我们可以首先计算所有子串的数目，随后减去公共前缀的数目即可。</p>
<p>故而不同子串数目 $sum = (N * (N + 1)) / 2 - \sum height[i]$。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-前缀树/后缀树</title>
    <url>/2020/07/26/dataStructure/dataStructure-tiretree/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>前缀树</strong> 是一种专门用于处理字符串匹配问题的树形结构，它利用字符串公共前缀以减少查询所需时间。其典型应用为搜索引擎的搜索提示。</p>
<a id="more"></a>

<p>其结构图大致如下：</p>
<img src="/2020/07/26/dataStructure/dataStructure-tiretree/trie.png" alt="图一：前缀树" style="zoom:80%;">

<p>当面对字符串查询问题时，前缀树和哈希表通常会被同时提及，故而在此说明二者在此问题上的异同点：</p>
<ol>
<li>前者基于 “空间换时间” 加速查询；后者基于字符串公共前缀加速查询。</li>
<li>前者查询过程中存在 <em>冲突</em> 问题，如果散列函数选择得当，其查询操作的平均时间复杂度为 $O(1)$；后者按序匹配字符串中字符可实现查找，故而其查询操作的时间复杂度为 $O(k),k = str.length$。</li>
</ol>
<blockquote>
<p>前缀树中节点需要维护一个映射所有字符的引用数组，故而其耗费空间往往大于哈希表。</p>
<p>如果需要使用前缀树，现实情况应最好满足以下两点：字符集相对较小、字符串前缀重合较多。</p>
<p>前缀树又称为 Trie 树、字典树。</p>
</blockquote>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieTree</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 节点结构</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 词尾次数(end=0,表示当前节点并非任何字符串尾部;end=?,表示当前节点为?个字符串尾部)</span></span><br><span class="line">        <span class="keyword">int</span> end;</span><br><span class="line">        <span class="comment">// 26个元素的数组，表征26个字母</span></span><br><span class="line">        Node[] childrens;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.end = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">this</span>.childrens = <span class="keyword">new</span> Node[<span class="number">26</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根节点</span></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="辅助方法"><a href="#辅助方法" class="headerlink" title="辅助方法"></a>辅助方法</h3><ul>
<li><p>当前节点的孩子节点是否均为空</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isNullChildren</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Node node : root.childrens) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != node) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>当前子树中插入子串，并返回插入后的子树</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">insertTree</span><span class="params">(Node root, String str, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果当前子树为空，则先构建该子树。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == root) &#123;</span><br><span class="line">        root = <span class="keyword">new</span> Node();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果已到达字符串尾部，需更新当前节点end字段，否则找到相应字符，递归下去。</span></span><br><span class="line">    <span class="keyword">if</span> (index == str.length()) &#123;</span><br><span class="line">        root.end++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> charIndex = str.charAt(index) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        root.childrens[charIndex] = insertTree(root.childrens[charIndex], str, index + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>当前子树中删除指定字符串，并返回删除后的子树</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">deleteTree</span><span class="params">(Node root, String str, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前子树为空，直接返回。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已到达字符串尾部，择情处理，否则找到相应字符，递归下去。</span></span><br><span class="line">    <span class="keyword">if</span> (index == str.length()) &#123;</span><br><span class="line">        <span class="comment">// 表明存在该字符串，则次数减一。</span></span><br><span class="line">        <span class="keyword">if</span> (root.end &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            root.end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> charIndex = str.charAt(index) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        root.childrens[charIndex] = deleteTree(root.childrens[charIndex], str, index + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断当前节点是否需要删去。</span></span><br><span class="line">    <span class="keyword">if</span> (root.end == <span class="number">0</span> &amp;&amp; isNullChildren(root)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>当前子树中查询子串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">searchTree</span><span class="params">(Node root, String str, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前子树为空，直接返回false即可。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已到达字符串尾部，如果存在该字符串，则返回true，否则找到相应字符，递归下去。</span></span><br><span class="line">    <span class="keyword">if</span> (index == str.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> (root.end &gt; <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> charIndex = str.charAt(index) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> searchTree(root.childrens[charIndex], str, index + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TrieTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 无需任何操作。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><ul>
<li><p>查询字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> searchTree(<span class="keyword">this</span>.root, str, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="操纵"><a href="#操纵" class="headerlink" title="操纵"></a>操纵</h3></li>
<li><p>前缀树中添加字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 节点仅存储a-z的引用，故而需有此操作。</span></span><br><span class="line">    str = str.toLowerCase();</span><br><span class="line">    <span class="keyword">this</span>.root = insertTree(<span class="keyword">this</span>.root, str, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>前缀树中删除字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 节点仅存储a-z的引用，故而需有此操作。</span></span><br><span class="line">    str = str.toLowerCase();</span><br><span class="line">    <span class="keyword">this</span>.root = deleteTree(<span class="keyword">this</span>.root, str, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2></li>
</ul>
<h3 id="优化前缀树"><a href="#优化前缀树" class="headerlink" title="优化前缀树"></a>优化前缀树</h3><p>如上所述，前缀树中节点需要维护一个映射所有字符的引用数组，这使得其将耗费巨大空间。</p>
<p>我们以小写英文单词构建前缀树举例：树中节点需要维护一个引用数组，该数组映射字符集 $[a-z]$。如果向该前缀树中插入许多小写英文单词，我们将看到如下现象 (可参见图一)：</p>
<ol>
<li>引用数组的使用率很低。一个节点含有 $26$ 个引用，通常最多仅 $10$ 余个引用处于使用之中，其余引用均为 <code>null</code>。</li>
<li>部分节点往往仅有一个子节点，即该节点仅 $1$ 个引用处于使用之中。</li>
</ol>
<p>优化前缀树即在于如何管理引用数组。常见优化策略有如下两种：</p>
<ol>
<li>使用平衡二叉树代替引用数组，此时如果需要映射相关字符，就向平衡二叉树中动态插入一个引用节点。</li>
<li>如果节点仅含有一个子节点，则压缩两个节点为一个节点，此时节点内容为 “原节点内容 + 原子节点内容”。这种前缀树又被称为 <strong>压缩前缀树</strong>。</li>
</ol>
<h3 id="后缀树"><a href="#后缀树" class="headerlink" title="后缀树"></a>后缀树</h3><p>前缀树用于处理字符串查询匹配问题，后缀树则用于处理特定字符串的模式匹配问题，即模式是否出现于特定字符串之中？、模式在特定字符串中出现了几次，具体出现在哪些位置？</p>
<p>首先讲明一个结论：如果模式出现于特定字符串中，那么它一定是某个后缀的前缀。</p>
<p>基于此结论及前缀树的用法，我们可将特定字符串的所有后缀输入至空的前缀树之中，并使用此树解决特定字符串的模式匹配问题，而该树即是后缀树。</p>
<blockquote>
<p>后缀树又称为 <em>后缀压缩前缀树</em>，故而其实际上是将特定字符串的所有后缀输入至压缩前缀树之中。</p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-主席树</title>
    <url>/2020/07/24/dataStructure/dataStructure-hjttree/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>主席树</strong> 全称为 “可持久化权值线段树”，它可在 $O(log^N)$ 时间复杂度内实现查询任意指定区间 $[L,R]$ 内的第 $K$ 大/小元素。</p>
<a id="more"></a>

<p>其结构图大致如下：</p>
<img src="/2020/07/24/dataStructure/dataStructure-hjttree/image-20200724193347751.png" alt="图一：主席树" style="zoom: 50%;">

<p>主席树基于权值线段树实现，故而首先说明权值线段树的两个性质：</p>
<ol>
<li>权值线段树可以 $O(log^N)$ 时间查找整个区间内第 K 大/小元素。</li>
<li>假定所有元素按序尾部插入到数组之中，那么数组 $[0,R]$ 对应的权值线段树减去数组 $[0,L-1]$ 对应的权值线段树就是数组 $[L,R]$ 对应的权值线段树。</li>
</ol>
<p>基于上述两个性质，可以知道：如果保存插入任意元素后的所有权值线段树，那么就可实现在 $O(log^N)$ 时间复杂度内实现查询任意指定区间 $[L,R]$ 内的第 $K$ 大/小元素。如果保存所有权值线段树，其所需空间将是无法承受的。</p>
<p>观察权值线段树的插入操作，可以发现：一次操作仅会使得对应路径上的 $log^N$ 个节点内容发生变化。故而我们可以通过共用未修改节点使得所需空间降下来。当然，这也就是主席树的基本思想。</p>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HJTTree</span></span>&#123;</span><br><span class="line">    <span class="comment">// 权值数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] tree;</span><br><span class="line">    <span class="comment">// 历史根节点数组(基于此找到历史权值线段树)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] root;</span><br><span class="line">    <span class="comment">// 左儿子</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] left;</span><br><span class="line">    <span class="comment">// 右儿子</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] right;</span><br><span class="line">    <span class="comment">// 节点计数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> nodeCount;</span><br><span class="line">    <span class="comment">// 最新根节点位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> rootIndex;</span><br><span class="line">    <span class="comment">// 最大边界</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> Bound = <span class="number">1000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="辅助方法"><a href="#辅助方法" class="headerlink" title="辅助方法"></a>辅助方法</h3><ul>
<li><p>构建空的权值线段树</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前子树所负责区间仅有一个值，故直接赋值0即可。</span></span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        <span class="keyword">this</span>.tree[root] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取中间位置。</span></span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 基于nodeCount构建左右儿子节点。</span></span><br><span class="line">    <span class="keyword">this</span>.left[root] = ++<span class="keyword">this</span>.nodeCount;</span><br><span class="line">    <span class="keyword">this</span>.right[root] = ++<span class="keyword">this</span>.nodeCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归构建左右子树。</span></span><br><span class="line">    build(<span class="keyword">this</span>.left[root], l, mid);</span><br><span class="line">    build(<span class="keyword">this</span>.right[root], mid + <span class="number">1</span>, r);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 子树构建结果为空子树，故而无需更新根节点值。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>当前子树插入指定元素</p>
<p>插入指定元素过程中所经过路径上的节点均需拷贝以生成新节点，并更新这些节点的内容。这样新节点与未曾更改的旧节点就构成了插入指定元素后所对应的权值线段树。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">updateTree</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 复制该节点，并更新节点信息。</span></span><br><span class="line">    <span class="keyword">int</span> newNode = ++<span class="keyword">this</span>.nodeCount;</span><br><span class="line">    <span class="keyword">this</span>.left[newNode] = <span class="keyword">this</span>.left[root];</span><br><span class="line">    <span class="keyword">this</span>.right[newNode] = <span class="keyword">this</span>.right[root];</span><br><span class="line">    <span class="keyword">this</span>.tree[newNode] = <span class="keyword">this</span>.tree[root] + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前子树所负责区间仅有一个值，则直接返回复制的节点即可。</span></span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        <span class="keyword">return</span> newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取中间位置。</span></span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果mid&gt;=k，表明k应当位于左子树之中，故而需在左子树中进行更新；否则需在右子树中进行更新。</span></span><br><span class="line">    <span class="keyword">if</span> (mid &gt;= k) &#123;</span><br><span class="line">        <span class="keyword">this</span>.left[newNode] = updateTree(<span class="keyword">this</span>.left[newNode], l, mid, k);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.right[newNode] = updateTree(<span class="keyword">this</span>.right[newNode], mid + <span class="number">1</span>, r, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素的结果便是所经路径上各节点的值加一，第六行代码已经加过了，故而无需再更新根节点值。</span></span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>查询指定区间内第 $k$ 小元素</p>
<p>”概述“ 中通过二者相减得到指定区间 $[L.R]$ 对应的权值线段树，然后在此树上进行查找第 $k$ 小元素。实际代码实现中，这两步可直接合为一步，具体如代码示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getKthTree</span><span class="params">(<span class="keyword">int</span> startRoot, <span class="keyword">int</span> endRoot, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前子树所负责区域仅有一个值，如果对应元素个数(指代[L,R]对应权值线段树中的元素个数)大于k，则返回该元素，否则表明不存在，直接返回一个负数。</span></span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">this</span>.tree[endRoot] - <span class="keyword">this</span>.tree[startRoot] &gt; k) ? l : -HJTTree.Bound;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取中间位置。</span></span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 获取[L,R]对应权值线段树中左子树所包含的元素个数</span></span><br><span class="line">    <span class="keyword">int</span> x = <span class="keyword">this</span>.tree[<span class="keyword">this</span>.left[endRoot]] - <span class="keyword">this</span>.tree[<span class="keyword">this</span>.left[startRoot]];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果x&gt;k，表明第k小元素位于左子树之中，故而应在左子树中进行查找；否则应在右子树中进行查找。</span></span><br><span class="line">    <span class="keyword">if</span> (x &gt; k) &#123;</span><br><span class="line">        <span class="keyword">return</span> getKthTree(<span class="keyword">this</span>.left[startRoot], <span class="keyword">this</span>.left[endRoot], l, mid, k);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getKthTree(<span class="keyword">this</span>.right[startRoot], <span class="keyword">this</span>.right[endRoot], mid + <span class="number">1</span>, r, k - x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HJTTree</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 为各数组赋予足够大的空间。</span></span><br><span class="line">    <span class="keyword">this</span>.tree = <span class="keyword">new</span> <span class="keyword">int</span>[HJTTree.Bound &lt;&lt; <span class="number">5</span>];</span><br><span class="line">    <span class="keyword">this</span>.root = <span class="keyword">new</span> <span class="keyword">int</span>[HJTTree.Bound &lt;&lt; <span class="number">5</span>];</span><br><span class="line">    <span class="keyword">this</span>.left = <span class="keyword">new</span> <span class="keyword">int</span>[HJTTree.Bound &lt;&lt; <span class="number">5</span>];</span><br><span class="line">    <span class="keyword">this</span>.right = <span class="keyword">new</span> <span class="keyword">int</span>[HJTTree.Bound &lt;&lt; <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化各字段</span></span><br><span class="line">    <span class="keyword">this</span>.nodeCount = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">this</span>.rootIndex = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在this.root[0]处构建空的权值线段树</span></span><br><span class="line">    <span class="keyword">this</span>.root[++<span class="keyword">this</span>.rootIndex] = ++<span class="keyword">this</span>.nodeCount;</span><br><span class="line">    build(<span class="keyword">this</span>.root[<span class="keyword">this</span>.rootIndex], <span class="number">0</span>, HJTTree.Bound);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将元素依次插入，从而构建权值线段树集。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        update(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><ul>
<li><p>查询指定区间内的第$K$ 小元素</p>
<p>代码实现与 “概述” 中的描述同样有些不同。由于初始化时 <code>this.root[0]</code> 对应空权值线段树，故而区间 $[0,R]$ 对应的权值线段树为 <code>this.root[r + 1]</code>、区间 $[0,L]$ 对应的权值线段树为 <code>this.root[l + 1]</code>。此时按照 “概述” 所述，区间 $[L,R]$ 对应的权值线段树为 <code>this.root[r + 1] - this.root[l]</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getKth</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getKthTree(<span class="keyword">this</span>.root[l], <span class="keyword">this</span>.root[r + <span class="number">1</span>], <span class="number">0</span>, HJTTree.Bound, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="操纵"><a href="#操纵" class="headerlink" title="操纵"></a>操纵</h3></li>
<li><p>插入指定元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果该值不在当前值域之中，则直接返回。</span></span><br><span class="line">    <span class="keyword">if</span> (k &lt; <span class="number">0</span> || k &gt; HJTTree.Bound) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 每次插入元素后，需更新this.root[]。</span></span><br><span class="line">    ++<span class="keyword">this</span>.rootIndex;</span><br><span class="line">    <span class="keyword">this</span>.root[<span class="keyword">this</span>.rootIndex] = updateTree(<span class="keyword">this</span>.root[<span class="keyword">this</span>.rootIndex - <span class="number">1</span>], <span class="number">0</span>, HJTTree.Bound, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2></li>
</ul>
<p>另有两种数据结构可在 $O(log^N)$ 时间复杂度内实现查询任意指定区间 $[L,R]$ 内的第 $K$ 大/小元素——划分树和归并树。前者基于线段树和快速排序而成，后者基于线段树和归并排序而成。在这两种数据结构中，线段树中节点维护的不再是特定信息 (例如区间最大值)，而是区间具体内容。</p>
<h3 id="划分树"><a href="#划分树" class="headerlink" title="划分树"></a>划分树</h3><ul>
<li><p>构建过程</p>
<p>假定初始数组为 <code>a</code>，排序后的数组为 <code>b</code>。首先置 <code>level0</code> 为初始数组，故而其所负责区间为 $[0,a.length -1]$；随后利用 <code>level0</code> 所负责区间所在数组的中间值 (即 $b[a.length / 2]$) 将当前区间及所在数组划分为左右两部分，这两部分将构成 <code>level1</code>，随后递归处理 <code>level1</code> 左右两部分以构成最终的线段树。</p>
<p>另外在构建过程中，每个层级区间所在数组中每个元素 $i$ 还会存储 <code>cnt</code> 信息，它表示当前区间前 $i - 1$ 个元素被划分到左半部分的元素个数。</p>
<blockquote>
<p>划分过程中两点需要注意：</p>
<ol>
<li>如果中间值存在多个，需保证一部分中间值位于左半部分，一部分中间值位于右半部分。为达到这一目的，我们需要统计小于中间值的元素个数，按照左半部分区间大小即可确定左半部分需要放置的中间值个数。</li>
<li>划分过程需保证 <strong>元素相对顺序保持不变</strong>。例如：<code>level1</code> 中 <code>[3, 1, 4, 2]</code> 一定可以在 <code>[5, 3, 1, 7, 4, 2, 8, 6]</code> 上按序找到，而不会发生元素顺序倒逆的情况。</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a: [<span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">6</span>]</span><br><span class="line">b: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line"></span><br><span class="line">level0: [<span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">6</span>] </span><br><span class="line">    cnt:[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>]</span><br><span class="line">level1: [<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>][<span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">6</span>] </span><br><span class="line">    cnt:[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>][<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">level2: [<span class="number">1</span>, <span class="number">2</span>][<span class="number">3</span>, <span class="number">4</span>][<span class="number">5</span>, <span class="number">6</span>][<span class="number">7</span>, <span class="number">8</span>] </span><br><span class="line">    cnt:[<span class="number">0</span>, <span class="number">1</span>][<span class="number">0</span>, <span class="number">1</span>][<span class="number">0</span>, <span class="number">1</span>][<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">level3: [<span class="number">1</span>][<span class="number">2</span>][<span class="number">3</span>][<span class="number">4</span>][<span class="number">5</span>][<span class="number">6</span>][<span class="number">7</span>][<span class="number">8</span>] </span><br><span class="line">    cnt:[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] (这行信息没意义)</span><br></pre></td></tr></table></figure></li>
<li><p>查询过程</p>
<p>假定当前节点所在区间为 $[l,r]$、查找指定区间 $[L,R]$ 内的第 $K$ 个元素，$count = cnt[R + 1] - cnt[L]$ 即表示当前区间有多少个元素进入了左子树。如果 $count &gt; K$，则表明我们需在左子树中查找第 $K$ 个元素，由于元素区间已经发生变化，所以我们需要更新区间为 $[l + cnt[L],l + cnt[R + 1] - 1]$ ；否则我们需要在右子树中查找第 $K - count$ 个元素，此时更新区间为 $[mid + 1 + L - l - cnt[L],mid + 1 + R - l - cnt[R]]$。</p>
<blockquote>
<p>可以如此更新区间的原因在于：划分过程中元素相对顺序保持不变。</p>
</blockquote>
</li>
</ul>
<h3 id="归并树"><a href="#归并树" class="headerlink" title="归并树"></a>归并树</h3><ul>
<li><p>构建过程</p>
<p>由于归并排序过程与线段树构建过程高度一致，因此可以很容易构建归并树：</p>
<p><img src="/2020/07/24/dataStructure/dataStructure-hjttree/20160420202824621.png" alt="图二：构建归并树"></p>
</li>
<li><p>查询过程</p>
<p>归并树的查询过程比较废物。</p>
<p>为完成查询过程，首先需要构建一个函数 <code>rank</code>，它用于查询指定元素 <code>x</code> 在待查找区间 $[L,R]$ 中属于第几小元素。我们可以从线段树根节点开始，如果当前子树根节点所在区间在 $[L,R]$ 之内，则使用二分查找判断 <code>x</code> 在当前区间内属于第几小元素，否则递归左右子树，并将左右子树递归结构相加返回。二分过程的时间复杂度为 $O(log^N)$，查找区间过程的时间复杂度平均为 $O(log^N)$，故而该函数的时间复杂度平均为 $O(log^N * log^N)$ 。</p>
<p>由于线段树根节点所保存数组为有序的，那么我们可以再次使用二分算法搜索待查找区间 $[L,R]$ 内的第 $K$ 小元素。我们首先取中间位置元素，并且假定该元素为待查找区间 $[L,R]$ 中第 $k$ 小元素。如果 $k &gt; K$，则待查找区间 $[L,R]$ 内的第 $K$ 小元素应当位于左半部分；否则位于右半部分，然后进一步缩小区间查找即可。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-权值线段树</title>
    <url>/2020/07/24/dataStructure/dataStructure-weightsegmenttree/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>权值线段树</strong> 属于一种特殊的线段树。普通线段树基于元素个数开辟节点空间，节点之内维护特定信息 (例如，区间最大值、区间最小值)，权值线段树则基于元素值域开辟节点空间，节点之内维护当前区间内的元素个数。</p>
<a id="more"></a>

<p>其结构图大致如下：</p>
<p><img src="/2020/07/24/dataStructure/dataStructure-weightsegmenttree/image-20200724111818405.png" alt="图一：权值线段树"></p>
<p>由于节点维护当前区间内的元素个数，故而权值线段树可以 $O(log^N)$ 时间查找整个区间内第 $K$ 大/小元素。</p>
<p>权值线段树具有一个非常重要的性质：假定所有元素按序尾部插入到数组之中，那么数组 $[0,R]$ 对应的权值线段树减去数组 $[0,L-1]$ 对应的权值线段树就是数组 $[L,R]$ 对应的权值线段树。如果保存以往的权值线段树，那么就可以在 $log^N$ 时间复杂度内实现查询任意指定区间 $[L,R]$ 内的第 $K$ 大/小元素，这也是主席树的基本思想。</p>
<blockquote>
<ul>
<li>如果了解桶排序，容易知道：权值线段树维护的是桶信息。</li>
</ul>
</blockquote>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>在 <a href="/2020/07/16/dataStructure/dataStructure-segmenttree/" title="数据结构-线段树">数据结构-线段树</a> 中，我们直接使用数组实现线段树。这里采用一种不同的写法，我们选用静态链表进行实现。另外我们直接指定元素类型为 <code>int</code> 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeightSegmentTree</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 权值数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] tree;</span><br><span class="line">    <span class="comment">// 左儿子</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] left;</span><br><span class="line">    <span class="comment">// 右儿子</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] right;</span><br><span class="line">    <span class="comment">// 节点计数(以此方式指定左右儿子节点在tree中位置)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> nodeCount;</span><br><span class="line">    <span class="comment">// 最大边界，故而值域范围为[0,1000]</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> Bound = <span class="number">1000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="辅助方法"><a href="#辅助方法" class="headerlink" title="辅助方法"></a>辅助方法</h3><ul>
<li><p>构建权值线段树</p>
<p>以 <code>root</code> 为根节点、所负责区间为 $[l,r]$ 的子树基于含有元素个数信息的 <code>sum</code> 进行构建权值线段树。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> l, <span class="keyword">int</span> r, HashMap&lt;Integer, Integer&gt; sum)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 区间内仅有一个值，则赋值sum中该值对应的个数，如果没有就赋值为0。</span></span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        <span class="keyword">this</span>.tree[root] = sum.containsKey(l) ? sum.get(l) : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取中间位置。</span></span><br><span class="line">    <span class="keyword">int</span> mid = (l + r ) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 基于nodeCount构建左右儿子节点。</span></span><br><span class="line">    <span class="keyword">this</span>.left[root] = ++nodeCount;</span><br><span class="line">    <span class="keyword">this</span>.right[root] = ++nodeCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归构建左右子树。</span></span><br><span class="line">    build(<span class="keyword">this</span>.left[root], l, mid, sum);</span><br><span class="line">    build(<span class="keyword">this</span>.right[root], mid + <span class="number">1</span>, r, sum);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新根节点值。</span></span><br><span class="line">    <span class="keyword">this</span>.tree[root] = <span class="keyword">this</span>.tree[<span class="keyword">this</span>.left[root]] + <span class="keyword">this</span>.tree[<span class="keyword">this</span>.right[root]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>当前子树内查询第 $K$ 小元素 ($K \in[0,\infty)$)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getKthTree</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前子树所负责区域仅有一个值，如果对应元素个数大于k，则返回该元素，否则表明不存在，直接返回一个负数。</span></span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">this</span>.tree[root] &gt; k) ? l : -WeightSegmentTree.Bound;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取中间位置。</span></span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取左子树所负责区间中的元素个数</span></span><br><span class="line">    <span class="keyword">int</span> x = <span class="keyword">this</span>.tree[<span class="keyword">this</span>.left[root]];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// x&gt;k，表明第k小元素在左子树之中，故而应在左子树中进行查询；否则在右子树中进行查询。</span></span><br><span class="line">    <span class="keyword">if</span> (x &gt; k) &#123;</span><br><span class="line">        <span class="keyword">return</span> getKthTree(<span class="keyword">this</span>.left[root], l, mid, k);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getKthTree(<span class="keyword">this</span>.right[root], mid + <span class="number">1</span>, r, k - x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第 $K$ 大元素代码与此类似，故不赘述。</p>
</blockquote>
</li>
<li><p>当前子树插入/删除指定元素若干次</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> num, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        <span class="comment">// 如果更新有效，则更新，否则不更新。</span></span><br><span class="line">        <span class="keyword">this</span>.tree[root] = (<span class="keyword">this</span>.tree[root] + count &gt;= <span class="number">0</span>) ? <span class="keyword">this</span>.tree[root] + count : <span class="keyword">this</span>.tree[root];</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取中间位置。</span></span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据中间位置判断指定元素位于何处。如果位于左子树，则在左子树中更新，否则在右子树中更新。</span></span><br><span class="line">    <span class="keyword">if</span> (mid &gt;= num) &#123;</span><br><span class="line">        update(<span class="keyword">this</span>.left[root], l, mid, num ,count);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        update(<span class="keyword">this</span>.right[root], l, mid, num ,count);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更新根节点值。</span></span><br><span class="line">    <span class="keyword">this</span>.tree[root] = <span class="keyword">this</span>.tree[<span class="keyword">this</span>.left[root]] + <span class="keyword">this</span>.tree[<span class="keyword">this</span>.right[root]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">WeightSegmentTree</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 为各数组赋予足够大的空间。</span></span><br><span class="line">    <span class="keyword">this</span>.tree = <span class="keyword">new</span> <span class="keyword">int</span>[WeightSegmentTree.Bound &lt;&lt; <span class="number">5</span>];</span><br><span class="line">    <span class="keyword">this</span>.left = <span class="keyword">new</span> <span class="keyword">int</span>[WeightSegmentTree.Bound &lt;&lt; <span class="number">5</span>];</span><br><span class="line">    <span class="keyword">this</span>.right = <span class="keyword">new</span> <span class="keyword">int</span>[WeightSegmentTree.Bound &lt;&lt; <span class="number">5</span>];</span><br><span class="line">    <span class="keyword">this</span>.nodeCount = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计各元素的个数信息。</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; sum = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> element : arr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sum.containsKey(element)) &#123;</span><br><span class="line">            sum.replace(element, sum.get(element) + <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sum.put(element, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建根节点</span></span><br><span class="line">    <span class="keyword">int</span> root = ++<span class="keyword">this</span>.nodeCount;</span><br><span class="line">    build(root, <span class="number">0</span>, WeightSegmentTree.Bound, sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><ul>
<li><p>查询第$K$小元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getKth</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getKthTree(<span class="number">0</span>, <span class="number">0</span>, WeightSegmentTree.Bound, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="操纵"><a href="#操纵" class="headerlink" title="操纵"></a>操纵</h3></li>
<li><p>插入/删除指定元素若干次</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果该值不在当前值域之中，则直接返回。</span></span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="number">0</span> || num &gt; WeightSegmentTree.Bound) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    update(<span class="number">0</span>, <span class="number">0</span>, WeightSegmentTree.Bound, num, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-树状数组(二叉索引树)</title>
    <url>/2020/07/17/dataStructure/dataStructure-binaryindexedtree/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>树状数组 (二叉索引树)</strong> 是一种用以维护<em>区间信息</em> 的数据结构。它具有实现简单、操作时间复杂度常数低于线段树等优点，但是它的适用范围小于线段树。</p>
<a id="more"></a>

<p>其结构图大致如下：</p>
<img src="/2020/07/17/dataStructure/dataStructure-binaryindexedtree/v2-9534bfb8a16941e7bba2af2e8cc934eb_b.png" alt="图一：树状数组" style="zoom:80%;">

<p>树状数组常用于求取指定区间元素之和，故而我们以此为引，讲述树状数组的思想。</p>
<p>假定存在一个数组 $A = [a_1, a_2, \dots, a_n]$ ，其上有两种操作：求取指定区间 $[fromIndex, toIndex]$ 元素之和、动态修改指定位置 $index$ 所在元素。我们很容易想到如下两种方案以满足这两种操作：</p>
<ol>
<li><p>基于普通数组</p>
<p>直接在该数组之上执行这两种操作。对于第一个操作而言，遍历指定区间，求和各元素，其时间复杂度为 $O(N)$；对于第二个操作，直接修改指定位置元素，其时间复杂度为 $O(1)$ 。</p>
</li>
<li><p>基于前缀数组</p>
<p>将该数组转换为前缀数组 $prefix[]$ 以执行这两种操作。对于第一种操作而言，$prefix(toIndex) - prefix(fromIndex - 1)$ 即为指定区间元素之和，其时间复杂度为 $O(1)$；对于第二种操作，由于该位置之后的前缀元素都涉及加和该元素，故而需修改区间 $[index, prefix.length - 1]$ 内的所有元素，其时间复杂度为 $O(N)$ 。</p>
</li>
</ol>
<p>从上述描述中，可以看到：两种方案各有优缺点，一种操作的时间复杂度极低，另一种操作的时间复杂度极高。对于树状数组而言，它可保证两种操作的时间复杂度均为 $O(log^N)$，这一点通过 “分层构造前缀和” 而做到。</p>
<p>树状数组其本质是一个数组，只不过基于数组索引的二进制位将数组逻辑映射为一棵树。我们首先介绍若干概念：</p>
<ol>
<li><p>$lowBit(index)$ </p>
<p>$lowBit(index)$ 定义为非负整数 $index$ 在二进制位表示下 “最低位的 $1$ 及其后所有的 $0$ “ 构成的数值。</p>
<p>举例：$lowBit(24) = lowBit(0b00011000) = 0b1000 = 8$ 。</p>
</li>
<li><p>$rangSum(index)$</p>
<p>$rangSum(index)$ 定义为当前位置开始前 $i$ 个数之和，其中 $i = 2^k$，$k$ 为 $index$ 的二进制位表示下低位连续 $0$ 的个数。该定义同样可表示为当前位置开始前 $lowBit(index)$ 个数之和。</p>
<p>举例：$rangSum(24) = rangSum(0b00011000)$，其为当前位置 $24$ 开始前 $2^3 = 8$ 个数之和，即区间 $[17,24]$ 元素之和。</p>
</li>
</ol>
<p>基于此二者概念，按照 $rangSum(index)$ 所覆区间范围，可将其抽象为一棵树，具体如图一所示。</p>
<p>如果修改指定位置所在元素，只要向上依次修改其对应父节点所在元素即可，这一点可基于 $lowBit(index)$ 实现。例如：$parent(5) = 5 + lowBit(5) = 6， parent(6) = 6 + lowBit(6) = 8$ 。</p>
<p>另外，我们还可容易计算 $prefix(index)$ (假定数组开始位置为 $1$)，同样以图一举例说明：</p>
<p>$$prefix(6) = rangSum(6) + rangSum(6 - lowBit(6)) = rangSum(6) + rangSum(4) = [5,6] + [1,4]$$</p>
<blockquote>
<p>树状数组不仅可用于指定区间求和，还可用于指定区间求最大值、指定区间求最小值等操作，但是为叙述方便，上述均以指定区间求和为例进行解释。</p>
</blockquote>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryIndexedTree</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 树状数组</span></span><br><span class="line">    <span class="keyword">private</span> Object[] bitArr;</span><br><span class="line">    <span class="comment">// 合并函数</span></span><br><span class="line">    <span class="keyword">private</span> Merge&lt;E&gt; merger;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Merge</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">E <span class="title">merge</span><span class="params">(E o1, E o2)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对应到求取 $prefix(index)$，接口实现应当为 $merger = (o1, o2) -&gt; o1 + o2$ 。</p>
</blockquote>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="辅助方法"><a href="#辅助方法" class="headerlink" title="辅助方法"></a>辅助方法</h3><ul>
<li><p>$lowBit()$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lowBit</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> index &amp; (-index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3></li>
</ul>
<p>树状数组初始化有两种方式，在此一一叙述：</p>
<ol>
<li><p>基于更新实现</p>
<p>最初置 $bitArr$ 中元素均为 $0$，顺序使用 $update()$ 更新每位。这种做法的时间复杂度为 $O(Nlog^N)$，但是它揭示了树状数组可在尾部插入元素这一事实。</p>
</li>
<li><p>直接遍历实现</p>
<p>首先置 $bitArr$ 中元素均为元素数组对应元素，然后顺序遍历该数组，当遍历到某一个位置时，将当前元素合并到其父节点所在元素之中即可。这种做法的时间复杂度为 $O(N)$。代码实现中使用的便是这种做法。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BinaryIndexedTree</span><span class="params">(E[] arr, Merge&lt;E&gt; merger)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 相比于原始数组而言，树状数组元素需后移一位。</span></span><br><span class="line">    <span class="keyword">this</span>.bitArr = <span class="keyword">new</span> Object[arr.length + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">this</span>.merger = merger;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>.bitArr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">this</span>.bitArr[i] = arr[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>.bitArr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = i + lowBit(i);</span><br><span class="line">        <span class="keyword">if</span> (j &lt; <span class="keyword">this</span>.bitArr.length) &#123;</span><br><span class="line">            <span class="keyword">this</span>.bitArr[j] = <span class="keyword">this</span>.merger.merge((E) <span class="keyword">this</span>.bitArr[j], (E) <span class="keyword">this</span>.bitArr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><ul>
<li><p>查询指定区间 $[0,index]$ 值 </p>
<p>该值可以是区间元素之和、区间最大值、区间最小值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">query</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// bitArr中元素均后移一位，故而需有此操作。</span></span><br><span class="line">    index++;</span><br><span class="line">    <span class="comment">// 输入非法，直接返回。</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt;= <span class="number">0</span> || index &gt;= <span class="keyword">this</span>.bitArr.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    E result = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (index != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == result) &#123;</span><br><span class="line">            result = (E) <span class="keyword">this</span>.bitArr[index];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result = <span class="keyword">this</span>.merger.merge(result, (E) <span class="keyword">this</span>.bitArr[index]);</span><br><span class="line">        &#125;</span><br><span class="line">        index -= lowBit(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="操纵"><a href="#操纵" class="headerlink" title="操纵"></a>操纵</h3></li>
<li><p>为指定位置元素加上某一差值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> index, E delta)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// bitArr中元素均后移一位，故而需有此操作。</span></span><br><span class="line">    index++;</span><br><span class="line">    <span class="comment">// 输入非法，直接返回。</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt;= <span class="number">0</span> || index &gt;= <span class="keyword">this</span>.bitArr.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (index &lt; <span class="keyword">this</span>.bitArr.length) &#123;</span><br><span class="line">        <span class="keyword">this</span>.bitArr[index] = <span class="keyword">this</span>.merger.merge((E) <span class="keyword">this</span>.bitArr[index], delta);</span><br><span class="line">        index += lowBit(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>这里介绍一种类似的数据结构——ST表。</p>
<p>ST表常用于解决 <strong>可重复贡献问题</strong> 。它可实现 $O(Nlog^N)$ 内建表、$O(1)$ 内查询，但是无法动态修改。</p>
<blockquote>
<p><strong>可重复贡献问题：</strong></p>
<p>对于运算 $opt$，如果满足 $x \ opt \ x = x $，则对应的区间查询就是一个可重复贡献问题。例如，区间最大值、区间最小值，但是区间求和就不是一个可重复贡献问题。</p>
</blockquote>
<p>ST表其本质是基于倍增思想、动态规划构建的一张二维表格。这里以求取区间最大值为例。</p>
<p>我们规定：$A$ 为元素数组、$f[i][j]$ 表示区间 $[i,i + 2^j - 1]$ 内元素最大值。</p>
<p>初始化条件即为：$f[i][0] = A[i], i \in [0, A.length]$ 。</p>
<p>状态转换方程即为：$f[i][j] = max(f[i][j - 1],f[i + 2^{j - 1}][j - 1])$ 。</p>
<p>基于上面两个等式，即可构建这张表。表大小为 $O(Nlog^N)$，故而建表的时间复杂度亦是如此。</p>
<p>对于任意指定区间 $[L,R]$，区间内最大值即为 $max(f[L][k],f[R - 2^{k} + 1][k]), \  k= \lfloor log_2^{(R - L + 1)}\rfloor$ 。</p>
<blockquote>
<p>该等式成立原因即在于：$2^{\lfloor log_2^{(R - L + 1)}\rfloor} &gt;= (R - L + 1) / 2$。正因如此，从 $L$ 开始前向 $2^k$ 个元素对应区间与从 $R$ 开始后向 $2^k$ 个元素对应区间的并集一定等于 $[L,R]$，故而二者之间的最大值亦为区间 $[L,R]$ 的最大值。从中也可看出，$f[L][k]$ 与 $f[R - 2^{k} + 1][k]$ 所覆盖区间是有重叠的，这也正是 “ST表只能解决可重复贡献问题” 的原因。</p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>线性表</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-线段树</title>
    <url>/2020/07/16/dataStructure/dataStructure-segmenttree/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>线段树</strong> 是一种用以维护<em>区间信息</em> 的数据结构，它可在 $O(log^N)$ 时间内实现单点修改、区间修改、区间查询（区间求和，求区间最大值，求区间最小值）等操作。</p>
<a id="more"></a>

<p>其结构图大致如下：</p>
<img src="/2020/07/16/dataStructure/dataStructure-segmenttree/2971b5df5eba05a50650ec77e938d28689108333de3802c194b0b9982e881999-u=1091946519,1765257349&amp;fm=26&amp;gp=0.png" alt="图一：线段树" style="zoom:50%;">

<p>关于线段树，以下几点需要注意：</p>
<ol>
<li>线段树与区间树没有任何关系。</li>
<li>线段树不支持插入、删除操作。</li>
<li>叶节点保存数组中指定位置元素，非叶节点保存所在区间的值 (例如：区间最大值、区间最小值)。</li>
</ol>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>观察图一，发现其结构基本等同于一棵完全二叉树，故而我们使用数组加以实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SegmentTree</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 基础数组(从0开始)</span></span><br><span class="line">    <span class="keyword">private</span> Object[] elementData;</span><br><span class="line">    <span class="comment">// 线段树元素个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="comment">// 合并接口</span></span><br><span class="line">    <span class="keyword">private</span> Merge&lt;E&gt; merger;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Merge</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">E <span class="title">merge</span><span class="params">(E o1, E o2)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="辅助方法"><a href="#辅助方法" class="headerlink" title="辅助方法"></a>辅助方法</h3><ul>
<li><p>构建线段树</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> treeIndex, <span class="keyword">int</span> l, <span class="keyword">int</span> r, E[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 到达叶节点，直接赋值、返回即可。</span></span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData[treeIndex] = arr[l];</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取中间位置、左节点位置、右节点位置。</span></span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> leftTreeIndex = treeIndex * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> rightTreeIndex = treeIndex * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 递归构建左右子树，并更新当前节点所在区间值。</span></span><br><span class="line">    build(leftTreeIndex, l, mid, arr);</span><br><span class="line">    build(rightTreeIndex, mid + <span class="number">1</span>, r, arr);</span><br><span class="line">    <span class="keyword">this</span>.elementData[treeIndex] = merger.merge((E) <span class="keyword">this</span>.elementData[leftTreeIndex], (E) <span class="keyword">this</span>.elementData[rightTreeIndex]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>当前子树查询指定区间值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">queryTree</span><span class="params">(<span class="keyword">int</span> treeIndex, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 满足查询区间，直接返回即可。</span></span><br><span class="line">    <span class="keyword">if</span> (l == left &amp;&amp; r == right) &#123;</span><br><span class="line">        <span class="keyword">return</span> (E) <span class="keyword">this</span>.elementData[treeIndex];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取中间位置、左节点位置、右节点位置。</span></span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> leftTreeIndex = treeIndex * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> rightTreeIndex = treeIndex * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查询区间在左子树所在区间之中，则在左子树中进行查询。</span></span><br><span class="line">    <span class="keyword">if</span> (mid &gt;= right) &#123;</span><br><span class="line">        <span class="keyword">return</span> queryTree(leftTreeIndex, l, mid, left, right);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mid &lt; left) &#123;</span><br><span class="line">        <span class="comment">// 查询区间在右子树所在区间之中，则在右子树中进行查询。</span></span><br><span class="line">        <span class="keyword">return</span> queryTree(rightTreeIndex, mid + <span class="number">1</span>, r, left, right);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 查询区间横贯左右子树所在区间，则在左右子树中进行相应查找，然后合并查询结果即可。</span></span><br><span class="line">        <span class="keyword">return</span> merger.merge(queryTree(leftTreeIndex, l, mid, left, mid), queryTree(rightTreeIndex, mid + <span class="number">1</span>, r, mid + <span class="number">1</span>, right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>当前子树更新指定位置元素内容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateTree</span><span class="params">(<span class="keyword">int</span> treeIndex, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> index, E value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 找到指定位置元素，直接修改即可。</span></span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData[treeIndex] = value;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取中间位置、左节点位置、右节点位置。</span></span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> leftTreeIndex = treeIndex * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> rightTreeIndex = treeIndex * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果指定位置在左子树所在区间之中，则在左子树中进行修改，反之则在右子树中进行修改。</span></span><br><span class="line">    <span class="keyword">if</span> (mid &gt;= index) &#123;</span><br><span class="line">        updateTree(leftTreeIndex, l, mid, index, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        updateTree(rightTreeIndex, mid + <span class="number">1</span>, r, index, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新当前节点所在区间值。</span></span><br><span class="line">    <span class="keyword">this</span>.elementData[treeIndex] = merger.merge((E) <span class="keyword">this</span>.elementData[leftTreeIndex], (E) <span class="keyword">this</span>.elementData[rightTreeIndex]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SegmentTree</span><span class="params">(E[] arr, Merge&lt;E&gt; merger)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据相关推理，如果数组长度为N,对应线段树最多需要4N空间。</span></span><br><span class="line">    <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[<span class="number">4</span> * arr.length];</span><br><span class="line">    <span class="keyword">this</span>.size = arr.length;</span><br><span class="line">    <span class="keyword">this</span>.merger = merger;</span><br><span class="line"></span><br><span class="line">    build(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">this</span>.size - <span class="number">1</span>, arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><ul>
<li><p>查询指定区间的值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">query</span><span class="params">(<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; <span class="number">0</span> || right &gt;= <span class="keyword">this</span>.size || left &lt; right) &#123;</span><br><span class="line">        <span class="comment">// 输入非法，直接返回。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queryTree(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">this</span>.size - <span class="number">1</span>, left, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="操纵"><a href="#操纵" class="headerlink" title="操纵"></a>操纵</h3></li>
<li><p>更新指定位置元素内容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> index, E value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="keyword">this</span>.size) &#123;</span><br><span class="line">        <span class="comment">// 输入非法，直接返回。</span></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    updateTree(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">this</span>.size - <span class="number">1</span>, index, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>更新指定区间内容</p>
<p>更新指定区间内容涉及更新具体操作，我们在此规定情景，并指明更新区间内容的方法。</p>
<p>我们规定情景如下：</p>
<ol>
<li>非叶节点保存所在区间元素的最大值。</li>
<li>更新操作为：为指定区间所有元素均加上某一常数。</li>
</ol>
<p>搜索找到区间内所有元素，并为其加上某一常数，这样即可达到更新目的。显而易见，这种方式的时间复杂度为 $O(N)$。为使得更新操作复杂度降为 $O(log^N)$，线段树引入懒更新。</p>
<p>首先在节点结构中引入 <code>mark</code> 字段 (其意义：为左右子树各元素需要加上的常数)。进行更新操作时，我们找到需要更新区间对应的节点，然后仅更新这些节点的所在区间值和 <code>mark</code> 字段。后续查询到某个节点时，如果该节点的 <code>mark</code> 字段非零，表明左右子树需要更新，则更新左右子树根节点的信息 (如果左右子树根节点被访问，则进一步更新对应节点的左右子树根节点，直至到达叶节点)。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-块状链表</title>
    <url>/2020/07/13/dataStructure/dataStructure-blocklist/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>块状链表</strong> 是一种比较中庸的数据结构。它将 “分块思想” 应用于链表之中，从而整合了线性表与链表的优缺点，使得其上操作的时间复杂度均为 $O(\sqrt{N})$。</p>
<a id="more"></a>

<p>其结构图大致如下：</p>
<p><img src="/2020/07/13/dataStructure/dataStructure-blocklist/image-20200713144042279.png" alt="图一：块状链表"></p>
<p>假定数据总量为 $N$，将这些数据均分为 $\sqrt{N}$ 块，块内数据使用线性表进行存储，块间使用引用进行链接，如此组织便是块状链表。对块状链表操作时，首先需要花费 $O(\sqrt{N})$ 时间定位到块，随后花费 $O(\sqrt{N})$ 在块内执行操作，故而操作的时间复杂度为 $O(\sqrt{N})$。</p>
<blockquote>
<p>“分块思想” 其本质为一棵仅有三层的多叉树，其结构如图所示。</p>
<img src="/2020/07/13/dataStructure/dataStructure-blocklist/20200115105823531.png" alt="图二：分块思想" style="zoom: 25%;">
</blockquote>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>块状链表中存储的数据量大小通常是未知的，故而通常需要预估数据量大小以指定块大小。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlockList</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 节点结构</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">// 块内元素个数</span></span><br><span class="line">        <span class="keyword">int</span> blockSize;</span><br><span class="line">        <span class="comment">// 块内线性表</span></span><br><span class="line">        Object[] blockArr;</span><br><span class="line">        <span class="comment">// 后继块</span></span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.blockSize = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">this</span>.blockArr = <span class="keyword">new</span> Object[BlockList.BLOCK_SIZE];</span><br><span class="line">            <span class="keyword">this</span>.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 块大小</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BLOCK_SIZE = <span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 链首</span></span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>块状链表中块大小及块个数决定着操作的时间复杂度，因此每次操作后需要对此二者进行一定调整。</p>
<h3 id="辅助方法"><a href="#辅助方法" class="headerlink" title="辅助方法"></a>辅助方法</h3><ul>
<li><p>相邻块合并</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unionBlock</span><span class="params">(Node&lt;E&gt; e1, Node&lt;E&gt; e2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 合并线性表中元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; e2.blockSize; i++) &#123;</span><br><span class="line">        e1.blockArr[e1.blockSize + i] = e2.blockArr[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新相关字段</span></span><br><span class="line">    e1.blockSize += e2.blockSize;</span><br><span class="line">    e1.next = e2.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>维护链形态</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">maintain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">this</span>.head;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">null</span> != node &amp;&amp; <span class="keyword">null</span> != node.next) &#123;</span><br><span class="line">        <span class="comment">// 如果相邻块中元素个数小于指定的块大小，则需要进行合并。</span></span><br><span class="line">        <span class="keyword">if</span> (node.blockSize + node.next.blockSize &lt; BlockList.BLOCK_SIZE) &#123;</span><br><span class="line">            unionBlock(node, node.next);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在指定位置处分割块</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">splitBlock</span><span class="params">(Node&lt;E&gt; e1, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// index非法，直接返回即可。</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; e1.blockSize) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建新块，并调整引用。</span></span><br><span class="line">    Node&lt;E&gt; e2 = <span class="keyword">new</span> Node&lt;&gt;();</span><br><span class="line">    e2.next = e1.next;</span><br><span class="line">    e1.next = e2;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 分割线性表中元素。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; e1.blockSize; i++) &#123;</span><br><span class="line">        e2.blockArr[i - index] = e1.blockArr[i];</span><br><span class="line">        e2.blockSize++;</span><br><span class="line">        e1.blockArr[i] = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    e1.blockSize = index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BlockList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    head = <span class="keyword">new</span> Node&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><ul>
<li><p>查询指定位置的元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">this</span>.head;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">null</span> != node) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= node.blockSize) &#123;</span><br><span class="line">            index = index - node.blockSize;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span> == node ? <span class="keyword">null</span> : (E) node.blockArr[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="操纵"><a href="#操纵" class="headerlink" title="操纵"></a>操纵</h3></li>
<li><p>块状链表中添加元素</p>
<p>我们假定块中元素个数始终小于指定的块大小。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> index, E item)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 寻找待插入块及待插入位置</span></span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">this</span>.head;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; node.blockSize) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != node.next) &#123;</span><br><span class="line">                index = index - node.blockSize;</span><br><span class="line">                node = node.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 插入位置有误，直接返回即可。</span></span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素至指定位置。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = node.blockSize; i &gt; index; i--) &#123;</span><br><span class="line">        node.blockArr[i] = node.blockArr[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    node.blockArr[index] = item;</span><br><span class="line">    node.blockSize++;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 插入元素后，如果块已满，则需要从中部分割块。</span></span><br><span class="line">    <span class="keyword">if</span> (node.blockSize == BlockList.BLOCK_SIZE) &#123;</span><br><span class="line">        splitBlock(node, BlockList.BLOCK_SIZE / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    maintain();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>块状链表中删除元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 寻找待删除块及待删除位置</span></span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">this</span>.head;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">null</span> != node) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= node.blockSize) &#123;</span><br><span class="line">            index = index - node.blockSize;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有找到，直接返回即可。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == node) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除指定元素。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; node.blockSize - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        node.blockArr[i] = node.blockArr[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    node.blockSize--;</span><br><span class="line">    node.blockArr[node.blockSize] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    maintain();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>线性表</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-配对堆</title>
    <url>/2020/07/12/dataStructure/dataStructure-pairheap/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>配对堆</strong> 是斐波那契堆的简化版本。其不仅具有斐波那契堆那般优秀的操作复杂度，同时易于实现。</p>
<a id="more"></a>

<p>其结构图大致如下：</p>
<p><img src="/2020/07/12/dataStructure/dataStructure-pairheap/%E4%B8%8B%E8%BD%BD.png" alt="图一：配对堆"></p>
<p>相比斐波那契堆实现而言，配对堆主要在如下两个方面进行优化：1. 优化节点结构，节省节点所需内存空间；2. 降低各种操作的编码复杂度。</p>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>配对堆中节点除保存具体元素外，仅需保存三个引用即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PairHeap</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 节点结构</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">// 具体元素</span></span><br><span class="line">        E item;</span><br><span class="line">        <span class="comment">// 左儿子</span></span><br><span class="line">        Node&lt;E&gt; leftChild;</span><br><span class="line">        <span class="comment">// 兄弟节点</span></span><br><span class="line">        Node&lt;E&gt; nextSibling;</span><br><span class="line">        <span class="comment">// 前驱节点，如果当前节点为第一个左儿子，其指向即为父节点。</span></span><br><span class="line">        Node&lt;E&gt; pre;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E item, Node&lt;E&gt; leftChild, Node&lt;E&gt; nextSibling, Node&lt;E&gt; pre)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.item = item;</span><br><span class="line">            <span class="keyword">this</span>.leftChild = leftChild;</span><br><span class="line">            <span class="keyword">this</span>.nextSibling = nextSibling;</span><br><span class="line">            <span class="keyword">this</span>.pre = pre;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根节点</span></span><br><span class="line">    Node&lt;E&gt; root;</span><br><span class="line">    <span class="comment">// 比较函数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> E&gt; comparator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="辅助方法"><a href="#辅助方法" class="headerlink" title="辅助方法"></a>辅助方法</h3><ul>
<li><p>重置 <code>pre</code> 与 <code>nextSibling</code> 引用</p>
<p>重置此二者，保证配对堆合法（配对堆根节点的 <code>pre</code> 与 <code>nextSibling</code> 应当为 <code>null</code>）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">(Node&lt;E&gt; root)</span> </span>&#123;</span><br><span class="line">    root.pre = <span class="keyword">null</span>;</span><br><span class="line">    root.nextSibling = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>合并两个配对堆</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;E&gt; <span class="title">merge</span><span class="params">(Node&lt;E&gt; root1, Node&lt;E&gt; root2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 只要一者为空，直接返回另一者即可。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == root1) &#123;</span><br><span class="line">        <span class="keyword">return</span> root2;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">null</span> == root2) &#123;</span><br><span class="line">        <span class="keyword">return</span> root1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果前者大于后者，则应交换二者。</span></span><br><span class="line">    <span class="keyword">if</span> (comparator.compare(root1.item, root2.item) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> merge(root2, root1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保证配对堆合法。</span></span><br><span class="line">    reset(root1);</span><br><span class="line">    reset(root2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调整相关引用。</span></span><br><span class="line">    root2.nextSibling = root1.leftChild;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != root1.leftChild) &#123;</span><br><span class="line">        root1.leftChild.pre = root2;</span><br><span class="line">    &#125;</span><br><span class="line">    root1.leftChild = root2;</span><br><span class="line">    root2.pre = root1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>合并一个节点的所有兄弟节点</p>
<p>合并兄弟节点的顺序是有要求的：所有兄弟节点按顺序从前往后两两配对进行合并，随后从后往前依次合并即可。只有按照此种方式进行合并，才能够保证 $O(log^N)$ 的复杂度界限。</p>
<img src="/2020/07/12/dataStructure/dataStructure-pairheap/image-20200712214247925.png" alt="图二：合并一个节点的所有兄弟节点" style="zoom: 50%;">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;E&gt; <span class="title">merges</span><span class="params">(Node&lt;E&gt; root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前节点为空，或者没有任何儿子节点，直接返回该节点即可。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == root || <span class="keyword">null</span> == root.nextSibling) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != root) &#123;</span><br><span class="line">            reset(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出前两个兄弟节点</span></span><br><span class="line">    Node&lt;E&gt; first = root;</span><br><span class="line">    Node&lt;E&gt; second = first.nextSibling;</span><br><span class="line">    root = second.nextSibling;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> merge(merge(first, second), merges(root));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PairHeap</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><ul>
<li><p>查询最小元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span> == <span class="keyword">this</span>.root ? <span class="keyword">null</span> : <span class="keyword">this</span>.root.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="操纵"><a href="#操纵" class="headerlink" title="操纵"></a>操纵</h3></li>
<li><p>配对堆合并</p>
<p>直接合并即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(PairHeap&lt;E&gt; pairHeap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.root = merge(<span class="keyword">this</span>.root, pairHeap.root);</span><br><span class="line">    pairHeap.root = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>配对堆中添加元素</p>
<p>将待添加元素包装为一个配对堆，然后合并两个堆即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E item)</span> </span>&#123;</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;&gt;(item, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">this</span>.root = merge(<span class="keyword">this</span>.root, node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>配对堆中删除最小元素</p>
<p>合并根节点的所有儿子节点，然后将合并结果赋值给 <code>this.root</code> 即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == <span class="keyword">this</span>.root) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.root = merges(<span class="keyword">this</span>.root.leftChild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>配对堆中指定节点降低元素值</p>
<p>将指定节点所表示的配对堆从当前配对堆中剔除，合并两个配对堆即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decreaseKey</span><span class="params">(Node&lt;E&gt; node, E item)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果修改值大于当前值，则直接返回。</span></span><br><span class="line">    <span class="keyword">if</span> (comparator.compare(node.item, item) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node.item = item;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定节点为根节点，直接返回即可。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == node.pre) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从配对堆中剔除指定节点所表示的子配对堆。</span></span><br><span class="line">    <span class="comment">// 当前节点为第一个儿子节点</span></span><br><span class="line">    <span class="keyword">if</span> (node.pre.leftChild == node) &#123;</span><br><span class="line">        node.pre.leftChild = node.nextSibling;</span><br><span class="line">        node.nextSibling.pre = node.pre;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node.pre.nextSibling = node.nextSibling;</span><br><span class="line">        node.nextSibling.pre = node.pre;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.root = merge(<span class="keyword">this</span>.root, node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>配对堆中删除指定节点</p>
<p>通过降低元素值方式使指定节点称为根节点，然后删除根节点即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">    decreaseKey(node, <span class="keyword">this</span>.root.item);</span><br><span class="line">    deleteMin();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-k-d树</title>
    <url>/2020/07/11/dataStructure/dataStructure-kdtree/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>k-d 树</strong> 是在 $k$ 维欧几里德空间中组织点的一种数据结构。其可应用于多种场合，例如多维键值查询、范围查询、最近邻搜索。</p>
<a id="more"></a>

<p>其结构图大致如下：</p>
<p><img src="/2020/07/11/dataStructure/dataStructure-kdtree/111.jpg" alt="图一：k-d树"></p>
<p>k-d 树看似复杂，其实原理十分简单。本文之中，我们便以 1-d树、2-d树为例说明 k-d树的原理。</p>
<ul>
<li><p>1-d 树</p>
<p>1-d 树是在一维空间 (直线) 中组织点的一种数据结构，其实就是二叉查找树。观察该种数据结构，可以发现：它借由某个点将直线划分为两部分，前半部分直线中点所表示的数据均小于该点所表示的数据，后半部分直线中点所表示的数据均大于该点所表示的数据。通过这种有序组织数据，可避免无效的搜索，从而降低查询操作的时间复杂度。</p>
<img src="/2020/07/11/dataStructure/dataStructure-kdtree/image-20200711165142924.png" alt="图二：1-d树映射于直线" width="50%">
</li>
<li><p>2-d 树</p>
<p>2-d 树是在二维空间 (平面) 中组织点的一种数据结构。为降低查询操作的时间复杂度，我们同样需要有序组织数据。按照升维的一般规律，我们可以这样设想该种数据结构 (实际上也是这么做的)：它借由某条直线将平面划分为两部分，前半部分平面中点所表示的数据均小于该条直线上点所表示的数据，后半部分平面中点所表示的数据均大于该条直线上点所表示的数据。</p>
<p><img src="/2020/07/11/dataStructure/dataStructure-kdtree/1359957049_9183.jpg" alt="图三：2-d树映射于平面"></p>
</li>
</ul>
<p>从上面例子中，可以窥知：k-d 树会借由某种方式将 $k$ 维空间划分为两部分，并以此有序组织数据，从而更为快速地完成数据查询。</p>
<p>考虑到 2-d树易于实现，因此本文仅涉及 2-d树的代码实现。上面例子仅说明了 2-d树的原理，接下来通过几个问题详细描述一下 2-d树的实现方式。</p>
<ol>
<li><p>如何表示这条直线？</p>
<p>对于一个 $k$ 维空间，仅以某一维度的数据值进行排序，这样便会将该空间划分为两部分。对于二维空间而言，其将映射为一条直线；对于三维空间而言，其将映射为一个平面。</p>
</li>
<li><p>如何选择维度？</p>
<p>通常有两种维度选择方式：</p>
<ul>
<li>按原始维度顺序依次指定为排序维度，循环往复。对于 2-d树而言，树的第一层按照 $x$ 轴进行排序，树的第二层按照 $y$ 轴进行排序，树的第三层按照 $x$ 轴进行排序，$\dots$。</li>
<li>对初始数据集计算各维度方差，方差大者在前，方差小者在后，以此构建一个维度顺序。按此维度顺序依次指定为排序维度，循环往复。假定根据构建的维度顺序为 $(y,x)$，那么对于 2-d树而言，树的第一层按照 $y$ 轴进行排序，树的第二层按照 $x$ 轴进行排序，树的第三层按照 $y$ 轴进行排序，$\dots$。</li>
</ul>
</li>
<li><p>如何选择这条直线？</p>
<p>假定对数据集中所有数据按照排序维度进行排序，排序结果位于中间的那个多维数据即为划分点。指定当前划分点为根结点，如果一个多维数据的排序维度值小于划分点的排序维度值，那么其将位于左子树之中，否则其将位于右子树之中。</p>
</li>
</ol>
<blockquote>
<p>k-d树查询操作的最好时间复杂度为 $O(log^N)$，最坏时间复杂度为 $O(N^{1 - 1/k})$。如果数据维度较低，综合考虑时间复杂度及编程复杂度，应当选择使用 k-d树，；如果数据维度较高，应当着重考虑时间复杂度，此时需选择使用 R树。</p>
</blockquote>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>为支撑众多功能，2-d树结构比较复杂。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KDTree</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 位置坐标</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> x;</span><br><span class="line">        <span class="keyword">double</span> y;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Point</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.x = x;</span><br><span class="line">            <span class="keyword">this</span>.y = y;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 与指定坐标的曼哈顿距离</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">distance</span><span class="params">(Point point)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Math.abs(<span class="keyword">this</span>.x - point.x) + Math.abs(<span class="keyword">this</span>.y - point.y);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 比较函数</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Point point, <span class="keyword">boolean</span> dimension)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (dimension) &#123;</span><br><span class="line">                <span class="keyword">return</span> Double.compare(<span class="keyword">this</span>.x, point.x);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> Double.compare(<span class="keyword">this</span>.y, point.y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 比较器</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Comparator <span class="title">comparator</span><span class="params">(<span class="keyword">boolean</span> dimension)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (dimension) &#123;</span><br><span class="line">                <span class="keyword">return</span> (o1, o2) -&gt; Double.compare(((Point) o1).x, ((Point) o2).x);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> (o1, o2) -&gt; Double.compare(((Point) o1).y, ((Point) o2).y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 克隆</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Point <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 节点结构</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 具体元素</span></span><br><span class="line">        Point item;</span><br><span class="line">        <span class="comment">// 节点所覆盖区域左下角的位置坐标</span></span><br><span class="line">        Point leftBottom;</span><br><span class="line">        <span class="comment">// 节点所覆盖区域右上角的位置坐标</span></span><br><span class="line">        Point rightUp;</span><br><span class="line">        <span class="comment">// 左儿子</span></span><br><span class="line">        Node left;</span><br><span class="line">        <span class="comment">// 右儿子</span></span><br><span class="line">        Node right;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Point item, Point leftBottom, Point rightUp, Node left, Node right)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.item = item;</span><br><span class="line">            <span class="keyword">this</span>.leftBottom = leftBottom;</span><br><span class="line">            <span class="keyword">this</span>.rightUp = rightUp;</span><br><span class="line">            <span class="keyword">this</span>.left = left;</span><br><span class="line">            <span class="keyword">this</span>.right = right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新节点所覆盖区域</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">maintain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.leftBottom.x = Math.min(Math.min(<span class="keyword">this</span>.left.leftBottom.x, <span class="keyword">this</span>.right.leftBottom.x), <span class="keyword">this</span>.item.x);</span><br><span class="line">            <span class="keyword">this</span>.leftBottom.y = Math.min(Math.min(<span class="keyword">this</span>.left.leftBottom.y, <span class="keyword">this</span>.right.leftBottom.y), <span class="keyword">this</span>.item.y);</span><br><span class="line">            <span class="keyword">this</span>.rightUp.x = Math.max(Math.max(<span class="keyword">this</span>.left.rightUp.x, <span class="keyword">this</span>.right.rightUp.x), <span class="keyword">this</span>.item.x);</span><br><span class="line">            <span class="keyword">this</span>.rightUp.y = Math.max(Math.max(<span class="keyword">this</span>.left.rightUp.y, <span class="keyword">this</span>.right.rightUp.y), <span class="keyword">this</span>.item.y);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指定坐标与当前节点所覆盖区域的最近曼哈顿距离</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">minDistance</span><span class="params">(Point point)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 如果当前节点为空节点，直接返回无穷大。</span></span><br><span class="line">            <span class="keyword">if</span> (KDTree.nullNode == <span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> KDTree.INF;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">this</span>.leftBottom.x &lt; point.x &amp;&amp; point.x &lt; <span class="keyword">this</span>.rightUp.x)</span><br><span class="line">                    &amp;&amp; (<span class="keyword">this</span>.leftBottom.y &lt; point.y &amp;&amp; point.y &lt; <span class="keyword">this</span>.rightUp.y)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Point leftUp = <span class="keyword">new</span> Point(<span class="keyword">this</span>.leftBottom.x, <span class="keyword">this</span>.rightUp.y);</span><br><span class="line">            Point rightBottom = <span class="keyword">new</span> Point(<span class="keyword">this</span>.rightUp.x, <span class="keyword">this</span>.leftBottom.y);</span><br><span class="line">            <span class="keyword">return</span> Math.min(Math.min(<span class="keyword">this</span>.leftBottom.distance(point), <span class="keyword">this</span>.rightUp.distance(point)),</span><br><span class="line">                    Math.min(leftUp.distance(point), rightBottom.distance(point)));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指定坐标与当前节点所覆盖区域的最远曼哈顿距离</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">maxDistance</span><span class="params">(Point point)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 如果当前节点为空节点，直接返回负无穷大。</span></span><br><span class="line">            <span class="keyword">if</span> (KDTree.nullNode == <span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> -KDTree.INF;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Point leftUp = <span class="keyword">new</span> Point(<span class="keyword">this</span>.leftBottom.x, <span class="keyword">this</span>.rightUp.y);</span><br><span class="line">            Point rightBottom = <span class="keyword">new</span> Point(<span class="keyword">this</span>.rightUp.x, <span class="keyword">this</span>.leftBottom.y);</span><br><span class="line">            <span class="keyword">return</span> Math.max(Math.max(<span class="keyword">this</span>.leftBottom.distance(point), <span class="keyword">this</span>.rightUp.distance(point)),</span><br><span class="line">                    Math.max(leftUp.distance(point), rightBottom.distance(point)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 状态（大小堆之用）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Status</span> <span class="keyword">implements</span> <span class="title">Comparable</span> </span>&#123;</span><br><span class="line">        Point point;</span><br><span class="line">        <span class="keyword">double</span> distance;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Status</span><span class="params">(Point point, <span class="keyword">double</span> distance)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.point = point;</span><br><span class="line">            <span class="keyword">this</span>.distance = distance;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Double.compare(<span class="keyword">this</span>.distance, ((Status) o).distance);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 无穷值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="comment">// 空节点（方便编码）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Node nullNode = <span class="keyword">new</span> Node(<span class="keyword">null</span>, <span class="keyword">new</span> Point(KDTree.INF, KDTree.INF),</span><br><span class="line">            <span class="keyword">new</span> Point(-KDTree.INF, -KDTree.INF), <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 根节点</span></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="辅助方法"><a href="#辅助方法" class="headerlink" title="辅助方法"></a>辅助方法</h3><ul>
<li><p>基于 <code>arr[l,r)</code> 间元素、按照指定维度构建 KDTree</p>
<p>该代码实现需要注意两部分：</p>
<ol>
<li>代码实现中直接排序 <code>arr[l,r)</code> 中全部元素，其时间复杂度为 $O(nlog^n)$。实际上没有必要这样做，只要找到一个元素将其放置中间位置，使得前面元素均小于它，后面元素均大于它即可。这一操作的平均时间复杂度为 $O(n)$ (具体实现可参见 <code>C++</code> 中的 <code>nth_element</code> 函数)。故而构建 KDTree 的时间复杂度为 $O(Nlog^N)$ 。</li>
<li>构建节点时，<code>item</code>、<code>leftBottom</code> 与 <code>rightUp</code> 应当是互相独立的，故而其无法引用同一对象，应当引用内容相同的对象。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dimension为true,表示应当按 x轴排序，反之应当按 y轴排序。后面同此，故不再赘述。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, Point[] arr, <span class="keyword">boolean</span> dimension)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 基于零个元素构建KDTree，直接返回空节点即可。</span></span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">        <span class="keyword">return</span> KDTree.nullNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 排序这部分元素</span></span><br><span class="line">    Arrays.sort(arr, l, r, arr[l].comparator(dimension));</span><br><span class="line">    <span class="comment">// 获取中间位置</span></span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建节点及其子树</span></span><br><span class="line">    Node root = <span class="keyword">new</span> Node(arr[mid], arr[mid].clone(), arr[mid].clone(), <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    root.left = build(l, mid, arr, !dimension);</span><br><span class="line">    root.right = build(mid + <span class="number">1</span>, r, arr, !dimension);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新节点所覆盖区域</span></span><br><span class="line">    root.maintain();</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>当前子树中获取KNN</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">KNNTree</span><span class="params">(Point point, <span class="keyword">int</span> k, PriorityQueue&lt;Status&gt; priorityQueue, Node root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 空子树中一定不存在，直接返回即可。</span></span><br><span class="line">    <span class="keyword">if</span> (KDTree.nullNode == root) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前子树根节点与指定节点的曼哈顿距离</span></span><br><span class="line">    <span class="keyword">double</span> distance = root.item.distance(point);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果搜索到的邻居节点数不足，则直接插入。如果搜索到的邻居节点数已满，但是当前子树根节点与指定节点的曼哈顿距离小于大顶堆堆顶元素，则应当移除堆顶元素，并将该曼哈顿距离置于堆中。</span></span><br><span class="line">    <span class="keyword">if</span> (priorityQueue.size() &lt; k || distance &lt; priorityQueue.peek().distance) &#123;</span><br><span class="line">        <span class="keyword">if</span> (priorityQueue.size() == k) &#123;</span><br><span class="line">            priorityQueue.remove();</span><br><span class="line">        &#125;</span><br><span class="line">        priorityQueue.add(<span class="keyword">new</span> Status(root.item, distance));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> leftDistance = root.left.minDistance(point);</span><br><span class="line">    <span class="keyword">double</span> rightDistance = root.right.minDistance(point);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (leftDistance &lt; rightDistance) &#123;</span><br><span class="line">        KNNTree(point, k, priorityQueue, root.left);</span><br><span class="line">        <span class="comment">// 如果搜索到的邻居节点数不足或者邻居节点数已足但是右子树最近距离小于大顶堆堆顶元素，就需要搜索右子树。</span></span><br><span class="line">        <span class="keyword">if</span> (priorityQueue.size() &lt; k || rightDistance &lt; priorityQueue.peek().distance) &#123;</span><br><span class="line">            KNNTree(point, k, priorityQueue, root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        KNNTree(point, k, priorityQueue, root.right);</span><br><span class="line">        <span class="comment">// 如果搜索到的邻居节点数不足或者邻居节点数已足但是左子树最近距离小于大顶堆堆顶元素，就需要搜索左子树。</span></span><br><span class="line">        <span class="keyword">if</span> (priorityQueue.size() &lt; k || leftDistance &lt; priorityQueue.peek().distance) &#123;</span><br><span class="line">            KNNTree(point, k, priorityQueue, root.left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>当前子树中获取KNF</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">KNFTree</span><span class="params">(Point point, <span class="keyword">int</span> k, PriorityQueue&lt;Status&gt; priorityQueue, Node root)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 空子树中一定不存在，直接返回即可。</span></span><br><span class="line">    <span class="keyword">if</span> (KDTree.nullNode == root) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 获取当前子树根节点与指定节点的曼哈顿距离</span></span><br><span class="line">    <span class="keyword">double</span> distance = root.item.distance(point);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果搜索到的邻居节点数不足，则直接插入。如果搜索到的邻居节点数已满，但是当前子树根节点与指定节点的曼哈顿距离大于小顶堆堆顶元素，则应当移除堆顶元素，并将该曼哈顿距离置于堆中。</span></span><br><span class="line">    <span class="keyword">if</span> (priorityQueue.size() &lt; k || distance &gt; priorityQueue.peek().distance) &#123;</span><br><span class="line">        <span class="keyword">if</span> (priorityQueue.size() == k) &#123;</span><br><span class="line">            priorityQueue.remove();</span><br><span class="line">        &#125;</span><br><span class="line">        priorityQueue.add(<span class="keyword">new</span> Status(root.item, distance));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> leftDistance = root.left.minDistance(point);</span><br><span class="line">    <span class="keyword">double</span> rightDistance = root.right.minDistance(point);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (leftDistance &gt; rightDistance) &#123;</span><br><span class="line">        KNFTree(point, k, priorityQueue, root.left);</span><br><span class="line">        <span class="comment">// 如果搜索到的邻居节点数不足或者邻居节点数已足但是右子树最远距离大于小顶堆堆顶元素，就需要搜索右子树。</span></span><br><span class="line">        <span class="keyword">if</span> (priorityQueue.size() &lt; k || rightDistance &gt; priorityQueue.peek().distance) &#123;</span><br><span class="line">            KNFTree(point, k, priorityQueue, root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        KNFTree(point, k, priorityQueue, root.right);</span><br><span class="line">        <span class="comment">// 如果搜索到的邻居节点数不足或者邻居节点数已足但是左子树最远距离大于小顶堆堆顶元素，就需要搜索左子树。</span></span><br><span class="line">        <span class="keyword">if</span> (priorityQueue.size() &lt; k || leftDistance &gt; priorityQueue.peek().distance) &#123;</span><br><span class="line">            KNFTree(point, k, priorityQueue, root.left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>当前子树中获取具有指定维度最小值的节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">findminTree</span><span class="params">(Node root, <span class="keyword">boolean</span> dimension, <span class="keyword">boolean</span> specDim, Node min)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前子树为空，直接返回传入的min。</span></span><br><span class="line">    <span class="keyword">if</span> (KDTree.nullNode == root) &#123;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果min为空节点，或者当前子树根节点指定维度值小于min，则赋值min为当前子树根节点。</span></span><br><span class="line">    <span class="keyword">if</span> (KDTree.nullNode == min || root.item.compareTo(min.item, specDim) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        min = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前维度为指定维度，只需在左子树中查找即可。否则左右子树均需查找。</span></span><br><span class="line">    <span class="keyword">if</span> (dimension == specDim) &#123;</span><br><span class="line">        <span class="keyword">return</span> findminTree(root.left, !dimension, specDim, min);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node leftMin = findminTree(root.left, !dimension, specDim, min);</span><br><span class="line">        Node rightMin = findminTree(root.right, !dimension, specDim, min);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> leftMin.item.compareTo(rightMin.item, specDim) &lt; <span class="number">0</span> ? leftMin : rightMin;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>当前子树中添加指定元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addTree</span><span class="params">(Point point, Node root, <span class="keyword">boolean</span> dimension)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前子树为空，直接创建节点并返回即可。</span></span><br><span class="line">    <span class="keyword">if</span> (KDTree.nullNode == root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Node(point, point.clone(), point.clone(), KDTree.nullNode, KDTree.nullNode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 待添加元素小于当前子树根节点值，表明应插入于左子树之中。</span></span><br><span class="line">    <span class="keyword">if</span> (root.item.compareTo(point,dimension) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        root.left = addTree(point, root.left, !dimension);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        root.right = addTree(point, root.right, !dimension);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新节点所覆盖区域</span></span><br><span class="line">    root.maintain();</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>当前子树中删除指定元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">deleteTree</span><span class="params">(Point point, Node root, <span class="keyword">boolean</span> dimension)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前子树为空，直接返回即可。</span></span><br><span class="line">    <span class="keyword">if</span> (KDTree.nullNode == root) &#123;</span><br><span class="line">        <span class="keyword">return</span> KDTree.nullNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前子树根节点并非待删除元素，根据维度顺序，在左右子树中删除即可。</span></span><br><span class="line">    <span class="keyword">if</span> (root.item.x != point.x || root.item.y != point.y) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root.item.compareTo(point, dimension) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            root.left = deleteTree(point, root.left, !dimension);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root.right = deleteTree(point, root.right, !dimension);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 表明当前子树根节点就是待删除元素</span></span><br><span class="line">        <span class="comment">// 当前子树右子树不为空，将当前子树根节点的元素值与其后继节点元素值交换，然后删除其后继节点即可。</span></span><br><span class="line">        <span class="keyword">if</span> (KDTree.nullNode != root.right) &#123;</span><br><span class="line">            root.item = findminTree(root.right, !dimension, dimension, KDTree.nullNode).item;</span><br><span class="line">            root.right = deleteTree(root.item, root.right, !dimension);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (KDTree.nullNode != root.left)&#123;</span><br><span class="line">            <span class="comment">// 当前子树左子树不为空，将当前子树根节点的元素值与左子树中具有指定维度最小值的节点的元素值交换，然后删除左子树中具有指定维度最小值的节点，最后为保证有序，将当前子树的左右子树交换即可。</span></span><br><span class="line">            root.item = findminTree(root.left, !dimension, dimension, KDTree.nullNode).item;</span><br><span class="line">            root.left = deleteTree(root.item, root.left, !dimension);</span><br><span class="line">            root.right = root.left;</span><br><span class="line">            root.left = KDTree.nullNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 左右子树为空，删除该节点后，应当返回空节点。</span></span><br><span class="line">            <span class="keyword">return</span> KDTree.nullNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新节点所覆盖区域</span></span><br><span class="line">    root.maintain();</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">KDTree</span><span class="params">(Point[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.root = build(<span class="number">0</span>, arr.length, arr, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><ul>
<li><p>KNN（K邻近）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">KNN</span><span class="params">(Point point, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构建大顶堆</span></span><br><span class="line">    PriorityQueue&lt;Status&gt; priorityQueue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Status&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Status o1, Status o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Double.compare(o2.distance, o1.distance);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    KNNTree(point, k, priorityQueue, <span class="keyword">this</span>.root);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;KNN: &quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (!priorityQueue.isEmpty()) &#123;</span><br><span class="line">        Status tmp = priorityQueue.remove();</span><br><span class="line">        System.out.println(<span class="string">&quot;X: &quot;</span> + tmp.point.x + <span class="string">&quot;,Y: &quot;</span> + tmp.point.y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>KNF（K最远）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">KNF</span><span class="params">(Point point, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构建小顶堆</span></span><br><span class="line">    PriorityQueue&lt;Status&gt; priorityQueue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Status&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Status o1, Status o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Double.compare(o1.distance, o2.distance);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    KNFTree(point, k, priorityQueue, <span class="keyword">this</span>.root);</span><br><span class="line">    System.out.println(<span class="string">&quot;KNF: &quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (!priorityQueue.isEmpty()) &#123;</span><br><span class="line">        Status tmp = priorityQueue.remove();</span><br><span class="line">        System.out.println(<span class="string">&quot;X: &quot;</span> + tmp.point.x + <span class="string">&quot;,Y: &quot;</span> + tmp.point.y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="操纵"><a href="#操纵" class="headerlink" title="操纵"></a>操纵</h3></li>
<li><p>KDTree 中添加元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Point point)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.root = addTree(point, <span class="keyword">this</span>.root, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>KDTree 中删除元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Point point)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.root = deleteTree(point, <span class="keyword">this</span>.root, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-跳跃表</title>
    <url>/2020/07/04/dataStructure/dataStructure-skiplist/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>跳跃表</strong> 是一种基于链表实现的数据结构。它具有实现简单、查找性能媲美甚至优于平衡树、内存占用较少等特点。</p>
<a id="more"></a>

<p>其结构图大致如下：</p>
<p><img src="/2020/07/04/dataStructure/dataStructure-skiplist/580b14b344513bbead4d1b188f94bb25.png" alt="图一：跳跃表"></p>
<p>对于排序数组而言，基于二分思想可将查找操作的时间复杂度降为 $O(log^N)$；而对于排序链表而言，由于其节点只保存后继节点的引用信息，故而其查找操作的时间复杂度只能是 $O(N)$。受 “空间换时间” 思想的启发，我们会产生这样一种想法：如果一部分节点不仅保存后继节点的引用信息，而且保存后继节点的后继节点的引用信息，甚至于保存后继节点的后继节点的后继节点的引用信息，那么一定可以降低查询操作的时间复杂度。最终我们可以得到这样一种理想的跳跃表：第零层级存在所有节点，第一层级只有 $1/2$ 的节点，而且是均匀间隔的，第二层级只有 $1/4$ 的节点，同样是均匀间隔的，以此类推，直至最高层级仅有两个节点。这种跳跃表共有 $log^N$ 层，故而其查询操作的时间复杂度为 $O(log^N)$。</p>
<p><img src="/2020/07/04/dataStructure/dataStructure-skiplist/d88e4d282ec5981c207c.png" alt="图二：理想的跳跃表"></p>
<p>理想的跳跃表存在一个非常大的问题：结构过于严谨，致使插入操作和删除操作非常复杂。为简化操作复杂度，不确定性跳跃表和确定性跳跃表应运而生。前者基于概率模拟理想的跳跃表，故而其查询操作的平均时间复杂度为 $O(log^N)$，后者基于结构限制模拟理想的跳跃表，故而其查询操作的时间复杂度为 $O(log^N)$ 。</p>
<blockquote>
<p>因为确定性跳跃表并不常用，故而本文着重于不确定性跳跃表的代码实现，仅在 <em>拓展</em> 一节简要介绍确定性跳跃表。</p>
</blockquote>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SkipList</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 节点结构</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">// 具体元素</span></span><br><span class="line">        E item;</span><br><span class="line">        <span class="comment">// 后继节点的引用数组</span></span><br><span class="line">        Node&lt;E&gt;[] next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E item, <span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.item = item;</span><br><span class="line">            <span class="keyword">this</span>.next = <span class="keyword">new</span> Node[level + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最大层级数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxLevel;</span><br><span class="line">    <span class="comment">// 概率参数，指定层级数之用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> p;</span><br><span class="line">    <span class="comment">// 当前跳跃表中最大层级数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> level;</span><br><span class="line">    <span class="comment">// 首节点</span></span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; head;</span><br><span class="line">    <span class="comment">// 随机函数，指定层级数之用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random random = <span class="keyword">new</span> Random(System.currentTimeMillis());</span><br><span class="line">    <span class="comment">// 比较函数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> E&gt; comparator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="辅助方法"><a href="#辅助方法" class="headerlink" title="辅助方法"></a>辅助方法</h3><ul>
<li><p>指定层级数</p>
<p>跳跃表中指定节点层级数的方法十分有趣。最初设置层级数为零，如果随机数值小于指定的概率参数，且当前层级数小于指定的最大层级数，则层级数加一；反之当前层级数就是该节点的最终层级数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">randomLevel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (random.nextDouble() &lt; <span class="keyword">this</span>.p &amp;&amp; level &lt; <span class="keyword">this</span>.maxLevel) &#123;</span><br><span class="line">        level++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> level;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SkipList</span><span class="params">(<span class="keyword">int</span> maxLevel, <span class="keyword">double</span> p, Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 赋值相关参数。</span></span><br><span class="line">    <span class="keyword">this</span>.maxLevel = maxLevel;</span><br><span class="line">    <span class="keyword">this</span>.p = p;</span><br><span class="line">    <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化相关参数</span></span><br><span class="line">    <span class="keyword">this</span>.head = <span class="keyword">new</span> Node&lt;&gt;(<span class="keyword">null</span>, <span class="keyword">this</span>.maxLevel);</span><br><span class="line">    <span class="keyword">this</span>.level = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><ul>
<li><p>查询指定元素是否存在</p>
<p>从最高层级开始向前搜索，如果下一个节点元素值大于等于待查找元素值，则转向下一层级并向前搜索，依此而行，直至转向第零层级。如果第零层级不存在该值则查找失败，否则查找成功。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(E item)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 栈，用于存放各个层级上最后一个小于待查找元素的节点。</span></span><br><span class="line">    ArrayDeque&lt;Node&lt;E&gt;&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    <span class="comment">// 当前搜索节点</span></span><br><span class="line">    Node&lt;E&gt; current = <span class="keyword">this</span>.head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="keyword">this</span>.maxLevel; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 当前层级之下当前节点的下一个节点存在，且值小于或等于待查找元素，则继续向前搜索。</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">null</span> != current.next[i] &amp;&amp; comparator.compare(current.next[i].item, item) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            current = current.next[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前节点为当前层级之上最后一个小于或等于待查找元素的节点，故将其添加至栈中。</span></span><br><span class="line">        stack.push(current);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第零层级当前搜索节点的下一个节点不存在或者节点元素值不等于待查找元素，则查找失败。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == current.next[<span class="number">0</span>] || comparator.compare(current.next[<span class="number">0</span>].item, item) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="操纵"><a href="#操纵" class="headerlink" title="操纵"></a>操纵</h3></li>
<li><p>跳跃表中添加元素</p>
<p>插入过程与查询过程类似，只是需要从下往上依次插入待添加元素即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E item)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 栈，用于存放各个层级上最后一个小于待添加元素的节点。</span></span><br><span class="line">    ArrayDeque&lt;Node&lt;E&gt;&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    <span class="comment">// 当前搜索节点</span></span><br><span class="line">    Node&lt;E&gt; current = <span class="keyword">this</span>.head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="keyword">this</span>.maxLevel; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 当前层级之下当前节点的下一个节点存在，且值小于待添加元素，则继续向前搜索。</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">null</span> != current.next[i] &amp;&amp; comparator.compare(current.next[i].item, item) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            current = current.next[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前节点为当前层级之上最后一个小于待添加元素的节点，故将其添加至栈中。</span></span><br><span class="line">        stack.push(current);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定层级数，同时更新当前跳跃表中最大层级数。</span></span><br><span class="line">    <span class="keyword">int</span> rLevel = randomLevel();</span><br><span class="line">    <span class="keyword">if</span> (rLevel &gt; <span class="keyword">this</span>.level) &#123;</span><br><span class="line">        <span class="keyword">this</span>.level = rLevel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从下往上插入节点</span></span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;&gt;(item, rLevel);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= rLevel; i++) &#123;</span><br><span class="line">        current = stack.pop();</span><br><span class="line">        node.next[i] = current.next[i];</span><br><span class="line">        current.next[i] = node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>跳跃表中删除元素</p>
<p>删除过程与查询过程类似，只是需要从下往上依次删除待删除元素即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(E item)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 栈，用于存放各个层级上最后一个小于待删除元素的节点。</span></span><br><span class="line">    ArrayDeque&lt;Node&lt;E&gt;&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    <span class="comment">// 当前搜索节点</span></span><br><span class="line">    Node&lt;E&gt; current = <span class="keyword">this</span>.head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="keyword">this</span>.maxLevel; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 当前层级之下当前节点的下一个节点存在，且值小于或等于待删除元素，则继续向前搜索。</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">null</span> != current.next[i] &amp;&amp; comparator.compare(current.next[i].item, item) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            current = current.next[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前节点为当前层级之上最后一个小于或等于待删除元素的节点，故将其添加至栈中。</span></span><br><span class="line">        stack.push(current);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node&lt;E&gt; deleteNode = current.next[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果待删除节点不存在，则直接退出即可。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == deleteNode || comparator.compare(deleteNode.item, item) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> deleteLevel = deleteNode.next.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除待删除节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= deleteLevel; i++) &#123;</span><br><span class="line">        current = stack.pop();</span><br><span class="line">        current.next[i] = deleteNode.next[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新当前跳跃表中最大层级数。</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">this</span>.level &gt; <span class="number">0</span> &amp;&amp; <span class="keyword">null</span> == <span class="keyword">this</span>.head.next[<span class="keyword">this</span>.level]) &#123;</span><br><span class="line">        <span class="keyword">this</span>.level--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2></li>
</ul>
<h3 id="不确定性跳跃表"><a href="#不确定性跳跃表" class="headerlink" title="不确定性跳跃表"></a>不确定性跳跃表</h3><p>这里探讨两个比较简单的问题：</p>
<ol>
<li><p>跳跃表中节点包含的平均引用数目是多少？</p>
<p>查看函数 “指定层级数”，我们可以发现节点包含的引用数目满足一个概率分布：</p>
<ul>
<li>节点包含的引用数目为一的概率为 $(1 - p)$；</li>
<li>节点包含的引用数目为二的概率为 $p(1 - p)$；</li>
<li>节点包含的引用数目为三的概率为 $p^2(1 - p)$；</li>
<li>$\dots$</li>
</ul>
<p>那么跳跃表中节点包含的平均引用数目可计算如下：</p>
<p>$1 \times (1 - p) + 2 \times p(1 - p) + 3 \times p^2(1 - p) + \dots = (1 - p)\sum_{i = 1}^{\infty}(i \times p^{i - 1}) = (1 - p) \times \frac{1}{(1 - p)^2} = \frac{1}{1 - p}$</p>
<p>依据推导结果，我们可以看到：节点包含的平均引用数目与指定的概率参数相关，且指定的概率参数值越小，节点包含的平均引用数目越少。</p>
<p>当 $p = 1/2$ 时，节点包含的平均引用数目为 $2$；当 $p = 1/4$ 时，节点包含的平均引用数目为 $1.33$。</p>
</li>
<li><p>与平衡树、哈希表的比较？</p>
<p>查找性能比较优良的数据结构就这三种：平衡树、哈希表和跳跃表。故而在此简要对比一下三者：</p>
<ul>
<li>哈希表中元素无序排列，而平衡树与跳跃表中元素有序排列。故而前者只能进行单个查询，后者即可进行单个查询，又可进行范围查询。</li>
<li>进行单个查询时，哈希表可达到 $O(1)$ 的时间复杂度，平衡树和跳跃表的时间复杂度为 $O(log^N)$。</li>
<li>进行范围查询时，平衡树操作较为复杂，原因在于：找到范围起点后，需中序遍历平衡树直至范围终点。而对跳跃表而言，只要在第零层级向前搜索到范围终点即可。</li>
<li>平衡树插入、删除操作可能引发子树调整，故而逻辑复杂。哈希表和跳跃表只需要修改相关节点引用即可，比较简单。</li>
<li>从无关数据的内存占用上来说，平衡树通常需要 $2-3$ 个节点引用 (左右儿子节点、父节点)；跳跃表通过指定概率参数可仅使用 $1.33$ 个节点引用。</li>
</ul>
</li>
</ol>
<h3 id="确定性跳跃表"><a href="#确定性跳跃表" class="headerlink" title="确定性跳跃表"></a>确定性跳跃表</h3><p>此处简要介绍其中一种确定性跳跃表—— 1-2-3 确定性跳跃表。</p>
<p>我们首先做出如下两个定义：</p>
<ol>
<li>如果至少存在一个链从一个元素指向另一个元素，我们就称两个元素是 <strong>链接的</strong>。</li>
<li>第 $h$ 层级之上的两个链接元素间的 <strong>间隙容量</strong> 等于第 $h - 1$ 层级中这两个元素间的元素个数。</li>
</ol>
<p>1-2-3 确定性跳跃表满足如下性质：任意链接元素间的间隙容量只可能是 1 或 2 或 3。 </p>
<p>图三即为确定性跳跃表的一个例子。其中第一层级之上的两个链接元素 ( $10$ 与 $25$ ) 间的间隙容量等于第零层级中这两个元素间的元素个数 ( $15$ 与 $20$，共计两个元素 )。<br><img src="/2020/07/04/dataStructure/dataStructure-skiplist/image-20200708194847004.png" alt="图三：确定性跳跃表"></p>
<p>接下来我们介绍一下确定性跳跃表中的插入与删除操作：</p>
<ul>
<li><p>插入操作</p>
<p>插入操作可能使得某链接元素间的间隙容量扩大为 $4$，故而需要进行适当拆分。</p>
<p>一种可行的做法为：向下搜索插入位置之时，如果当前节点与后继节点间的间隙容量为 $3$，则令下一层级中位于中间的那个节点的层级加一，使得其成为当前节点的后继节点。</p>
<p>图四所示为向跳跃表中插入元素 $27$ 。由于第二层级之上首尾两个元素间的间隙容量为 $3$，故而提升下一层级中的 $25$，使得其与首节点的间隙容量、其与尾节点的间隙容量均为 $1$，此时在这两者间插入元素则不再会破坏性质。</p>
<p><img src="/2020/07/04/dataStructure/dataStructure-skiplist/image-20200708201043243.png" alt="图四：插入元素27"></p>
</li>
<li><p>删除操作</p>
<p>删除操作可能使得某链接元素间的间隙容量缩小为 $0$，故而需要进行适当合并。</p>
<p>一种可行的做法为：向下搜索删除元素过程中，如果当前节点与后继节点间的间隙容量为 $1$，那么删除指定元素后，可能会破坏此处的性质，因此我们需要扩大当前节点与后继节点间的间隙容量。如果后继节点与后继节点的后继节点的间隙容量大于 $1$，我们便从后继节点借 $1$ 个间隙容量；如果后继节点与后继节点的后继节点的间隙容量等于 $1$，我们便降低后继节点的层级，此时当前节点与新后继节点的间隙容量就为 $3$。</p>
</li>
</ul>
<blockquote>
<p>图中所示仅为确定性跳跃表的表示图，其逻辑结构与此还是有一定区别的。</p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-Treap树/替罪羊树</title>
    <url>/2020/07/03/dataStructure/dataStructure-treaptree/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>Treap 树</strong> 是一个附加域满足堆性质的二叉查找树，其基本操作的期望时间复杂度为 $O(log^N)$。相比于 AVL、红黑树而言，其实现简单，且能基本实现随机平衡。</p>
<a id="more"></a>

<p>其结构图大致如下：</p>
<p><img src="/2020/07/03/dataStructure/dataStructure-treaptree/2012073000522678.png" alt="图一：Treap树"></p>
<p>对于二叉查找树而言，特殊插入序列将会使得二叉查找树退化为一个链表，这样会大大降低二叉查找树的性能。为避免这一情况的发生，AVL 限制左右子树高度差不超过 1、红黑树要求任意节点到其所有后代叶节点的简单路径均包含相同数目的黑色节点。对于 Treap 树而言，要求附加域满足堆性质使得不存在特殊插入序列，从而避免这一情况的发生 (查看下面的插入过程就可理解这句话)。</p>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>附加域即是该节点的优先级，它在建立节点时随机指定。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Treap</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 节点结构</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">// 具体元素</span></span><br><span class="line">        E item;</span><br><span class="line">        <span class="comment">// 左儿子</span></span><br><span class="line">        Node&lt;E&gt; left;</span><br><span class="line">        <span class="comment">// 右儿子</span></span><br><span class="line">        Node&lt;E&gt; right;</span><br><span class="line">        <span class="comment">// 优先级</span></span><br><span class="line">        <span class="keyword">int</span> priority;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E item, <span class="keyword">int</span> priority)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.item = item;</span><br><span class="line">            <span class="keyword">this</span>.left = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.right = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.priority = priority;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 比较函数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> E&gt; comparator;</span><br><span class="line">    <span class="comment">// 根节点</span></span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; root;</span><br><span class="line">    <span class="comment">// 随机函数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random random = <span class="keyword">new</span> Random(System.currentTimeMillis());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="辅助方法"><a href="#辅助方法" class="headerlink" title="辅助方法"></a>辅助方法</h3><ul>
<li><p>右旋</p>
<p>Treap 树中两大基本操作之一，用于维持堆性质。</p>
<p><img src="/2020/07/03/dataStructure/dataStructure-treaptree/image-20200630184952581.png" alt="图二：右旋"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;E&gt; <span class="title">rightRotate</span><span class="params">(Node&lt;E&gt; root)</span> </span>&#123;</span><br><span class="line">    Node&lt;E&gt; k1 = root;</span><br><span class="line">    Node&lt;E&gt; k2 = root.left;</span><br><span class="line"></span><br><span class="line">    k1.left = k2.right;</span><br><span class="line">    k2.right = k1;</span><br><span class="line">    <span class="keyword">return</span> k2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>左旋</p>
<p>Treap 树中两大基本操作之一，用于维持堆性质。</p>
<p><img src="/2020/07/03/dataStructure/dataStructure-treaptree/image-20200630185055765.png" alt="图三：左旋"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;E&gt; <span class="title">leftRotate</span><span class="params">(Node&lt;E&gt; root)</span> </span>&#123;</span><br><span class="line">    Node&lt;E&gt; k1 = root;</span><br><span class="line">    Node&lt;E&gt; k2 = root.right;</span><br><span class="line"></span><br><span class="line">    k1.right = k2.left;</span><br><span class="line">    k2.left = k1;</span><br><span class="line">    <span class="keyword">return</span> k2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>当前子树中插入元素，并返回插入元素后的该子树</p>
<p>插入过程与二叉查找树插入过程基本相同，不同点即在于：将元素插入到合适位置之后，如果堆性质不满足，需借助于左旋或右旋进行调整。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;E&gt; <span class="title">addTree</span><span class="params">(E item, Node&lt;E&gt; root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前子树为空，创建该节点并返回即可。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Node&lt;&gt;(item, random.nextInt());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前子树根节点值大于指定元素，则应当插入于左子树之中。</span></span><br><span class="line">    <span class="keyword">if</span> (comparator.compare(root.item, item) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        root.left = addTree(item, root.left);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果子节点优先级低于当前节点优先级，则需进行右旋。</span></span><br><span class="line">        <span class="keyword">if</span> (root.left.priority &lt; root.priority) &#123;</span><br><span class="line">            root = rightRotate(root);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (comparator.compare(root.item, item) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 当前子树根节点值小于指定元素，则应当插入于右子树之中。</span></span><br><span class="line">        root.right = addTree(item, root.right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果子节点优先级低于当前节点优先级，则需进行左旋。</span></span><br><span class="line">        <span class="keyword">if</span> (root.right.priority &lt; root.priority) &#123;</span><br><span class="line">            root = leftRotate(root);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>当前子树中删除元素，并返回删除元素后的该子树</p>
<p>删除元素过程比较巧妙。借助于左旋与右旋，逐步将待删除节点下沉至叶节点，然后直接删除即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;E&gt; <span class="title">deleteTree</span><span class="params">(E item, Node&lt;E&gt; root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前子树为空，直接返回空即可。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前子树根节点值大于待删除元素，则待删除元素一定位于左子树之中。</span></span><br><span class="line">    <span class="keyword">if</span> (comparator.compare(root.item, item) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        root.left = deleteTree(item, root.left);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (comparator.compare(root.item, item) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 当前子树根节点值小于待删除元素，则待删除元素一定位于右子树之中。</span></span><br><span class="line">        root.right = deleteTree(item, root.right);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 当前子树根节点值等于待删除元素，此即为待删除元素。</span></span><br><span class="line">        <span class="comment">// 只要左右儿子一者为空，则直接使用另一儿子节点所在子树代替当前子树即可。</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == root.right) &#123;</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">null</span> == root.left) &#123;</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 当前子树根节点的左右儿子均不为空。</span></span><br><span class="line">            <span class="comment">// 借助左旋或右旋使待删除节点下沉至叶节点，然后删除即可。</span></span><br><span class="line">            <span class="keyword">if</span> (root.left.priority &lt; root.right.priority) &#123;</span><br><span class="line">                root = rightRotate(root);</span><br><span class="line">                root.right = deleteTree(item, root.right);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                root = leftRotate(root);</span><br><span class="line">                root.left = deleteTree(item, root.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Treap</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="操纵"><a href="#操纵" class="headerlink" title="操纵"></a>操纵</h3><ul>
<li><p>Treap 树中添加元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.root = addTree(item, <span class="keyword">this</span>.root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Treap 树中删除元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(E item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.root = deleteTree(item, <span class="keyword">this</span>.root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2></li>
</ul>
<h3 id="替罪羊树"><a href="#替罪羊树" class="headerlink" title="替罪羊树"></a>替罪羊树</h3><p><strong>替罪羊树</strong> 是一种非常优雅的二叉查找树。如果当前子树极度不平衡，替罪羊树首先将中序遍历该子树的结果置于数组之中，然后按照 “以中间值元素为根节点，左半部分元素构建左子树，右半部分元素构建右子树” 的方式重构该子树。</p>
<p>接下来我们谈谈替罪羊树上的一些操作：</p>
<ul>
<li><p>插入操作</p>
<p>与普通二叉查找树的插入操作基本相同，不同点在于：插入完成后，递归向上至根节点过程中，找到最后一棵极度不平衡的子树，然后重构它。由于此过程并不常发生，所以其平均时间复杂度为 $O(log^N)$ 。</p>
</li>
<li><p>删除操作</p>
<p>删除过程采用 “懒惰删除”，即并不立即删除该节点，只是标记该节点为已删除节点。如果当前子树中已删除节点个数/当前子树中所有节点个数大于某一阈值，则在重构过程中删除这些节点。理论已经证明，其平均时间复杂度仍为 $O(log^N)$ 。</p>
</li>
<li><p>查询操作</p>
<p>与普通二叉查找树的查询操作基本相同，不同点在于：如果当前节点为已删除节点，直接忽略它即可。故而其平均时间复杂度为 $O(log^N)$ 。</p>
</li>
</ul>
<blockquote>
<p>“当前子树极度不平衡” 的衡量条件为：$$size(root.left) / size(root) &gt; \alpha \ || \  size(root.right) / size(root) &gt; \alpha$$，其中 $size(x)$ 表示以当前节点为根节点的子树中节点数量、$\alpha$ 为衡量阈值。</p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-红黑树</title>
    <url>/2020/06/30/dataStructure/dataStructure-rbtree/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>红黑树</strong> 是一种自平衡的二叉查找树。通过为树中节点添加颜色属性并施以一定规则，红黑树可保证针对二叉查找树各种操作的最坏时间复杂度为 $O(log^N)$。</p>
<a id="more"></a>

<p>其结构图大致如下：</p>
<p><img src="/2020/06/30/dataStructure/dataStructure-rbtree/251730074203156.jpg" alt="图一：红黑树"></p>
<p>一棵红黑树是满足如下 <em>红黑性质</em> 的二叉查找树：</p>
<ol>
<li>每个节点的颜色属性要么是红色，要么是黑色。</li>
<li>根节点的颜色属性为黑色。</li>
<li>每个叶节点 (<code>NIL</code>) 的颜色属性为黑色。</li>
<li>如果一个节点的颜色属性为红色，则其孩子节点的颜色属性一定为黑色。</li>
<li>对于每个节点而言，从该节点到其所有后代叶节点的简单路径中，均包含相同数目的黑色节点。</li>
</ol>
<p>基于上述红黑性质，我们可以得到如下结论：一棵含有 $N$ 个内部节点的红黑树，其高度至多为 $O(2log^{N + 1})$。正是此结论，保证了针对二叉查找树各种操作的最坏时间复杂度为 $O(log^N)$。</p>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>红黑树需额外保存节点的颜色信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RBTree</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 节点结构</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">// 具体元素</span></span><br><span class="line">        E item;</span><br><span class="line">        <span class="comment">// 父节点</span></span><br><span class="line">        Node&lt;E&gt; parent;</span><br><span class="line">        <span class="comment">// 左儿子</span></span><br><span class="line">        Node&lt;E&gt; left;</span><br><span class="line">        <span class="comment">// 右儿子</span></span><br><span class="line">        Node&lt;E&gt; right;</span><br><span class="line">        <span class="comment">// 节点颜色</span></span><br><span class="line">        <span class="keyword">boolean</span> isBlack;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 默认将节点颜色置为红色</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E item)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.item = item;</span><br><span class="line">            <span class="keyword">this</span>.parent = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.left = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.right = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.isBlack = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置节点颜色为红色</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.isBlack = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置节点颜色为黑色</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBlack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.isBlack = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根节点</span></span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; root;</span><br><span class="line">    <span class="comment">// 比较函数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> E&gt; comparator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="辅助方法"><a href="#辅助方法" class="headerlink" title="辅助方法"></a>辅助方法</h3><ul>
<li><p>当前节点颜色是否为黑色</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isBlack</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">null</span> == node) || (node.isBlack);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>当前节点颜色是否为红色</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isRed</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !isBlack(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>当前子树中查找具有最小元素的节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;E&gt; <span class="title">getMinTree</span><span class="params">(Node&lt;E&gt; root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 一路向左即可。</span></span><br><span class="line">    Node&lt;E&gt; node = root;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">null</span> != node.left) &#123;</span><br><span class="line">        node = node.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>右旋</p>
<p>该操作就是 AVL 中的 <code>LL</code>，也是伸展树中的 <code>zig</code>。</p>
<p><img src="/2020/06/30/dataStructure/dataStructure-rbtree/image-20200630184952581.png" alt="图二：右旋"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rightRotate</span><span class="params">(Node&lt;E&gt; root)</span> </span>&#123;</span><br><span class="line">    Node&lt;E&gt; k1 = root;</span><br><span class="line">    Node&lt;E&gt; k2 = root.left;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首先调整k1左儿子指向及相应儿子的父节点指向。</span></span><br><span class="line">    k1.left = k2.right;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != k2.right) &#123;</span><br><span class="line">        k2.right.parent = k1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其次调整k2的父节点指向及相应父节点的儿子节点指向。</span></span><br><span class="line">    <span class="comment">// 如果k2.parent为空，表明k2为根结点，需重新指定根结点。</span></span><br><span class="line">    k2.parent = k1.parent;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != k1.parent) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k1 == k1.parent.left) &#123;</span><br><span class="line">            k1.parent.left = k2;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            k1.parent.right = k2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.root = k2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后调整k1的右儿子指向及相应儿子的父节点指向。</span></span><br><span class="line">    k2.right = k1;</span><br><span class="line">    k1.parent = k2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>左旋</p>
<p>该操作就是 AVL 中的 <code>RR</code>，也是伸展树中的 <code>zag</code>。</p>
<p><img src="/2020/06/30/dataStructure/dataStructure-rbtree/image-20200630185055765.png" alt="图三：左旋"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">leftRotate</span><span class="params">(Node&lt;E&gt; root)</span> </span>&#123;</span><br><span class="line">    Node&lt;E&gt; k1 = root;</span><br><span class="line">    Node&lt;E&gt; k2 = root.right;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首先调整k1右儿子指向及相应儿子的父节点指向。</span></span><br><span class="line">    k1.right = k2.left;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != k2.left) &#123;</span><br><span class="line">        k2.left.parent = k1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其次调整k2的父节点指向及相应父节点的儿子指向。</span></span><br><span class="line">    <span class="comment">// 如果k1.parent为空，表明k1为根结点，需重新指定根结点。</span></span><br><span class="line">    k2.parent = k1.parent;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != k1.parent) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k1 == k1.parent.left) &#123;</span><br><span class="line">            k1.parent.left = k2;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            k1.parent.right = k2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.root = k2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后调整k2右儿子及相应儿子的父节点指向。</span></span><br><span class="line">    k2.left = k1;</span><br><span class="line">    k1.parent = k2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>插入修正</p>
<p>向红黑树中插入元素时，可能会破坏红黑性质，因此需要对红黑树进行一定调整。</p>
<blockquote>
<p>当向红黑树中插入元素时，我们需要指定新建节点的颜色。如果指定为黑色，红黑性质五一定遭到破坏，故而需要进行调整；如果指定为红色，只有当其父节点的颜色同样为红色时，红黑性质四才会遭到破坏，此时需要进行调整。考虑到编码简洁性，我们指定新建节点的颜色为红色。</p>
</blockquote>
<p>插入修正涉及多种情景，我们在此一一详述 (假定此时新建节点已插入到合适位置。图例中 <code>C</code> 表示当前节点，<code>P</code> 表示父节点，<code>PP</code> 表示祖父节点，<code>U</code> 表示叔叔节点。)。</p>
<p><strong>插入情景1：</strong>红黑树为空</p>
<p>将当前节点指定为根节点，并将节点颜色置为黑色。</p>
<p><strong>插入情景2：</strong>当前节点的父节点颜色为黑色</p>
<p>无需做任何处理。</p>
<p><strong>插入情景3：</strong>当前节点的父节点颜色为红色</p>
<p>当前节点颜色与父节点颜色同为红色，违反红黑性质四，故而需要进行调整。由于父节点颜色为红色，根据红黑性质四可知祖父节点一定存在。考虑到祖父节点及叔叔节点颜色的不确定性，此情景又可进一步细分为如下子情景。</p>
<p><strong>插入情景3.1：</strong> 当前节点的父节点为祖父节点的左儿子</p>
<p><strong>插入情景3.1.1：</strong>叔叔节点存在且颜色为红色</p>
<p>为维持红黑性质，我们只需要将 <code>P</code> 和 <code>U</code> 置为黑色、<code>PP</code> 置为红色，同时重置节点 <code>PP</code> 为当前节点，递归处理当前节点即可。</p>
<p><img src="/2020/06/30/dataStructure/dataStructure-rbtree/image-20200630091414199.png" alt="图四：插入情景3.1.1"></p>
<p><strong>插入情景3.1.2：</strong>叔叔节点不存在或存在且颜色为黑色，并且当前节点为父节点的左儿子</p>
<p>这里有关叔叔节点的表述存在一定问题。由于祖父节点满足红黑性质，那么容易得知叔叔节点一定是空节点。此时为维持红黑性质，我们需要先将 <code>P</code> 置为黑色、<code>PP</code> 置为红色，然后右旋节点 <code>PP</code> 即可。</p>
<p><img src="/2020/06/30/dataStructure/dataStructure-rbtree/image-20200630095210331.png" alt="图五：插入情景3.1.2"></p>
<p><strong>插入情景3.1.3：</strong> 叔叔节点不存在或存在且颜色为黑色，并且当前节点为父节点的右儿子</p>
<p>这里有关叔叔节点的表述存在一定问题。由于祖父节点满足红黑性质，那么容易得知叔叔节点一定是空节点。此时为维持红黑性质，我们先左旋节点 <code>P</code> ，然后重置节点 <code>P</code> 为当前节点，最后使用 <em>插入情景3.1.2</em> 的处理方法即可。</p>
<p><img src="/2020/06/30/dataStructure/dataStructure-rbtree/image-20200630100051519.png" alt="图六：插入情景3.1.3"></p>
<p><strong>插入情景3.2：</strong> 当前节点的父节点为祖父节点的右儿子</p>
<p><strong>插入情景3.2.1：</strong> 叔叔节点存在且颜色为红色</p>
<p>为维持红黑性质，我们只需要将 <code>P</code> 和 <code>U</code> 置为黑色、<code>PP</code> 置为红色，同时重置节点 <code>PP</code> 为当前节点，递归处理 当前节点即可。</p>
<p><img src="/2020/06/30/dataStructure/dataStructure-rbtree/image-20200630100717135.png" alt="图七：插入情景3.2.1"></p>
<p><strong>插入情景3.2.2：</strong> 叔叔节点不存在或存在且颜色为黑色，并且当前节点为父节点的右儿子</p>
<p>这里有关叔叔节点的表述存在一定问题。由于祖父节点满足红黑性质，那么容易得知叔叔节点一定是空节点。此时为维持红黑性质，我们需要先将 <code>P</code> 置为黑色、<code>PP</code> 置为红色，然后左旋节点 <code>PP</code> 即可。</p>
<p><img src="/2020/06/30/dataStructure/dataStructure-rbtree/image-20200630101441786.png" alt="图八：插入情景3.2.2"></p>
<p><strong>插入情景3.2.3：</strong> 叔叔节点不存在或存在且颜色为黑色，并且当前节点为父节点的左儿子</p>
<p>这里有关叔叔节点的表述存在一定问题。由于祖父节点满足红黑性质，那么容易得知叔叔节点一定是空节点。此时为维持红黑性质，我们先右旋节点 <code>P</code> ，然后重置节点 <code>P</code> 为当前节点，最后使用 <em>插入情景3.2.2</em> 的处理方法即可。</p>
<p><img src="/2020/06/30/dataStructure/dataStructure-rbtree/image-20200630101818279.png" alt="图九：插入情景3.2.3"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 插入情景1,2已在它处加以处理，此函数仅处理插入情景3。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insertFixUp</span><span class="params">(Node&lt;E&gt; root)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// 如果当前节点的父节点存在，且节点颜色为红色，则需要调整。</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">null</span> != root.parent &amp;&amp; isRed(root.parent)) &#123;</span><br><span class="line">        <span class="comment">// 获取父节点和祖父节点引用。</span></span><br><span class="line">        Node&lt;E&gt; parent = root.parent;</span><br><span class="line">        Node&lt;E&gt; grandParent = parent.parent;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 父节点为祖父节点的左儿子。</span></span><br><span class="line">        <span class="keyword">if</span> (parent == grandParent.left) &#123;</span><br><span class="line">            Node&lt;E&gt; uncle = grandParent.right;</span><br><span class="line">            <span class="comment">// 插入情景3.1.1：叔叔节点存在且颜色为红色。</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != uncle &amp;&amp; isRed(uncle)) &#123;</span><br><span class="line">                parent.setBlack();</span><br><span class="line">                uncle.setBlack();</span><br><span class="line">                grandParent.setRed();</span><br><span class="line">                root = grandParent;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 插入情景3.1.3：叔叔节点不存在或存在且颜色为黑色，并且当前节点为父节点的右儿子。</span></span><br><span class="line">            <span class="keyword">if</span> (root == parent.right) &#123;</span><br><span class="line">                leftRotate(parent);</span><br><span class="line">                Node&lt;E&gt; tmp;</span><br><span class="line">                tmp = root;</span><br><span class="line">                root = parent;</span><br><span class="line">                parent = tmp;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 插入情景3.1.2：叔叔节点不存在或存在且颜色为黑色，并且当前节点为父节点的左儿子。</span></span><br><span class="line">            rightRotate(grandParent);</span><br><span class="line">            parent.setBlack();</span><br><span class="line">            grandParent.setRed();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 父节点为祖父节点的右儿子。</span></span><br><span class="line"></span><br><span class="line">            Node&lt;E&gt; uncle = grandParent.left;</span><br><span class="line">            <span class="comment">// 插入情景3.2.1： 叔叔节点存在且颜色为红色。</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != uncle &amp;&amp; isRed(uncle)) &#123;</span><br><span class="line">                parent.setBlack();</span><br><span class="line">                uncle.setBlack();</span><br><span class="line">                grandParent.setRed();</span><br><span class="line">                root = grandParent;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 插入情景3.2.3： 叔叔节点不存在或存在且颜色为黑色，并且当前节点为父节点的左儿子。</span></span><br><span class="line">            <span class="keyword">if</span> (root == parent.left) &#123;</span><br><span class="line">                rightRotate(parent);</span><br><span class="line">                Node&lt;E&gt; tmp;</span><br><span class="line">                tmp = root;</span><br><span class="line">                root = parent;</span><br><span class="line">                parent = tmp;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 插入情景3.2.2： 叔叔节点不存在或存在且颜色为黑色，并且当前节点为父节点的右儿子。</span></span><br><span class="line">            leftRotate(grandParent);</span><br><span class="line">            parent.setBlack();</span><br><span class="line">            grandParent.setRed();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上述调整可能导致根结点变为红色，在此需要调整。</span></span><br><span class="line">    <span class="keyword">this</span>.root.setBlack();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>删除子过程</p>
<p>将前者节点所在子树替换为后者节点所在子树，同时调整前者节点父节点的孩子节点指向。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">judgeParent</span><span class="params">(Node&lt;E&gt; former, Node&lt;E&gt; latter)</span> </span>&#123;</span><br><span class="line">    latter.parent = former.parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前者的父节点为空，表明其为根节点，故而需要调整root指向。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == former.parent) &#123;</span><br><span class="line">        <span class="keyword">this</span>.root = latter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调整前者父节点的孩子指向。</span></span><br><span class="line">    <span class="keyword">if</span> (former == former.parent.left) &#123;</span><br><span class="line">        former.parent.left = latter;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        former.parent.right = latter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>删除修正</p>
<p>如果待删除节点颜色为黑色，红黑性质五则会遭到破坏，此时需要对红黑树进行一定调整。</p>
<p>删除修正涉及多种情景，我们在此一一详述 (假定此时待删除节点已删除完成，我们需要对顶替待删除节点所在位置的那个节点进行调整操作。图例中 <code>C</code> 表示当前节点，即顶替待删除节点所在位置的那个节点，<code>P</code> 表示父节点，<code>B</code> 表示兄弟节点，<code>LB</code> 表示兄弟节点的左儿子，<code>RB</code> 表示兄弟节点的右儿子，节点颜色为灰色表示该节点颜色或为红色、或为黑色。)。</p>
<blockquote>
<ul>
<li>为保证删除节点后的红黑树满足红黑性质，我们暂且视当前节点额外具有一重黑色。故而下面图例中，我们直接将当前节点颜色置为黑色。</li>
<li>如果待删除节点颜色为黑色，那么根据红黑性质五容易得知：兄弟节点一定存在。</li>
</ul>
</blockquote>
<p><strong>删除情景1：</strong> 当前节点为父节点的左儿子</p>
<p><strong>删除情景1.1：</strong> 兄弟节点颜色为红色</p>
<p>当兄弟节点颜色为红色时，根据红黑性质可容易推知其他相关节点颜色。为维持红黑性质，我们需要先将 <code>P</code> 置为红色、<code>B</code> 置为黑色，然后左旋节点 <code>P</code>，最后使用 <em>删除情景1.2</em> 的处理方法即可。</p>
<p><img src="/2020/06/30/dataStructure/dataStructure-rbtree/image-20200630154921671.png" alt="图十：删除情景1.1"></p>
<p><strong>删除情景1.2：</strong> 兄弟节点颜色为黑色</p>
<p><strong>删除情景1.2.1：</strong> 兄弟节点的左右儿子节点颜色均为黑色</p>
<p>为维持红黑性质，我们需先将 <code>B</code> 置为红色，<code>C</code> 恢复为原本颜色，然后重置节点 <code>P</code> 为当前节点，最后递归处理当前节点即可。</p>
<p><img src="/2020/06/30/dataStructure/dataStructure-rbtree/image-20200630191723288.png" alt="图十一：删除情景1.2.1"></p>
<p><strong>删除情景1.2.2：</strong> 兄弟节点的左儿子颜色为红色，右儿子颜色为黑色</p>
<p>为维持红黑性质，我们需先将 <code>LB</code> 置为黑色、<code>B</code> 置为红色，然后右旋节点 <code>B</code>，最后使用 <em>删除情景1.2.3</em> 的处理方法即可。</p>
<p><img src="/2020/06/30/dataStructure/dataStructure-rbtree/image-20200630161437135.png" alt="图十二：删除情景1.2.2"></p>
<p><strong>删除情景1.2.3：</strong> 兄弟节点的左儿子颜色任意，右儿子颜色为红色</p>
<p>为维持红黑性质，我们需先将 <code>B</code> 置节点 <code>P</code> 原本的颜色、<code>P</code> 置为黑色、<code>RB</code> 置为黑色、<code>C</code> 恢复为原本颜色，然后左旋节点 <code>P</code> 即可。</p>
<p>此情景为删除修正中最为重要的情景，我们在此说明一下 “为什么如下转换是可行的? “。</p>
<p>通过为当前节点添加一重额外的黑色，未调整前的红黑树是满足红黑性质的，此时我们可得到如下等式：$hb(C) = hb(LB) + 1；hb(RB) = hb(LB)$。 通过一系列颜色调整，使得 <code>C</code> 所在子树的黑高减一、<code>RB</code> 所在子树的黑高加一，最终可得到如下等式：$hb(C) = hb(LB)；hb(RB) = hb(LB) + 1$。此时对于 <code>P</code> 和 <code>B</code> 而言，红黑性质五均得到满足，调整完成。</p>
<p><img src="/2020/06/30/dataStructure/dataStructure-rbtree/image-20200630164534109.png" alt="图十三：删除情景1.2.3"></p>
<p><strong>删除情景2：</strong> 当前节点为父节点的右儿子</p>
<p><strong>删除情景2.1：</strong> 兄弟节点颜色为红色</p>
<p>当兄弟节点颜色为红色时，根据红黑性质可容易推知其他相关节点颜色。为维持红黑性质，我们需要先将 <code>P</code> 置为红色、<code>B</code> 置为黑色，然后右旋节点 <code>P</code>，最后使用 <em>删除情景2.2</em> 的处理方法即可。</p>
<p><img src="/2020/06/30/dataStructure/dataStructure-rbtree/image-20200630171048818.png" alt="图十四：删除情景2.1"></p>
<p><strong>删除情景2.2：</strong> 兄弟节点颜色为黑色</p>
<p><strong>删除情景2.2.1：</strong> 兄弟节点的左右儿子节点颜色均为黑色</p>
<p>为维持红黑性质，我们需先将 <code>B</code> 置为红色，<code>C</code> 恢复为原本颜色，然后重置节点 <code>P</code> 为当前节点，最后递归处理当前节点即可。</p>
<p><img src="/2020/06/30/dataStructure/dataStructure-rbtree/image-20200630192222423.png" alt="图十五：删除情景2.2.1"></p>
<p><strong>删除情景2.2.2：</strong> 兄弟节点的左儿子颜色为黑色，右儿子颜色为红色</p>
<p>为维持红黑性质，我们需先将 <code>RB</code> 置为黑色、<code>B</code> 置为红色，然后左旋节点 <code>B</code>，最后使用 <em>删除情景2.2.3</em> 的处理方法即可。</p>
<p><img src="/2020/06/30/dataStructure/dataStructure-rbtree/image-20200630192420802.png" alt="图十六：删除情景2.2.2"></p>
<p><strong>删除情景2.2.3：</strong> 兄弟节点的左儿子为红色，右儿子颜色为任意颜色</p>
<p>为维持红黑性质，我们需先将 <code>B</code> 置节点 <code>P</code> 原本的颜色、<code>P</code> 置为黑色、<code>LB</code> 置为黑色、<code>C</code> 恢复为原本颜色，然后右旋节点 <code>P</code> 即可。</p>
<p>转换可行性解释与 <em>删除情景1.2.3</em> 类似。</p>
<p><img src="/2020/06/30/dataStructure/dataStructure-rbtree/image-20200630173050582.png" alt="图十七：删除情景2.2.3"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteFixUp</span><span class="params">(Node&lt;E&gt; root, Node&lt;E&gt; parent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调整结束条件：root不为红黑树根节点。</span></span><br><span class="line">    <span class="keyword">while</span> (root != <span class="keyword">this</span>.root) &#123;</span><br><span class="line">        <span class="comment">// root节点为父节点左儿子。</span></span><br><span class="line">        <span class="keyword">if</span> (root == parent.left) &#123;</span><br><span class="line">            <span class="comment">// 获取root节点的兄弟节点。</span></span><br><span class="line">            Node&lt;E&gt; brother = parent.right;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 删除情景1.1：兄弟节点颜色为红色。</span></span><br><span class="line">            <span class="keyword">if</span> (isRed(brother)) &#123;</span><br><span class="line">                leftRotate(parent);</span><br><span class="line">                parent.setRed();</span><br><span class="line">                brother.setBlack();</span><br><span class="line">                <span class="comment">// 更新root节点的兄弟节点。</span></span><br><span class="line">                brother = parent.right;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 删除情景1.2.1：兄弟节点的左右儿子节点颜色均为黑色。</span></span><br><span class="line">            <span class="keyword">if</span> (isBlack(brother.left) &amp;&amp; isBlack(brother.right)) &#123;</span><br><span class="line">                brother.setRed();</span><br><span class="line">                root = parent;</span><br><span class="line">                <span class="comment">// 更新root节点的父节点。</span></span><br><span class="line">                parent = root.parent;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isBlack(brother.right)) &#123;</span><br><span class="line">                <span class="comment">// 删除情景1.2.2：兄弟节点的左儿子颜色为红色，右儿子颜色为黑色。</span></span><br><span class="line">                rightRotate(brother);</span><br><span class="line">                brother.left.setBlack();</span><br><span class="line">                brother.setRed();</span><br><span class="line">                <span class="comment">// 更新root节点的兄弟节点。</span></span><br><span class="line">                brother = parent.right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 删除情景1.2.3：兄弟节点的左儿子颜色任意，右儿子颜色为红色。</span></span><br><span class="line">                brother.isBlack = parent.isBlack;</span><br><span class="line">                parent.setBlack();</span><br><span class="line">                brother.right.setBlack();</span><br><span class="line">                leftRotate(parent);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 此一调整可保证红黑树性质得以满足，直接退出即可。</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// root节点为父节点右儿子。</span></span><br><span class="line">            Node&lt;E&gt; brother = parent.left;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 删除情景2.1：兄弟节点颜色为红色。</span></span><br><span class="line">            <span class="keyword">if</span> (isRed(brother)) &#123;</span><br><span class="line">                rightRotate(parent);</span><br><span class="line">                parent.setRed();</span><br><span class="line">                brother.setBlack();</span><br><span class="line">                <span class="comment">// 更新root节点的兄弟节点。</span></span><br><span class="line">                brother = parent.left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 删除情景2.2.1：兄弟节点的左右儿子节点颜色均为黑色。</span></span><br><span class="line">            <span class="keyword">if</span> (isBlack(brother.left) &amp;&amp; isBlack(brother.right)) &#123;</span><br><span class="line">                brother.setRed();</span><br><span class="line">                root = parent;</span><br><span class="line">                <span class="comment">// 更新root节点的父节点。</span></span><br><span class="line">                parent = root.parent;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isBlack(brother.left)) &#123;</span><br><span class="line">                <span class="comment">// 删除情景2.2.2：兄弟节点的左儿子颜色为黑色，右儿子颜色为红色。</span></span><br><span class="line">                leftRotate(brother);</span><br><span class="line">                brother.right.setBlack();</span><br><span class="line">                brother.setRed();</span><br><span class="line">                <span class="comment">// 更新root节点的兄弟节点。</span></span><br><span class="line">                brother = parent.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 删除情景2.2.3：兄弟节点的左儿子为红色，右儿子颜色为任意颜色。</span></span><br><span class="line">                brother.isBlack = parent.isBlack;</span><br><span class="line">                parent.setBlack();</span><br><span class="line">                brother.left.setBlack();</span><br><span class="line">                rightRotate(parent);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 此一调整可保证红黑树性质得以满足，直接退出即可。</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != <span class="keyword">this</span>.root) &#123;</span><br><span class="line">        <span class="keyword">this</span>.root.setBlack();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>该函数需要注意一点：传参时需要传入待调整节点的父节点。其原因在于：待调整节点可能为空节点，空节点是无法直接找到其父节点的。</p>
</blockquote>
</li>
</ul>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RBTree</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="操纵"><a href="#操纵" class="headerlink" title="操纵"></a>操纵</h3><ul>
<li><p>红黑树中添加元素</p>
<p>添加元素过程与二叉查找树基本相同，只是在最后多了一个 “插入修正”。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E item)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 红黑树为空，直接创建该节点即可。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == <span class="keyword">this</span>.root) &#123;</span><br><span class="line">        <span class="keyword">this</span>.root = <span class="keyword">new</span> Node&lt;&gt;(item);</span><br><span class="line">        <span class="keyword">this</span>.root.isBlack = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向插入节点。</span></span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">this</span>.root;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 当前节点元素值大于待插入值，则应插入于左子树。</span></span><br><span class="line">        <span class="keyword">if</span> (comparator.compare(node.item, item) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == node.left) &#123;</span><br><span class="line">                node.left = <span class="keyword">new</span> Node&lt;&gt;(item);</span><br><span class="line">                node.left.parent = node;</span><br><span class="line">                node = node.left;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node = node.left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (comparator.compare(node.item, item) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 当前节点元素值等于待插入值，直接返回即可。</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 当前节点元素值小于待插入值，则应插入于右子树。</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == node.right) &#123;</span><br><span class="line">                node.right = <span class="keyword">new</span> Node&lt;&gt;(item);</span><br><span class="line">                node.right.parent = node;</span><br><span class="line">                node = node.right;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node = node.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入修正。</span></span><br><span class="line">    insertFixUp(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>红黑树中删除元素</p>
<p>删除元素过程同样与二叉查找树类似，只是额外多了两个步骤：记录待删除节点颜色以及 “删除修正”。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(E item)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 指向待删除节点。</span></span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">this</span>.root;</span><br><span class="line">    <span class="comment">// 指向待调整节点。</span></span><br><span class="line">    Node&lt;E&gt; judgeNode = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 指向待调整节点的父节点。</span></span><br><span class="line">    Node&lt;E&gt; judgeNodeParent = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 待删除节点是否为黑色。</span></span><br><span class="line">    <span class="keyword">boolean</span> isBlack = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">null</span> != node) &#123;</span><br><span class="line">        <span class="keyword">if</span> (comparator.compare(node.item, item) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (comparator.compare(node.item, item) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 红黑树为空或者不存在具有该元素的节点，直接返回即可。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == node) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    isBlack = node.isBlack;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 待删除节点的左右子树均不为空。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != node.left &amp;&amp; <span class="keyword">null</span> != node.right) &#123;</span><br><span class="line">        <span class="comment">// 获取后继节点。</span></span><br><span class="line">        Node&lt;E&gt; next = getMinTree(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将待删除节点调整为后继节点。</span></span><br><span class="line">        <span class="comment">// 这里有多种方式可以采取。例如直接交换关键字、直接交换这两个节点所有引用指向。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 直接交换二者关键字</span></span><br><span class="line">        E tmp;</span><br><span class="line">        tmp = next.item;</span><br><span class="line">        next.item = node.item;</span><br><span class="line">        node.item = tmp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新node指向及isBlack取值。</span></span><br><span class="line">        node = next;</span><br><span class="line">        isBlack = node.isBlack;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 待删除节点左子树不为空。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != node.left) &#123;</span><br><span class="line">        judgeNode = node.left;</span><br><span class="line">        judgeParent(node, judgeNode);</span><br><span class="line">        judgeNodeParent = judgeNode.parent;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">null</span> != node.right) &#123;</span><br><span class="line">        <span class="comment">// 待删除节点右子树为空。</span></span><br><span class="line">        judgeNode = node.right;</span><br><span class="line">        judgeParent(node, judgeNode);</span><br><span class="line">        judgeNodeParent = judgeNode.parent;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 左右子树均为空。</span></span><br><span class="line">        judgeNodeParent = node.parent;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == node.parent) &#123;</span><br><span class="line">            <span class="keyword">this</span>.root = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (node == node.parent.left) &#123;</span><br><span class="line">                node.parent.left = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node.parent.right = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除节点为黑节点，则需要进行调整。</span></span><br><span class="line">    <span class="keyword">if</span> (isBlack) &#123;</span><br><span class="line">        deleteFixUp(judgeNode, judgeNodeParent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2></li>
</ul>
<h3 id="自顶向下红黑树"><a href="#自顶向下红黑树" class="headerlink" title="自顶向下红黑树"></a>自顶向下红黑树</h3><p>上面所示代码为自底向上实现红黑树，另外还可自顶向下实现红黑树，此种做法的优点在于无需存储父节点信息。</p>
<ul>
<li><p>红黑树中添加元素</p>
<p>自底向上实现红黑树中，当叔叔节点颜色为红色时，需要向上递归处理；当叔叔节点颜色为黑色时，只需要处理当前节点、父节点和祖父节点。因此，为自顶向下实现红黑树，只需要使用一定规则保证 “当需要进行调整时叔叔节点颜色不可能为红色” 即可。</p>
<p>这一规则具体内容如图示：</p>
<p>如果当前节点的左右儿子节点颜色均为红色，那么便置当前节点颜色为红色，左右儿子节点颜色为黑色。</p>
<p><img src="/2020/06/30/dataStructure/dataStructure-rbtree/image-20200703103613118.png" alt="图十八：自顶向下插入调整"></p>
<p>自顶向下实现红黑树中添加元素具体步骤如下：</p>
<ol>
<li>初始化当前节点为 <code>this.root</code>、父节点为 <code>null</code>、祖父节点为 <code>null</code>。</li>
<li>如果当前节点左右儿子节点颜色均为红色，则采用上图加以调整。</li>
<li>如果当前节点父节点颜色亦为红色，则根据当前节点、父节点、祖父节点间关系进行调整。</li>
<li>如果当前节点父节点颜色为黑色，则直接跳转到 <strong>步骤 6</strong> 。</li>
<li>将当前节点元素值与待插入元素值进行对比，更新当前节点、父节点、祖父节点，跳转到 <strong>步骤 2</strong>。</li>
<li>设置根节点颜色为黑色。</li>
</ol>
</li>
<li><p>红黑树中删除元素</p>
<p>自底向上实现红黑树中，我们将删除元素转换为 “删除一个至少含有一个空儿子节点的节点”。当待删除节点的一个儿子节点为空、另一个儿子节点不为空时，我们还可取不空儿子节点所在子树中的最大值/最小值所在节点替换待删除节点，并指定该节点成为待删除节点。依此思路而行，最终待删除节点的左右儿子节点均为空节点。故而，我们便将删除元素进一步转换为 “删除一个两个儿子节点均为空节点的节点”。</p>
<p>如果待删除节点颜色为红色，那么直接删除即可；反之删除后需调整红黑性质。为自顶向下实现红黑树，只需要使用一定规则保证 “当前正在处理的节点颜色为红色” 即可。</p>
<p>假定某一轮调整已保证当前正在处理的节点颜色为红色，如果当前节点并非待删除节点，那么我们需要进一步向下探索，如此可得到如图情况：</p>
<p><img src="/2020/06/30/dataStructure/dataStructure-rbtree/image-20200703153638801.png" alt="图十九：自顶向下删除调整"></p>
<p>此时我们便需要使用一定规则将当前节点颜色调整为红色，这样便可进一步向下探索。最终我们将得到：待删除节点的左右儿子为空，且待删除节点颜色为红色，此时直接删除该节点即可。</p>
<blockquote>
<p>这里涉及的规则比较复杂，就不说了。</p>
</blockquote>
</li>
</ul>
<h3 id="优化红黑树"><a href="#优化红黑树" class="headerlink" title="优化红黑树"></a>优化红黑树</h3><p>插入、删除情景众多，使得红黑树实现代码非常复杂。通过对红黑树结构进一步施加限制，可以得到实现较为简单的简化版红黑树，这其中比较著名的有 BB树、AA树。在此我们仅简要介绍 AA 树。</p>
<p>AA 树对红黑树施以如下限制：一个节点最多只有一个红色儿子节点，且该红色儿子节点只能是该节点的右儿子节点。</p>
<p>如此限制结构，使得插入、删除情景各缩减为两种，大大降低了编程复杂性，具体调整就不在叙述了。</p>
<h3 id="扩张红黑树"><a href="#扩张红黑树" class="headerlink" title="扩张红黑树"></a>扩张红黑树</h3><p>“扩张红黑树” 指代改造红黑树节点结构以支持特定操作，同时保证红黑树原有各种操作可正常实现。这里介绍两种基于此而实现的数据结构——顺序统计树和区间树。</p>
<ul>
<li><p>顺序统计树</p>
<p>顺序统计树可在 $O(log^N)$ 时间内确定指定元素在整棵树中的排名、整棵树中指定排名对应的元素。</p>
<p>向红黑树节点结构中添加字段 <code>size</code> (其意义为：当前节点所在子树含有的节点个数)，即可得到顺序统计树的节点结构。</p>
<blockquote>
<p>实现二叉查找树之时，我顺带实现了顺序统计树，其实现代码参见 <a href="/2020/06/04/dataStructure/dataStructure-binarysearchtree/" title="数据结构-二叉查找树">数据结构-二叉查找树</a>。</p>
</blockquote>
</li>
<li><p>区间树</p>
<p>区间树是一种以区间为元素的数据结构，可在 $O(log^N)$ 时间内实现插入区间元素、删除区间元素、查询与指定区间重叠的区间元素等操作。</p>
<p>区间树的节点结构与红黑树节点结构有较大差别，故而在此列举其结构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">// 区间左端点(关键字)</span></span><br><span class="line">        <span class="keyword">int</span> low;</span><br><span class="line">        <span class="comment">// 区间右端点</span></span><br><span class="line">        <span class="keyword">int</span> high;</span><br><span class="line">        <span class="comment">// 当前子树中所有区间右端点的最大值</span></span><br><span class="line">        <span class="keyword">int</span> max;</span><br><span class="line">        <span class="comment">// 父节点</span></span><br><span class="line">        Node&lt;E&gt; parent;</span><br><span class="line">        <span class="comment">// 左儿子</span></span><br><span class="line">        Node&lt;E&gt; left;</span><br><span class="line">        <span class="comment">// 右儿子</span></span><br><span class="line">        Node&lt;E&gt; right;</span><br><span class="line">        <span class="comment">// 节点颜色</span></span><br><span class="line">        <span class="keyword">boolean</span> isBlack;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们使用区间左端点作为关键字参与排序，故而遍历区间树将得到：各区间按左端点的排列次序依次输出。</p>
</blockquote>
<p>插入区间元素与删除区间元素的操作与红黑树类似，故而不再叙述。我们在此详述 “查询与指定区间重叠的区间元素” 这一操作。</p>
<p>任意两个区间 $i$ 与 $i’$ 一定满足 <strong>区间三分律</strong>，即下面三条性质之一成立：</p>
<ol>
<li>$i$ 与 $i’$ 重叠 ( $i.low \leq i’.high \  且 \  i’.low \leq i.high$ )</li>
<li>$i$ 在 $i’$ 的左边 ( $i.high &lt; i’.low$ )</li>
<li>$i$ 在 $i’$ 的右边 ( $i.low &gt; i’.high$ )</li>
</ol>
<p>根据上面这个定理，可容易得到该操作的伪代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">intervalSearch(T, i)</span><br><span class="line">    x = T.root;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">null</span> != x &amp;&amp; i does not overlop x)</span><br><span class="line">        <span class="comment">// x.left.max &gt;= i.low 表明左子树与i重叠，则在该子树中一定可以找到一个区间与i重叠。</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != x.left &amp;&amp; x.left.max &gt;= i.low)</span><br><span class="line">            x = x.left;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            x = x.right;</span><br><span class="line">    <span class="keyword">return</span>; </span><br></pre></td></tr></table></figure>
<blockquote>
<p>该伪代码仅查询一个重叠区间元素，其时间复杂度为 $O(log^N)$ 。查找全部重叠区间元素也是可以的，但是时间复杂度就无法保证了。</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-伸展树</title>
    <url>/2020/06/21/dataStructure/dataStructure-splaytree/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>伸展树</strong> 是一种自调整的二叉查找树。它没有 AVL 那样严格的平衡条件，通过施以某些调整可使得树上各种操作的平均时间复杂度为 $O(log^N)$。</p>
<a id="more"></a>

<p>其结构图大致如下：</p>
<img src="/2020/06/21/dataStructure/dataStructure-splaytree/1561649132346.png" alt="图一：伸展树" style="zoom:50%;">

<p>我们知道：对于二叉查找树而言，每次操作最坏时间复杂度 $O(N)$ 并非不好，只要它相对不常发生就行。另外我们发现，如果某个节点被访问，那么不久后该节点将再次被访问。基于上述两个事实，伸展树在访问一个节点后，会将该节点旋转至根节点，这样做有两大目的：1. 一定程度上平衡整棵树。2. 降低再次访问该节点所需的时间。</p>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>伸展树无需保存高度信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SplayTree</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 节点结构</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">// 具体元素</span></span><br><span class="line">        E item;</span><br><span class="line">        <span class="comment">// 父节点</span></span><br><span class="line">        Node&lt;E&gt; parent;</span><br><span class="line">        <span class="comment">// 左儿子</span></span><br><span class="line">        Node&lt;E&gt; left;</span><br><span class="line">        <span class="comment">// 右儿子</span></span><br><span class="line">        Node&lt;E&gt; right;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E item)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.item = item;</span><br><span class="line">            <span class="keyword">this</span>.parent = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.left = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.right = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根节点</span></span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; root;</span><br><span class="line">    <span class="comment">// 比较函数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> E&gt; comparator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="辅助方法"><a href="#辅助方法" class="headerlink" title="辅助方法"></a>辅助方法</h3><p>伸展树中的伸展操作主要涉及六大调整，依次为 <code>zig</code>、<code>zag</code>、<code>zig-zig</code>、<code>zag-zag</code>、<code>zig-zag</code>、<code>zag-zig</code>。</p>
<ul>
<li><p>zig</p>
<p>通过 <code>zig</code> 调整使节点 K1 成为根节点。</p>
<p><code>zig</code> 调整与 AVL 中的 <code>LL</code> 基本相同，同为右旋。</p>
<p><img src="/2020/06/21/dataStructure/dataStructure-splaytree/image-20200620225903738.png" alt="图二：zig调整节点K1"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">zig</span><span class="params">(Node&lt;E&gt; root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 右旋要求当前节点为父节点的左儿子，不符合要求直接返回即可。</span></span><br><span class="line">    <span class="keyword">if</span> (root != root.parent.left) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node&lt;E&gt; parent = root.parent;</span><br><span class="line">    Node&lt;E&gt; grandParents = parent.parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首先调整父节点的左儿子指向及对应左儿子的父节点指向。</span></span><br><span class="line">    parent.left = root.right;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != root.right) &#123;</span><br><span class="line">        root.right.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其次调整当前节点的父节点指向及对应父节点的儿子指向。</span></span><br><span class="line">    root.parent = grandParents;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != grandParents) &#123;</span><br><span class="line">        <span class="keyword">if</span> (parent == grandParents.left) &#123;</span><br><span class="line">            grandParents.left = root;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            grandParents.right = root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后调整当前节点的右儿子指向及对应右儿子的父节点指向</span></span><br><span class="line">    root.right = parent;</span><br><span class="line">    parent.parent = root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>zag</p>
<p>通过 <code>zag</code> 调整使节点 K1 成为根节点。</p>
<p><code>zag</code> 调整与 AVL 中的 <code>RR</code> 基本相同，同为左旋。</p>
<p><img src="/2020/06/21/dataStructure/dataStructure-splaytree/image-20200620230148756.png" alt="图三：zag调整节点K1"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">zag</span><span class="params">(Node&lt;E&gt; root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 左旋要求root节点为父节点的右儿子，不符合要求直接返回即可。</span></span><br><span class="line">    <span class="keyword">if</span> (root != root.parent.right) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node&lt;E&gt; parent = root.parent;</span><br><span class="line">    Node&lt;E&gt; grandParents = parent.parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首先调整父节点的右儿子指向及对应右儿子的父节点指向。</span></span><br><span class="line">    parent.right = root.left;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != root.left) &#123;</span><br><span class="line">        root.left.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其次调整当前节点的父节点指向及对应父节点的儿子指向。</span></span><br><span class="line">    root.parent = grandParents;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != grandParents) &#123;</span><br><span class="line">        <span class="keyword">if</span> (parent == grandParents.left) &#123;</span><br><span class="line">            grandParents.left = root;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            grandParents.right = root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后调整当前节点的左儿子指向及对应左儿子的父节点指向。</span></span><br><span class="line">    root.left = parent;</span><br><span class="line">    parent.parent = root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>zig-zig</p>
<p>首先 <code>zig</code> 调整节点 K2，然后 <code>zig</code> 调整节点 K1，最终使得节点 K1 成为根节点。</p>
<p><img src="/2020/06/21/dataStructure/dataStructure-splaytree/image-20200620230611170.png" alt="图四：zig-zig调整节点K1"></p>
</li>
<li><p>zag-zag</p>
<p>首先 <code>zag</code> 调整节点 K2，然后 <code>zag</code> 调整节点 K1，最终使得节点 K1 成为根节点。</p>
<p><img src="/2020/06/21/dataStructure/dataStructure-splaytree/image-20200620230848539.png" alt="图五：zag-zag调整节点K1"></p>
</li>
<li><p>zig-zag</p>
<p>首先 <code>zig</code> 调整节点 K1，然后 <code>zag</code> 调整节点 K1，最终使得节点 K1 成为根节点。</p>
<p><img src="/2020/06/21/dataStructure/dataStructure-splaytree/image-20200620231018307.png" alt="图六：zig-zag调整节点K1"></p>
</li>
<li><p>zag-zig</p>
<p>首先 <code>zag</code> 调整节点 K1，然后 <code>zig</code> 调整节点 K1，最终使得节点 K1 成为根节点。</p>
<p><img src="/2020/06/21/dataStructure/dataStructure-splaytree/image-20200620231251686.png" alt="图六：zag-zig调整节点K1"></p>
</li>
<li><p>伸展操作</p>
<p>将节点 <code>root</code> 伸展到节点 <code>target</code> 的儿子节点处。</p>
<p>伸展操作需使用到上述六大调整，此处代码对此作了些优化。 另外，当传入 <code>target = null</code> 时，需自行调整 <code>root</code> 指向。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">splay</span><span class="params">(Node&lt;E&gt; root, Node&lt;E&gt; target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 节点为空，无需伸展。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == root) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (root.parent != target) &#123;</span><br><span class="line">        Node&lt;E&gt; parent = root.parent;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root == parent.left) &#123;</span><br><span class="line">            <span class="comment">// 表明当前节点为父节点的左儿子。</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 祖父节点存在且父节点为祖父节点的左儿子，那么需要进行zig-zig调整，这种需要先调整父节点才能调整子节点。</span></span><br><span class="line">            <span class="comment">// 如果父节点为祖父节点的右儿子，那么需要进行zig-zag调整，这种属于先调整当前节点随后调整父节点，与当前代码流程相同，故而可不用处理。</span></span><br><span class="line">            <span class="keyword">if</span> (parent.parent != target &amp;&amp; parent == parent.parent.left) &#123;</span><br><span class="line">                zig(parent);</span><br><span class="line">            &#125;</span><br><span class="line">            zig(root);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 表明当前节点为父节点的右儿子。</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 祖父节点存在且父节点为祖父节点的右儿子，那么需要进行zag-zag调整，这种需要先调整父节点才能调整子节点。</span></span><br><span class="line">            <span class="comment">// 如果父节点为祖父节点的左儿子，那么需要进行zag-zig调整。这种属于先调整当前节点随后调整父节点，与当前代码流程相同，故而可不用处理。</span></span><br><span class="line">            <span class="keyword">if</span> (parent.parent != target &amp;&amp; parent == parent.parent.right) &#123;</span><br><span class="line">                zag(parent);</span><br><span class="line">            &#125;</span><br><span class="line">            zag(root);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当前子树中查找具有最小元素的节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;E&gt; <span class="title">getMinTree</span><span class="params">(Node&lt;E&gt; root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node&lt;E&gt; parent = root.parent;</span><br><span class="line">    Node&lt;E&gt; node = root;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">null</span> != node.left) &#123;</span><br><span class="line">        node = node.left;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 访问该节点，就需要将该节点进行伸展。</span></span><br><span class="line">    splay(node, parent);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>当前子树中查找具有最大元素的节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;E&gt; <span class="title">getMaxTree</span><span class="params">(Node&lt;E&gt; root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node&lt;E&gt; parent = root.parent;</span><br><span class="line">    Node&lt;E&gt; node = root;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">null</span> != node.right) &#123;</span><br><span class="line">        node = node.right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问该节点，就需要将该节点进行伸展。</span></span><br><span class="line">    splay(node, parent);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SplayTree</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><ul>
<li><p>查询指定元素是否存在</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E item)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 伸展树为空，直接返回false即可。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == <span class="keyword">this</span>.root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">this</span>.root;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">null</span> != node) &#123;</span><br><span class="line">        <span class="keyword">if</span> (comparator.compare(node.item, item) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (comparator.compare(node.item, item) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != node) &#123;</span><br><span class="line">        <span class="comment">// 访问该节点，就需要将该节点进行伸展。</span></span><br><span class="line">        <span class="comment">// 伸展到null，需要调整 root 指向。</span></span><br><span class="line">        splay(node, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">this</span>.root = node;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>查询最小元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">E <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.root = getMinTree(<span class="keyword">this</span>.root);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.root.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>查询最大元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">E <span class="title">getMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.root = getMaxTree(<span class="keyword">this</span>.root);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.root.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="操纵"><a href="#操纵" class="headerlink" title="操纵"></a>操纵</h3></li>
<li><p>伸展树中添加元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E item)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 伸展树为空，直接创建该结点即可。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == <span class="keyword">this</span>.root) &#123;</span><br><span class="line">        <span class="keyword">this</span>.root = <span class="keyword">new</span> Node&lt;&gt;(item);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 伸展树不为空，向下查找并插入待插入值。</span></span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">this</span>.root;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 当前节点值大于待插入值，则应在左子树中查找。</span></span><br><span class="line">        <span class="keyword">if</span> (comparator.compare(node.item, item) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == node.left) &#123;</span><br><span class="line">                node.left = <span class="keyword">new</span> Node&lt;&gt;(item);</span><br><span class="line">                node.left.parent = node;</span><br><span class="line">                node = node.left;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node = node.left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (comparator.compare(node.item, item) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 当前节点值等于待插入值，直接返回即可。</span></span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 当前节点值小于待插入值，则应在右子树中查找。</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == node.right) &#123;</span><br><span class="line">                node.right = <span class="keyword">new</span> Node&lt;&gt;(item);</span><br><span class="line">                node.right.parent = node;</span><br><span class="line">                node = node.right;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node = node.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问该节点，就需要将该节点进行伸展。</span></span><br><span class="line">    <span class="comment">// 伸展到null，需要调整 root 指向。</span></span><br><span class="line">    splay(node, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">this</span>.root = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>伸展树中删除指定元素</p>
<p>删除操作采用了比较高明的技巧。具体删除操作步骤如下：</p>
<ol>
<li>查找该元素，如果存在则将其伸展至根节点，否则直接返回。</li>
<li>删除该节点后，将剩余左右两棵子树。如果一方为空，则指定另一方为根节点即可。</li>
<li>两方均不为空，找到左子树中具有最大元素的节点并将其旋转至根节点，那么可想而知：此时左子树的右儿子为空，直接将右子树置于此位置即可。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(E item)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 查找该元素，如果存在则会通过伸展将其置于根结点，否则直接返回即可。</span></span><br><span class="line">    <span class="keyword">if</span> (contains(item) == <span class="keyword">false</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 至少一方为空。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == <span class="keyword">this</span>.root.left &amp;&amp; <span class="keyword">null</span> == <span class="keyword">this</span>.root.right) &#123;</span><br><span class="line">        <span class="keyword">this</span>.root = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == <span class="keyword">this</span>.root.left) &#123;</span><br><span class="line">        <span class="keyword">this</span>.root = <span class="keyword">this</span>.root.right;</span><br><span class="line">        <span class="keyword">this</span>.root.parent = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == <span class="keyword">this</span>.root.right) &#123;</span><br><span class="line">        <span class="keyword">this</span>.root = <span class="keyword">this</span>.root.left;</span><br><span class="line">        <span class="keyword">this</span>.root.parent = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左右子树均不为空。</span></span><br><span class="line">    <span class="comment">// 获取左子树中最大节点，亦即当前根节点的前驱节点。</span></span><br><span class="line">    Node&lt;E&gt; pre = getMaxTree(<span class="keyword">this</span>.root.left);</span><br><span class="line">    pre.parent = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 置前驱节点的右儿子为当前根节点的右儿子。</span></span><br><span class="line">    pre.right = <span class="keyword">this</span>.root.right;</span><br><span class="line">    pre.right.parent = pre;</span><br><span class="line">    <span class="comment">// 调整root指向。</span></span><br><span class="line">    <span class="keyword">this</span>.root = pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>上面所示代码为自底向上实现伸展树，另外还可自顶向下实现伸展树。大致做法为：从根节点向叶子节点搜索过程中，依次构造三棵树：<code>L</code> 小于当前树中节点所构成的树，<code>X</code> 当前节点所在树，<code>R</code> 大于当前树中节点所构成的树。最后通过一定规则合并这三棵树，从而使得访问节点成为伸展树的根结点。</p>
<p>具体做法不再详述，该种方法相比于自底向上实现伸展树而言，优点就是无需存储父节点信息。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-斐波那契堆</title>
    <url>/2020/06/15/dataStructure/dataStructure-fibonacciheap/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>斐波那契堆</strong> 属于一种构建极为精妙的堆。它由二项队列改造而成，并将懒惰合并及左式堆的 <code>decreaseKey()</code> 实现方法融入其中，最终造就除删除操作外的所有操作的平均时间复杂度为 $O(1)$。</p>
<a id="more"></a>

<p>其结构图大致如下：</p>
<p><img src="/2020/06/15/dataStructure/dataStructure-fibonacciheap/image2.png" alt="图一：斐波那契堆"></p>
<p>斐波那契堆是具有堆序结构的有根树的集合，该集合中允许具有相同高度的有根树同时存在。该有根树是一棵具有一定限制的树，而正是该种限制，使得有根树中节点数量 $N$ 与根结点的孩子节点数量 $R$ 间具有如下关系： $R = O(log^N)$ ，该关系保证了斐波那契堆之上所有操作的平均时间复杂度。</p>
<blockquote>
<ul>
<li>懒惰合并及左式堆的 <code>decreaseKey()</code> 实现方法见之前文章。</li>
<li>斐波那契堆理论上具有良好的性能，但是由于其编程复杂性及时间复杂度的常数因子过大，使得其并不常用。</li>
</ul>
</blockquote>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>斐波那契堆中节点结构极其复杂，涉及四个节点引用，这也使得其编程较为复杂。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FibonacciHeap</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 节点结构</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">// 具体元素</span></span><br><span class="line">        E item;</span><br><span class="line">        <span class="comment">// 度(当前节点的孩子数目)</span></span><br><span class="line">        <span class="keyword">int</span> degree;</span><br><span class="line">        <span class="comment">// 自上次成为另一个节点的孩子以来，是否失去过孩子</span></span><br><span class="line">        <span class="comment">// 基于此字段对有根树施以限制。</span></span><br><span class="line">        <span class="keyword">boolean</span> mark;</span><br><span class="line">        <span class="comment">// 父亲节点</span></span><br><span class="line">        Node&lt;E&gt; parent;</span><br><span class="line">        <span class="comment">// 某一个孩子节点</span></span><br><span class="line">        Node&lt;E&gt; child;</span><br><span class="line">        <span class="comment">// 左兄弟</span></span><br><span class="line">        Node&lt;E&gt; left;</span><br><span class="line">        <span class="comment">// 右兄弟</span></span><br><span class="line">        Node&lt;E&gt; right;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E item)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.item = item;</span><br><span class="line">            <span class="keyword">this</span>.degree = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">this</span>.mark = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">this</span>.parent = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.child = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.left = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.right = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 指向斐波那契堆最小节点,用以访问整个斐波那契堆</span></span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; min;</span><br><span class="line">    <span class="comment">// 堆中节点个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> currentSize;</span><br><span class="line">    <span class="comment">// 比较函数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> E&gt; comparator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="辅助方法"><a href="#辅助方法" class="headerlink" title="辅助方法"></a>辅助方法</h3><ul>
<li><p>合并两个环形链表</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unionLinked</span><span class="params">(Node&lt;E&gt; e1, Node&lt;E&gt; e2)</span> </span>&#123;</span><br><span class="line">    e1.right.left = e2.left;</span><br><span class="line">    e2.left.right = e1.right;</span><br><span class="line">    e1.right = e2;</span><br><span class="line">    e2.left = e1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>从环形链表中剔除指定节点 (当前节点非环形链表中最后一个节点)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteLinkedNode</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">    node.left.right = node.right;</span><br><span class="line">    node.right.left = node.left;</span><br><span class="line">    node.left = <span class="keyword">null</span>;</span><br><span class="line">    node.right = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>向指定环形链表中添加指定节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addLinkedNode</span><span class="params">(Node&lt;E&gt; node, Node&lt;E&gt; root)</span> </span>&#123;</span><br><span class="line">    node.left = root.left;</span><br><span class="line">    node.right = root;</span><br><span class="line">    root.left = node;</span><br><span class="line">    node.left.right = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>链接两棵有根树，将根值小者作为根值大者的孩子，并返回最终结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;E&gt; <span class="title">linkTree</span><span class="params">(Node&lt;E&gt; e1, Node&lt;E&gt; e2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 保证e1为根值小者，e2为根值大者。</span></span><br><span class="line">    <span class="keyword">if</span> (comparator.compare(e1.item, e2.item) &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> linkTree(e2, e1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果e1孩子节点为空，则需调整以指向e2。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == e1.child) &#123;</span><br><span class="line">        e2.left = e2;</span><br><span class="line">        e2.right = e2;</span><br><span class="line">        e1.child = e2;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        addLinkedNode(e2, e1.child);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新其他信息</span></span><br><span class="line">    <span class="comment">// 按照上述mark定义，此处应当置为false。</span></span><br><span class="line">    e2.parent = e1;</span><br><span class="line">    e2.mark = <span class="keyword">false</span>;</span><br><span class="line">    e1.degree++;</span><br><span class="line">    <span class="keyword">return</span> e1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>根链表有根树合并</p>
<p>根链表指代 <code>min</code> 字段指向的那个环形链表。</p>
<p>该部分做法与懒惰二项队列合并相同高度的二项树做法类似。具体步骤如下：</p>
<ol>
<li>构建一个集合，用于存放含有不同度数的有根树。</li>
<li>每次从环形链表中取出一棵有根树，如果集合中存在相同度数的有根树则合并，否则直接将其置于集合中即可。</li>
<li>根据集合，构建出一个环形链表，将 <code>min</code> 字段指向最小节点即可。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 估计有根树的最大度数。</span></span><br><span class="line">    <span class="keyword">int</span> rootNum = (<span class="keyword">int</span>)Math.floor(Math.log(<span class="keyword">this</span>.currentSize) / Math.log(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化一个存放相同度数有根树集合。</span></span><br><span class="line">    Node&lt;E&gt;[] trees = <span class="keyword">new</span> Node[rootNum];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每次从根链表中提取一个节点，将其置于有根树集合中。</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        Node&lt;E&gt; node1 = <span class="keyword">this</span>.min.right;</span><br><span class="line">        <span class="keyword">if</span> (node1 == <span class="keyword">this</span>.min) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        deleteLinkedNode(node1);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> degree = node1.degree;</span><br><span class="line">        <span class="comment">// 如果链表集当前度数位置不为空，表明需进行合并。</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">null</span> != trees[degree]) &#123;</span><br><span class="line">            Node&lt;E&gt; node2 = trees[degree];</span><br><span class="line">            node1 = linkTree(node1, node2);</span><br><span class="line">            trees[degree] = <span class="keyword">null</span>;</span><br><span class="line">            degree++;</span><br><span class="line">        &#125;</span><br><span class="line">        trees[degree] = node1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将有根树集合中的树恢复为根链表，并更新min字段。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; trees.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == trees[i]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == <span class="keyword">this</span>.min) &#123;</span><br><span class="line">            <span class="keyword">this</span>.min = trees[i];</span><br><span class="line">            <span class="keyword">this</span>.min.left = <span class="keyword">this</span>.min;</span><br><span class="line">            <span class="keyword">this</span>.min.right = <span class="keyword">this</span>.min;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            addLinkedNode(trees[i], <span class="keyword">this</span>.min);</span><br><span class="line">            <span class="keyword">this</span>.min = comparator.compare(<span class="keyword">this</span>.min.item, trees[i].item) &gt; <span class="number">0</span> ? trees[i] : <span class="keyword">this</span>.min;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>相关定理证明得到：斐波那契堆中有根树的最大度数 $D$ 与堆中节点数量 $N$ 之间具有如下关系：$D \leq \lfloor log_{\phi}^N \rfloor, \phi = (1 + \sqrt{5}) / 2 \approx 1.618$。</p>
</blockquote>
</li>
<li><p>切除当前节点与父节点间关系，并将当前节点置于根链表之中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cut</span><span class="params">(Node&lt;E&gt; node, Node&lt;E&gt; parent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前节点为父节点唯一节点，则需置空父节点的孩子节点指向，否则将该节点从父节点的孩子节点所在环形链表中删除即可。</span></span><br><span class="line">    <span class="keyword">if</span> (node.right == node) &#123;</span><br><span class="line">        parent.child = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        deleteLinkedNode(node);</span><br><span class="line">    &#125;</span><br><span class="line">    parent.degree--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将当前节点置于根链表之中。</span></span><br><span class="line">    <span class="comment">// 按照上述mark定义，此处应当置为false。</span></span><br><span class="line">    addLinkedNode(node, <span class="keyword">this</span>.min);</span><br><span class="line">    node.parent = <span class="keyword">null</span>;</span><br><span class="line">    node.mark = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>级联切除</p>
<p>通过 <code>mark</code> 字段判断是否需要及时将当前节点置于根链表之中，以保证有根树中节点数量 $N$ 与根结点的孩子节点数量 $R$ 之间的关系。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cascadingCut</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">    Node&lt;E&gt; parent = node.parent;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != parent) &#123;</span><br><span class="line">        <span class="comment">// 如果当前节点为非根节点，且为第二次失去儿子节点，则应当将其与父节点断开，置于根链表之中。</span></span><br><span class="line">        <span class="keyword">if</span> (node.mark) &#123;</span><br><span class="line">            cut(node, parent);</span><br><span class="line">            cascadingCut(parent);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 那么这便是首次失去儿子节点，应当将mark置为true。</span></span><br><span class="line">            node.mark = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FibonacciHeap</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><ul>
<li><p>查询最小元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span> == <span class="keyword">this</span>.min ? <span class="keyword">null</span> : <span class="keyword">this</span>.min.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="操纵"><a href="#操纵" class="headerlink" title="操纵"></a>操纵</h3></li>
<li><p>斐波那契堆中添加元素</p>
<p>直接将节点置于根链表之中即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(E item)</span> </span>&#123;</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;&gt;(item);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == <span class="keyword">this</span>.min) &#123;</span><br><span class="line">        <span class="comment">// 将当前节点构成一个双向链表</span></span><br><span class="line">        node.left = node;</span><br><span class="line">        node.right = node;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置最小节点指向</span></span><br><span class="line">        <span class="keyword">this</span>.min = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 将当前节点插入到根链表之中</span></span><br><span class="line">        addLinkedNode(node, <span class="keyword">this</span>.min);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前节点比最小节点小，则需更新</span></span><br><span class="line">        <span class="keyword">this</span>.min = comparator.compare(<span class="keyword">this</span>.min.item, node.item) &lt; <span class="number">0</span> ? <span class="keyword">this</span>.min : node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.currentSize++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>斐波那契堆合并</p>
<p>直接将两者根链表合并即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(FibonacciHeap&lt;E&gt; fibonacciHeap)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 待合并堆为空，或者待合并堆就是当前堆，直接返回即可</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == fibonacciHeap.min || fibonacciHeap == <span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前堆为空，则直接将待合并堆赋值给当前堆即可</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == <span class="keyword">this</span>.min) &#123;</span><br><span class="line">        <span class="keyword">this</span>.min = fibonacciHeap.min;</span><br><span class="line">        <span class="keyword">this</span>.currentSize = fibonacciHeap.currentSize;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二者皆不为空，先合并根链表，然后更新最小节点</span></span><br><span class="line">    <span class="keyword">this</span>.min = unionLinked(<span class="keyword">this</span>.min, fibonacciHeap.min);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.min = comparator.compare(<span class="keyword">this</span>.min.item, fibonacciHeap.min.item) &gt; <span class="number">0</span> ? fibonacciHeap.min : <span class="keyword">this</span>.min;</span><br><span class="line">    <span class="keyword">this</span>.currentSize = <span class="keyword">this</span>.currentSize + fibonacciHeap.currentSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>斐波那契堆中指定节点降低元素值</p>
<p>具体实现与左式堆中  <code>decreaseKey()</code> 操作实现类似。如果指定节点降低元素值后当前有根树不满足堆序性质，则将当前节点所在子树置于根链表之中，同时调整当前有根树。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decreaseKey</span><span class="params">(Node&lt;E&gt; node, E item)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果待赋值大于当前节点值，直接返回即可。</span></span><br><span class="line">    <span class="keyword">if</span> (comparator.compare(node.item, item) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node.item = item;</span><br><span class="line"></span><br><span class="line">    Node&lt;E&gt; parent = node.parent;</span><br><span class="line">    <span class="comment">// 当前节点父节点不为空，表明非有根树的根结点。另外如果减值后值小于父节点值，则需要进行调整以保证堆序</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != parent &amp;&amp; comparator.compare(node.item, parent.item) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 将当前节点从父节点中清除，并置于根链表之中。</span></span><br><span class="line">        cut(node, parent);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 级联切除</span></span><br><span class="line">        cascadingCut(parent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 减值后的值小于最小节点值，则应当更新最小节点。</span></span><br><span class="line">    <span class="keyword">if</span> (comparator.compare(node.item, <span class="keyword">this</span>.min.item) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.min = node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>斐波那契堆中删除最小节点</p>
<p>删除最小节点后，可能根链表中有根树过多，此时需要进行一次集中合并。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">deleteMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前堆为空，直接返回空即可。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == <span class="keyword">this</span>.min) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node&lt;E&gt; deleteNode = <span class="keyword">this</span>.min;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 待删除节点存在孩子节点，则将其置于当前堆的根链表之中</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != deleteNode.child) &#123;</span><br><span class="line">        Node&lt;E&gt; tmp = deleteNode.child;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">null</span> != tmp) &#123;</span><br><span class="line">            tmp.parent = <span class="keyword">null</span>;</span><br><span class="line">            tmp = tmp.right == deleteNode.child ? <span class="keyword">null</span> : tmp.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.min = unionLinked(<span class="keyword">this</span>.min, deleteNode.child);</span><br><span class="line">        deleteNode.child = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从当前堆中移除该节点</span></span><br><span class="line">    <span class="keyword">if</span> (deleteNode.right == deleteNode) &#123;</span><br><span class="line">        <span class="comment">// 堆中仅有这一个节点，移除后置空最小节点</span></span><br><span class="line">        <span class="keyword">this</span>.min = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 这里更新最小节点，并指向待删除节点的右兄弟。此时最小节点指向不需要一定正确，后续会进行union操作。</span></span><br><span class="line">        <span class="keyword">this</span>.min = deleteNode.right;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从根链表中删除最小节点</span></span><br><span class="line">        deleteLinkedNode(deleteNode);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除最小节点使得根链表中节点过多，因此需要整理，顺便找到最小节点。</span></span><br><span class="line">        union();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.currentSize--;</span><br><span class="line">    <span class="keyword">return</span> deleteNode.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>斐波那契堆中删除指定节点</p>
<p>具体操作可通过上面两个操作加以实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">    decreaseKey(node, <span class="keyword">this</span>.min.item);</span><br><span class="line">    <span class="keyword">this</span>.min = node;</span><br><span class="line">    deleteMin();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-并查集</title>
    <url>/2020/06/07/dataStructure/dataStructure-unionfind/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>并查集</strong> 是一种基于双亲表示法表示的森林。它以一棵树表示一个集合，进而处理不相交集合的合并、查询问题。</p>
<a id="more"></a>

<p>其结构图大致如下：</p>
<p><img src="/2020/06/07/dataStructure/dataStructure-unionfind/v2-3bf6c1a6ecf87fa93f4dbab2012446c7_r.jpg" alt="图一：并查集"></p>
<p>针对并查集中的合并、查询操作有多种优化手段，我们在此提前介绍，并且仅展示优化后的代码。</p>
<ul>
<li><p>针对合并操作的优化</p>
<ul>
<li>按大小求并：总让含有较少元素的树成为含有较多元素的树的子树。</li>
<li>按高度求并：总让高度较低的树成为高度较高的树的子树。</li>
</ul>
</li>
<li><p>针对查询操作的优化</p>
<ul>
<li>路径压缩：将查找点到根结点的路径上所有结点的父节点直接指定为根结点。</li>
</ul>
</li>
<li><p>综合合并、查询优化</p>
<p>按大小求并与路径压缩二者可同时实现，而按高度求并与路径压缩并不能同时实现，原因在于：路径压缩会破坏树的高度。由于此时节点存储的高度信息实际上为预估高度，故而称此时的按高度求并为按秩求并。</p>
<p>实际中大多数并查集都是基于按秩求并与路径压缩实现的。</p>
</li>
</ul>
<blockquote>
<p>经优化后，并查集各种操作的平均时间复杂度为 $O(1)$，证明过程十分麻烦，故不赘述。</p>
</blockquote>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>如上所述，并查集基于双亲表示法实现，故而使用数组最为合适。另外，本文仅考虑位置间合并、查询操作，而不考虑元素间合并、查询操作，毕竟通过散列表可将后者转换为前者。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 节点结构</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 父节点</span></span><br><span class="line">        <span class="keyword">int</span> parent;</span><br><span class="line">        <span class="comment">// 秩(预估高度)</span></span><br><span class="line">        <span class="keyword">int</span> rank;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 节点集</span></span><br><span class="line">    <span class="keyword">private</span> Node[] nodes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>各个位置自成一棵树，并使用根结点位置标识这一棵树。另外根据当前节点的父节点是否就是它自己，即可判断当前节点是否为所在树的根节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    nodes = <span class="keyword">new</span> Node[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        nodes[i].parent = i;</span><br><span class="line">        nodes[i].rank = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 表明为根节点，返回标识</span></span><br><span class="line">    <span class="keyword">if</span> (index == <span class="keyword">this</span>.nodes[index].parent) &#123;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 路径压缩</span></span><br><span class="line">    <span class="keyword">int</span> root = find(<span class="keyword">this</span>.nodes[index].parent);</span><br><span class="line">    <span class="keyword">this</span>.nodes[index].parent = root;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> index1, <span class="keyword">int</span> index2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> root1 = find(index1);</span><br><span class="line">    <span class="keyword">int</span> root2 = find(index2);</span><br><span class="line">    <span class="comment">// 如果二者具有相同的树标识，表明二者是在同一棵树中，无需合并。</span></span><br><span class="line">    <span class="keyword">if</span> (root1 == root2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按秩求并。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.nodes[root1].rank &lt; <span class="keyword">this</span>.nodes[root2].rank) &#123;</span><br><span class="line">        <span class="keyword">this</span>.nodes[root1].parent = root2;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.nodes[root1].rank &lt; <span class="keyword">this</span>.nodes[root2].rank) &#123;</span><br><span class="line">        <span class="keyword">this</span>.nodes[root2].parent = root1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.nodes[root1].parent = root2;</span><br><span class="line">        <span class="keyword">this</span>.nodes[root1].rank++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-平衡二叉树</title>
    <url>/2020/06/05/dataStructure/dataStructure-avl/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>AVL (平衡二叉树)</strong> 是一种自平衡的二叉查找树。该平衡条件为：对于每个节点而言，左右子树的高度差不超过 1。</p>
<a id="more"></a>

<p>其结构图大致如下：</p>
<p><img src="/2020/06/05/dataStructure/dataStructure-avl/1115031-70d8f9c2f0dd35aa.png" alt="图一：平衡二叉树"></p>
<p>平衡二叉树所涉操作的代码实现与二叉查找树基本相同，但是由于插入、删除操作可能破坏平衡条件，故而这两个操作需要一定额外代码以恢复平衡。为精简篇幅，本文仅展示插入、删除操作的代码实现。</p>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AVL</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 节点结构</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">// 具体元素</span></span><br><span class="line">        E item;</span><br><span class="line">        <span class="comment">// 左儿子</span></span><br><span class="line">        Node&lt;E&gt; left;</span><br><span class="line">        <span class="comment">// 右儿子</span></span><br><span class="line">        Node&lt;E&gt; right;</span><br><span class="line">        <span class="comment">// 当前子树的高度</span></span><br><span class="line">        <span class="keyword">int</span> height;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E item, Node&lt;E&gt; left, Node&lt;E&gt; right, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.item = item;</span><br><span class="line">            <span class="keyword">this</span>.left = left;</span><br><span class="line">            <span class="keyword">this</span>.right = right;</span><br><span class="line">            <span class="keyword">this</span>.height = height;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 比较函数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> E&gt; comparator;</span><br><span class="line">    <span class="comment">// 根节点</span></span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="辅助方法"><a href="#辅助方法" class="headerlink" title="辅助方法"></a>辅助方法</h3><ul>
<li><p>获取节点高度</p>
<p>空节点高度指定为 -1，方便后面编码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span> == node ? -<span class="number">1</span> : node.height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>调整节点高度</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reHeight</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == node) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    node.height = Math.max(height(node.left), height(node.right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>当前子树中查找最小元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">getMinTree</span><span class="params">(Node&lt;E&gt; root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前子树为空，直接返回空节点即可。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == root.left) &#123;</span><br><span class="line">        <span class="comment">// 当前子树根节点的左儿子为空，表明这是最左节点，此一定为最小元素，故直接返回之。</span></span><br><span class="line">        <span class="keyword">return</span> root.item;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 当前子树根节点的左儿子不为空，则在左子树中查找最小元素。</span></span><br><span class="line">        <span class="keyword">return</span> getMinTree(root.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>当前子树中查找最大元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">getMaxTree</span><span class="params">(Node&lt;E&gt; root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前子树为空，直接返回空节点即可。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == root.right) &#123;</span><br><span class="line">        <span class="comment">// 当前子树根节点的右儿子为空，表明这是最右节点，此一定为最大元素，故直接返回之。</span></span><br><span class="line">        <span class="keyword">return</span> root.item;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 当前子树根节点的右儿子不为空，则在右子树中查找最大元素。</span></span><br><span class="line">        <span class="keyword">return</span> getMaxTree(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>调整操作</p>
<p>向树中插入元素时，从插入点到根节点的路径上的所有节点的平衡条件都有可能被破坏，因为只有它们的子树可能发生变化。</p>
<p>从插入点沿该路径上行到根节点的过程中，我们称第一个平衡条件被破坏的节点为 $\alpha$ 。实践证明：通过调整 $\alpha$， 不仅可使得 $\alpha$ 满足平衡条件，同时可保证该路径上的其他节点也都满足平衡条件。接下来我们将详细讲述如何调整？</p>
<p>由平衡二叉树定义可知，平衡条件被破坏意指 $\alpha$ 的左右子树高度差为 2。具体可分为两种情况，如图二所示 ( $K2$ 指代 $\alpha$，较高子树高度比较低子树高度大 2 )：</p>
<p><img src="/2020/06/05/dataStructure/dataStructure-avl/image-20200604211827699.png" alt="图二：平衡条件被破坏的两种情况"></p>
<p>依据上图无法实施调整，因此可进一步细化为下图 ( $K2$ 指代 $\alpha$，两个较低子树具有相同高度，较高子树高度比较低子树高度大 1 )：</p>
<p><img src="/2020/06/05/dataStructure/dataStructure-avl/image-20200604211850103.png" alt="图三：平衡条件被破坏的四种情况"></p>
<p>该图从左到右四种情况，我们依次称之为：对 $\alpha$ 的左儿子的左子树进行一次插入 (LL)、对 $\alpha$ 的左儿子的右子树进行一次插入 (LR)、对 $\alpha$ 的右儿子的左子树进行一次插入 (RL)、对 $\alpha$ 的右儿子的右子树进行一次插入 (RR)。</p>
<p>情况一、四可通过对树的一次 <em>单旋转</em> 而完成调整，情况二、三则需要通过稍微复杂的 <em>双旋转</em> 完成调整。</p>
<p><strong>单旋转：</strong></p>
<ul>
<li><p>LL</p>
<p>调整方法如下：</p>
<p><img src="/2020/06/05/dataStructure/dataStructure-avl/image-20200604212141073.png" alt="图四：LL调整"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;E&gt; <span class="title">LL</span><span class="params">(Node&lt;E&gt; root)</span> </span>&#123;</span><br><span class="line">    Node&lt;E&gt; k1 = root.left;</span><br><span class="line">    Node&lt;E&gt; k2 = root;</span><br><span class="line">    k2.left = k1.right;</span><br><span class="line">    k1.right = k2;</span><br><span class="line">        reHeight(k1);</span><br><span class="line">    reHeight(k2);</span><br><span class="line">        <span class="keyword">return</span> k1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>RR</p>
<p>调整方法如下：</p>
<p><img src="/2020/06/05/dataStructure/dataStructure-avl/image-20200604212425415.png" alt="图五：RR调整"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;E&gt; <span class="title">RR</span><span class="params">(Node&lt;E&gt; root)</span> </span>&#123;</span><br><span class="line">    Node&lt;E&gt; k1 = root.right;</span><br><span class="line">    Node&lt;E&gt; k2 = root;</span><br><span class="line">    k2.right = k1.left;</span><br><span class="line">    k1.left = k2;</span><br><span class="line">    reHeight(k1);</span><br><span class="line">    reHeight(k2);</span><br><span class="line">    <span class="keyword">return</span> k1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>双旋转：</strong></p>
<p>依据图三无法针对情况二、三进行调整，故而对情况二、三进一步细化：</p>
<p>  <img src="/2020/06/05/dataStructure/dataStructure-avl/image-20200604214811255.png" alt="图六：细化LR与RL"></p>
<ul>
<li><p>LR</p>
<p>调整方法如下：</p>
<p><img src="/2020/06/05/dataStructure/dataStructure-avl/image-20200605095818357.png" alt="图七：LR调整"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;E&gt; <span class="title">LR</span><span class="params">(Node&lt;E&gt; root)</span> </span>&#123;</span><br><span class="line">    root.left = RR(root.left);</span><br><span class="line">    root = LL(root);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>RL</p>
<p>调整方法如下：</p>
<p><img src="/2020/06/05/dataStructure/dataStructure-avl/image-20200605100627457.png" alt="图八：RL调整"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;E&gt; <span class="title">RL</span><span class="params">(Node&lt;E&gt; root)</span> </span>&#123;</span><br><span class="line">    root.right = LL(root.right);</span><br><span class="line">    root = RR(root);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>细化依据：平衡条件被破坏意指 $\alpha$ 的左右子树高度差为 2。那么高度较高的子树一定可以提取出一个儿子节点和一个孙子节点。</li>
<li>我们知道：插入元素最多可使得子树高度增加一。故而原先保持平衡条件的子树高度比平衡条件被破坏后的子树高度小一。另外观察四种情况的恢复平衡图，可以发现恢复平衡后子树高度比平衡条件被破坏后子树高度小一。综合二者可得到如下结论：原先保持平衡条件的子树高度与恢复平衡后子树高度相同。既然相同，从 $\alpha$ 上行到根节点的路径上的所有节点的平衡条件自然无需再做调整。</li>
</ul>
</blockquote>
</li>
</ul>
</li>
<li><p>当前子树中插入元素，并返回插入元素后的该子树</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;E&gt; <span class="title">addTree</span><span class="params">(Node&lt;E&gt; root, E item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == root) &#123;</span><br><span class="line">        <span class="comment">// 向空树中插入元素，直接返回该元素即可。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Node&lt;&gt;(item, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (comparator.compare(root.item, item) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 当前子树根节点值大于指定元素，表明应当插于左子树之中。</span></span><br><span class="line">        root.left = addTree(root.left, item);</span><br><span class="line">        <span class="comment">// 插入可能导致平衡条件被破坏，应当进行适当调整</span></span><br><span class="line">        <span class="keyword">if</span> (height(root.left) - height(root.right) == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (height(root.left.left) &gt; height(root.left.right)) &#123;</span><br><span class="line">                <span class="comment">// 左儿子的左子树高度高于左儿子的右子树，对应情况一。</span></span><br><span class="line">                root = LL(root);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 左儿子的左子树高度低于左儿子的右子树，对应情况二。</span></span><br><span class="line">                root = LR(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (comparator.compare(root.item, item) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 当前子树根节点值小于指定元素，表明应当插于右子树之中。</span></span><br><span class="line">        root.right = addTree(root.right, item);</span><br><span class="line">        <span class="comment">// 插入可能导致平衡条件被破坏，应当进行适当调整</span></span><br><span class="line">        <span class="keyword">if</span> (height(root.right) - height(root.left) == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (height(root.right.right) &gt; height(root.right.left)) &#123;</span><br><span class="line">                <span class="comment">// 右儿子的右子树高度高于右儿子的左子树，对应情况四。</span></span><br><span class="line">                root = RR(root);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 右儿子的右子树高度低于右儿子的左子树，对应情况三。</span></span><br><span class="line">                root = RL(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    reHeight(root);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>当前子树中删除指定元素，并返回删除指定元素后的该子树</p>
<p>删除策略与二叉查找树中采取的策略大致相同。另外，通过将删除操作等价于添加操作，实现借用上述四种情况实施调整以恢复平衡条件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;E&gt; <span class="title">deleteTree</span><span class="params">(Node&lt;E&gt; root, E item)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前子树根节点为空，直接返回空即可。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (comparator.compare(root.item, item) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 当前子树根节点值大于给定元素，则待删除元素一定位于左子树。</span></span><br><span class="line">        root.left = deleteTree(root.left, item);</span><br><span class="line">        <span class="comment">// 删除可能导致平衡条件被破坏，应当进行适当调整</span></span><br><span class="line">        <span class="comment">// 向当前子树的左子树删除一个元素等价于向当前子树的右子树中添加一个元素，因此失衡条件判断应当为当前子树的右子树高度比当前子树的左子树高度大2。</span></span><br><span class="line">        <span class="keyword">if</span> (height(root.right) - height(root.left) == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (height(root.right.right) &gt; height(root.right.left)) &#123;</span><br><span class="line">                <span class="comment">// 右儿子的右子树高度高于右儿子的左子树，对应情况四。</span></span><br><span class="line">                root = RR(root);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 右儿子的右子树高度低于右儿子的左子树，对应情况三。</span></span><br><span class="line">                root = RL(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (comparator.compare(root.item, item) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 当前子树根节点值小于给定元素，则待删除元素一定位于右子树。</span></span><br><span class="line">        root.right = deleteTree(root.right, item);</span><br><span class="line">        <span class="comment">// 删除可能导致平衡条件被破坏，应当进行适当调整</span></span><br><span class="line">        <span class="comment">// 向当前子树的右子树删除一个元素等价于向当前子树的左子树添加一个元素，因此失衡条件判断应当为当前子树的左子树高度比当前子树的右子树高度大2。</span></span><br><span class="line">        <span class="keyword">if</span> (height(root.left) - height(root.right) == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (height(root.left.left) &gt; height(root.left.right)) &#123;</span><br><span class="line">                <span class="comment">// 左儿子的左子树高度高于左儿子的右子树，对应情况一。</span></span><br><span class="line">                root = LL(root);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 左儿子的左子树高度低于左儿子的右子树，对应情况二。</span></span><br><span class="line">                root = LR(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 当前元素就是待删除元素</span></span><br><span class="line">        <span class="comment">// 左右儿子其中一者为空，直接将另一者所在子树作为当前子树，这种操作并不会使得平衡条件被破坏，因此无需调整。</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == root.left) &#123;</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">null</span> == root.right) &#123;</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 删除元素最多使得当前子树高度差增加一。这里采取从高度较高的子树中删除一个元素，即使使得高度差增加一，也不会使当前子树根节点的平衡条件被破坏。</span></span><br><span class="line">            <span class="comment">// 左右儿子节点均不为空。采取与二叉查找树删除操作类似做法，但是有所改进。</span></span><br><span class="line">            <span class="keyword">if</span> (height(root.left) &gt; height(root.right)) &#123;</span><br><span class="line">                <span class="comment">// 当前子树的左子树更高，则找到当前子树左子树的最大值，将其与当前元素交换后，删除当前子树左子树的最大值即可。</span></span><br><span class="line">                root.item = getMaxTree(root.left);</span><br><span class="line">                root.left = deleteTree(root.left, root.item);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 当前子树的右子树更高，则找到当前子树右子树的最小值，将其与当前元素交换后，删除当前子树右子树的最小值即可。</span></span><br><span class="line">                root.item = getMinTree(root.right);</span><br><span class="line">                root.right = deleteTree(root.right, root.item);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    reHeight(root);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AVL</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="操纵"><a href="#操纵" class="headerlink" title="操纵"></a>操纵</h3><ul>
<li><p>树中添加元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.root = addTree(<span class="keyword">this</span>.root, item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>树中删除指定元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(E item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.root = deleteTree(<span class="keyword">this</span>.root, item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-二叉查找树</title>
    <url>/2020/06/04/dataStructure/dataStructure-binarysearchtree/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>二叉查找树</strong> 是一种特殊的二叉树。对于二叉查找树中每个节点 $X$ 而言，它的左子树中各个节点的值均小于 $X$ 的值，它的右子树中各个节点的值均大于 $X$ 的值。中序遍历二叉查找树，将得到一个递增排序的序列。</p>
<a id="more"></a>

<p>其结构图大致如下：</p>
<p><img src="/2020/06/04/dataStructure/dataStructure-binarysearchtree/%E4%BA%8C%E5%8F%89%E6%A0%91%E8%A7%A3%E9%87%8A%E5%9B%BE.png" alt="图一：二叉查找树"></p>
<p>对于一棵含有 $N$ 个节点的二叉树而言，其平均深度为 $log^N$。二叉查找树的各种操作均基于深度实现，故而各种操作的平均时间复杂度为 $O(log^N)$。</p>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>为方便实现，规定树中元素各不相同。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 节点结构</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">// 具体元素</span></span><br><span class="line">        E item;</span><br><span class="line">        <span class="comment">// 左儿子</span></span><br><span class="line">        Node&lt;E&gt; left;</span><br><span class="line">        <span class="comment">// 右儿子</span></span><br><span class="line">        Node&lt;E&gt; right;</span><br><span class="line">        <span class="comment">// 元素计数器，当前子树中的元素个数</span></span><br><span class="line">        <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E item, Node&lt;E&gt; left, Node&lt;E&gt; right, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.item = item;</span><br><span class="line">            <span class="keyword">this</span>.left = left;</span><br><span class="line">            <span class="keyword">this</span>.right = right;</span><br><span class="line">            <span class="keyword">this</span>.size = size;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 比较函数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> E&gt; comparator;</span><br><span class="line">    <span class="comment">// 根节点</span></span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="辅助方法"><a href="#辅助方法" class="headerlink" title="辅助方法"></a>辅助方法</h3><p>树中各种操作往往都需要通过递归实现，二叉查找树的各种操作更是如此。</p>
<ul>
<li><p>获取节点的元素计数器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span> == node ? <span class="number">0</span> : node.size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>调整节点的元素计数器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reSize</span><span class="params">(Node&lt;E&gt; root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == root) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    root.size = size(root.left) + size(root.right) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>当前子树中查找指定元素是否存在</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Boolean <span class="title">containsTree</span><span class="params">(Node&lt;E&gt; root, E item)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果当前子树为空，直接返回false即可。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (comparator.compare(root.item, item) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 当前子树根节点值大于待查元素，表明待查元素应该位于左子树之中。</span></span><br><span class="line">        <span class="keyword">return</span> containsTree(root.left, item);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (comparator.compare(root.item, item) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 等于则直接返回true。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 小于表明待查元素应该位于右子树之中。</span></span><br><span class="line">        <span class="keyword">return</span> containsTree(root.right, item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>当前子树中插入元素，并返回插入元素后的该子树</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;E&gt; <span class="title">addTree</span><span class="params">(Node&lt;E&gt; root, E item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == root) &#123;</span><br><span class="line">        <span class="comment">// 向空树中插入元素，直接返回该节点即可。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Node&lt;&gt;(item, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (comparator.compare(root.item, item) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 当前子树根节点值大于待插入元素，表明应当插于左子树之中。</span></span><br><span class="line">        root.left = addTree(root.left, item);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (comparator.compare(root.item, item) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 当前子树根节点值小于待插入元素，表明应当插于右子树之中。</span></span><br><span class="line">        root.right = addTree(root.right, item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    reSize(root);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>当前子树中查找最小元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">getMinTree</span><span class="params">(Node&lt;E&gt; root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前子树为空，直接返回空节点即可。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == root.left) &#123;</span><br><span class="line">        <span class="comment">// 当前子树根节点的左儿子为空，表明这是最左节点，此一定为最小元素，故直接返回之。</span></span><br><span class="line">        <span class="keyword">return</span> root.item;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 当前子树根节点的左儿子不为空，则在左子树中查找最小元素。</span></span><br><span class="line">        <span class="keyword">return</span> getMinTree(root.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>当前子树中查找最大元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">getMaxTree</span><span class="params">(Node&lt;E&gt; root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前子树为空，直接返回空节点即可。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == root.right) &#123;</span><br><span class="line">        <span class="comment">// 当前子树根节点的右儿子为空，表明这是最右节点，此一定为最大元素，故直接返回之。</span></span><br><span class="line">        <span class="keyword">return</span> root.item;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 当前子树根节点的右儿子不为空，则在右子树中查找最大元素。</span></span><br><span class="line">        <span class="keyword">return</span> getMaxTree(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>当前子树中向下取整</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">getFloorTree</span><span class="params">(Node&lt;E&gt; root, E item)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前子树为空，直接返回空节点即可。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (comparator.compare(root.item, item) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 当前子树根节点值大于给定元素，则表明floor(item)一定位于左子树之中。</span></span><br><span class="line">        <span class="keyword">return</span> getFloorTree(root.left, item);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (comparator.compare(root.item, item) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 当前子树根节点值等于给定元素，直接返回即可。</span></span><br><span class="line">        <span class="keyword">return</span> root.item;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 当前子树根节点值小于给定元素，floor(item)可能就是当前元素，或者位于右子树之中。</span></span><br><span class="line">        E element = getFloorTree(root.right, item);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span> == element ? root.item : element;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>当前子树中向上取整</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">getCeilingTree</span><span class="params">(Node&lt;E&gt; root, E item)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前子树为空，直接返回空节点即可。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (comparator.compare(root.item, item) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 当前子树根节点值大于给定元素，ceiling(item)可能就是当前元素，或者位于左子树之中。</span></span><br><span class="line">        E element = getCeilingTree(root.left, item);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span> == element ? root.item : element;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (comparator.compare(root.item, item) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 当前子树根节点值等于给定元素，直接返回即可。</span></span><br><span class="line">        <span class="keyword">return</span> root.item;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 当前子树根节点值小于给定元素，ceiling(item)一定位于右子树之中。</span></span><br><span class="line">        <span class="keyword">return</span> getCeilingTree(root.right, item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>当前子树中查找第 $k$ 个元素 (k从0开始)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">selectTree</span><span class="params">(Node&lt;E&gt; root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 当前子树为空，直接返回空节点即可。</span></span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">null</span> == root) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">       <span class="keyword">int</span> leftNum = size(root.left);</span><br><span class="line">       <span class="keyword">if</span> (leftNum &gt; k) &#123;</span><br><span class="line">           <span class="comment">// 左子树元素个数大于k，则直接到左子树中查找即可。</span></span><br><span class="line">           <span class="keyword">return</span> selectTree(root.left, k);</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (leftNum == k) &#123;</span><br><span class="line">           <span class="comment">// 第leftNum个元素就是当前子树根节点</span></span><br><span class="line">           <span class="keyword">return</span> root.item;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// 左子树元素个数小于k，则应当到右子树中找寻第(k - leftNum - 1)个元素。</span></span><br><span class="line">           <span class="keyword">return</span> selectTree(root.right, k - leftNum - <span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当前子树中查看指定元素排名</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">rankTree</span><span class="params">(Node&lt;E&gt; root, E item)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根节点为空，表明找不到元素，应当返回一个无穷负数</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == root) &#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> leftNum = size(root.left);</span><br><span class="line">    <span class="keyword">if</span> (comparator.compare(root.item, item) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 当前子树根节点值大于指定元素，则表明指定元素应当位于左子树之中。</span></span><br><span class="line">        <span class="keyword">return</span> rankTree(root.left, item);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (comparator.compare(root.item, item) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 二者相等，表明找寻的就是该节点。而该节点排名就是leftNum。</span></span><br><span class="line">        <span class="keyword">return</span> leftNum;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 当前子树根节点值小于指定元素，应该在右子树中查找该元素。并且该元素排名应当为右子树中排名 + leftNum + 1。</span></span><br><span class="line">        <span class="keyword">return</span> leftNum + <span class="number">1</span> + rankTree(root.right, item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>当前子树中删除最小元素，并返回删除最小元素后的该子树</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;E&gt; <span class="title">deleteMinTree</span><span class="params">(Node&lt;E&gt; root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前子树为空，直接返回空节点即可。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == root.left) &#123;</span><br><span class="line">        <span class="comment">// 当前子树根节点的左儿子为空，表明这是最左节点。删除该节点后，直接以右子树作为当前子树即可。</span></span><br><span class="line">        root = root.right;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 当前子树根节点的左儿子不为空，则在左子树中删除最小值。</span></span><br><span class="line">        root.left = deleteMinTree(root.left);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    reSize(root);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>当前子树中删除最大元素，并返回删除最大元素后的该子树</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;E&gt; <span class="title">deleteMaxTree</span><span class="params">(Node&lt;E&gt; root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前子树为空，直接返回空节点即可。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == root.right) &#123;</span><br><span class="line">        <span class="comment">// 当前子树根节点的右儿子为空，表明这是最右节点。删除该节点后，直接以左子树作为当前子树即可。</span></span><br><span class="line">        root = root.left;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 当前子树根节点的右儿子不为空，则在右子树中删除最大值。</span></span><br><span class="line">        root.right = deleteMaxTree(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    reSize(root);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>当前子树中删除指定元素，并返回删除指定元素后的该子树</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;E&gt; <span class="title">deleteTree</span><span class="params">(Node&lt;E&gt; root, E item)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前子树为空，直接返回空即可。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (comparator.compare(root.item, item) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 当前子树根节点值大于给定元素，则待删除元素一定位于左子树。</span></span><br><span class="line">        root.left = deleteTree(root.left, item);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (comparator.compare(root.item, item) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 当前子树根节点值小于给定元素，则待删除元素一定位于右子树。</span></span><br><span class="line">        root.right = deleteTree(root.right, item);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 二者相等，表明当前子树根节点就是待删除节点。</span></span><br><span class="line">        <span class="comment">// 如果左右儿子有一者为空，则直接以另一者表示的子树作为当前子树即可。</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == root.right) &#123;</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">null</span> == root.left) &#123;</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 左右儿子均不为空。为保证删除节点后仍保持有序，将右子树中最小元素赋值给当前子树根节点，然后删除右子树中最小元素即可。</span></span><br><span class="line">            root.item = getMinTree(root.right);</span><br><span class="line">            root.right = deleteMinTree(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    reSize(root);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BinarySearchTree</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><ul>
<li><p>查询指定元素是否存在</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> containsTree(<span class="keyword">this</span>.root, item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>查询最小元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getMinTree(<span class="keyword">this</span>.root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>查询最大元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getMaxTree(<span class="keyword">this</span>.root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>向下取整(查找所有小于等于item中的最大元素)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getFloor</span><span class="params">(E item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getFloorTree(<span class="keyword">this</span>.root, item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>向上取整(查找所有大于等于item中的最小元素)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getCeiling</span><span class="params">(E item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getCeilingTree(<span class="keyword">this</span>.root, item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>查询第 $k$ 个元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">select</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> selectTree(<span class="keyword">this</span>.root, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>查看指定元素是第几个元素(即指定元素排名)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rank</span><span class="params">(E item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> rankTree(<span class="keyword">this</span>.root, item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="操纵"><a href="#操纵" class="headerlink" title="操纵"></a>操纵</h3></li>
<li><p>树中添加元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.root = addTree(<span class="keyword">this</span>.root, item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>树中删除最小元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.root = deleteMinTree(<span class="keyword">this</span>.root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>树中删除最大元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.root = deleteMaxTree(<span class="keyword">this</span>.root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>树中删除指定元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(E item)</span> </span>&#123;</span><br><span class="line">    deleteTree(<span class="keyword">this</span>.root, item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-二叉树</title>
    <url>/2020/06/03/dataStructure/dataStructure-binarytree/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>二叉树</strong> 是一种特殊的树，其中每个节点至多具有两个儿子节点。本文仅探讨 “树” 中最基本的操作——构建和遍历。</p>
<a id="more"></a>

<p>其结构图大致如下：</p>
<p><img src="/2020/06/03/dataStructure/dataStructure-binarytree/%E4%BA%8C%E5%8F%89%E6%A0%91%E8%A7%A3%E9%87%8A%E5%9B%BE.png" alt="图一：二叉树"></p>
<p>本文为 “树” 的第一篇文章，故而在此总结一下有关 “树” 的表示方法。</p>
<ul>
<li><p>双亲表示法</p>
<p>借用一组连续/离散空间来存储 “树” 中节点。在保存节点内容的同时，还保存一个指向双亲节点的指针元素。</p>
<p>应用举例：并查集。</p>
</li>
<li><p>孩子表示法</p>
<p>借用一组连续/离散空间来存储 “树” 中节点。在保存节点内容的同时，还保存若干指向孩子节点的的指针元素。</p>
<p>应用举例：二叉查找树。</p>
</li>
<li><p>孩子兄弟表示法</p>
<p>借用一组连续/离散空间来存储 “树” 中节点。在保存节点内容的同时，还保存有两个指针元素，其中一个指针指向第一个孩子节点，另一个指针指向兄弟节点。</p>
<p>应用举例：二项队列。</p>
</li>
</ul>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>本文使用孩子表示法以表示二叉树。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 节点结构</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">// 具体元素</span></span><br><span class="line">        E item;</span><br><span class="line">        <span class="comment">// 左儿子</span></span><br><span class="line">        Node&lt;E&gt; left;</span><br><span class="line">        <span class="comment">// 右儿子</span></span><br><span class="line">        Node&lt;E&gt; right;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E item, Node&lt;E&gt; left, Node&lt;E&gt; right)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.item = item;</span><br><span class="line">            <span class="keyword">this</span>.left = left;</span><br><span class="line">            <span class="keyword">this</span>.right = right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根节点</span></span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; root;</span><br><span class="line">    <span class="comment">// 索引(用于构建二叉树)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="辅助方法"><a href="#辅助方法" class="headerlink" title="辅助方法"></a>辅助方法</h3><ul>
<li><p>前序遍历构建二叉树</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;E&gt; <span class="title">treePreOrder</span><span class="params">(E[] arr)</span> </span>&#123;</span><br><span class="line">    E element = arr[<span class="keyword">this</span>.index++];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == element) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node&lt;E&gt; root = <span class="keyword">new</span> Node&lt;&gt;(element, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    root.left = treePreOrder(arr);</span><br><span class="line">    root.right = treePreOrder(arr);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>层序遍历构建二叉树</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;E&gt; <span class="title">treeLevelOrder</span><span class="params">(E[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    Node&lt;E&gt; root = <span class="keyword">new</span> Node&lt;&gt;(arr[index++], <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用双端队列模拟队列</span></span><br><span class="line">    ArrayDeque&lt;Node&lt;E&gt;&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    queue.addLast(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (queue.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        Node&lt;E&gt; tmp = queue.pollFirst();</span><br><span class="line">        E left = arr[index++];</span><br><span class="line">        E right = arr[index++];</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != left) &#123;</span><br><span class="line">            tmp.left = <span class="keyword">new</span> Node&lt;&gt;(left, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            queue.addLast(tmp.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != right) &#123;</span><br><span class="line">            tmp.right = <span class="keyword">new</span> Node&lt;&gt;(right, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            queue.addLast(tmp.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>前序遍历二叉树</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">traverseTreePreOrder</span><span class="params">(<span class="keyword">final</span> Node&lt;E&gt; root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == root) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.print(root.item + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    traverseTreePreOrder(root.left);</span><br><span class="line">    traverseTreePreOrder(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>中序遍历二叉树</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">traverseTreeInOrder</span><span class="params">(<span class="keyword">final</span> Node&lt;E&gt; root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == root) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    traverseTreeInOrder(root.left);</span><br><span class="line">    System.out.print(root.item + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    traverseTreeInOrder(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>后序遍历二叉树</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">traverseTreePostOrder</span><span class="params">(<span class="keyword">final</span> Node&lt;E&gt; root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == root) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    traverseTreePostOrder(root.left);</span><br><span class="line">    traverseTreePostOrder(root.right);</span><br><span class="line">    System.out.print(root.item + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3></li>
</ul>
<p>基于前序遍历、后序遍历和层序遍历的遍历结果，均可实现构建一棵二叉树。后序遍历顺序为 “左右根”，反向查看后序遍历的遍历结果，其遍历顺序便是 “根右左”，故而其与基于前序遍历的遍历结果构建一棵二叉树类似。</p>
<p>无法基于中序遍历构建一棵二叉树，原因在于：遍历过程中存在 “节点跳跃”。举例如下 (二者具有相同的中序遍历结果)：</p>
<p><img src="/2020/06/03/dataStructure/dataStructure-binarytree/20191003141457557.png" alt="图二：中序遍历构建二叉树冲突"></p>
<blockquote>
<p>实际使用中，基本上也不会以这种方式构建二叉树。通常都是基于插入操作构建二叉树的。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BinaryTree</span><span class="params">(E[] arr, <span class="keyword">int</span> option)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (option == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.root = treePreOrder(arr);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.root = treeLevelOrder(arr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>前中后序遍历的非递归版本都十分难写，但可喜的是，三者具有一种统一的写法，具体见代码。</p>
<ul>
<li><p>前序遍历 (递归)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">traversePreOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.print(<span class="string">&quot;前序遍历（递归）：&quot;</span>);</span><br><span class="line">    traverseTreePreOrder(<span class="keyword">this</span>.root);</span><br><span class="line">    System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>前序遍历 (非递归)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">traversePreOrderStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">this</span>.root;</span><br><span class="line">    <span class="comment">// 使用双端队列模拟栈</span></span><br><span class="line">    ArrayDeque&lt;Node&lt;E&gt;&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    System.out.print(<span class="string">&quot;前序遍历（非递归）：&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> ((<span class="keyword">null</span> != node) || (stack.size() &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">null</span> != node) &#123;</span><br><span class="line">            System.out.print(node.item + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            stack.addLast(node);</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stack.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            node = stack.pollLast();</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>中序遍历 (递归)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">traverseInOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.print(<span class="string">&quot;中序遍历（递归）：&quot;</span>);</span><br><span class="line">    traverseTreeInOrder(<span class="keyword">this</span>.root);</span><br><span class="line">    System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>中序遍历 (非递归)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">traverseInOrderStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">this</span>.root;</span><br><span class="line">    <span class="comment">// 使用双端队列模拟栈</span></span><br><span class="line">    ArrayDeque&lt;Node&lt;E&gt;&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    System.out.print(<span class="string">&quot;中序遍历（非递归）：&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> ((<span class="keyword">null</span> != node) || (stack.size() &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">null</span> != node) &#123;</span><br><span class="line">            stack.addLast(node);</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stack.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            node = stack.pollLast();</span><br><span class="line">            System.out.print(node.item + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>后序遍历 (递归)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">traversePostOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.print(<span class="string">&quot;后序遍历（递归）：&quot;</span>);</span><br><span class="line">    traverseTreePostOrder(<span class="keyword">this</span>.root);</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>后序遍历 (非递归)</p>
<p>后序遍历顺序为 “左右根”，故而只有当左子树和右子树遍历完成后，才可遍历根节点。后序遍历的非递归版本难点在于：判断当前栈顶元素的右子树是否已遍历完成？</p>
<p>可使用一个指针以解决该问题，其中该指针指向上一个遍历过的元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">traversePostOrderStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">this</span>.root;</span><br><span class="line">    <span class="comment">// 记录上一个遍历过的节点</span></span><br><span class="line">    Node&lt;E&gt; pre = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 使用双端队列模拟栈</span></span><br><span class="line">    ArrayDeque&lt;Node&lt;E&gt;&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    System.out.print(<span class="string">&quot;后序遍历（非递归）：&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> ((<span class="keyword">null</span> != node) || (stack.size() &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">null</span> != node) &#123;</span><br><span class="line">            stack.addLast(node);</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stack.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            node = stack.getLast();</span><br><span class="line">            <span class="comment">// 当前节点右子树为空或当前节点的右儿子为上一个遍历过的节点，表明右子树已遍历完成。此时即可遍历当前节点。</span></span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">null</span> == node.right) || (node.right == pre)) &#123;</span><br><span class="line">                System.out.print(node.item + <span class="string">&quot; &quot;</span>);</span><br><span class="line">                stack.pollLast();</span><br><span class="line">                pre = node;</span><br><span class="line">                node = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node = node.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>层序遍历</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">traverseLevelOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == <span class="keyword">this</span>.root) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用双端队列模拟队列</span></span><br><span class="line">    ArrayDeque&lt;Node&lt;E&gt;&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    queue.addLast(<span class="keyword">this</span>.root);</span><br><span class="line"></span><br><span class="line">    System.out.print(<span class="string">&quot;层序遍历：&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (queue.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        Node&lt;E&gt; tmp = queue.pollFirst();</span><br><span class="line">        System.out.print(tmp.item + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != tmp.left) &#123;</span><br><span class="line">            queue.addLast(tmp.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != tmp.right) &#123;</span><br><span class="line">            queue.addLast(tmp.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-散列表</title>
    <url>/2020/05/26/dataStructure/dataStructure-hashtable/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>散列表</strong> 是一种可实现以常数平均时间执行插入、删除、查询的数据结构。它基于散列函数将元素映射到固定空间中的某一位置。</p>
<a id="more"></a>

<p>其结构图大致如下：</p>
<p><img src="/2020/05/26/dataStructure/dataStructure-hashtable/v2-aa2188e188caa7010c3a7b362e766abf_720w.jpg" alt="图一：散列表"></p>
<p>散列表中有两大概念，在此先行解释。</p>
<ul>
<li><p>散列函数</p>
<p>顾名思义，它就是一个函数，形如 $hash(key)$。其中 $key$ 表示元素键值，$hash(key)$ 表示经散列函数计算得到的散列值。</p>
<p>散列函数的选择对于散列表性能具有重大影响。一个好的散列函数，可保证元素均匀分布于散列表之中。</p>
</li>
<li><p>冲突</p>
<p>散列表本质是将无穷元素映射到有穷空间之上。故而一定存在某两个元素键值不同，而具有相同的散列值，此种便称为冲突。</p>
</li>
</ul>
<p>为解决 “冲突发生时如何映射元素” 这一问题，不同的散列表实现给出了不同的策略。我们主要展示基于链地址法实现的散列表，其余实现方法在 <a href="##%E6%89%A9%E5%B1%95">扩展</a> 中简单介绍。</p>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>基于链地址法实现散列表，故而固定数组存储内容为一个链表。另外数组大小应为一个<strong>素数</strong>，这样做有助于元素均匀分布于散列表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashTable</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 默认表长</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_TABLE_SIZE = <span class="number">101</span>;</span><br><span class="line">    <span class="comment">// 基于链地址法的散列表</span></span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;E&gt;[] lls;</span><br><span class="line">    <span class="comment">// 元素数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> currentSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="辅助方法"><a href="#辅助方法" class="headerlink" title="辅助方法"></a>辅助方法</h3><ul>
<li><p>散列函数</p>
<p>借用 $Object.hashCode()$ 加以实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hashVal = e.hashCode() % <span class="keyword">this</span>.lls.length;</span><br><span class="line">    <span class="keyword">return</span> (hashVal + <span class="keyword">this</span>.lls.length) % <span class="keyword">this</span>.lls.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashTable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.lls = <span class="keyword">new</span> LinkedList[HashTable.DEFAULT_TABLE_SIZE];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.lls.length; i++) &#123;</span><br><span class="line">        <span class="keyword">this</span>.lls[i] = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><ul>
<li><p>查询元素是否存在</p>
<p>首先使用散列函数定位到链，然后在该链中查找该元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取待查询链</span></span><br><span class="line">    LinkedList&lt;E&gt; link = <span class="keyword">this</span>.lls[hash(e)];</span><br><span class="line">    <span class="keyword">return</span> link.indexOf(e) != -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="操纵"><a href="#操纵" class="headerlink" title="操纵"></a>操纵</h3></li>
<li><p>散列表中添加元素</p>
<p>首先使用散列函数定位到链，当该元素并不存在于散列表中才插入。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取待插入链</span></span><br><span class="line">    LinkedList&lt;E&gt; link = <span class="keyword">this</span>.lls[hash(e)];</span><br><span class="line">    <span class="keyword">if</span> (link.indexOf(e) == -<span class="number">1</span>) &#123;</span><br><span class="line">        link.addFirst(e);</span><br><span class="line">        <span class="keyword">this</span>.currentSize++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>散列表中删除元素</p>
<p>首先使用散列函数定位到链，当该元素存在与散列表中才删除。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取待删除元素所在链</span></span><br><span class="line">    LinkedList&lt;E&gt; link = <span class="keyword">this</span>.lls[hash(e)];</span><br><span class="line">    <span class="keyword">int</span> index = link.indexOf(e);</span><br><span class="line">    <span class="keyword">if</span> (index != -<span class="number">1</span>) &#123;</span><br><span class="line">        link.remove(index);</span><br><span class="line">        <span class="keyword">this</span>.currentSize--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2></li>
</ul>
<p>在此列举若干常用的散列表实现：</p>
<ul>
<li><p>基于开放定址法的实现</p>
<p>开放定址法下另有多种实现，分别为基于线性探测法的实现、基于平方探测法的实现和基于双散列的实现。</p>
<ul>
<li><p>基于线性探测法的实现</p>
<p>当发生冲突时，依次探测空间 $h_i(x) = (hash(x) + f(i)) \ %\  tableSize$，如果某个空间未使用，则将元素置于该空间之中，停止探测。</p>
<p>此方法的一大问题在于将会导致存在 “一次聚集” ，即空间成块使用。</p>
</li>
<li><p>基于平方探测法的实现</p>
<p>当发生冲突时，依次探测空间 $h_i(x) = (hash(x) + f(i^2)) \ %\  tableSize$，如果某个空间未使用，则将元素置于该空间之中，停止探测。</p>
<p>此方法可解决 “一次聚集”，但会导致 “二次聚集”。</p>
</li>
<li><p>基于双散列的实现</p>
<p>当发生冲突时，依次探测空间 $h_i(x) = (i \times hash_2(x)) \ %\  tableSize$，如果某个空间未使用，则将元素置于该空间之中，停止探测。</p>
<p>如果第二个散列函数选择的好，则散列表性能就好；否则就是灭顶之灾。</p>
</li>
</ul>
</li>
<li><p>再散列</p>
<p>如果散列表中存在元素过多，则创建一个具有原散列表两倍空间的新散列表，并基于新的散列函数将原散列表中元素映射到新散列表之中。此举的时间复杂度为 $O(N)$，由于不是经常发生此种情况，因此实际效果还行。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>散列表</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-二项队列</title>
    <url>/2020/05/25/dataStructure/dataStructure-binomialqueue/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>二项队列</strong> 属于一种构建极为精妙的堆。它不仅具有左式堆的优点（$O(log^N)$ 时间复杂度内实现堆合并），同时具有二叉堆的优点（$O(N)$ 时间复杂度内实现建堆）。</p>
<a id="more"></a>

<p>其结构图大致如下：</p>
<p><img src="/2020/05/25/dataStructure/dataStructure-binomialqueue/500px-Binomial_Trees.png" alt="图一：二项队列"></p>
<p>二项队列主要涉及一个概念和一个定理，在此先行解释。</p>
<ul>
<li><p>二项树 ($B_i$)</p>
<p>高度为 $i$ 的二项树 $B_i$ 构造规则如下：</p>
<ul>
<li>当 $i = 0$ 时，$B_i$ 为一棵单结点树。</li>
<li>当 $i &gt; 0$ 时，$B_i$ 通过将一棵二项树 $B_{i - 1}$ 附接到另一棵二项树 $B_{i - 1}$ 的根上而构成。</li>
</ul>
<p>仔细观察构造规则及上方结构图，我们可得到如下结论：</p>
<ul>
<li>二项树 $B_i$ 由一个带有儿子 $B_0,B_1,\dots,B_{i - 1}$ 的根组成。</li>
<li>二项树 $B_i$ 具有 $2^i$ 个结点。</li>
</ul>
<p>此时可以给出二项队列的具体定义：<strong>二项队列是具有堆序结构的二项树的集合，而且该集合中不存在具有相同高度的两棵二项树</strong>。</p>
</li>
<li><p>含有 $N$ 个结点的二项队列最多含有 $log^N$ 棵二项树。</p>
<p>此定理证明比较简单。</p>
<p>假定一个二项队列为 ${B_0,B_1,\dots,B_k}$，容易得知其含有 $2^0 + 2^1 + \dots + 2^k = 2^{k + 1} - 1$ 个结点。这句话反过来就是定理。</p>
<p>二项队列的操作都是基于二项树而言的，正是由于具有这样的性质，故而其操作的最坏时间复杂度为 $O(log^N)$。</p>
</li>
</ul>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>二项队列结构比较精妙，在此简单说明一下：</p>
<ul>
<li>二项树具有多个儿子结点，因此我们使用孩子兄弟表示法表示之。</li>
<li>为方便相同高度的二项树合并操作，我们逆向存放子二项树。例如：对于二项树 $B_i$ 而言，其根结点的兄弟结点为 $B_{i - 1}$，$B_{i - 1}$ 的兄弟结点为 $B_{i - 2}$，$\dots$ ，$B_{1}$ 的兄弟结点为 $B_{0}$。</li>
<li>我们采用数组从前往后依次存放相应高度的二项树，这样做的优点在于可以快速获取二项队列中的元素个数，同时方便编写二项队列合并操作的代码。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinomialQueue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 孩子兄弟表示法表示一颗二项树</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">// 具体元素</span></span><br><span class="line">        E item;</span><br><span class="line">        <span class="comment">// 孩子结点</span></span><br><span class="line">        Node&lt;E&gt; leftChild;</span><br><span class="line">        <span class="comment">// 兄弟结点</span></span><br><span class="line">        Node&lt;E&gt; nextSibling;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E item, Node&lt;E&gt; leftChild, Node&lt;E&gt; nextSibling)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.item = item;</span><br><span class="line">            <span class="keyword">this</span>.leftChild = leftChild;</span><br><span class="line">            <span class="keyword">this</span>.nextSibling = nextSibling;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 二项队列(使用数组保存二项树的根)</span></span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt;[] trees;</span><br><span class="line">    <span class="comment">// 元素个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> currentSize;</span><br><span class="line">    <span class="comment">// 比较函数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> E&gt; comparator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="辅助方法"><a href="#辅助方法" class="headerlink" title="辅助方法"></a>辅助方法</h3><ul>
<li><p>扩容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">expandTrees</span><span class="params">(<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    Node&lt;E&gt;[] newTrees = <span class="keyword">new</span> Node[length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.trees.length; i++) &#123;</span><br><span class="line">        newTrees[i] = <span class="keyword">this</span>.trees[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.trees = newTrees;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>获取最小元素下标</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findMinIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">    E min = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.trees.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == <span class="keyword">this</span>.trees[i]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == min) &#123;</span><br><span class="line">            min = <span class="keyword">this</span>.trees[i].item;</span><br><span class="line">            index = i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (comparator.compare(min, <span class="keyword">this</span>.trees[i].item) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(min + <span class="string">&quot; &quot;</span> + <span class="keyword">this</span>.trees[i].item);</span><br><span class="line">                min = <span class="keyword">this</span>.trees[i].item;</span><br><span class="line">                index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>合并高度相同的二项树</p>
<p>如上所述，二项树构造具有一定之规。另外二项队列中的二项树同时需要满足堆序性质。综合二者，二项队列中的二项树合成规则为：$B_i$ 通过将根值较小者/较大者的二项树 $B_{i - 1}$ 附接到另一棵二项树 $B_{i - 1}$ 的根上而构成。</p>
<p>此函数实现代码体现了 “逆向存放子二项树” 的好处。如果顺序存放子二项树，我们应当首先找到 <code>t1.leftChild</code> 的最后一个兄弟结点，然后将其兄弟结点的引用指向 <code>t2</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;E&gt; <span class="title">combineTrees</span><span class="params">(Node&lt;E&gt; t1, Node&lt;E&gt; t2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (comparator.compare(t1.item, t2.item) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> combineTrees(t2, t1);</span><br><span class="line">    &#125;</span><br><span class="line">    t2.nextSibling = t1.leftChild;</span><br><span class="line">    t1.leftChild = t2;</span><br><span class="line">    <span class="keyword">return</span> t1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3></li>
<li><p>空初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BinomialQueue</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.trees = <span class="keyword">new</span> Node[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>初始化携带一个元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BinomialQueue</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; comparator, E element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.trees = <span class="keyword">new</span> Node[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">this</span>.trees[<span class="number">0</span>] = <span class="keyword">new</span> Node&lt;&gt;(element, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">this</span>.currentSize = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3></li>
<li><p>查询容量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">capacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; trees.length) - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>查询最小值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = findMinIndex();</span><br><span class="line">    <span class="keyword">return</span> index == -<span class="number">1</span> ? <span class="keyword">null</span> : <span class="keyword">this</span>.trees[index].item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="操纵"><a href="#操纵" class="headerlink" title="操纵"></a>操纵</h3></li>
<li><p>合并两个二项队列</p>
<p>二项队列合并过程类似于数值相加。另外</p>
<p>举例如下：</p>
<p><img src="/2020/05/25/dataStructure/dataStructure-binomialqueue/20131109173216500.jpg" alt="图二：合并二项队列"></p>
<p>现需要将 $H1 = {B_1}$ 和 $H2 = {B_0,B_1,B_2}$ 合并为 $H3$ ，具体合并步骤如下：</p>
<ul>
<li> 对于 $H3$ 中的 $B_0$ 而言，$H1$ 没有而 $H2$ 有，则直接将 $H2$ 中的 $B_0$ 赋值给 $H3$ 的 $B_0$ 即可。</li>
<li> 对于 $H3$ 中的 $B_1$ 而言，$H1$ 和 $H2$ 均有，合并二者得到 “进位” $B_2$。再无多余 $B_1$，故而 $H3$ 的 $B_1$ 为 $null$。</li>
<li>对于 $H3$ 中的 $B_2$ 而言，$H1$ 没有而$H2$ 有，同时存在一个 “进位” $B_2$，合并二者得到 “进位” $B_3$。再无多余 $B_2$，故而 $H3$ 的 $B_2$ 为 $null$。</li>
<li>对于 $H3$ 中的 $B_3$ 而言，$H1$ 和 $H2$ 均无，但是存在一个 “进位” $B_3$，直接将进位$B_3$赋值给$H3$ 的 $B_3$ 即可。</li>
<li>$H1$ 和 $H2$ 无再合并之物，则合并结果为 $H3 = {B_0,B_2,B_3}$。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(BinomialQueue&lt;E&gt; binomialQueue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == binomialQueue) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.currentSize += binomialQueue.currentSize;</span><br><span class="line">    <span class="comment">//空间不足，需要扩容。这是一种扩容方式。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.currentSize &gt; capacity()) &#123;</span><br><span class="line">        <span class="keyword">int</span> maxLength = Math.max(<span class="keyword">this</span>.trees.length, binomialQueue.trees.length);</span><br><span class="line">        expandTrees(maxLength + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存上一次合并结果的“余数”</span></span><br><span class="line">    Node&lt;E&gt; carry = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.trees.length; i++) &#123;</span><br><span class="line">        Node&lt;E&gt; t1 = <span class="keyword">this</span>.trees[i];</span><br><span class="line">        Node&lt;E&gt; t2 = i &lt; binomialQueue.trees.length ? binomialQueue.trees[i] : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> whichCase = t1 == <span class="keyword">null</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">        whichCase += t2 == <span class="keyword">null</span> ? <span class="number">0</span> : <span class="number">2</span>;</span><br><span class="line">        whichCase += carry == <span class="keyword">null</span> ? <span class="number">0</span> : <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (whichCase) &#123;</span><br><span class="line">            <span class="comment">// 表明t2和carry均为null，无需操作</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 表明仅t2不为空，直接赋给this即可</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">this</span>.trees[i] = t2;</span><br><span class="line">                binomialQueue.trees[i] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 表明t1和t2均不为空，合并即可。</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                carry = combineTrees(t1, t2);</span><br><span class="line">                <span class="keyword">this</span>.trees[i] = binomialQueue.trees[i] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 表明仅carry不为空，直接赋给this即可</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                <span class="keyword">this</span>.trees[i] = carry;</span><br><span class="line">                carry = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 表明仅t1和carry不为空，合并即可</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                carry = combineTrees(t1, carry);</span><br><span class="line">                <span class="keyword">this</span>.trees[i] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 表明仅t2和carry不为空，合并即可</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                carry = combineTrees(t2, carry);</span><br><span class="line">                binomialQueue.trees[i] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 表明三者俱在</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">                carry = combineTrees(t2, carry);</span><br><span class="line">                binomialQueue.trees[i] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调整待合并堆相关参数</span></span><br><span class="line">    binomialQueue.currentSize = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>二项队列中添加元素</p>
<p>将待添加元素看做一个二项队列，合并二者即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(E element)</span> </span>&#123;</span><br><span class="line">    BinomialQueue&lt;E&gt; eBinomialQueue = <span class="keyword">new</span> BinomialQueue&lt;&gt;(<span class="keyword">this</span>.comparator, element);</span><br><span class="line">    merge(eBinomialQueue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处我们分析一下为什么可在 $O(N)$ 时间复杂度内实现建堆？也即为什么插入操作的平均时间复杂度为 $O(1)$ ？</p>
<p>通过上面的合并代码，可以发现合并两个二项队列所花费的时间依托于其上的二项树分布。</p>
<ul>
<li><p>如果将仅含一个元素的二项队列与一个含有偶数个元素的二项队列合并，仅需合并到 $B_0$ 即可，故而花费时间为 O(1)。</p>
</li>
<li><p>如果将仅含一个元素的二项队列与含有 $2^k - 1$ 个元素的二项队列合并，由于已有 $B_0,B_1,\dots, B_{k-1}$，所以需一直合并到 $B_k$，故而花费时间为 $O(k)$。</p>
</li>
</ul>
<p>上述两种情况属于运行时间的最好情况和最坏情况。最好情况的发生概率为 $1/2$，最坏情况的发生概率则极低。</p>
<p>假定总共执行插入操作 $N$ 次，可粗略得到：$N/2$ 次插入的运行时间为 $O(1)$，$N / 4$ 次插入的运行时间为 $O(2)$，$\dots$，$N/2^k$ 次插入的运行时间为 $O(k)$。</p>
<p>所有 $N$ 次插入的总运行时间为：$\sum_{i = 1}^k\frac{N \times i}{2^i} &lt; N \times \sum_{i = 1}^\infty\frac{i}{2^i} = 2N$。</p>
<p>故而一次插入操作的平均运行时间为 $2N / N = 2 = O(1)$，所以可在 $O(N)$ 时间复杂度内实现建堆 。</p>
</li>
<li><p>二项队列中删除最小元素</p>
<p>最小元素一定属于某个二项树的根结点。首先从当前二项队列中删除此二项树，然后使用该二项树的子二项树构建一个二项队列，合并此二者即可达到 “从二项队列中删除最小元素” 的目的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">deleteMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 为空则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.currentSize == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> index = findMinIndex();</span><br><span class="line">    E minElement = <span class="keyword">this</span>.trees[index].item;</span><br><span class="line">    Node&lt;E&gt; deletedTree = <span class="keyword">this</span>.trees[index].leftChild;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基于该二项队列的子二项树构建一个二项队列。</span></span><br><span class="line">    BinomialQueue eBinomialQueue = <span class="keyword">new</span> BinomialQueue(<span class="keyword">this</span>.comparator);</span><br><span class="line">    eBinomialQueue.expandTrees(index);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = index - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        eBinomialQueue.trees[i] = deletedTree;</span><br><span class="line">        deletedTree = deletedTree.nextSibling;</span><br><span class="line">        eBinomialQueue.trees[i].nextSibling = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    eBinomialQueue.currentSize += ((<span class="number">1</span> &lt;&lt; index) - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.trees[index] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.currentSize -= (<span class="number">1</span> &lt;&lt; index);</span><br><span class="line"></span><br><span class="line">    merge(eBinomialQueue);</span><br><span class="line">    <span class="keyword">return</span> minElement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2></li>
</ul>
<p>为进一步降低二项队列相关操作的时间复杂度，<em>懒惰二项队列</em> 应运而生，它通过支持懒惰合并使得合并操作的</p>
<p>平均时间复杂度为 $O(1)$，同时保证删除最小元素操作的平均时间复杂度仍为 $O(log^N)$。</p>
<p>由于支持懒惰合并，因此懒惰二项队列的具体定义如下：懒惰二项队列是具有堆序结构的二项树的集合，它允许集合中存在高度相同的两棵二项树。</p>
<p>懒惰合并仅涉及合并操作和删除最小元素操作，因此在此详述二者。</p>
<ul>
<li><p>合并操作</p>
<p>直接将高度相同的二项树放在一起即可。</p>
</li>
<li><p>删除最小元素操作</p>
<p>遍历所有二项树，找到最小元素将其删除。随后我们需要将懒惰二项队列转变为标准的二项队列，即通过合并二项树，使得集合中不存在高度相同的两棵二项树。</p>
</li>
</ul>
<blockquote>
<ol>
<li>合并操作和删除最小元素的平均时间复杂度证明过程极为复杂，这里省略。</li>
<li>为支持懒惰二项队列，将二项队列结构中的 <code>private Node&lt;E&gt;[] trees;</code> 修改为 <code>private LinkedList&lt;Node&lt;E&gt;&gt; trees</code> 即可得到懒惰二项队列结构。</li>
<li>通过合并操作和删除最小元素操作的具体内容，可以得知：懒惰合并指代只有当两个二项队列真正需要合并时 (即删除最小元素后) 才进行合并。</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-左式堆</title>
    <url>/2020/05/25/dataStructure/dataStructure-leftheap/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>左式堆</strong> 属于一种特殊的堆。除具有二叉堆所有功能外，它还可以在 $O(log^N)$ 时间复杂度内实现堆合并操作。</p>
<a id="more"></a>

<p>其结构图大致如下：</p>
<p><img src="/2020/05/25/dataStructure/dataStructure-leftheap/image-20200523111458539.png" alt="图一：左式堆"></p>
<p>左式堆主要涉及一个概念和一个定理，在此先行解释。</p>
<ul>
<li><p>零路径长 ($npl(x)$)</p>
<p>节点 $x$ 的零路径长 $npl(x)$  定义为：从 $x$ 到一个不具有两个儿子节点的最短路径的长。</p>
<p>如果节点 $x$ 具有 0 或 1 个儿子节点，那么 $npl(x) = 0$；如果该节点为空节点，则 $npl(null) = -1$。</p>
<p>根据如上定义，可以推知：任一节点的零路径长比它的各个儿子节点的零路径长的最小值大一。</p>
<p>此时可以给出左式堆的具体定义：<strong>左式堆是一棵具有堆序性质的二叉树，而且对于堆中任一节点而言，其左儿子节点的零路径长总是大于等于右儿子节点的零路径长。</strong></p>
</li>
<li><p>在右路径上有 $r$ 个节点的左式堆必然至少有 $2^r -1$ 个节点。</p>
<p>右路径：左式堆最右侧节点所形成的的路径。</p>
<p>使用数学归纳法加以证明。</p>
<p>如果 $i = 1$，左式堆具有 $1$ 个节点，符合定理。</p>
<p>假定 $i = r$ 符合定理。当 $i = r + 1$ 时，可知右子堆至少具有  $2^r - 1$ 个节点，为满足 “左儿子节点的零路径长总是大于等于右儿子节点的零路径长”，可知左子堆同样至少具有 $2^r - 1$ 个节点，再加上一个根节点，总的节点个数至少为 $(2^r - 1) * 2 + 1 = 2^{r + 1} - 1$，符合定理。故而证明完毕。</p>
<p>该定理没有什么用，我们主要使用它的推导定理：具有 $N$ 个节点的左式堆，其右路径最多含有 $log^{N + 1}$ 节点。</p>
<p><strong>由于右路径具有这样的性质，所以我们将对左式堆的所有操作都放到右路径上进行。这样也保证了复杂度为 $O(log^N)$。</strong></p>
</li>
</ul>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>左式堆中元素需可比较，为简化代码，我们直接在内部存储一个比较类，用于比较堆中元素。另外节点结构除保存元素外，还需保存 $npl$。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LeftHeap</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 节点结构</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">// 具体元素</span></span><br><span class="line">        E item;</span><br><span class="line">        <span class="comment">// 左儿子</span></span><br><span class="line">        Node&lt;E&gt; left;</span><br><span class="line">        <span class="comment">// 右儿子</span></span><br><span class="line">        Node&lt;E&gt; right;</span><br><span class="line">        <span class="comment">// 零路径长</span></span><br><span class="line">        <span class="keyword">int</span> npl;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E item, Node&lt;E&gt; left, Node&lt;E&gt; right, <span class="keyword">int</span> npl)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.item = item;</span><br><span class="line">            <span class="keyword">this</span>.left = left;</span><br><span class="line">            <span class="keyword">this</span>.right = right;</span><br><span class="line">            <span class="keyword">this</span>.npl = npl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 比较函数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> E&gt; comparator;</span><br><span class="line">    <span class="comment">// 根节点</span></span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="辅助方法"><a href="#辅助方法" class="headerlink" title="辅助方法"></a>辅助方法</h3><ul>
<li><p>$npl(x)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">npl</span><span class="params">(Node&lt;E&gt; e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span> == e ? -<span class="number">1</span> : e.npl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>合并</p>
<p>对链式结构的操作，基于递归实现往往比较简单。因此在此虽同时给出递归和迭代思路，但是仅给出递归代码。</p>
<ul>
<li><p>基于递归</p>
<ol>
<li>如果一方为空，则直接返回另一方。</li>
<li>比较两方根节点，<em>合并根节点较大者与根节点较小者的右子树</em>，并将其作为根节点较小者的右子树，做相关调整（包括：是否需交换左右子树以满足 “左儿子节点的零路径长总是大于等于右儿子节点的零路径长”、重新计算根节点的零路径长）使当前合并后的左式堆满足要求，然后返回之。</li>
</ol>
<p>举例：</p>
<p><img src="/2020/05/25/dataStructure/dataStructure-leftheap/merge_op.png" alt="图二：合并左式堆"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;E&gt; <span class="title">merge</span><span class="params">(Node&lt;E&gt; h1, Node&lt;E&gt; h2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 一方为空，则直接返回另一方</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == h1) &#123;</span><br><span class="line">        <span class="keyword">return</span> h2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == h2) &#123;</span><br><span class="line">        <span class="keyword">return</span> h1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二者皆不为空</span></span><br><span class="line">    <span class="comment">// 如果前者根值大于后者根值，需进行交换以保证h1引用根值较小者表示的左式堆。</span></span><br><span class="line">    <span class="keyword">if</span> (comparator.compare(h1.item, h2.item) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> merge(h2, h1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将根值较大者与根值较小者的右子堆合并，合并后的堆成为根值较小者的右子堆，最后调整npl值即可。</span></span><br><span class="line">    h1.right = merge(h1.right, h2);</span><br><span class="line">    <span class="keyword">if</span> (npl(h1.left) &lt; npl(h1.right)) &#123;</span><br><span class="line">        <span class="comment">// 交换两个节点</span></span><br><span class="line">        Node&lt;E&gt; tmp = h1.left;</span><br><span class="line">        h1.left = h1.right;</span><br><span class="line">        h1.right = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    h1.npl = npl(h1.right) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> h1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>基于迭代</p>
</li>
</ul>
<ol>
<li>按照大小关系合并两方的右路径以构建一颗新的树。</li>
<li>按照 “左右根” 顺序遍历整棵树，做相关调整（包括：是否需交换左右子树以满足 “左儿子节点的零路径长总是大于等于右儿子节点的零路径长”、重新计算根节点的零路径长），使得此树满足左式堆性质即可。</li>
</ol>
</li>
</ul>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LeftHeap</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><ul>
<li><p>查询最小值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == <span class="keyword">this</span>.root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.root.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="操纵"><a href="#操纵" class="headerlink" title="操纵"></a>操纵</h3></li>
<li><p>合并两个左式堆</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(LeftHeap&lt;E&gt; leftHeap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == leftHeap) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.root = merge(<span class="keyword">this</span>.root, leftHeap.root);</span><br><span class="line">    leftHeap.root = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>堆中添加元素</p>
<p>将待添加元素看做一个左式堆，然后合并两个左式堆即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(E element)</span> </span>&#123;</span><br><span class="line">    Node&lt;E&gt; eNode = <span class="keyword">new</span> Node&lt;&gt;(element, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">this</span>.root = merge(<span class="keyword">this</span>.root, eNode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>堆中删除最小元素</p>
<p>删除最小元素，直接合并两个左右子堆即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == <span class="keyword">this</span>.root) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.root = merge(<span class="keyword">this</span>.root.left, <span class="keyword">this</span>.root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>降低某个节点的元素值</p>
<p>这个操作只提思路，不做实现 (当前左式堆结构无法实现)。</p>
<p>在二叉堆 (小顶堆) 中，这一操作可通过上移至根节点实现，且时间复杂度为 $O(log^N)$。在左式堆中，如果采用相同的实现方法，由于并非所有节点到根节点的距离都是 $O(log^N)$，故而其时间复杂度一定大于 $O(log^N)$。</p>
<p>为保证此操作时间复杂度为 $O(log^N)$，左式堆应当采取另一种实现方法：将该节点与其父节点断开，将形成一个左式堆和一个堆 (可很容易恢复为左式堆)，然后合并二者即可。将堆恢复为左式堆及合并操作的时间复杂度均为 $O(log^N)$，故此操作的时间复杂度亦为 $O(log^N)$。 </p>
<p>将堆恢复为左式堆的时间复杂度为 $O(log^N)$，其原因在于：1. 只有父节点到根节点路径上的节点才有可能破坏左式堆性质，因此通过交换左右子树即可恢复性质。2. 由于最大右路径长为 $log^{N + 1}$，故而只需调整从父节点到根结点上的前 $log^{N + 1}$ 个节点即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decreaseKey</span><span class="params">(Node&lt;E&gt; e, E element)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2></li>
</ul>
<p><strong>斜堆</strong> 是左式堆的自调节形式，它与左式堆的关系类似于伸展树与 AVL 树间的关系。</p>
<p>斜堆本质上只是一个具有堆序的二叉树。相比于左式堆而言，它没有 “其左儿子节点的零路径长总是大于等于右儿子节点的零路径长” 这样的限制，故而关于节点的零路径长信息皆无需保留。也正因如此，斜堆的右路径可以无限长，故而单次操作时间复杂度为 $O(N)$。但是理论证明：<strong>对任意 $M$ 次连续操作，总的最坏情形运行时间为 $O(Mlog^N)$，故而平均时间复杂度为 $O(log^N)$。</strong></p>
<p>从左式堆实现中可以看到：其他操纵操纵都是基于合并操作实现的。斜堆亦是如此。故而在此简要介绍斜堆的合并操作。</p>
<p>在斜堆的合并操作中，除右路径最后一个节点外，左右子堆交换总是进行。借助上面合并代码，斜堆的合并代码列举如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;E&gt; <span class="title">merge</span><span class="params">(Node&lt;E&gt; h1, Node&lt;E&gt; h2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 一方为空，则直接返回另一方</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == h1) &#123;</span><br><span class="line">        <span class="keyword">return</span> h2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == h2) &#123;</span><br><span class="line">        <span class="keyword">return</span> h1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二者皆不为空</span></span><br><span class="line">    <span class="comment">// 如果前者根值大于后者根值，需进行交换以保证h1引用根值较小者表示的左式堆。</span></span><br><span class="line">    <span class="keyword">if</span> (comparator.compare(h1.item, h2.item) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        Node&lt;E&gt; tmp = h1;</span><br><span class="line">        h1 = h2;</span><br><span class="line">        h2 = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将根值较大者与根值较小者的右子堆合并，合并后的堆成为根值较小者的右子堆。</span></span><br><span class="line">    h1.right = merge(h1.right, h2);</span><br><span class="line">    <span class="comment">// 直接交换两个节点即可，因为h1.right为空情况已在2-8行代码中排除了。</span></span><br><span class="line">    Node&lt;E&gt; tmp = h1.left;</span><br><span class="line">    h1.left = h1.right;</span><br><span class="line">    h1.right = tmp;</span><br><span class="line">    <span class="keyword">return</span> h1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>








]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-二叉堆</title>
    <url>/2020/05/22/dataStructure/dataStructure-binaryheap/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>二叉堆</strong> 属于一种特殊的堆，其本质为一颗完全二叉树。</p>
<a id="more"></a>

<p>二叉堆分为两种——大顶堆和小顶堆。二者结构图大致如下：</p>
<p><img src="/2020/05/22/dataStructure/dataStructure-binaryheap/1024555-20161217182750011-675658660.png" alt="图一：二叉堆"></p>
<p>二叉堆本质上是一棵二叉树，通常应当采用链式存储结构加以实现。由于完全二叉树的性质，我们可以很方便地使用数组实现二叉堆。另外大顶堆与小顶堆原理相同，实现也差不多。故而，本文基于数组实现一个小顶堆。</p>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>堆中元素需可比较，为简化代码，我们直接在内部存储一个比较类，用于比较堆中元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryHeap</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 比较函数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> E&gt; comparator;</span><br><span class="line">    <span class="comment">// 基础数组(从下标1开始存储元素)</span></span><br><span class="line">    <span class="keyword">private</span> Object[] elementData;</span><br><span class="line">    <span class="comment">// 元素个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><blockquote>
<p>对堆进行操作后，需保持堆性质 (每个结点表示值总是大于/小于左右子结点表示值) 不发生变化。</p>
</blockquote>
<h3 id="辅助方法"><a href="#辅助方法" class="headerlink" title="辅助方法"></a>辅助方法</h3><p>堆具有两大基本操作——上移和下沉。</p>
<ul>
<li><p>上移</p>
<p>将指定位置结点上移时，将首先判断当前结点与父结点间大小关系。如果当前结点较小，则需将二者交换然后进一步判断父结点，反之表明已符合堆性质，直接退出即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 迭代写法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> length = <span class="keyword">this</span>.size;</span><br><span class="line">    <span class="keyword">final</span> Object element = <span class="keyword">this</span>.elementData[index];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = index / <span class="number">2</span>; i &gt; <span class="number">0</span>; i = i / <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (comparator.compare((E) <span class="keyword">this</span>.elementData[i], (E) element) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.elementData[index] = <span class="keyword">this</span>.elementData[i];</span><br><span class="line">            index = i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.elementData[index] = element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归写法</span></span><br><span class="line"><span class="comment">// 将element上移到堆中合适的位置，现已处理到index</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">upD</span><span class="params">(Object element, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index / <span class="number">2</span> &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData[index] = element;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = index / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (comparator.compare((E) <span class="keyword">this</span>.elementData[i], (E) element) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData[index] = <span class="keyword">this</span>.elementData[i];</span><br><span class="line">        index = i;</span><br><span class="line">        upD(element, index);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData[index] = element;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>下沉</p>
<p>将指定位置结点下沉时，将首先判断当前结点与左右子结点较小者间大小关系。如果当前结点较大，则需将二者交换然后进一步判断左右子结点较小者，反之表明已符合堆性质，直接退出即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 迭代写法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> length = <span class="keyword">this</span>.size;</span><br><span class="line">    <span class="keyword">final</span> Object element = <span class="keyword">this</span>.elementData[index];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = index * <span class="number">2</span>; i &lt;= length; i = i * <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 找寻左右儿子中小者</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; length &amp;&amp; comparator.compare((E) <span class="keyword">this</span>.elementData[i], (E) <span class="keyword">this</span>.elementData[i + <span class="number">1</span>]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            i = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (comparator.compare((E) <span class="keyword">this</span>.elementData[i], (E) element) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.elementData[index] = <span class="keyword">this</span>.elementData[i];</span><br><span class="line">            index = i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.elementData[index] = element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归写法</span></span><br><span class="line"><span class="comment">// 将element下沉到堆中合适的位置，现已处理到index</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">downD</span><span class="params">(Object element, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index * <span class="number">2</span> &gt; <span class="keyword">this</span>.size) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData[index] = element;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> i = index * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="keyword">this</span>.size &amp;&amp; comparator.compare((E) <span class="keyword">this</span>.elementData[i], (E) <span class="keyword">this</span>.elementData[i + <span class="number">1</span>]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            i = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (comparator.compare((E) <span class="keyword">this</span>.elementData[i], (E) element) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.elementData[index] = <span class="keyword">this</span>.elementData[i];</span><br><span class="line">            index = i;</span><br><span class="line">            downD(element, index);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.elementData[index] = element;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<blockquote>
<p>描述性内容写的是 “交换两个结点”；但是代码实现中略有不同。原因如下：假定执行一次上移共需迭代 $d$ 次。对于前者需执行 $3d$ 次赋值操作，而 后者则仅需要 $d + 1$ 次赋值。</p>
<p><strong>使用前者带来的负担是：运行效率略低；使用后者带来的负担则是：递归写法比较复杂。</strong></p>
</blockquote>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>堆初始化存在两种方式——自顶向下和自底向上。前者复杂度为 $O(Nlog^N)$，后者复杂度为 $O(N)$。</p>
<ul>
<li><p>自顶向下初始化</p>
<p>此种初始化方式比较简单，就是将每个元素依次插入到堆中即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BinaryHeap</span><span class="params">(E [] arr, Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> length = arr.length;</span><br><span class="line">    <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">    <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; length; i++) &#123;</span><br><span class="line">        insert(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>复杂度分析</p>
<p>容易知道，插入元素的时间复杂度为 $O(log^N)$ ，其中 $N$ 为当前堆中结点个数。</p>
<p>那么自顶向下初始化过程的时间复杂度便是：$\sum_{i = 1}^Nlog^i$，其中 $N$ 为最终堆中结点个数。</p>
<p>基于积分学知识，我们知道：$\int_{i - 1}^ilog^idi &lt; log^i &lt; \int_i^{i + 1}log^idi$，那么便有如下等式：</p>
<p>$$\sum_{i = 1}^N(\int_{i - 1}^ilog^idi) &lt; \sum_{i = 1}^Nlog^i &lt; \sum_{i = 1}^N\int_i^{i + 1}log^idi$$</p>
<p>$$\int_0^Nlog^idi &lt; \sum_{i = 1}^Nlog^i &lt; \int_1^{N + 1}log^idi$$</p>
<p>左右两端结果均为 $O(Nlog^N)$，故而 $\sum_{i = 1}^Nlog^i \approx O(Nlog^N)$。</p>
<p>所以，自顶向下初始化过程的时间复杂度为 $O(Nlog^N)$。 </p>
</li>
</ul>
</li>
<li><p>自底向上初始化</p>
<p>此种初始化方式比较巧妙，将非叶结点依次下沉即可得到一个堆。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BinaryHeap</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; comparator, E [] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> length = arr.length;</span><br><span class="line">    <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">    <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">this</span>.size = length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData[i + <span class="number">1</span>] = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = length / <span class="number">2</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        down(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>容易知道，下沉结点的时间复杂度为 $O(log^h)$，其中 $h$ 为当前结点的高度。</p>
<p>那么自底向上初始化过程的时间复杂度便是所有结点的高度之和，即 $S = \sum_{i = 0}^h2^i\times (h - i)$，其中 $h$ 为最终堆的高度。</p>
<p>使用错位相减法求解该式，可以得到 $S \approx O(2^h)$。高度为 $h$ 的完全二叉树，其结点个数 $N$ 满足等式 $2^h &lt; N &lt; 2^{h + 1}$，故而 $S \approx O(N)$。</p>
<p>所以，自底向上初始化过程的时间复杂度为 $O(N)$。 </p>
</li>
</ul>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><ul>
<li><p>查询最小值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size == <span class="number">0</span> ? <span class="keyword">null</span> : (E) <span class="keyword">this</span>.elementData[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="操纵"><a href="#操纵" class="headerlink" title="操纵"></a>操纵</h3></li>
<li><p>堆中添加元素</p>
<p>方法十分巧妙。将待添加元素置于堆末，然后上移该结点，即可实现将元素添加到堆中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(E element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData[++<span class="keyword">this</span>.size] = element;</span><br><span class="line">    up(<span class="keyword">this</span>.size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>堆中删除最小元素</p>
<p>方法十分巧妙。将堆头结点与堆末结点互换，此时删除堆末结点十分简单，然后下沉堆头结点，即可实现将最小元素从堆中删除。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">deleteMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.size &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    E element = (E) <span class="keyword">this</span>.elementData[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.size == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.size--;</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData[<span class="number">1</span>] = <span class="keyword">this</span>.elementData[<span class="keyword">this</span>.size--];</span><br><span class="line">        down(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-队列/栈</title>
    <url>/2020/05/21/dataStructure/dataStructure-arraydeque/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>队列</strong> 属于一种特殊的线性表/链表，它仅允许从一端插入元素、另一端删除元素。</p>
<p><strong>栈</strong> 属于一种特殊的线性表/链表，它仅允许在某一端插入、删除元素。</p>
<a id="more"></a>


<p>其结构图大致如下：</p>
<p><img src="/2020/05/21/dataStructure/dataStructure-arraydeque/images.png" alt="图一：队列/栈"></p>
<p>我们并不单独实现队列/栈，而是仅实现一个双端队列，它不仅具有队列功能、也具有栈功能。</p>
<p>双端队列实现方法有两种，一种基于循环数组，另一种基于链表。基于链表的已在 <a href="/2020/05/21/dataStructure/dataStructure-linkedlist/" title="数据结构-链表">数据结构-链表</a> 中给出，故而此处的双端队列基于循环数组实现。</p>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>在 Java 库中，<code>ArrayDeque</code> 类为双端队列的实现。在这种实现方法中，其中无法存储 <code>null</code> 值。</p>
<p>我们采用 Java库中类似方法，并在稍后代码中给出无法存储 <code>null</code> 值的原因。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayDeque</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 默认容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">16</span>;</span><br><span class="line">    <span class="comment">// 基础数组</span></span><br><span class="line">    <span class="keyword">private</span> Object[] elementData;</span><br><span class="line">    <span class="comment">// 队首(指向第一个元素的位置)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> head;</span><br><span class="line">    <span class="comment">// 队尾(指向最后一个元素的下一个位置)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="辅助方法"><a href="#辅助方法" class="headerlink" title="辅助方法"></a>辅助方法</h3><ul>
<li><p>单增($0 \leq i &lt; modulus$)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">inc</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> modulus)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((++i) &gt;= modulus) &#123;</span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>多增</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">inc</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> distance, <span class="keyword">int</span> modulus)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((i += distance) &gt;= modulus) &#123;</span><br><span class="line">        i -= modulus;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>单减($0 \leq i &lt; modulus$)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dec</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> modulus)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((--i) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        i = modulus - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>多减</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> modulus)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((i -= j) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        i += modulus;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>扩容</p>
<p>第 9 行代码可以看到，它借用 <code>null</code> 判断该双端队列为满状态还是空状态。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = <span class="keyword">this</span>.elementData.length;</span><br><span class="line">    Object[] elementData = <span class="keyword">new</span> Object[oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>)];</span><br><span class="line">    <span class="comment">// 将全部元素赋值过去</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; oldCapacity; i++) &#123;</span><br><span class="line">        elementData[i] = <span class="keyword">this</span>.elementData[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将原数组中右半部分元素移动到新数组中右半部分。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.tail &lt; <span class="keyword">this</span>.head || (<span class="keyword">this</span>.tail == <span class="keyword">this</span>.head &amp;&amp; <span class="keyword">null</span> !=<span class="keyword">this</span>.elementData[<span class="keyword">this</span>.head])) &#123;</span><br><span class="line">        <span class="keyword">int</span> spaceCapacity = oldCapacity &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="keyword">this</span>.head; i &lt; oldCapacity; i++) &#123;</span><br><span class="line">            elementData[i + spaceCapacity] = <span class="keyword">this</span>.elementData[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.head += spaceCapacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.elementData = elementData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>单增、多增、单减、多减四个函数意在封装下标移动时的取模操作。</p>
</blockquote>
</li>
</ul>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ul>
<li><p>空初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayDeque</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(ArrayDeque.DEFAULT_CAPACITY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>带参数初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayDeque</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        initialCapacity = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3></li>
<li><p>查询元素个数</p>
<p>我们无需变量存放元素个数信息，只需通过队首、队尾相减即可得到该信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sub(<span class="keyword">this</span>.tail, <span class="keyword">this</span>.head, <span class="keyword">this</span>.elementData.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>查询双端队列是否为空</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>查询队首</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ArrayDequeu中二者是有差别的。如果双端队列为空，前者返回一个异常，后者返回null。对此我做了简化。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) <span class="keyword">this</span>.elementData[<span class="keyword">this</span>.head];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peekFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getFirst();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>查询队尾</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ArrayDequeu中二者是有差别的。如果双端队列为空，前者返回一个异常，后者返回null。对此我做了简化。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) <span class="keyword">this</span>.elementData[dec(<span class="keyword">this</span>.tail, <span class="keyword">this</span>.elementData.length)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peekLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getLast();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="操纵"><a href="#操纵" class="headerlink" title="操纵"></a>操纵</h3></li>
<li><p>队首添加元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ArrayDequeu中二者是有差别的。如果双端队列为空，前者返回一个异常，后者返回null。对此我做了简化。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == e) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.elementData[<span class="keyword">this</span>.head = dec(<span class="keyword">this</span>.head,<span class="keyword">this</span>.elementData.length)] = e;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.head == <span class="keyword">this</span>.tail) &#123;</span><br><span class="line">        grow();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offerFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    addFirst(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>队尾添加元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ArrayDequeu中二者是有差别的。如果双端队列为空，前者返回一个异常，后者返回null。对此我做了简化。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == e) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.elementData[<span class="keyword">this</span>.tail] = e;</span><br><span class="line">    <span class="keyword">this</span>.tail = inc(<span class="keyword">this</span>.tail,<span class="keyword">this</span>.elementData.length);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.head == <span class="keyword">this</span>.tail) &#123;</span><br><span class="line">        grow();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offerLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    addLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>队首删除元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ArrayDequeu中二者是有差别的。如果双端队列为空，前者返回一个异常，后者返回null。对此我做了简化。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> E e = (E) <span class="keyword">this</span>.elementData[<span class="keyword">this</span>.head];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != e) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData[<span class="keyword">this</span>.head] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.head = inc(<span class="keyword">this</span>.head, <span class="keyword">this</span>.elementData.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> removeFirst();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>队尾删除元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ArrayDequeu中二者是有差别的。如果双端队列为空，前者返回一个异常，后者返回null。对此我做了简化。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> index = dec(<span class="keyword">this</span>.tail, <span class="keyword">this</span>.elementData.length);</span><br><span class="line">    <span class="keyword">final</span> E e = (E) <span class="keyword">this</span>.elementData[index];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != e) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData[index] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.tail = index;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> removeLast();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>清空双端队列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="keyword">this</span>.head; i != <span class="keyword">this</span>.tail; i = inc(i, <span class="keyword">this</span>.elementData.length)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData[i] = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.head = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.tail = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>对队列/栈中元素施加以单调性质便形成了一种新的数据结构——单调队列/单调栈。在单调队列/单调栈中，所有元素按序单调递增或单调递增。</p>
<p>该种数据结构用途不太广泛，仅能处理一种特定问题—— Next Greater Element。例如：给你一个数组，返回一个等长的数组，对应索引存储着下一个更大元素，如果没有更大的元素，就存 -1。如果输入为 <code> [2,1,2,4,3]</code> ，输出应当为 <code>[4,2,4,-1,-1]</code> 。基于单调栈，从后往前存储数组元素即可解决此问题。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>队列</tag>
        <tag>单调队列</tag>
        <tag>栈</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-链表</title>
    <url>/2020/05/21/dataStructure/dataStructure-linkedlist/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>链表</strong> 是采用链式存储结构表示和实现的线性表。本文仅探讨双向链表。</p>
<a id="more"></a>

<p>其结构图大致如下：</p>
<p><img src="/2020/05/21/dataStructure/dataStructure-linkedlist/shuanxianglianbiao.png" alt="图一：链表"></p>
<p>链表的优缺点：</p>
<ul>
<li>优点<ul>
<li>快速实现插入、删除元素。</li>
</ul>
</li>
<li>缺点<ul>
<li>需额外空间保存元素间逻辑关系。</li>
<li>查询效率低。</li>
</ul>
</li>
</ul>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>链表采用链式存储结构实现，故而需要首先定义结点结构。我们采用 Java 库相同的做法，将结点定义为链表类中的一个静态类。</p>
<p>另外依据 Java库中 <code>LinkedList</code> 类的定义，可以发现它同样实现了双端队列 <code>Deque</code>，在此我们也这样做。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 节点结构</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">// 具体元素</span></span><br><span class="line">        E item;</span><br><span class="line">        <span class="comment">// 前驱</span></span><br><span class="line">        Node&lt;E&gt; prev;</span><br><span class="line">        <span class="comment">// 后继</span></span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line"></span><br><span class="line">        Node(Node&lt;E&gt; prev, E item, Node&lt;E&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.prev = prev;</span><br><span class="line">            <span class="keyword">this</span>.item = item;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 头结点</span></span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; first;</span><br><span class="line">    <span class="comment">// 尾结点</span></span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; last;</span><br><span class="line">    <span class="comment">// 元素个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><blockquote>
<p>链表往往具有两种写法——一种具有标记结点，一种不具有标记结点。</p>
<p>使用前者，可无需考虑一些特殊情况，但是需要耗费一个结点的空间。</p>
<p>Java 库采用后者，故而我们亦采用后者。</p>
</blockquote>
<h3 id="辅助方法"><a href="#辅助方法" class="headerlink" title="辅助方法"></a>辅助方法</h3><ul>
<li><p>链接元素于首部</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; first = <span class="keyword">this</span>.first;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(<span class="keyword">null</span>, e, first);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == first) &#123;</span><br><span class="line">        <span class="keyword">this</span>.last = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        first.prev = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.first = newNode;</span><br><span class="line">    <span class="keyword">this</span>.size = <span class="keyword">this</span>.size + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>链接元素于尾部</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; last = <span class="keyword">this</span>.last;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(last, e, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == last) &#123;</span><br><span class="line">        <span class="keyword">this</span>.first = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        last.next = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.last = newNode;</span><br><span class="line">    <span class="keyword">this</span>.size = <span class="keyword">this</span>.size + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>链接元素于某结点之前(结点一定存在)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = succ.prev;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(prev, e, succ);</span><br><span class="line">    succ.prev = newNode;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == prev) &#123;</span><br><span class="line">        <span class="keyword">this</span>.first = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prev.next = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.size = <span class="keyword">this</span>.size + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>删除某元素(元素一定存在)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">    E element = x.item;</span><br><span class="line">    x.prev = <span class="keyword">null</span>;</span><br><span class="line">    x.item = <span class="keyword">null</span>;</span><br><span class="line">    x.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == prev) &#123;</span><br><span class="line">        <span class="keyword">this</span>.first = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prev.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.last = prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.size = <span class="keyword">this</span>.size - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>查找指定位置结点</p>
<p>查询指定位置结点，在此做一简单优化。如果位置位于链表前半部分，则顺序查找；否则逆向查找。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; (<span class="keyword">this</span>.size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = <span class="keyword">this</span>.first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">            x = x.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = <span class="keyword">this</span>.last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="keyword">this</span>.size - <span class="number">1</span>; i &gt; index; i--) &#123;</span><br><span class="line">            x = x.prev;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3></li>
<li><p>空初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3></li>
<li><p>查询元素个数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>查询链首</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Dequeu中二者是有差别的。如果链表为空，前者返回一个异常，后者返回null。对此我做了简化。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; e = <span class="keyword">this</span>.first;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> e.item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peekFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getFirst();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>查询链尾</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 同上</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; e = <span class="keyword">this</span>.last;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> e.item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peekLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getLast();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>查询指定位置元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="keyword">this</span>.size) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>查询元素位置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == o) &#123;</span><br><span class="line">        Node&lt;E&gt; x = <span class="keyword">this</span>.first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == x.item) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">            x = x.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = <span class="keyword">this</span>.first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.item.equals(o)) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">            x = x.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="操纵"><a href="#操纵" class="headerlink" title="操纵"></a>操纵</h3></li>
<li><p>链首添加元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Dequeu中二者是有差别的。如果因空间限制而添加失败，前者返回一个异常，后者返回false。对此我做了简化。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkFirst(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offerFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkFirst(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>链尾添加元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 同上</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offerLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>指定位置添加元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; <span class="keyword">this</span>.size) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (index == <span class="keyword">this</span>.size) &#123;</span><br><span class="line">        linkLast(element);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        linkBefore(element, node(index));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>链首删除元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Dequeu中二者是有差别的。如果链表为空，前者返回一个异常，后者返回null。对此我做了简化。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = <span class="keyword">this</span>.first;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == f) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> unlink(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> removeFirst();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>链尾删除元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 同上</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = <span class="keyword">this</span>.last;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == l) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> unlink(l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> removeLast();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>指定位置删除元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="keyword">this</span>.size) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>清空链表</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; x = <span class="keyword">this</span>.first; x != <span class="keyword">null</span>;) &#123;</span><br><span class="line">        Node&lt;E&gt; next = x.next;</span><br><span class="line">        x.prev = <span class="keyword">null</span>;</span><br><span class="line">        x.item = <span class="keyword">null</span>;</span><br><span class="line">        x.next = <span class="keyword">null</span>;</span><br><span class="line">        x = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.first = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.last = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>修改指定位置元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="keyword">this</span>.size) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node&lt;E&gt; x = node(index);</span><br><span class="line">    E oldElement = x.item;</span><br><span class="line">    x.item = element;</span><br><span class="line">    <span class="keyword">return</span> oldElement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>将 “分块思想” 应用于链表之中，便得到了一种新的数据结构—— <a href="/2020/07/13/dataStructure/dataStructure-blocklist/" title="块状链表">块状链表</a>。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-线性表</title>
    <url>/2020/05/20/dataStructure/dataStructure-arraylist/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>线性表</strong> 是具有线性结构特点、最简单、且最常用的一种数据结构。它是具有相同特性的数据元素组成的一个有限序列。</p>
<a id="more"></a>

<p>其结构图大致如下：</p>
<p><img src="/2020/05/20/dataStructure/dataStructure-arraylist/image-20200520201858696.png" alt="图一：线性表"></p>
<p>线性表的优缺点：</p>
<ul>
<li>优点<ol>
<li>随机存取。</li>
<li>无需额外空间保存元素间逻辑关系。</li>
</ol>
</li>
<li>缺点<ol>
<li>插入、删除需要移动大量元素。</li>
<li>可能存在存储空间“碎片“，即申请了但未使用的空间。</li>
</ol>
</li>
</ul>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>线性表需要先申请一定空间，然后再想其中存放元素，因此存在 <em>容量</em> 和 <em>元素个数</em> 两个概念。其中 <em>容量</em> 指的是当前线性表可容纳的元素个数；<em>元素个数</em> 指的是当前线性表已容纳的元素个数。由于 Java 数组本身就保存容量信息，因此在此无需存储它，仅需存储元素个数即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 默认容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 基础数组</span></span><br><span class="line">    <span class="keyword">private</span> Object[] elementData;</span><br><span class="line">    <span class="comment">// 元素个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="辅助方法"><a href="#辅助方法" class="headerlink" title="辅助方法"></a>辅助方法</h3><ul>
<li><p>扩容</p>
<p>每扩充一次，线性表容量增加一半。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Object[] grow() &#123;</span><br><span class="line">    Object[] newElementData = <span class="keyword">new</span> Object[<span class="keyword">this</span>.elementData.length + (<span class="keyword">this</span>.elementData.length &gt;&gt; <span class="number">1</span>)];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="keyword">this</span>.size; i++)</span><br><span class="line">        newElementData[i] = <span class="keyword">this</span>.elementData[i];</span><br><span class="line">    <span class="keyword">return</span> newElementData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3></li>
<li><p>空初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(ArrayList.DEFAULT_CAPACITY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>带参数初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        initialCapacity = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3></li>
<li><p>查询元素个数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>查询线性表是否为空</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size() == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>查询元素位置</p>
<p>如果存在则返回其下标，否则返回 -1。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == o)  &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == <span class="keyword">this</span>.elementData[i])</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(<span class="keyword">this</span>.elementData[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>查询指定位置内容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="keyword">this</span>.size) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (E)<span class="keyword">this</span>.elementData[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="操纵"><a href="#操纵" class="headerlink" title="操纵"></a>操纵</h3></li>
<li><p>指定位置添加元素</p>
<p>添加元素之前需要判断容量是否足够，不够则扩容。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; <span class="keyword">this</span>.size) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.elementData.length == <span class="keyword">this</span>.size) &#123;</span><br><span class="line">            <span class="keyword">this</span>.elementData = grow();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="keyword">this</span>.size; i &gt;= index; i--)</span><br><span class="line">            <span class="keyword">this</span>.elementData[i + <span class="number">1</span>] = <span class="keyword">this</span>.elementData[i];</span><br><span class="line">        <span class="keyword">this</span>.elementData[index] = element;</span><br><span class="line">        <span class="keyword">this</span>.size = <span class="keyword">this</span>.size + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>线性表末添加元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> add(size(),element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>删除指定位置元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= <span class="keyword">this</span>.size) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        E oldElement = (E) <span class="keyword">this</span>.elementData[index];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; <span class="keyword">this</span>.size; i++) &#123;</span><br><span class="line">            <span class="keyword">this</span>.elementData[i + <span class="number">1</span>] = <span class="keyword">this</span>.elementData[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.size = <span class="keyword">this</span>.size - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">this</span>.elementData[<span class="keyword">this</span>.size] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> oldElement;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>清空线性表</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.size; i++)</span><br><span class="line">        <span class="keyword">this</span>.elementData[i] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>修改指定位置元素</p>
<p>修改指定位置元素并返回旧元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="keyword">this</span>.size) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        E oldElement = (E)<span class="keyword">this</span>.elementData[index];</span><br><span class="line">        <span class="keyword">this</span>.elementData[index] = element;</span><br><span class="line">        <span class="keyword">return</span> oldElement;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>将 “分块思想” 应用于线性表之中，便得到了一种新的数据结构——块状数组。块状数组将首先对整个数组进行分块处理，所有针对数组的操作，将首先施加于分块之上，然后进一步施加于分块所在的块数组之上。</p>
<p>块状数组之上各种操作的时间复杂度均为 $O(\sqrt{N})$，其常用于区间求和、区间查询等问题。</p>
<p><img src="/2020/05/20/dataStructure/dataStructure-arraylist/v2-1655c12e302625448e5c09c6349258d7_720w.png" alt="图二：块状数组"></p>
<blockquote>
<p>块状数组代码实现比较灵活，故而在此简单介绍思想即可。</p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>线性表</tag>
      </tags>
  </entry>
  <entry>
    <title>字符编码</title>
    <url>/2020/03/08/sundry/character-encoding/</url>
    <content><![CDATA[<p>本文描述两种字符编码 <code>ascii</code> 和 <code>unicode</code>，并详解 <code>unicode</code> 编码的三种实现方式 <code>utf-8</code>、<code>utf-16</code> 和 <code>utf-32</code>。</p>
<a id="more"></a>

<h2 id="ascii"><a href="#ascii" class="headerlink" title="ascii"></a>ascii</h2><p>上世纪60年代，美国制定了一套字符编码 <strong>ascii</strong>，对英文字符和二进制位之间定义了一个映射关系。</p>
<p><img src="/2020/03/08/sundry/character-encoding/e850352ac65c103880a07b53bc119313b17e8941.png" alt="图一：字符编码"></p>
<p>在 <strong>ascii</strong> 中，一个英文字符使用一个字节的二进制位进行表述。</p>
<p><strong>ascii</strong> 仅对128个英文字符进行编码，因此一个字节的二进制位仅使用了 <code>00000000~01111111</code>。</p>
<h2 id="非ascii"><a href="#非ascii" class="headerlink" title="非ascii"></a>非ascii</h2><p>随着计算机的流行，其他国家也需要对其语言中的字符进行编码，通常做法是这样的——对 <strong>ascii</strong> 进行扩充，使用二进制位中的 <code>10000000~11111111</code> 表示其国家语言中的字符。</p>
<blockquote>
<p>中文编码比较特殊，这里不考虑。</p>
</blockquote>
<p>那么这样就会出现一个问题：二进制位中的 <code>10000000~11111111</code> 在不同国家的编码中表示不同的字符，如果以错误的字符编码打开一个文件，将会出现乱码？</p>
<p>为解决这个问题，需要制定一套字符编码，定义世界上所有字符与二进制位之间的映射关系，这种字符编码就是 <code>unicode</code>。</p>
<h2 id="unicode"><a href="#unicode" class="headerlink" title="unicode"></a>unicode</h2><p><strong>unicode</strong> 为世界上所有字符与二进制位之间定义了一个映射关系，形成一个巨大的字符集 。</p>
<p><strong>unicode</strong> 的编码空间为 <code>U+0000 ~  U+10FFFF</code>，共可容纳 1112064 个字符。</p>
<p><strong>unicode</strong> 定义了字符与二进制位之间的映射关系，但并没有规定如何存储这个二进制位。因此出现了众多 <strong>unicode</strong> 的实现方式，这里介绍三种——<code>utf-8</code> 、 <code>utf-16</code> 和 <code>utf-32</code>。</p>
<h3 id="utf-8"><a href="#utf-8" class="headerlink" title="utf-8"></a>utf-8</h3><p><strong>utf-8</strong> 是一种变长字符编码，即字符集中不同字符，可能具有不同的字节长度 (1/2/3/4 字节)。</p>
<p><strong>utf-8</strong> 的编码规则如下：</p>
<ul>
<li>对于单字节字符，字节第一位置为 <code>0</code>，其余 7 位为该字符的 <code>unicode</code> 编码。因此对于英文字母， <strong>utf-8</strong> 编码结果与 <strong>ascii</strong> 是相同的。</li>
<li>对于 <code>n</code>字节字符，第一个字节的前 <code>n</code> 位置为 <code>1</code>，<code>n + 1</code> 位置为 <code>0</code>，其余字节的前两位置为 <code>10</code>，其余二进制位为该字符的 <code>unicode</code> 编码。</li>
</ul>
<p><strong>unicode</strong> 与 <strong>utf-8</strong> 之间的对应关系：</p>
<table>
<thead>
<tr>
<th align="left">unicode编码</th>
<th align="left">utf-8编码</th>
</tr>
</thead>
<tbody><tr>
<td align="left">U+ 0000 ~ U+  007F</td>
<td align="left">0XXXXXXX</td>
</tr>
<tr>
<td align="left">U+ 0080 ~ U+  07FF</td>
<td align="left">110XXXXX 10XXXXXX</td>
</tr>
<tr>
<td align="left">U+ 0800 ~ U+  FFFF</td>
<td align="left">1110XXXX 10XXXXXX 10XXXXXX</td>
</tr>
<tr>
<td align="left">U+10000 ~ U+10FFFF</td>
<td align="left">11110XXX 10XXXXXX 10XXXXXX 10XXXXXX</td>
</tr>
</tbody></table>
<p>举一个例子：<code>严</code> 的 unicode编码 是 <code>U+4E25</code>，通过上面的对应关系，可以得知 <code>严</code> 的 utf-8 编码占三个字节，即格式为 <code>1110XXXX 10XXXXXX 10XXXXXX</code>。从最后一个二进制位开始，依次从后向前将 <code>U+4E25</code> 的二进制位填到<code>X</code>，多余的 <code>X</code> 填入 0，最终得到 <code>严</code> 的 utf-8 编码为 <code>11100100 10111000 10100101</code>。 </p>
<h3 id="utf-16"><a href="#utf-16" class="headerlink" title="utf-16"></a>utf-16</h3><p><strong>utf-16</strong> 是一种变长字符编码,即字符集中不同字符，可能具有不同的字节长度 (2/4 字节)。</p>
<p><strong>utf-16</strong> 的编码规则比较麻烦，具体如下：</p>
<ul>
<li><p><strong>utf-16</strong> 将 unicode 的编码空间划分为 16 个平面。第 <code>XX</code> 个平面的编码范围为 <code>0xXX0000 ~ 0xXXFFFF</code>。第一个平面称为 <em>基本多语言平面</em>  ( 2字节 ) ，其余平面称为 <em>辅助平面</em>  ( 4字节 )  。</p>
</li>
<li><p>unicode 标准规定区间 <code>U+D800 ~ U+DFFF</code> 不对应任何字符，因此  <strong>utf-16</strong> 使用这部分区间对辅助空间中的字符进行编码。</p>
</li>
<li><p>在 <em>基本多语言平面</em> 中，<code>U+D800 ~ U+DFFF</code> 区间不对应任何字符，因此无需编码；<code>U+0000 ~ U+D7FF</code> 和 <code>U+E000 ~ U+FFFF</code> 区间中的字符，其 <strong>utf-16</strong> 编码结果就是 unicode 编码。</p>
</li>
<li><p>在 <em>辅助平面</em>  中，<strong>utf-16</strong> 将 区间<code>U+10000 ~ U+10FFFF</code>中的字符编码为 <em>代理对</em> 。</p>
<p>具体编码方式如下：</p>
<ul>
<li>将 unicode 编码值减去 <code>0x10000</code> ，得到一个值 (值范围为 <code>0x00000 ~ 0xFFFFF</code> ) 。</li>
<li>取该值高 10 位 (值范围为 <code>0x00 ~ 0x3FF</code>)，加上 <code>0xD800</code> 得到 <em>前导代理</em>  (值范围为<code>0xD800 ~ 0xDBFF</code>)</li>
<li>取该值低 10 位 (值范围为 <code>0x00 ~ 0x3FF</code>)，加上 <code>0xDC00</code> 得到 <em>后尾代理</em>  (值范围为<code>0xDC00 ~ 0xDFFF</code>)</li>
<li>(前导代理，后尾代理) 即为 <strong>utf-16</strong> 编码结果。</li>
</ul>
</li>
</ul>
<p>举一个例子：𐐷 的 unicode编码为 <code>U+10437</code>。由于它在辅助平面，因此先减去 <code>0x10000</code> 得到 <code>0000 0000 0100 0011 0111</code> , 取高 10 位 和低 10 位 分别处理得到 <code>0xD800 + 0x0001 = 0xD801,0xDC00 + 0x0037 = 0xDC37</code>，最终 <strong>utf-16</strong> 编码结果就是 <code>0xD801 DC37</code>。</p>
<h3 id="utf-32"><a href="#utf-32" class="headerlink" title="utf-32"></a>utf-32</h3><p><strong>utf-32</strong> 是一种定长字符编码，即字符集中所有字符均编码为 4 字节。</p>
<p><strong>utf-32</strong> 的编码规则十分简单，具体如下：</p>
<ul>
<li>从低位到高位依次放置 unicode 编码，多余位置 <code>0</code> 即可。</li>
</ul>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>字符编码</tag>
      </tags>
  </entry>
</search>
